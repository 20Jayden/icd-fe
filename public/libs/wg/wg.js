(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["wg"] = factory();
	else
		root["wg"] = factory();
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
 // A linked list to keep track of recently-used-ness

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var Yallist = __webpack_require__(/*! yallist */ "./node_modules/yallist/yallist.js");

var MAX = Symbol('max');
var LENGTH = Symbol('length');
var LENGTH_CALCULATOR = Symbol('lengthCalculator');
var ALLOW_STALE = Symbol('allowStale');
var MAX_AGE = Symbol('maxAge');
var DISPOSE = Symbol('dispose');
var NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
var LRU_LIST = Symbol('lruList');
var CACHE = Symbol('cache');
var UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

var naiveLength = function naiveLength() {
  return 1;
}; // lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.


var LRUCache = /*#__PURE__*/function () {
  function LRUCache(options) {
    _classCallCheck(this, LRUCache);

    if (typeof options === 'number') options = {
      max: options
    };
    if (!options) options = {};
    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number'); // Kind of weird to have a default max of Infinity, but oh well.

    var max = this[MAX] = options.max || Infinity;
    var lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  } // resize the cache when the max changes.


  _createClass(LRUCache, [{
    key: "max",
    get: function get() {
      return this[MAX];
    },
    set: function set(mL) {
      if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
      this[MAX] = mL || Infinity;
      trim(this);
    }
  }, {
    key: "allowStale",
    get: function get() {
      return this[ALLOW_STALE];
    },
    set: function set(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
  }, {
    key: "maxAge",
    get: function get() {
      return this[MAX_AGE];
    } // resize the cache when the lengthCalculator changes.
    ,
    set: function set(mA) {
      if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
      this[MAX_AGE] = mA;
      trim(this);
    }
  }, {
    key: "lengthCalculator",
    get: function get() {
      return this[LENGTH_CALCULATOR];
    },
    set: function set(lC) {
      var _this = this;

      if (typeof lC !== 'function') lC = naiveLength;

      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach(function (hit) {
          hit.length = _this[LENGTH_CALCULATOR](hit.value, hit.key);
          _this[LENGTH] += hit.length;
        });
      }

      trim(this);
    }
  }, {
    key: "length",
    get: function get() {
      return this[LENGTH];
    }
  }, {
    key: "itemCount",
    get: function get() {
      return this[LRU_LIST].length;
    }
  }, {
    key: "rforEach",
    value: function rforEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].tail; walker !== null;) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
  }, {
    key: "forEach",
    value: function forEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].head; walker !== null;) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
  }, {
    key: "keys",
    value: function keys() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.key;
      });
    }
  }, {
    key: "values",
    value: function values() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.value;
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this2 = this;

      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach(function (hit) {
          return _this2[DISPOSE](hit.key, hit.value);
        });
      }

      this[CACHE] = new Map(); // hash of items by key

      this[LRU_LIST] = new Yallist(); // list of items in order of use recency

      this[LENGTH] = 0; // length of items in the list
    }
  }, {
    key: "dump",
    value: function dump() {
      var _this3 = this;

      return this[LRU_LIST].map(function (hit) {
        return isStale(_this3, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        };
      }).toArray().filter(function (h) {
        return h;
      });
    }
  }, {
    key: "dumpLru",
    value: function dumpLru() {
      return this[LRU_LIST];
    }
  }, {
    key: "set",
    value: function set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR](value, key);

      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          _del(this, this[CACHE].get(key));

          return false;
        }

        var node = this[CACHE].get(key);
        var item = node.value; // dispose of the old one before overwriting
        // split out into 2 ifs for better coverage tracking

        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
        }

        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }

      var hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.

      if (hit.length > this[MAX]) {
        if (this[DISPOSE]) this[DISPOSE](key, value);
        return false;
      }

      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
  }, {
    key: "has",
    value: function has(key) {
      if (!this[CACHE].has(key)) return false;
      var hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
  }, {
    key: "get",
    value: function get(key) {
      return _get(this, key, true);
    }
  }, {
    key: "peek",
    value: function peek(key) {
      return _get(this, key, false);
    }
  }, {
    key: "pop",
    value: function pop() {
      var node = this[LRU_LIST].tail;
      if (!node) return null;

      _del(this, node);

      return node.value;
    }
  }, {
    key: "del",
    value: function del(key) {
      _del(this, this[CACHE].get(key));
    }
  }, {
    key: "load",
    value: function load(arr) {
      // reset the cache
      this.reset();
      var now = Date.now(); // A previous serialized cache has the most recent items first

      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) // the item was created without expiration in a non aged cache
          this.set(hit.k, hit.v);else {
          var maxAge = expiresAt - now; // dont add already expired items

          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
  }, {
    key: "prune",
    value: function prune() {
      var _this4 = this;

      this[CACHE].forEach(function (value, key) {
        return _get(_this4, key, false);
      });
    }
  }]);

  return LRUCache;
}();

var _get = function _get(self, key, doUse) {
  var node = self[CACHE].get(key);

  if (node) {
    var hit = node.value;

    if (isStale(self, hit)) {
      _del(self, node);

      if (!self[ALLOW_STALE]) return undefined;
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
        self[LRU_LIST].unshiftNode(node);
      }
    }

    return hit.value;
  }
};

var isStale = function isStale(self, hit) {
  if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
  var diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};

var trim = function trim(self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev;

      _del(self, walker);

      walker = prev;
    }
  }
};

var _del = function _del(self, node) {
  if (node) {
    var hit = node.value;
    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
    self[LENGTH] -= hit.length;
    self[CACHE].delete(hit.key);
    self[LRU_LIST].removeNode(node);
  }
};

var Entry = /*#__PURE__*/_createClass(function Entry(key, value, length, now, maxAge) {
  _classCallCheck(this, Entry);

  this.key = key;
  this.value = value;
  this.length = length;
  this.now = now;
  this.maxAge = maxAge || 0;
});

var forEachStep = function forEachStep(self, fn, node, thisp) {
  var hit = node.value;

  if (isStale(self, hit)) {
    _del(self, node);

    if (!self[ALLOW_STALE]) hit = undefined;
  }

  if (hit) fn.call(thisp, hit.value, hit.key, self);
};

module.exports = LRUCache;

/***/ }),

/***/ "./node_modules/pbf/index.js":
/*!***********************************!*\
  !*** ./node_modules/pbf/index.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = Pbf;

var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");

function Pbf(buf) {
  this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
  this.pos = 0;
  this.type = 0;
  this.length = this.buf.length;
}

Pbf.Varint = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum

Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64

Pbf.Bytes = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields

Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32; // Threshold chosen based on both benchmarking and knowledge about browser string
// data structures (which currently switch structure types at 12 bytes or more)

var TEXT_DECODER_MIN_LENGTH = 12;
var utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf8');
Pbf.prototype = {
  destroy: function destroy() {
    this.buf = null;
  },
  // === READING =================================================================
  readFields: function readFields(readField, result, end) {
    end = end || this.length;

    while (this.pos < end) {
      var val = this.readVarint(),
          tag = val >> 3,
          startPos = this.pos;
      this.type = val & 0x7;
      readField(tag, result, this);
      if (this.pos === startPos) this.skip(val);
    }

    return result;
  },
  readMessage: function readMessage(readField, result) {
    return this.readFields(readField, result, this.readVarint() + this.pos);
  },
  readFixed32: function readFixed32() {
    var val = readUInt32(this.buf, this.pos);
    this.pos += 4;
    return val;
  },
  readSFixed32: function readSFixed32() {
    var val = readInt32(this.buf, this.pos);
    this.pos += 4;
    return val;
  },
  // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
  readFixed64: function readFixed64() {
    var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
    this.pos += 8;
    return val;
  },
  readSFixed64: function readSFixed64() {
    var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
    this.pos += 8;
    return val;
  },
  readFloat: function readFloat() {
    var val = ieee754.read(this.buf, this.pos, true, 23, 4);
    this.pos += 4;
    return val;
  },
  readDouble: function readDouble() {
    var val = ieee754.read(this.buf, this.pos, true, 52, 8);
    this.pos += 8;
    return val;
  },
  readVarint: function readVarint(isSigned) {
    var buf = this.buf,
        val,
        b;
    b = buf[this.pos++];
    val = b & 0x7f;
    if (b < 0x80) return val;
    b = buf[this.pos++];
    val |= (b & 0x7f) << 7;
    if (b < 0x80) return val;
    b = buf[this.pos++];
    val |= (b & 0x7f) << 14;
    if (b < 0x80) return val;
    b = buf[this.pos++];
    val |= (b & 0x7f) << 21;
    if (b < 0x80) return val;
    b = buf[this.pos];
    val |= (b & 0x0f) << 28;
    return readVarintRemainder(val, isSigned, this);
  },
  readVarint64: function readVarint64() {
    // for compatibility with v2.0.1
    return this.readVarint(true);
  },
  readSVarint: function readSVarint() {
    var num = this.readVarint();
    return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
  },
  readBoolean: function readBoolean() {
    return Boolean(this.readVarint());
  },
  readString: function readString() {
    var end = this.readVarint() + this.pos;
    var pos = this.pos;
    this.pos = end;

    if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
      // longer strings are fast with the built-in browser TextDecoder API
      return readUtf8TextDecoder(this.buf, pos, end);
    } // short strings are fast with our custom implementation


    return readUtf8(this.buf, pos, end);
  },
  readBytes: function readBytes() {
    var end = this.readVarint() + this.pos,
        buffer = this.buf.subarray(this.pos, end);
    this.pos = end;
    return buffer;
  },
  // verbose for performance reasons; doesn't affect gzipped size
  readPackedVarint: function readPackedVarint(arr, isSigned) {
    if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));
    var end = readPackedEnd(this);
    arr = arr || [];

    while (this.pos < end) {
      arr.push(this.readVarint(isSigned));
    }

    return arr;
  },
  readPackedSVarint: function readPackedSVarint(arr) {
    if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());
    var end = readPackedEnd(this);
    arr = arr || [];

    while (this.pos < end) {
      arr.push(this.readSVarint());
    }

    return arr;
  },
  readPackedBoolean: function readPackedBoolean(arr) {
    if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());
    var end = readPackedEnd(this);
    arr = arr || [];

    while (this.pos < end) {
      arr.push(this.readBoolean());
    }

    return arr;
  },
  readPackedFloat: function readPackedFloat(arr) {
    if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());
    var end = readPackedEnd(this);
    arr = arr || [];

    while (this.pos < end) {
      arr.push(this.readFloat());
    }

    return arr;
  },
  readPackedDouble: function readPackedDouble(arr) {
    if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());
    var end = readPackedEnd(this);
    arr = arr || [];

    while (this.pos < end) {
      arr.push(this.readDouble());
    }

    return arr;
  },
  readPackedFixed32: function readPackedFixed32(arr) {
    if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());
    var end = readPackedEnd(this);
    arr = arr || [];

    while (this.pos < end) {
      arr.push(this.readFixed32());
    }

    return arr;
  },
  readPackedSFixed32: function readPackedSFixed32(arr) {
    if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());
    var end = readPackedEnd(this);
    arr = arr || [];

    while (this.pos < end) {
      arr.push(this.readSFixed32());
    }

    return arr;
  },
  readPackedFixed64: function readPackedFixed64(arr) {
    if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());
    var end = readPackedEnd(this);
    arr = arr || [];

    while (this.pos < end) {
      arr.push(this.readFixed64());
    }

    return arr;
  },
  readPackedSFixed64: function readPackedSFixed64(arr) {
    if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());
    var end = readPackedEnd(this);
    arr = arr || [];

    while (this.pos < end) {
      arr.push(this.readSFixed64());
    }

    return arr;
  },
  skip: function skip(val) {
    var type = val & 0x7;
    if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {} else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;else if (type === Pbf.Fixed32) this.pos += 4;else if (type === Pbf.Fixed64) this.pos += 8;else throw new Error('Unimplemented type: ' + type);
  },
  // === WRITING =================================================================
  writeTag: function writeTag(tag, type) {
    this.writeVarint(tag << 3 | type);
  },
  realloc: function realloc(min) {
    var length = this.length || 16;

    while (length < this.pos + min) {
      length *= 2;
    }

    if (length !== this.length) {
      var buf = new Uint8Array(length);
      buf.set(this.buf);
      this.buf = buf;
      this.length = length;
    }
  },
  finish: function finish() {
    this.length = this.pos;
    this.pos = 0;
    return this.buf.subarray(0, this.length);
  },
  writeFixed32: function writeFixed32(val) {
    this.realloc(4);
    writeInt32(this.buf, val, this.pos);
    this.pos += 4;
  },
  writeSFixed32: function writeSFixed32(val) {
    this.realloc(4);
    writeInt32(this.buf, val, this.pos);
    this.pos += 4;
  },
  writeFixed64: function writeFixed64(val) {
    this.realloc(8);
    writeInt32(this.buf, val & -1, this.pos);
    writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
    this.pos += 8;
  },
  writeSFixed64: function writeSFixed64(val) {
    this.realloc(8);
    writeInt32(this.buf, val & -1, this.pos);
    writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
    this.pos += 8;
  },
  writeVarint: function writeVarint(val) {
    val = +val || 0;

    if (val > 0xfffffff || val < 0) {
      writeBigVarint(val, this);
      return;
    }

    this.realloc(4);
    this.buf[this.pos++] = val & 0x7f | (val > 0x7f ? 0x80 : 0);
    if (val <= 0x7f) return;
    this.buf[this.pos++] = (val >>>= 7) & 0x7f | (val > 0x7f ? 0x80 : 0);
    if (val <= 0x7f) return;
    this.buf[this.pos++] = (val >>>= 7) & 0x7f | (val > 0x7f ? 0x80 : 0);
    if (val <= 0x7f) return;
    this.buf[this.pos++] = val >>> 7 & 0x7f;
  },
  writeSVarint: function writeSVarint(val) {
    this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
  },
  writeBoolean: function writeBoolean(val) {
    this.writeVarint(Boolean(val));
  },
  writeString: function writeString(str) {
    str = String(str);
    this.realloc(str.length * 4);
    this.pos++; // reserve 1 byte for short string length

    var startPos = this.pos; // write the string directly to the buffer and see how much was written

    this.pos = writeUtf8(this.buf, str, this.pos);
    var len = this.pos - startPos;
    if (len >= 0x80) makeRoomForExtraLength(startPos, len, this); // finally, write the message length in the reserved place and restore the position

    this.pos = startPos - 1;
    this.writeVarint(len);
    this.pos += len;
  },
  writeFloat: function writeFloat(val) {
    this.realloc(4);
    ieee754.write(this.buf, val, this.pos, true, 23, 4);
    this.pos += 4;
  },
  writeDouble: function writeDouble(val) {
    this.realloc(8);
    ieee754.write(this.buf, val, this.pos, true, 52, 8);
    this.pos += 8;
  },
  writeBytes: function writeBytes(buffer) {
    var len = buffer.length;
    this.writeVarint(len);
    this.realloc(len);

    for (var i = 0; i < len; i++) {
      this.buf[this.pos++] = buffer[i];
    }
  },
  writeRawMessage: function writeRawMessage(fn, obj) {
    this.pos++; // reserve 1 byte for short message length
    // write the message directly to the buffer and see how much was written

    var startPos = this.pos;
    fn(obj, this);
    var len = this.pos - startPos;
    if (len >= 0x80) makeRoomForExtraLength(startPos, len, this); // finally, write the message length in the reserved place and restore the position

    this.pos = startPos - 1;
    this.writeVarint(len);
    this.pos += len;
  },
  writeMessage: function writeMessage(tag, fn, obj) {
    this.writeTag(tag, Pbf.Bytes);
    this.writeRawMessage(fn, obj);
  },
  writePackedVarint: function writePackedVarint(tag, arr) {
    if (arr.length) this.writeMessage(tag, _writePackedVarint, arr);
  },
  writePackedSVarint: function writePackedSVarint(tag, arr) {
    if (arr.length) this.writeMessage(tag, _writePackedSVarint, arr);
  },
  writePackedBoolean: function writePackedBoolean(tag, arr) {
    if (arr.length) this.writeMessage(tag, _writePackedBoolean, arr);
  },
  writePackedFloat: function writePackedFloat(tag, arr) {
    if (arr.length) this.writeMessage(tag, _writePackedFloat, arr);
  },
  writePackedDouble: function writePackedDouble(tag, arr) {
    if (arr.length) this.writeMessage(tag, _writePackedDouble, arr);
  },
  writePackedFixed32: function writePackedFixed32(tag, arr) {
    if (arr.length) this.writeMessage(tag, _writePackedFixed, arr);
  },
  writePackedSFixed32: function writePackedSFixed32(tag, arr) {
    if (arr.length) this.writeMessage(tag, _writePackedSFixed, arr);
  },
  writePackedFixed64: function writePackedFixed64(tag, arr) {
    if (arr.length) this.writeMessage(tag, _writePackedFixed2, arr);
  },
  writePackedSFixed64: function writePackedSFixed64(tag, arr) {
    if (arr.length) this.writeMessage(tag, _writePackedSFixed2, arr);
  },
  writeBytesField: function writeBytesField(tag, buffer) {
    this.writeTag(tag, Pbf.Bytes);
    this.writeBytes(buffer);
  },
  writeFixed32Field: function writeFixed32Field(tag, val) {
    this.writeTag(tag, Pbf.Fixed32);
    this.writeFixed32(val);
  },
  writeSFixed32Field: function writeSFixed32Field(tag, val) {
    this.writeTag(tag, Pbf.Fixed32);
    this.writeSFixed32(val);
  },
  writeFixed64Field: function writeFixed64Field(tag, val) {
    this.writeTag(tag, Pbf.Fixed64);
    this.writeFixed64(val);
  },
  writeSFixed64Field: function writeSFixed64Field(tag, val) {
    this.writeTag(tag, Pbf.Fixed64);
    this.writeSFixed64(val);
  },
  writeVarintField: function writeVarintField(tag, val) {
    this.writeTag(tag, Pbf.Varint);
    this.writeVarint(val);
  },
  writeSVarintField: function writeSVarintField(tag, val) {
    this.writeTag(tag, Pbf.Varint);
    this.writeSVarint(val);
  },
  writeStringField: function writeStringField(tag, str) {
    this.writeTag(tag, Pbf.Bytes);
    this.writeString(str);
  },
  writeFloatField: function writeFloatField(tag, val) {
    this.writeTag(tag, Pbf.Fixed32);
    this.writeFloat(val);
  },
  writeDoubleField: function writeDoubleField(tag, val) {
    this.writeTag(tag, Pbf.Fixed64);
    this.writeDouble(val);
  },
  writeBooleanField: function writeBooleanField(tag, val) {
    this.writeVarintField(tag, Boolean(val));
  }
};

function readVarintRemainder(l, s, p) {
  var buf = p.buf,
      h,
      b;
  b = buf[p.pos++];
  h = (b & 0x70) >> 4;
  if (b < 0x80) return toNum(l, h, s);
  b = buf[p.pos++];
  h |= (b & 0x7f) << 3;
  if (b < 0x80) return toNum(l, h, s);
  b = buf[p.pos++];
  h |= (b & 0x7f) << 10;
  if (b < 0x80) return toNum(l, h, s);
  b = buf[p.pos++];
  h |= (b & 0x7f) << 17;
  if (b < 0x80) return toNum(l, h, s);
  b = buf[p.pos++];
  h |= (b & 0x7f) << 24;
  if (b < 0x80) return toNum(l, h, s);
  b = buf[p.pos++];
  h |= (b & 0x01) << 31;
  if (b < 0x80) return toNum(l, h, s);
  throw new Error('Expected varint not more than 10 bytes');
}

function readPackedEnd(pbf) {
  return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
}

function toNum(low, high, isSigned) {
  if (isSigned) {
    return high * 0x100000000 + (low >>> 0);
  }

  return (high >>> 0) * 0x100000000 + (low >>> 0);
}

function writeBigVarint(val, pbf) {
  var low, high;

  if (val >= 0) {
    low = val % 0x100000000 | 0;
    high = val / 0x100000000 | 0;
  } else {
    low = ~(-val % 0x100000000);
    high = ~(-val / 0x100000000);

    if (low ^ 0xffffffff) {
      low = low + 1 | 0;
    } else {
      low = 0;
      high = high + 1 | 0;
    }
  }

  if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
    throw new Error('Given varint doesn\'t fit into 10 bytes');
  }

  pbf.realloc(10);
  writeBigVarintLow(low, high, pbf);
  writeBigVarintHigh(high, pbf);
}

function writeBigVarintLow(low, high, pbf) {
  pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
  low >>>= 7;
  pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
  low >>>= 7;
  pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
  low >>>= 7;
  pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
  low >>>= 7;
  pbf.buf[pbf.pos] = low & 0x7f;
}

function writeBigVarintHigh(high, pbf) {
  var lsb = (high & 0x07) << 4;
  pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 0x80 : 0);
  if (!high) return;
  pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
  if (!high) return;
  pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
  if (!high) return;
  pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
  if (!high) return;
  pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
  if (!high) return;
  pbf.buf[pbf.pos++] = high & 0x7f;
}

function makeRoomForExtraLength(startPos, len, pbf) {
  var extraLen = len <= 0x3fff ? 1 : len <= 0x1fffff ? 2 : len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7)); // if 1 byte isn't enough for encoding message length, shift the data to the right

  pbf.realloc(extraLen);

  for (var i = pbf.pos - 1; i >= startPos; i--) {
    pbf.buf[i + extraLen] = pbf.buf[i];
  }
}

function _writePackedVarint(arr, pbf) {
  for (var i = 0; i < arr.length; i++) {
    pbf.writeVarint(arr[i]);
  }
}

function _writePackedSVarint(arr, pbf) {
  for (var i = 0; i < arr.length; i++) {
    pbf.writeSVarint(arr[i]);
  }
}

function _writePackedFloat(arr, pbf) {
  for (var i = 0; i < arr.length; i++) {
    pbf.writeFloat(arr[i]);
  }
}

function _writePackedDouble(arr, pbf) {
  for (var i = 0; i < arr.length; i++) {
    pbf.writeDouble(arr[i]);
  }
}

function _writePackedBoolean(arr, pbf) {
  for (var i = 0; i < arr.length; i++) {
    pbf.writeBoolean(arr[i]);
  }
}

function _writePackedFixed(arr, pbf) {
  for (var i = 0; i < arr.length; i++) {
    pbf.writeFixed32(arr[i]);
  }
}

function _writePackedSFixed(arr, pbf) {
  for (var i = 0; i < arr.length; i++) {
    pbf.writeSFixed32(arr[i]);
  }
}

function _writePackedFixed2(arr, pbf) {
  for (var i = 0; i < arr.length; i++) {
    pbf.writeFixed64(arr[i]);
  }
}

function _writePackedSFixed2(arr, pbf) {
  for (var i = 0; i < arr.length; i++) {
    pbf.writeSFixed64(arr[i]);
  }
} // Buffer code below from https://github.com/feross/buffer, MIT-licensed


function readUInt32(buf, pos) {
  return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 0x1000000;
}

function writeInt32(buf, val, pos) {
  buf[pos] = val;
  buf[pos + 1] = val >>> 8;
  buf[pos + 2] = val >>> 16;
  buf[pos + 3] = val >>> 24;
}

function readInt32(buf, pos) {
  return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
}

function readUtf8(buf, pos, end) {
  var str = '';
  var i = pos;

  while (i < end) {
    var b0 = buf[i];
    var c = null; // codepoint

    var bytesPerSequence = b0 > 0xEF ? 4 : b0 > 0xDF ? 3 : b0 > 0xBF ? 2 : 1;
    if (i + bytesPerSequence > end) break;
    var b1, b2, b3;

    if (bytesPerSequence === 1) {
      if (b0 < 0x80) {
        c = b0;
      }
    } else if (bytesPerSequence === 2) {
      b1 = buf[i + 1];

      if ((b1 & 0xC0) === 0x80) {
        c = (b0 & 0x1F) << 0x6 | b1 & 0x3F;

        if (c <= 0x7F) {
          c = null;
        }
      }
    } else if (bytesPerSequence === 3) {
      b1 = buf[i + 1];
      b2 = buf[i + 2];

      if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
        c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | b2 & 0x3F;

        if (c <= 0x7FF || c >= 0xD800 && c <= 0xDFFF) {
          c = null;
        }
      }
    } else if (bytesPerSequence === 4) {
      b1 = buf[i + 1];
      b2 = buf[i + 2];
      b3 = buf[i + 3];

      if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
        c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | b3 & 0x3F;

        if (c <= 0xFFFF || c >= 0x110000) {
          c = null;
        }
      }
    }

    if (c === null) {
      c = 0xFFFD;
      bytesPerSequence = 1;
    } else if (c > 0xFFFF) {
      c -= 0x10000;
      str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
      c = 0xDC00 | c & 0x3FF;
    }

    str += String.fromCharCode(c);
    i += bytesPerSequence;
  }

  return str;
}

function readUtf8TextDecoder(buf, pos, end) {
  return utf8TextDecoder.decode(buf.subarray(pos, end));
}

function writeUtf8(buf, str, pos) {
  for (var i = 0, c, lead; i < str.length; i++) {
    c = str.charCodeAt(i); // code point

    if (c > 0xD7FF && c < 0xE000) {
      if (lead) {
        if (c < 0xDC00) {
          buf[pos++] = 0xEF;
          buf[pos++] = 0xBF;
          buf[pos++] = 0xBD;
          lead = c;
          continue;
        } else {
          c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
          lead = null;
        }
      } else {
        if (c > 0xDBFF || i + 1 === str.length) {
          buf[pos++] = 0xEF;
          buf[pos++] = 0xBF;
          buf[pos++] = 0xBD;
        } else {
          lead = c;
        }

        continue;
      }
    } else if (lead) {
      buf[pos++] = 0xEF;
      buf[pos++] = 0xBF;
      buf[pos++] = 0xBD;
      lead = null;
    }

    if (c < 0x80) {
      buf[pos++] = c;
    } else {
      if (c < 0x800) {
        buf[pos++] = c >> 0x6 | 0xC0;
      } else {
        if (c < 0x10000) {
          buf[pos++] = c >> 0xC | 0xE0;
        } else {
          buf[pos++] = c >> 0x12 | 0xF0;
          buf[pos++] = c >> 0xC & 0x3F | 0x80;
        }

        buf[pos++] = c >> 0x6 & 0x3F | 0x80;
      }

      buf[pos++] = c & 0x3F | 0x80;
    }
  }

  return pos;
}

/***/ }),

/***/ "./node_modules/rbush/rbush.min.js":
/*!*****************************************!*\
  !*** ./node_modules/rbush/rbush.min.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

!function (t, i) {
  "object" == ( false ? 0 : _typeof(exports)) && "undefined" != "object" ? module.exports = i() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (i),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;
}(this, function () {
  "use strict";

  function t(t, r, e, a, h) {
    !function t(n, r, e, a, h) {
      for (; a > e;) {
        if (a - e > 600) {
          var o = a - e + 1,
              s = r - e + 1,
              l = Math.log(o),
              f = .5 * Math.exp(2 * l / 3),
              u = .5 * Math.sqrt(l * f * (o - f) / o) * (s - o / 2 < 0 ? -1 : 1),
              m = Math.max(e, Math.floor(r - s * f / o + u)),
              c = Math.min(a, Math.floor(r + (o - s) * f / o + u));
          t(n, r, m, c, h);
        }

        var p = n[r],
            d = e,
            x = a;

        for (i(n, e, r), h(n[a], p) > 0 && i(n, e, a); d < x;) {
          for (i(n, d, x), d++, x--; h(n[d], p) < 0;) {
            d++;
          }

          for (; h(n[x], p) > 0;) {
            x--;
          }
        }

        0 === h(n[e], p) ? i(n, e, x) : i(n, ++x, a), x <= r && (e = x + 1), r <= x && (a = x - 1);
      }
    }(t, r, e || 0, a || t.length - 1, h || n);
  }

  function i(t, i, n) {
    var r = t[i];
    t[i] = t[n], t[n] = r;
  }

  function n(t, i) {
    return t < i ? -1 : t > i ? 1 : 0;
  }

  var r = function r(t) {
    void 0 === t && (t = 9), this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear();
  };

  function e(t, i, n) {
    if (!n) return i.indexOf(t);

    for (var r = 0; r < i.length; r++) {
      if (n(t, i[r])) return r;
    }

    return -1;
  }

  function a(t, i) {
    h(t, 0, t.children.length, i, t);
  }

  function h(t, i, n, r, e) {
    e || (e = p(null)), e.minX = 1 / 0, e.minY = 1 / 0, e.maxX = -1 / 0, e.maxY = -1 / 0;

    for (var a = i; a < n; a++) {
      var h = t.children[a];
      o(e, t.leaf ? r(h) : h);
    }

    return e;
  }

  function o(t, i) {
    return t.minX = Math.min(t.minX, i.minX), t.minY = Math.min(t.minY, i.minY), t.maxX = Math.max(t.maxX, i.maxX), t.maxY = Math.max(t.maxY, i.maxY), t;
  }

  function s(t, i) {
    return t.minX - i.minX;
  }

  function l(t, i) {
    return t.minY - i.minY;
  }

  function f(t) {
    return (t.maxX - t.minX) * (t.maxY - t.minY);
  }

  function u(t) {
    return t.maxX - t.minX + (t.maxY - t.minY);
  }

  function m(t, i) {
    return t.minX <= i.minX && t.minY <= i.minY && i.maxX <= t.maxX && i.maxY <= t.maxY;
  }

  function c(t, i) {
    return i.minX <= t.maxX && i.minY <= t.maxY && i.maxX >= t.minX && i.maxY >= t.minY;
  }

  function p(t) {
    return {
      children: t,
      height: 1,
      leaf: !0,
      minX: 1 / 0,
      minY: 1 / 0,
      maxX: -1 / 0,
      maxY: -1 / 0
    };
  }

  function d(i, n, r, e, a) {
    for (var h = [n, r]; h.length;) {
      if (!((r = h.pop()) - (n = h.pop()) <= e)) {
        var o = n + Math.ceil((r - n) / e / 2) * e;
        t(i, o, n, r, a), h.push(n, o, o, r);
      }
    }
  }

  return r.prototype.all = function () {
    return this._all(this.data, []);
  }, r.prototype.search = function (t) {
    var i = this.data,
        n = [];
    if (!c(t, i)) return n;

    for (var r = this.toBBox, e = []; i;) {
      for (var a = 0; a < i.children.length; a++) {
        var h = i.children[a],
            o = i.leaf ? r(h) : h;
        c(t, o) && (i.leaf ? n.push(h) : m(t, o) ? this._all(h, n) : e.push(h));
      }

      i = e.pop();
    }

    return n;
  }, r.prototype.collides = function (t) {
    var i = this.data;
    if (!c(t, i)) return !1;

    for (var n = []; i;) {
      for (var r = 0; r < i.children.length; r++) {
        var e = i.children[r],
            a = i.leaf ? this.toBBox(e) : e;

        if (c(t, a)) {
          if (i.leaf || m(t, a)) return !0;
          n.push(e);
        }
      }

      i = n.pop();
    }

    return !1;
  }, r.prototype.load = function (t) {
    if (!t || !t.length) return this;

    if (t.length < this._minEntries) {
      for (var i = 0; i < t.length; i++) {
        this.insert(t[i]);
      }

      return this;
    }

    var n = this._build(t.slice(), 0, t.length - 1, 0);

    if (this.data.children.length) {
      if (this.data.height === n.height) this._splitRoot(this.data, n);else {
        if (this.data.height < n.height) {
          var r = this.data;
          this.data = n, n = r;
        }

        this._insert(n, this.data.height - n.height - 1, !0);
      }
    } else this.data = n;
    return this;
  }, r.prototype.insert = function (t) {
    return t && this._insert(t, this.data.height - 1), this;
  }, r.prototype.clear = function () {
    return this.data = p([]), this;
  }, r.prototype.remove = function (t, i) {
    if (!t) return this;

    for (var n, r, a, h = this.data, o = this.toBBox(t), s = [], l = []; h || s.length;) {
      if (h || (h = s.pop(), r = s[s.length - 1], n = l.pop(), a = !0), h.leaf) {
        var f = e(t, h.children, i);
        if (-1 !== f) return h.children.splice(f, 1), s.push(h), this._condense(s), this;
      }

      a || h.leaf || !m(h, o) ? r ? (n++, h = r.children[n], a = !1) : h = null : (s.push(h), l.push(n), n = 0, r = h, h = h.children[0]);
    }

    return this;
  }, r.prototype.toBBox = function (t) {
    return t;
  }, r.prototype.compareMinX = function (t, i) {
    return t.minX - i.minX;
  }, r.prototype.compareMinY = function (t, i) {
    return t.minY - i.minY;
  }, r.prototype.toJSON = function () {
    return this.data;
  }, r.prototype.fromJSON = function (t) {
    return this.data = t, this;
  }, r.prototype._all = function (t, i) {
    for (var n = []; t;) {
      t.leaf ? i.push.apply(i, t.children) : n.push.apply(n, t.children), t = n.pop();
    }

    return i;
  }, r.prototype._build = function (t, i, n, r) {
    var e,
        h = n - i + 1,
        o = this._maxEntries;
    if (h <= o) return a(e = p(t.slice(i, n + 1)), this.toBBox), e;
    r || (r = Math.ceil(Math.log(h) / Math.log(o)), o = Math.ceil(h / Math.pow(o, r - 1))), (e = p([])).leaf = !1, e.height = r;
    var s = Math.ceil(h / o),
        l = s * Math.ceil(Math.sqrt(o));
    d(t, i, n, l, this.compareMinX);

    for (var f = i; f <= n; f += l) {
      var u = Math.min(f + l - 1, n);
      d(t, f, u, s, this.compareMinY);

      for (var m = f; m <= u; m += s) {
        var c = Math.min(m + s - 1, u);
        e.children.push(this._build(t, m, c, r - 1));
      }
    }

    return a(e, this.toBBox), e;
  }, r.prototype._chooseSubtree = function (t, i, n, r) {
    for (; r.push(i), !i.leaf && r.length - 1 !== n;) {
      for (var e = 1 / 0, a = 1 / 0, h = void 0, o = 0; o < i.children.length; o++) {
        var s = i.children[o],
            l = f(s),
            u = (m = t, c = s, (Math.max(c.maxX, m.maxX) - Math.min(c.minX, m.minX)) * (Math.max(c.maxY, m.maxY) - Math.min(c.minY, m.minY)) - l);
        u < a ? (a = u, e = l < e ? l : e, h = s) : u === a && l < e && (e = l, h = s);
      }

      i = h || i.children[0];
    }

    var m, c;
    return i;
  }, r.prototype._insert = function (t, i, n) {
    var r = n ? t : this.toBBox(t),
        e = [],
        a = this._chooseSubtree(r, this.data, i, e);

    for (a.children.push(t), o(a, r); i >= 0 && e[i].children.length > this._maxEntries;) {
      this._split(e, i), i--;
    }

    this._adjustParentBBoxes(r, e, i);
  }, r.prototype._split = function (t, i) {
    var n = t[i],
        r = n.children.length,
        e = this._minEntries;

    this._chooseSplitAxis(n, e, r);

    var h = this._chooseSplitIndex(n, e, r),
        o = p(n.children.splice(h, n.children.length - h));

    o.height = n.height, o.leaf = n.leaf, a(n, this.toBBox), a(o, this.toBBox), i ? t[i - 1].children.push(o) : this._splitRoot(n, o);
  }, r.prototype._splitRoot = function (t, i) {
    this.data = p([t, i]), this.data.height = t.height + 1, this.data.leaf = !1, a(this.data, this.toBBox);
  }, r.prototype._chooseSplitIndex = function (t, i, n) {
    for (var r, e, a, o, s, l, u, m = 1 / 0, c = 1 / 0, p = i; p <= n - i; p++) {
      var d = h(t, 0, p, this.toBBox),
          x = h(t, p, n, this.toBBox),
          v = (e = d, a = x, o = void 0, s = void 0, l = void 0, u = void 0, o = Math.max(e.minX, a.minX), s = Math.max(e.minY, a.minY), l = Math.min(e.maxX, a.maxX), u = Math.min(e.maxY, a.maxY), Math.max(0, l - o) * Math.max(0, u - s)),
          M = f(d) + f(x);
      v < m ? (m = v, r = p, c = M < c ? M : c) : v === m && M < c && (c = M, r = p);
    }

    return r || n - i;
  }, r.prototype._chooseSplitAxis = function (t, i, n) {
    var r = t.leaf ? this.compareMinX : s,
        e = t.leaf ? this.compareMinY : l;
    this._allDistMargin(t, i, n, r) < this._allDistMargin(t, i, n, e) && t.children.sort(r);
  }, r.prototype._allDistMargin = function (t, i, n, r) {
    t.children.sort(r);

    for (var e = this.toBBox, a = h(t, 0, i, e), s = h(t, n - i, n, e), l = u(a) + u(s), f = i; f < n - i; f++) {
      var m = t.children[f];
      o(a, t.leaf ? e(m) : m), l += u(a);
    }

    for (var c = n - i - 1; c >= i; c--) {
      var p = t.children[c];
      o(s, t.leaf ? e(p) : p), l += u(s);
    }

    return l;
  }, r.prototype._adjustParentBBoxes = function (t, i, n) {
    for (var r = n; r >= 0; r--) {
      o(i[r], t);
    }
  }, r.prototype._condense = function (t) {
    for (var i = t.length - 1, n = void 0; i >= 0; i--) {
      0 === t[i].children.length ? i > 0 ? (n = t[i - 1].children).splice(n.indexOf(t[i]), 1) : this.clear() : a(t[i], this.toBBox);
    }
  }, r;
});

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }

  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  define(Gp, iteratorSymbol, function () {
    return this;
  });
  define(Gp, "toString", function () {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function stop() {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
( false ? 0 : _typeof(module)) === "object" ? module.exports : {});

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if ((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

/***/ }),

/***/ "./node_modules/xml-utils/find-tag-by-name.js":
/*!****************************************************!*\
  !*** ./node_modules/xml-utils/find-tag-by-name.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var indexOfMatch = __webpack_require__(/*! ./index-of-match.js */ "./node_modules/xml-utils/index-of-match.js");

function findTagByName(xml, tagName, options) {
  var debug = options && options.debug || false;
  var startIndex = options && options.startIndex || 0;
  if (debug) console.log("starting findTagByName with", tagName, " and ", options);
  var start = indexOfMatch(xml, "<".concat(tagName, "[ >]"), startIndex);
  if (debug) console.log("start:", start);
  if (start === -1) return undefined;
  var afterStart = xml.slice(start + tagName.length);
  var relativeEnd = indexOfMatch(afterStart, "[ /]" + tagName + ">", 0);
  var selfClosing = relativeEnd === -1;

  if (selfClosing) {
    relativeEnd = indexOfMatch(afterStart, "[ /]>", 0);
  }

  var end = start + tagName.length + relativeEnd + 1 + (selfClosing ? 0 : tagName.length) + 1;
  if (debug) console.log("end:", end);
  if (end === -1) return undefined;
  var outer = xml.slice(start, end); // tag is like <gml:identifier codeSpace="OGP">urn:ogc:def:crs:EPSG::32617</gml:identifier>

  var inner;

  if (selfClosing) {
    inner = null;
  } else {
    inner = outer.slice(outer.indexOf(">") + 1, outer.lastIndexOf("<"));
  }

  return {
    inner: inner,
    outer: outer,
    start: start,
    end: end
  };
}

module.exports = findTagByName;

/***/ }),

/***/ "./node_modules/xml-utils/find-tags-by-name.js":
/*!*****************************************************!*\
  !*** ./node_modules/xml-utils/find-tags-by-name.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var findTagByName = __webpack_require__(/*! ./find-tag-by-name.js */ "./node_modules/xml-utils/find-tag-by-name.js");

function findTagsByName(xml, tagName, options) {
  var tags = [];
  var debug = options && options.debug || false;
  var startIndex = options && options.startIndex || 0;
  var tag;

  while (tag = findTagByName(xml, tagName, {
    debug: debug,
    startIndex: startIndex
  })) {
    startIndex = tag.end;
    tags.push(tag);
  }

  if (debug) console.log("findTagsByName found", tags.length, "tags");
  return tags;
}

module.exports = findTagsByName;

/***/ }),

/***/ "./node_modules/xml-utils/get-attribute.js":
/*!*************************************************!*\
  !*** ./node_modules/xml-utils/get-attribute.js ***!
  \*************************************************/
/***/ (function(module) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function getAttribute(tag, attributeName, options) {
  var debug = options && options.debug || false;
  if (debug) console.log("getting " + attributeName + " in " + tag);
  var xml = _typeof(tag) === "object" ? tag.outer : tag;
  var pattern = "".concat(attributeName, "\\=\"([^\"]*)\"");
  if (debug) console.log("pattern:", pattern);
  var re = new RegExp(pattern);
  var match = re.exec(xml);
  if (debug) console.log("match:", match);
  if (match) return match[1];
}

module.exports = getAttribute;

/***/ }),

/***/ "./node_modules/xml-utils/index-of-match.js":
/*!**************************************************!*\
  !*** ./node_modules/xml-utils/index-of-match.js ***!
  \**************************************************/
/***/ (function(module) {

function indexOfMatch(xml, pattern, startIndex) {
  var re = new RegExp(pattern);
  var match = re.exec(xml.slice(startIndex));
  if (match) return startIndex + match.index;else return -1;
}

module.exports = indexOfMatch;

/***/ }),

/***/ "./node_modules/yallist/iterator.js":
/*!******************************************!*\
  !*** ./node_modules/yallist/iterator.js ***!
  \******************************************/
/***/ (function(module) {

"use strict";


module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var walker;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            walker = this.head;

          case 1:
            if (!walker) {
              _context.next = 7;
              break;
            }

            _context.next = 4;
            return walker.value;

          case 4:
            walker = walker.next;
            _context.next = 1;
            break;

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  });
};

/***/ }),

/***/ "./node_modules/yallist/yallist.js":
/*!*****************************************!*\
  !*** ./node_modules/yallist/yallist.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;

function Yallist(list) {
  var self = this;

  if (!(self instanceof Yallist)) {
    self = new Yallist();
  }

  self.tail = null;
  self.head = null;
  self.length = 0;

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }

  return self;
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list');
  }

  var next = node.next;
  var prev = node.prev;

  if (next) {
    next.prev = prev;
  }

  if (prev) {
    prev.next = next;
  }

  if (node === this.head) {
    this.head = next;
  }

  if (node === this.tail) {
    this.tail = prev;
  }

  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var head = this.head;
  node.list = this;
  node.next = head;

  if (head) {
    head.prev = node;
  }

  this.head = node;

  if (!this.tail) {
    this.tail = node;
  }

  this.length++;
};

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var tail = this.tail;
  node.list = this;
  node.prev = tail;

  if (tail) {
    tail.next = node;
  }

  this.tail = node;

  if (!this.head) {
    this.head = node;
  }

  this.length++;
};

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined;
  }

  var res = this.tail.value;
  this.tail = this.tail.prev;

  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined;
  }

  var res = this.head.value;
  this.head = this.head.next;

  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }

  return res;
};

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }

  return res;
};

Yallist.prototype.reduce = function (fn, initial) {
  var acc;
  var walker = this.head;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }

  return acc;
};

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc;
  var walker = this.tail;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }

  return acc;
};

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }

  return arr;
};

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }

  return arr;
};

Yallist.prototype.slice = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }

  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }

  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.splice = function (start, deleteCount) {
  if (start > this.length) {
    start = this.length - 1;
  }

  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }

  var ret = [];

  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }

  if (walker === null) {
    walker = this.tail;
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }

  for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {
    walker = insert(this, walker, i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2]);
  }

  return ret;
};

Yallist.prototype.reverse = function () {
  var head = this.head;
  var tail = this.tail;

  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }

  this.head = tail;
  this.tail = head;
  return this;
};

function insert(self, node, value) {
  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);

  if (inserted.next === null) {
    self.tail = inserted;
  }

  if (inserted.prev === null) {
    self.head = inserted;
  }

  self.length++;
  return inserted;
}

function push(self, item) {
  self.tail = new Node(item, self.tail, null, self);

  if (!self.head) {
    self.head = self.tail;
  }

  self.length++;
}

function unshift(self, item) {
  self.head = new Node(item, null, self.head, self);

  if (!self.tail) {
    self.tail = self.head;
  }

  self.length++;
}

function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }

  this.list = list;
  this.value = value;

  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }

  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(/*! ./iterator.js */ "./node_modules/yallist/iterator.js")(Yallist);
} catch (er) {}

/***/ }),

/***/ "?cdec":
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?753a":
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?4e4d":
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?662e":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "./build/index.js":
/*!************************!*\
  !*** ./build/index.js ***!
  \************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _wg_array_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./wg/array.js */ "./build/wg/array.js");
/* harmony import */ var _wg_AssertionError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wg/AssertionError.js */ "./build/wg/AssertionError.js");
/* harmony import */ var _wg_asserts_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./wg/asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _wg_centerconstraint_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./wg/centerconstraint.js */ "./build/wg/centerconstraint.js");
/* harmony import */ var _wg_Collection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wg/Collection.js */ "./build/wg/Collection.js");
/* harmony import */ var _wg_color_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./wg/color.js */ "./build/wg/color.js");
/* harmony import */ var _wg_colorlike_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./wg/colorlike.js */ "./build/wg/colorlike.js");
/* harmony import */ var _wg_control_Attribution_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./wg/control/Attribution.js */ "./build/wg/control/Attribution.js");
/* harmony import */ var _wg_control_Control_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./wg/control/Control.js */ "./build/wg/control/Control.js");
/* harmony import */ var _wg_control_FullScreen_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./wg/control/FullScreen.js */ "./build/wg/control/FullScreen.js");
/* harmony import */ var _wg_control_MousePosition_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./wg/control/MousePosition.js */ "./build/wg/control/MousePosition.js");
/* harmony import */ var _wg_control_OverviewMap_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./wg/control/OverviewMap.js */ "./build/wg/control/OverviewMap.js");
/* harmony import */ var _wg_control_Rotate_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./wg/control/Rotate.js */ "./build/wg/control/Rotate.js");
/* harmony import */ var _wg_control_ScaleLine_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./wg/control/ScaleLine.js */ "./build/wg/control/ScaleLine.js");
/* harmony import */ var _wg_control_Zoom_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./wg/control/Zoom.js */ "./build/wg/control/Zoom.js");
/* harmony import */ var _wg_control_ZoomSlider_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./wg/control/ZoomSlider.js */ "./build/wg/control/ZoomSlider.js");
/* harmony import */ var _wg_control_ZoomToExtent_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./wg/control/ZoomToExtent.js */ "./build/wg/control/ZoomToExtent.js");
/* harmony import */ var _wg_control_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./wg/control.js */ "./build/wg/control.js");
/* harmony import */ var _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./wg/coordinate.js */ "./build/wg/coordinate.js");
/* harmony import */ var _wg_css_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./wg/css.js */ "./build/wg/css.js");
/* harmony import */ var _wg_DataTile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wg/DataTile.js */ "./build/wg/DataTile.js");
/* harmony import */ var _wg_Disposable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wg/Disposable.js */ "./build/wg/Disposable.js");
/* harmony import */ var _wg_dom_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./wg/dom.js */ "./build/wg/dom.js");
/* harmony import */ var _wg_easing_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./wg/easing.js */ "./build/wg/easing.js");
/* harmony import */ var _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./wg/events/condition.js */ "./build/wg/events/condition.js");
/* harmony import */ var _wg_events_Event_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./wg/events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _wg_events_Target_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./wg/events/Target.js */ "./build/wg/events/Target.js");
/* harmony import */ var _wg_events_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./wg/events.js */ "./build/wg/events.js");
/* harmony import */ var _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./wg/extent.js */ "./build/wg/extent.js");
/* harmony import */ var _wg_Feature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wg/Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _wg_featureloader_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./wg/featureloader.js */ "./build/wg/featureloader.js");
/* harmony import */ var _wg_format_EsriJSON_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./wg/format/EsriJSON.js */ "./build/wg/format/EsriJSON.js");
/* harmony import */ var _wg_format_Feature_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./wg/format/Feature.js */ "./build/wg/format/Feature.js");
/* harmony import */ var _wg_format_filter_And_js__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./wg/format/filter/And.js */ "./build/wg/format/filter/And.js");
/* harmony import */ var _wg_format_filter_Bbox_js__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./wg/format/filter/Bbox.js */ "./build/wg/format/filter/Bbox.js");
/* harmony import */ var _wg_format_filter_Comparison_js__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./wg/format/filter/Comparison.js */ "./build/wg/format/filter/Comparison.js");
/* harmony import */ var _wg_format_filter_ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./wg/format/filter/ComparisonBinary.js */ "./build/wg/format/filter/ComparisonBinary.js");
/* harmony import */ var _wg_format_filter_Contains_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./wg/format/filter/Contains.js */ "./build/wg/format/filter/Contains.js");
/* harmony import */ var _wg_format_filter_Disjoint_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./wg/format/filter/Disjoint.js */ "./build/wg/format/filter/Disjoint.js");
/* harmony import */ var _wg_format_filter_During_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./wg/format/filter/During.js */ "./build/wg/format/filter/During.js");
/* harmony import */ var _wg_format_filter_DWithin_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./wg/format/filter/DWithin.js */ "./build/wg/format/filter/DWithin.js");
/* harmony import */ var _wg_format_filter_EqualTo_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./wg/format/filter/EqualTo.js */ "./build/wg/format/filter/EqualTo.js");
/* harmony import */ var _wg_format_filter_Filter_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./wg/format/filter/Filter.js */ "./build/wg/format/filter/Filter.js");
/* harmony import */ var _wg_format_filter_GreaterThan_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./wg/format/filter/GreaterThan.js */ "./build/wg/format/filter/GreaterThan.js");
/* harmony import */ var _wg_format_filter_GreaterThanOrEqualTo_js__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./wg/format/filter/GreaterThanOrEqualTo.js */ "./build/wg/format/filter/GreaterThanOrEqualTo.js");
/* harmony import */ var _wg_format_filter_Intersects_js__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./wg/format/filter/Intersects.js */ "./build/wg/format/filter/Intersects.js");
/* harmony import */ var _wg_format_filter_IsBetween_js__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./wg/format/filter/IsBetween.js */ "./build/wg/format/filter/IsBetween.js");
/* harmony import */ var _wg_format_filter_IsLike_js__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./wg/format/filter/IsLike.js */ "./build/wg/format/filter/IsLike.js");
/* harmony import */ var _wg_format_filter_IsNull_js__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./wg/format/filter/IsNull.js */ "./build/wg/format/filter/IsNull.js");
/* harmony import */ var _wg_format_filter_LessThan_js__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./wg/format/filter/LessThan.js */ "./build/wg/format/filter/LessThan.js");
/* harmony import */ var _wg_format_filter_LessThanOrEqualTo_js__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./wg/format/filter/LessThanOrEqualTo.js */ "./build/wg/format/filter/LessThanOrEqualTo.js");
/* harmony import */ var _wg_format_filter_LogicalNary_js__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./wg/format/filter/LogicalNary.js */ "./build/wg/format/filter/LogicalNary.js");
/* harmony import */ var _wg_format_filter_Not_js__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./wg/format/filter/Not.js */ "./build/wg/format/filter/Not.js");
/* harmony import */ var _wg_format_filter_NotEqualTo_js__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./wg/format/filter/NotEqualTo.js */ "./build/wg/format/filter/NotEqualTo.js");
/* harmony import */ var _wg_format_filter_Or_js__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./wg/format/filter/Or.js */ "./build/wg/format/filter/Or.js");
/* harmony import */ var _wg_format_filter_ResourceId_js__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./wg/format/filter/ResourceId.js */ "./build/wg/format/filter/ResourceId.js");
/* harmony import */ var _wg_format_filter_Spatial_js__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./wg/format/filter/Spatial.js */ "./build/wg/format/filter/Spatial.js");
/* harmony import */ var _wg_format_filter_Within_js__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./wg/format/filter/Within.js */ "./build/wg/format/filter/Within.js");
/* harmony import */ var _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./wg/format/filter.js */ "./build/wg/format/filter.js");
/* harmony import */ var _wg_format_GeoJSON_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./wg/format/GeoJSON.js */ "./build/wg/format/GeoJSON.js");
/* harmony import */ var _wg_format_GML_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./wg/format/GML.js */ "./build/wg/format/GML.js");
/* harmony import */ var _wg_format_GML2_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./wg/format/GML2.js */ "./build/wg/format/GML2.js");
/* harmony import */ var _wg_format_GML3_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./wg/format/GML3.js */ "./build/wg/format/GML3.js");
/* harmony import */ var _wg_format_GML32_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./wg/format/GML32.js */ "./build/wg/format/GML32.js");
/* harmony import */ var _wg_format_GMLBase_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./wg/format/GMLBase.js */ "./build/wg/format/GMLBase.js");
/* harmony import */ var _wg_format_GPX_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./wg/format/GPX.js */ "./build/wg/format/GPX.js");
/* harmony import */ var _wg_format_IGC_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./wg/format/IGC.js */ "./build/wg/format/IGC.js");
/* harmony import */ var _wg_format_IIIFInfo_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./wg/format/IIIFInfo.js */ "./build/wg/format/IIIFInfo.js");
/* harmony import */ var _wg_format_JSONFeature_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./wg/format/JSONFeature.js */ "./build/wg/format/JSONFeature.js");
/* harmony import */ var _wg_format_KML_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./wg/format/KML.js */ "./build/wg/format/KML.js");
/* harmony import */ var _wg_format_MVT_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./wg/format/MVT.js */ "./build/wg/format/MVT.js");
/* harmony import */ var _wg_format_OSMXML_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./wg/format/OSMXML.js */ "./build/wg/format/OSMXML.js");
/* harmony import */ var _wg_format_OWS_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./wg/format/OWS.js */ "./build/wg/format/OWS.js");
/* harmony import */ var _wg_format_Polyline_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./wg/format/Polyline.js */ "./build/wg/format/Polyline.js");
/* harmony import */ var _wg_format_TextFeature_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./wg/format/TextFeature.js */ "./build/wg/format/TextFeature.js");
/* harmony import */ var _wg_format_TopoJSON_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./wg/format/TopoJSON.js */ "./build/wg/format/TopoJSON.js");
/* harmony import */ var _wg_format_WFS_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./wg/format/WFS.js */ "./build/wg/format/WFS.js");
/* harmony import */ var _wg_format_WKB_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./wg/format/WKB.js */ "./build/wg/format/WKB.js");
/* harmony import */ var _wg_format_WKT_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./wg/format/WKT.js */ "./build/wg/format/WKT.js");
/* harmony import */ var _wg_format_WMSCapabilities_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./wg/format/WMSCapabilities.js */ "./build/wg/format/WMSCapabilities.js");
/* harmony import */ var _wg_format_WMSGetFeatureInfo_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./wg/format/WMSGetFeatureInfo.js */ "./build/wg/format/WMSGetFeatureInfo.js");
/* harmony import */ var _wg_format_WMTSCapabilities_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./wg/format/WMTSCapabilities.js */ "./build/wg/format/WMTSCapabilities.js");
/* harmony import */ var _wg_format_xlink_js__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./wg/format/xlink.js */ "./build/wg/format/xlink.js");
/* harmony import */ var _wg_format_XML_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./wg/format/XML.js */ "./build/wg/format/XML.js");
/* harmony import */ var _wg_format_XMLFeature_js__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./wg/format/XMLFeature.js */ "./build/wg/format/XMLFeature.js");
/* harmony import */ var _wg_format_xsd_js__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./wg/format/xsd.js */ "./build/wg/format/xsd.js");
/* harmony import */ var _wg_functions_js__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./wg/functions.js */ "./build/wg/functions.js");
/* harmony import */ var _wg_Geolocation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wg/Geolocation.js */ "./build/wg/Geolocation.js");
/* harmony import */ var _wg_geom_Circle_js__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./wg/geom/Circle.js */ "./build/wg/geom/Circle.js");
/* harmony import */ var _wg_geom_flat_area_js__WEBPACK_IMPORTED_MODULE_120__ = __webpack_require__(/*! ./wg/geom/flat/area.js */ "./build/wg/geom/flat/area.js");
/* harmony import */ var _wg_geom_flat_center_js__WEBPACK_IMPORTED_MODULE_121__ = __webpack_require__(/*! ./wg/geom/flat/center.js */ "./build/wg/geom/flat/center.js");
/* harmony import */ var _wg_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_122__ = __webpack_require__(/*! ./wg/geom/flat/closest.js */ "./build/wg/geom/flat/closest.js");
/* harmony import */ var _wg_geom_flat_contains_js__WEBPACK_IMPORTED_MODULE_123__ = __webpack_require__(/*! ./wg/geom/flat/contains.js */ "./build/wg/geom/flat/contains.js");
/* harmony import */ var _wg_geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_124__ = __webpack_require__(/*! ./wg/geom/flat/deflate.js */ "./build/wg/geom/flat/deflate.js");
/* harmony import */ var _wg_geom_flat_flip_js__WEBPACK_IMPORTED_MODULE_125__ = __webpack_require__(/*! ./wg/geom/flat/flip.js */ "./build/wg/geom/flat/flip.js");
/* harmony import */ var _wg_geom_flat_geodesic_js__WEBPACK_IMPORTED_MODULE_126__ = __webpack_require__(/*! ./wg/geom/flat/geodesic.js */ "./build/wg/geom/flat/geodesic.js");
/* harmony import */ var _wg_geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_127__ = __webpack_require__(/*! ./wg/geom/flat/inflate.js */ "./build/wg/geom/flat/inflate.js");
/* harmony import */ var _wg_geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_128__ = __webpack_require__(/*! ./wg/geom/flat/interiorpoint.js */ "./build/wg/geom/flat/interiorpoint.js");
/* harmony import */ var _wg_geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_129__ = __webpack_require__(/*! ./wg/geom/flat/interpolate.js */ "./build/wg/geom/flat/interpolate.js");
/* harmony import */ var _wg_geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_130__ = __webpack_require__(/*! ./wg/geom/flat/intersectsextent.js */ "./build/wg/geom/flat/intersectsextent.js");
/* harmony import */ var _wg_geom_flat_length_js__WEBPACK_IMPORTED_MODULE_131__ = __webpack_require__(/*! ./wg/geom/flat/length.js */ "./build/wg/geom/flat/length.js");
/* harmony import */ var _wg_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_132__ = __webpack_require__(/*! ./wg/geom/flat/orient.js */ "./build/wg/geom/flat/orient.js");
/* harmony import */ var _wg_geom_flat_reverse_js__WEBPACK_IMPORTED_MODULE_133__ = __webpack_require__(/*! ./wg/geom/flat/reverse.js */ "./build/wg/geom/flat/reverse.js");
/* harmony import */ var _wg_geom_flat_segments_js__WEBPACK_IMPORTED_MODULE_134__ = __webpack_require__(/*! ./wg/geom/flat/segments.js */ "./build/wg/geom/flat/segments.js");
/* harmony import */ var _wg_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_135__ = __webpack_require__(/*! ./wg/geom/flat/simplify.js */ "./build/wg/geom/flat/simplify.js");
/* harmony import */ var _wg_geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_136__ = __webpack_require__(/*! ./wg/geom/flat/straightchunk.js */ "./build/wg/geom/flat/straightchunk.js");
/* harmony import */ var _wg_geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_137__ = __webpack_require__(/*! ./wg/geom/flat/textpath.js */ "./build/wg/geom/flat/textpath.js");
/* harmony import */ var _wg_geom_flat_topology_js__WEBPACK_IMPORTED_MODULE_138__ = __webpack_require__(/*! ./wg/geom/flat/topology.js */ "./build/wg/geom/flat/topology.js");
/* harmony import */ var _wg_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_139__ = __webpack_require__(/*! ./wg/geom/flat/transform.js */ "./build/wg/geom/flat/transform.js");
/* harmony import */ var _wg_geom_Geometry_js__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./wg/geom/Geometry.js */ "./build/wg/geom/Geometry.js");
/* harmony import */ var _wg_geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./wg/geom/GeometryCollection.js */ "./build/wg/geom/GeometryCollection.js");
/* harmony import */ var _wg_geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./wg/geom/LinearRing.js */ "./build/wg/geom/LinearRing.js");
/* harmony import */ var _wg_geom_LineString_js__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./wg/geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _wg_geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./wg/geom/MultiLineString.js */ "./build/wg/geom/MultiLineString.js");
/* harmony import */ var _wg_geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./wg/geom/MultiPoint.js */ "./build/wg/geom/MultiPoint.js");
/* harmony import */ var _wg_geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./wg/geom/MultiPolygon.js */ "./build/wg/geom/MultiPolygon.js");
/* harmony import */ var _wg_geom_Point_js__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./wg/geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _wg_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_118__ = __webpack_require__(/*! ./wg/geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _wg_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_119__ = __webpack_require__(/*! ./wg/geom/SimpleGeometry.js */ "./build/wg/geom/SimpleGeometry.js");
/* harmony import */ var _wg_has_js__WEBPACK_IMPORTED_MODULE_140__ = __webpack_require__(/*! ./wg/has.js */ "./build/wg/has.js");
/* harmony import */ var _wg_Image_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./wg/Image.js */ "./build/wg/Image.js");
/* harmony import */ var _wg_ImageBase_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./wg/ImageBase.js */ "./build/wg/ImageBase.js");
/* harmony import */ var _wg_ImageCanvas_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./wg/ImageCanvas.js */ "./build/wg/ImageCanvas.js");
/* harmony import */ var _wg_ImageTile_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./wg/ImageTile.js */ "./build/wg/ImageTile.js");
/* harmony import */ var _wg_interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_141__ = __webpack_require__(/*! ./wg/interaction/DoubleClickZoom.js */ "./build/wg/interaction/DoubleClickZoom.js");
/* harmony import */ var _wg_interaction_DragAndDrop_js__WEBPACK_IMPORTED_MODULE_142__ = __webpack_require__(/*! ./wg/interaction/DragAndDrop.js */ "./build/wg/interaction/DragAndDrop.js");
/* harmony import */ var _wg_interaction_DragBox_js__WEBPACK_IMPORTED_MODULE_143__ = __webpack_require__(/*! ./wg/interaction/DragBox.js */ "./build/wg/interaction/DragBox.js");
/* harmony import */ var _wg_interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_144__ = __webpack_require__(/*! ./wg/interaction/DragPan.js */ "./build/wg/interaction/DragPan.js");
/* harmony import */ var _wg_interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_145__ = __webpack_require__(/*! ./wg/interaction/DragRotate.js */ "./build/wg/interaction/DragRotate.js");
/* harmony import */ var _wg_interaction_DragRotateAndZoom_js__WEBPACK_IMPORTED_MODULE_146__ = __webpack_require__(/*! ./wg/interaction/DragRotateAndZoom.js */ "./build/wg/interaction/DragRotateAndZoom.js");
/* harmony import */ var _wg_interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_147__ = __webpack_require__(/*! ./wg/interaction/DragZoom.js */ "./build/wg/interaction/DragZoom.js");
/* harmony import */ var _wg_interaction_Draw_js__WEBPACK_IMPORTED_MODULE_148__ = __webpack_require__(/*! ./wg/interaction/Draw.js */ "./build/wg/interaction/Draw.js");
/* harmony import */ var _wg_interaction_Extent_js__WEBPACK_IMPORTED_MODULE_149__ = __webpack_require__(/*! ./wg/interaction/Extent.js */ "./build/wg/interaction/Extent.js");
/* harmony import */ var _wg_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_150__ = __webpack_require__(/*! ./wg/interaction/Interaction.js */ "./build/wg/interaction/Interaction.js");
/* harmony import */ var _wg_interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_151__ = __webpack_require__(/*! ./wg/interaction/KeyboardPan.js */ "./build/wg/interaction/KeyboardPan.js");
/* harmony import */ var _wg_interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_152__ = __webpack_require__(/*! ./wg/interaction/KeyboardZoom.js */ "./build/wg/interaction/KeyboardZoom.js");
/* harmony import */ var _wg_interaction_Modify_js__WEBPACK_IMPORTED_MODULE_153__ = __webpack_require__(/*! ./wg/interaction/Modify.js */ "./build/wg/interaction/Modify.js");
/* harmony import */ var _wg_interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_154__ = __webpack_require__(/*! ./wg/interaction/MouseWheelZoom.js */ "./build/wg/interaction/MouseWheelZoom.js");
/* harmony import */ var _wg_interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_155__ = __webpack_require__(/*! ./wg/interaction/PinchRotate.js */ "./build/wg/interaction/PinchRotate.js");
/* harmony import */ var _wg_interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_156__ = __webpack_require__(/*! ./wg/interaction/PinchZoom.js */ "./build/wg/interaction/PinchZoom.js");
/* harmony import */ var _wg_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_157__ = __webpack_require__(/*! ./wg/interaction/Pointer.js */ "./build/wg/interaction/Pointer.js");
/* harmony import */ var _wg_interaction_Select_js__WEBPACK_IMPORTED_MODULE_158__ = __webpack_require__(/*! ./wg/interaction/Select.js */ "./build/wg/interaction/Select.js");
/* harmony import */ var _wg_interaction_Snap_js__WEBPACK_IMPORTED_MODULE_159__ = __webpack_require__(/*! ./wg/interaction/Snap.js */ "./build/wg/interaction/Snap.js");
/* harmony import */ var _wg_interaction_Translate_js__WEBPACK_IMPORTED_MODULE_160__ = __webpack_require__(/*! ./wg/interaction/Translate.js */ "./build/wg/interaction/Translate.js");
/* harmony import */ var _wg_interaction_js__WEBPACK_IMPORTED_MODULE_161__ = __webpack_require__(/*! ./wg/interaction.js */ "./build/wg/interaction.js");
/* harmony import */ var _wg_Kinetic_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./wg/Kinetic.js */ "./build/wg/Kinetic.js");
/* harmony import */ var _wg_layer_Base_js__WEBPACK_IMPORTED_MODULE_162__ = __webpack_require__(/*! ./wg/layer/Base.js */ "./build/wg/layer/Base.js");
/* harmony import */ var _wg_layer_BaseImage_js__WEBPACK_IMPORTED_MODULE_163__ = __webpack_require__(/*! ./wg/layer/BaseImage.js */ "./build/wg/layer/BaseImage.js");
/* harmony import */ var _wg_layer_BaseTile_js__WEBPACK_IMPORTED_MODULE_164__ = __webpack_require__(/*! ./wg/layer/BaseTile.js */ "./build/wg/layer/BaseTile.js");
/* harmony import */ var _wg_layer_BaseVector_js__WEBPACK_IMPORTED_MODULE_165__ = __webpack_require__(/*! ./wg/layer/BaseVector.js */ "./build/wg/layer/BaseVector.js");
/* harmony import */ var _wg_layer_Graticule_js__WEBPACK_IMPORTED_MODULE_166__ = __webpack_require__(/*! ./wg/layer/Graticule.js */ "./build/wg/layer/Graticule.js");
/* harmony import */ var _wg_layer_Group_js__WEBPACK_IMPORTED_MODULE_167__ = __webpack_require__(/*! ./wg/layer/Group.js */ "./build/wg/layer/Group.js");
/* harmony import */ var _wg_layer_Heatmap_js__WEBPACK_IMPORTED_MODULE_168__ = __webpack_require__(/*! ./wg/layer/Heatmap.js */ "./build/wg/layer/Heatmap.js");
/* harmony import */ var _wg_layer_Image_js__WEBPACK_IMPORTED_MODULE_169__ = __webpack_require__(/*! ./wg/layer/Image.js */ "./build/wg/layer/Image.js");
/* harmony import */ var _wg_layer_Layer_js__WEBPACK_IMPORTED_MODULE_170__ = __webpack_require__(/*! ./wg/layer/Layer.js */ "./build/wg/layer/Layer.js");
/* harmony import */ var _wg_layer_MapboxVector_js__WEBPACK_IMPORTED_MODULE_171__ = __webpack_require__(/*! ./wg/layer/MapboxVector.js */ "./build/wg/layer/MapboxVector.js");
/* harmony import */ var _wg_layer_Tile_js__WEBPACK_IMPORTED_MODULE_172__ = __webpack_require__(/*! ./wg/layer/Tile.js */ "./build/wg/layer/Tile.js");
/* harmony import */ var _wg_layer_Vector_js__WEBPACK_IMPORTED_MODULE_173__ = __webpack_require__(/*! ./wg/layer/Vector.js */ "./build/wg/layer/Vector.js");
/* harmony import */ var _wg_layer_VectorImage_js__WEBPACK_IMPORTED_MODULE_174__ = __webpack_require__(/*! ./wg/layer/VectorImage.js */ "./build/wg/layer/VectorImage.js");
/* harmony import */ var _wg_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_175__ = __webpack_require__(/*! ./wg/layer/VectorTile.js */ "./build/wg/layer/VectorTile.js");
/* harmony import */ var _wg_layer_WebGLPoints_js__WEBPACK_IMPORTED_MODULE_176__ = __webpack_require__(/*! ./wg/layer/WebGLPoints.js */ "./build/wg/layer/WebGLPoints.js");
/* harmony import */ var _wg_layer_WebGLTile_js__WEBPACK_IMPORTED_MODULE_177__ = __webpack_require__(/*! ./wg/layer/WebGLTile.js */ "./build/wg/layer/WebGLTile.js");
/* harmony import */ var _wg_loadingstrategy_js__WEBPACK_IMPORTED_MODULE_178__ = __webpack_require__(/*! ./wg/loadingstrategy.js */ "./build/wg/loadingstrategy.js");
/* harmony import */ var _wg_Map_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./wg/Map.js */ "./build/wg/Map.js");
/* harmony import */ var _wg_MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./wg/MapBrowserEvent.js */ "./build/wg/MapBrowserEvent.js");
/* harmony import */ var _wg_MapBrowserEventHandler_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./wg/MapBrowserEventHandler.js */ "./build/wg/MapBrowserEventHandler.js");
/* harmony import */ var _wg_MapEvent_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./wg/MapEvent.js */ "./build/wg/MapEvent.js");
/* harmony import */ var _wg_math_js__WEBPACK_IMPORTED_MODULE_179__ = __webpack_require__(/*! ./wg/math.js */ "./build/wg/math.js");
/* harmony import */ var _wg_net_js__WEBPACK_IMPORTED_MODULE_180__ = __webpack_require__(/*! ./wg/net.js */ "./build/wg/net.js");
/* harmony import */ var _wg_obj_js__WEBPACK_IMPORTED_MODULE_181__ = __webpack_require__(/*! ./wg/obj.js */ "./build/wg/obj.js");
/* harmony import */ var _wg_Object_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./wg/Object.js */ "./build/wg/Object.js");
/* harmony import */ var _wg_Observable_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./wg/Observable.js */ "./build/wg/Observable.js");
/* harmony import */ var _wg_Overlay_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./wg/Overlay.js */ "./build/wg/Overlay.js");
/* harmony import */ var _wg_PluggableMap_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./wg/PluggableMap.js */ "./build/wg/PluggableMap.js");
/* harmony import */ var _wg_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_184__ = __webpack_require__(/*! ./wg/proj/epsg3857.js */ "./build/wg/proj/epsg3857.js");
/* harmony import */ var _wg_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_185__ = __webpack_require__(/*! ./wg/proj/epsg4326.js */ "./build/wg/proj/epsg4326.js");
/* harmony import */ var _wg_proj_proj4_js__WEBPACK_IMPORTED_MODULE_186__ = __webpack_require__(/*! ./wg/proj/proj4.js */ "./build/wg/proj/proj4.js");
/* harmony import */ var _wg_proj_Projection_js__WEBPACK_IMPORTED_MODULE_182__ = __webpack_require__(/*! ./wg/proj/Projection.js */ "./build/wg/proj/Projection.js");
/* harmony import */ var _wg_proj_projections_js__WEBPACK_IMPORTED_MODULE_187__ = __webpack_require__(/*! ./wg/proj/projections.js */ "./build/wg/proj/projections.js");
/* harmony import */ var _wg_proj_transforms_js__WEBPACK_IMPORTED_MODULE_188__ = __webpack_require__(/*! ./wg/proj/transforms.js */ "./build/wg/proj/transforms.js");
/* harmony import */ var _wg_proj_Units_js__WEBPACK_IMPORTED_MODULE_183__ = __webpack_require__(/*! ./wg/proj/Units.js */ "./build/wg/proj/Units.js");
/* harmony import */ var _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wg/proj.js */ "./build/wg/proj.js");
/* harmony import */ var _wg_render_Box_js__WEBPACK_IMPORTED_MODULE_189__ = __webpack_require__(/*! ./wg/render/Box.js */ "./build/wg/render/Box.js");
/* harmony import */ var _wg_render_canvas_Builder_js__WEBPACK_IMPORTED_MODULE_193__ = __webpack_require__(/*! ./wg/render/canvas/Builder.js */ "./build/wg/render/canvas/Builder.js");
/* harmony import */ var _wg_render_canvas_BuilderGroup_js__WEBPACK_IMPORTED_MODULE_194__ = __webpack_require__(/*! ./wg/render/canvas/BuilderGroup.js */ "./build/wg/render/canvas/BuilderGroup.js");
/* harmony import */ var _wg_render_canvas_Executor_js__WEBPACK_IMPORTED_MODULE_195__ = __webpack_require__(/*! ./wg/render/canvas/Executor.js */ "./build/wg/render/canvas/Executor.js");
/* harmony import */ var _wg_render_canvas_ExecutorGroup_js__WEBPACK_IMPORTED_MODULE_196__ = __webpack_require__(/*! ./wg/render/canvas/ExecutorGroup.js */ "./build/wg/render/canvas/ExecutorGroup.js");
/* harmony import */ var _wg_render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_204__ = __webpack_require__(/*! ./wg/render/canvas/hitdetect.js */ "./build/wg/render/canvas/hitdetect.js");
/* harmony import */ var _wg_render_canvas_ImageBuilder_js__WEBPACK_IMPORTED_MODULE_197__ = __webpack_require__(/*! ./wg/render/canvas/ImageBuilder.js */ "./build/wg/render/canvas/ImageBuilder.js");
/* harmony import */ var _wg_render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_198__ = __webpack_require__(/*! ./wg/render/canvas/Immediate.js */ "./build/wg/render/canvas/Immediate.js");
/* harmony import */ var _wg_render_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_199__ = __webpack_require__(/*! ./wg/render/canvas/Instruction.js */ "./build/wg/render/canvas/Instruction.js");
/* harmony import */ var _wg_render_canvas_LineStringBuilder_js__WEBPACK_IMPORTED_MODULE_200__ = __webpack_require__(/*! ./wg/render/canvas/LineStringBuilder.js */ "./build/wg/render/canvas/LineStringBuilder.js");
/* harmony import */ var _wg_render_canvas_PolygonBuilder_js__WEBPACK_IMPORTED_MODULE_201__ = __webpack_require__(/*! ./wg/render/canvas/PolygonBuilder.js */ "./build/wg/render/canvas/PolygonBuilder.js");
/* harmony import */ var _wg_render_canvas_TextBuilder_js__WEBPACK_IMPORTED_MODULE_202__ = __webpack_require__(/*! ./wg/render/canvas/TextBuilder.js */ "./build/wg/render/canvas/TextBuilder.js");
/* harmony import */ var _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__ = __webpack_require__(/*! ./wg/render/canvas.js */ "./build/wg/render/canvas.js");
/* harmony import */ var _wg_render_Event_js__WEBPACK_IMPORTED_MODULE_190__ = __webpack_require__(/*! ./wg/render/Event.js */ "./build/wg/render/Event.js");
/* harmony import */ var _wg_render_Feature_js__WEBPACK_IMPORTED_MODULE_191__ = __webpack_require__(/*! ./wg/render/Feature.js */ "./build/wg/render/Feature.js");
/* harmony import */ var _wg_render_VectorContext_js__WEBPACK_IMPORTED_MODULE_192__ = __webpack_require__(/*! ./wg/render/VectorContext.js */ "./build/wg/render/VectorContext.js");
/* harmony import */ var _wg_render_js__WEBPACK_IMPORTED_MODULE_205__ = __webpack_require__(/*! ./wg/render.js */ "./build/wg/render.js");
/* harmony import */ var _wg_renderer_canvas_common_js__WEBPACK_IMPORTED_MODULE_215__ = __webpack_require__(/*! ./wg/renderer/canvas/common.js */ "./build/wg/renderer/canvas/common.js");
/* harmony import */ var _wg_renderer_canvas_ImageLayer_js__WEBPACK_IMPORTED_MODULE_209__ = __webpack_require__(/*! ./wg/renderer/canvas/ImageLayer.js */ "./build/wg/renderer/canvas/ImageLayer.js");
/* harmony import */ var _wg_renderer_canvas_Layer_js__WEBPACK_IMPORTED_MODULE_210__ = __webpack_require__(/*! ./wg/renderer/canvas/Layer.js */ "./build/wg/renderer/canvas/Layer.js");
/* harmony import */ var _wg_renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_211__ = __webpack_require__(/*! ./wg/renderer/canvas/TileLayer.js */ "./build/wg/renderer/canvas/TileLayer.js");
/* harmony import */ var _wg_renderer_canvas_VectorImageLayer_js__WEBPACK_IMPORTED_MODULE_212__ = __webpack_require__(/*! ./wg/renderer/canvas/VectorImageLayer.js */ "./build/wg/renderer/canvas/VectorImageLayer.js");
/* harmony import */ var _wg_renderer_canvas_VectorLayer_js__WEBPACK_IMPORTED_MODULE_213__ = __webpack_require__(/*! ./wg/renderer/canvas/VectorLayer.js */ "./build/wg/renderer/canvas/VectorLayer.js");
/* harmony import */ var _wg_renderer_canvas_VectorTileLayer_js__WEBPACK_IMPORTED_MODULE_214__ = __webpack_require__(/*! ./wg/renderer/canvas/VectorTileLayer.js */ "./build/wg/renderer/canvas/VectorTileLayer.js");
/* harmony import */ var _wg_renderer_Composite_js__WEBPACK_IMPORTED_MODULE_206__ = __webpack_require__(/*! ./wg/renderer/Composite.js */ "./build/wg/renderer/Composite.js");
/* harmony import */ var _wg_renderer_Layer_js__WEBPACK_IMPORTED_MODULE_207__ = __webpack_require__(/*! ./wg/renderer/Layer.js */ "./build/wg/renderer/Layer.js");
/* harmony import */ var _wg_renderer_Map_js__WEBPACK_IMPORTED_MODULE_208__ = __webpack_require__(/*! ./wg/renderer/Map.js */ "./build/wg/renderer/Map.js");
/* harmony import */ var _wg_renderer_vector_js__WEBPACK_IMPORTED_MODULE_216__ = __webpack_require__(/*! ./wg/renderer/vector.js */ "./build/wg/renderer/vector.js");
/* harmony import */ var _wg_renderer_webgl_Layer_js__WEBPACK_IMPORTED_MODULE_217__ = __webpack_require__(/*! ./wg/renderer/webgl/Layer.js */ "./build/wg/renderer/webgl/Layer.js");
/* harmony import */ var _wg_renderer_webgl_PointsLayer_js__WEBPACK_IMPORTED_MODULE_218__ = __webpack_require__(/*! ./wg/renderer/webgl/PointsLayer.js */ "./build/wg/renderer/webgl/PointsLayer.js");
/* harmony import */ var _wg_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_219__ = __webpack_require__(/*! ./wg/renderer/webgl/TileLayer.js */ "./build/wg/renderer/webgl/TileLayer.js");
/* harmony import */ var _wg_reproj_common_js__WEBPACK_IMPORTED_MODULE_224__ = __webpack_require__(/*! ./wg/reproj/common.js */ "./build/wg/reproj/common.js");
/* harmony import */ var _wg_reproj_Image_js__WEBPACK_IMPORTED_MODULE_220__ = __webpack_require__(/*! ./wg/reproj/Image.js */ "./build/wg/reproj/Image.js");
/* harmony import */ var _wg_reproj_Tile_js__WEBPACK_IMPORTED_MODULE_221__ = __webpack_require__(/*! ./wg/reproj/Tile.js */ "./build/wg/reproj/Tile.js");
/* harmony import */ var _wg_reproj_Triangulation_js__WEBPACK_IMPORTED_MODULE_222__ = __webpack_require__(/*! ./wg/reproj/Triangulation.js */ "./build/wg/reproj/Triangulation.js");
/* harmony import */ var _wg_reproj_js__WEBPACK_IMPORTED_MODULE_223__ = __webpack_require__(/*! ./wg/reproj.js */ "./build/wg/reproj.js");
/* harmony import */ var _wg_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_225__ = __webpack_require__(/*! ./wg/resolutionconstraint.js */ "./build/wg/resolutionconstraint.js");
/* harmony import */ var _wg_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_226__ = __webpack_require__(/*! ./wg/rotationconstraint.js */ "./build/wg/rotationconstraint.js");
/* harmony import */ var _wg_size_js__WEBPACK_IMPORTED_MODULE_227__ = __webpack_require__(/*! ./wg/size.js */ "./build/wg/size.js");
/* harmony import */ var _wg_source_BingMaps_js__WEBPACK_IMPORTED_MODULE_228__ = __webpack_require__(/*! ./wg/source/BingMaps.js */ "./build/wg/source/BingMaps.js");
/* harmony import */ var _wg_source_CartoDB_js__WEBPACK_IMPORTED_MODULE_229__ = __webpack_require__(/*! ./wg/source/CartoDB.js */ "./build/wg/source/CartoDB.js");
/* harmony import */ var _wg_source_Cluster_js__WEBPACK_IMPORTED_MODULE_230__ = __webpack_require__(/*! ./wg/source/Cluster.js */ "./build/wg/source/Cluster.js");
/* harmony import */ var _wg_source_common_js__WEBPACK_IMPORTED_MODULE_259__ = __webpack_require__(/*! ./wg/source/common.js */ "./build/wg/source/common.js");
/* harmony import */ var _wg_source_DataTile_js__WEBPACK_IMPORTED_MODULE_231__ = __webpack_require__(/*! ./wg/source/DataTile.js */ "./build/wg/source/DataTile.js");
/* harmony import */ var _wg_source_GeoTIFF_js__WEBPACK_IMPORTED_MODULE_232__ = __webpack_require__(/*! ./wg/source/GeoTIFF.js */ "./build/wg/source/GeoTIFF.js");
/* harmony import */ var _wg_source_IIIF_js__WEBPACK_IMPORTED_MODULE_233__ = __webpack_require__(/*! ./wg/source/IIIF.js */ "./build/wg/source/IIIF.js");
/* harmony import */ var _wg_source_Image_js__WEBPACK_IMPORTED_MODULE_234__ = __webpack_require__(/*! ./wg/source/Image.js */ "./build/wg/source/Image.js");
/* harmony import */ var _wg_source_ImageArcGISRest_js__WEBPACK_IMPORTED_MODULE_235__ = __webpack_require__(/*! ./wg/source/ImageArcGISRest.js */ "./build/wg/source/ImageArcGISRest.js");
/* harmony import */ var _wg_source_ImageCanvas_js__WEBPACK_IMPORTED_MODULE_236__ = __webpack_require__(/*! ./wg/source/ImageCanvas.js */ "./build/wg/source/ImageCanvas.js");
/* harmony import */ var _wg_source_ImageMapGuide_js__WEBPACK_IMPORTED_MODULE_237__ = __webpack_require__(/*! ./wg/source/ImageMapGuide.js */ "./build/wg/source/ImageMapGuide.js");
/* harmony import */ var _wg_source_ImageStatic_js__WEBPACK_IMPORTED_MODULE_238__ = __webpack_require__(/*! ./wg/source/ImageStatic.js */ "./build/wg/source/ImageStatic.js");
/* harmony import */ var _wg_source_ImageWMS_js__WEBPACK_IMPORTED_MODULE_239__ = __webpack_require__(/*! ./wg/source/ImageWMS.js */ "./build/wg/source/ImageWMS.js");
/* harmony import */ var _wg_source_OGCMapTile_js__WEBPACK_IMPORTED_MODULE_240__ = __webpack_require__(/*! ./wg/source/OGCMapTile.js */ "./build/wg/source/OGCMapTile.js");
/* harmony import */ var _wg_source_ogcTileUtil_js__WEBPACK_IMPORTED_MODULE_260__ = __webpack_require__(/*! ./wg/source/ogcTileUtil.js */ "./build/wg/source/ogcTileUtil.js");
/* harmony import */ var _wg_source_OGCVectorTile_js__WEBPACK_IMPORTED_MODULE_241__ = __webpack_require__(/*! ./wg/source/OGCVectorTile.js */ "./build/wg/source/OGCVectorTile.js");
/* harmony import */ var _wg_source_OSM_js__WEBPACK_IMPORTED_MODULE_242__ = __webpack_require__(/*! ./wg/source/OSM.js */ "./build/wg/source/OSM.js");
/* harmony import */ var _wg_source_Raster_js__WEBPACK_IMPORTED_MODULE_243__ = __webpack_require__(/*! ./wg/source/Raster.js */ "./build/wg/source/Raster.js");
/* harmony import */ var _wg_source_Source_js__WEBPACK_IMPORTED_MODULE_244__ = __webpack_require__(/*! ./wg/source/Source.js */ "./build/wg/source/Source.js");
/* harmony import */ var _wg_source_Stamen_js__WEBPACK_IMPORTED_MODULE_245__ = __webpack_require__(/*! ./wg/source/Stamen.js */ "./build/wg/source/Stamen.js");
/* harmony import */ var _wg_source_Tile_js__WEBPACK_IMPORTED_MODULE_246__ = __webpack_require__(/*! ./wg/source/Tile.js */ "./build/wg/source/Tile.js");
/* harmony import */ var _wg_source_TileArcGISRest_js__WEBPACK_IMPORTED_MODULE_247__ = __webpack_require__(/*! ./wg/source/TileArcGISRest.js */ "./build/wg/source/TileArcGISRest.js");
/* harmony import */ var _wg_source_TileDebug_js__WEBPACK_IMPORTED_MODULE_248__ = __webpack_require__(/*! ./wg/source/TileDebug.js */ "./build/wg/source/TileDebug.js");
/* harmony import */ var _wg_source_TileImage_js__WEBPACK_IMPORTED_MODULE_249__ = __webpack_require__(/*! ./wg/source/TileImage.js */ "./build/wg/source/TileImage.js");
/* harmony import */ var _wg_source_TileJSON_js__WEBPACK_IMPORTED_MODULE_250__ = __webpack_require__(/*! ./wg/source/TileJSON.js */ "./build/wg/source/TileJSON.js");
/* harmony import */ var _wg_source_TileWMS_js__WEBPACK_IMPORTED_MODULE_251__ = __webpack_require__(/*! ./wg/source/TileWMS.js */ "./build/wg/source/TileWMS.js");
/* harmony import */ var _wg_source_UrlTile_js__WEBPACK_IMPORTED_MODULE_253__ = __webpack_require__(/*! ./wg/source/UrlTile.js */ "./build/wg/source/UrlTile.js");
/* harmony import */ var _wg_source_UTFGrid_js__WEBPACK_IMPORTED_MODULE_252__ = __webpack_require__(/*! ./wg/source/UTFGrid.js */ "./build/wg/source/UTFGrid.js");
/* harmony import */ var _wg_source_Vector_js__WEBPACK_IMPORTED_MODULE_254__ = __webpack_require__(/*! ./wg/source/Vector.js */ "./build/wg/source/Vector.js");
/* harmony import */ var _wg_source_VectorTile_js__WEBPACK_IMPORTED_MODULE_255__ = __webpack_require__(/*! ./wg/source/VectorTile.js */ "./build/wg/source/VectorTile.js");
/* harmony import */ var _wg_source_WMTS_js__WEBPACK_IMPORTED_MODULE_256__ = __webpack_require__(/*! ./wg/source/WMTS.js */ "./build/wg/source/WMTS.js");
/* harmony import */ var _wg_source_XYZ_js__WEBPACK_IMPORTED_MODULE_257__ = __webpack_require__(/*! ./wg/source/XYZ.js */ "./build/wg/source/XYZ.js");
/* harmony import */ var _wg_source_Zoomify_js__WEBPACK_IMPORTED_MODULE_258__ = __webpack_require__(/*! ./wg/source/Zoomify.js */ "./build/wg/source/Zoomify.js");
/* harmony import */ var _wg_source_js__WEBPACK_IMPORTED_MODULE_261__ = __webpack_require__(/*! ./wg/source.js */ "./build/wg/source.js");
/* harmony import */ var _wg_sphere_js__WEBPACK_IMPORTED_MODULE_262__ = __webpack_require__(/*! ./wg/sphere.js */ "./build/wg/sphere.js");
/* harmony import */ var _wg_string_js__WEBPACK_IMPORTED_MODULE_263__ = __webpack_require__(/*! ./wg/string.js */ "./build/wg/string.js");
/* harmony import */ var _wg_structs_LinkedList_js__WEBPACK_IMPORTED_MODULE_265__ = __webpack_require__(/*! ./wg/structs/LinkedList.js */ "./build/wg/structs/LinkedList.js");
/* harmony import */ var _wg_structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_264__ = __webpack_require__(/*! ./wg/structs/LRUCache.js */ "./build/wg/structs/LRUCache.js");
/* harmony import */ var _wg_structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_266__ = __webpack_require__(/*! ./wg/structs/PriorityQueue.js */ "./build/wg/structs/PriorityQueue.js");
/* harmony import */ var _wg_structs_RBush_js__WEBPACK_IMPORTED_MODULE_267__ = __webpack_require__(/*! ./wg/structs/RBush.js */ "./build/wg/structs/RBush.js");
/* harmony import */ var _wg_style_Circle_js__WEBPACK_IMPORTED_MODULE_268__ = __webpack_require__(/*! ./wg/style/Circle.js */ "./build/wg/style/Circle.js");
/* harmony import */ var _wg_style_expressions_js__WEBPACK_IMPORTED_MODULE_278__ = __webpack_require__(/*! ./wg/style/expressions.js */ "./build/wg/style/expressions.js");
/* harmony import */ var _wg_style_Fill_js__WEBPACK_IMPORTED_MODULE_269__ = __webpack_require__(/*! ./wg/style/Fill.js */ "./build/wg/style/Fill.js");
/* harmony import */ var _wg_style_Icon_js__WEBPACK_IMPORTED_MODULE_270__ = __webpack_require__(/*! ./wg/style/Icon.js */ "./build/wg/style/Icon.js");
/* harmony import */ var _wg_style_IconImage_js__WEBPACK_IMPORTED_MODULE_271__ = __webpack_require__(/*! ./wg/style/IconImage.js */ "./build/wg/style/IconImage.js");
/* harmony import */ var _wg_style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_272__ = __webpack_require__(/*! ./wg/style/IconImageCache.js */ "./build/wg/style/IconImageCache.js");
/* harmony import */ var _wg_style_Image_js__WEBPACK_IMPORTED_MODULE_273__ = __webpack_require__(/*! ./wg/style/Image.js */ "./build/wg/style/Image.js");
/* harmony import */ var _wg_style_RegularShape_js__WEBPACK_IMPORTED_MODULE_274__ = __webpack_require__(/*! ./wg/style/RegularShape.js */ "./build/wg/style/RegularShape.js");
/* harmony import */ var _wg_style_Stroke_js__WEBPACK_IMPORTED_MODULE_275__ = __webpack_require__(/*! ./wg/style/Stroke.js */ "./build/wg/style/Stroke.js");
/* harmony import */ var _wg_style_Style_js__WEBPACK_IMPORTED_MODULE_276__ = __webpack_require__(/*! ./wg/style/Style.js */ "./build/wg/style/Style.js");
/* harmony import */ var _wg_style_Text_js__WEBPACK_IMPORTED_MODULE_277__ = __webpack_require__(/*! ./wg/style/Text.js */ "./build/wg/style/Text.js");
/* harmony import */ var _wg_Tile_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./wg/Tile.js */ "./build/wg/Tile.js");
/* harmony import */ var _wg_TileCache_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./wg/TileCache.js */ "./build/wg/TileCache.js");
/* harmony import */ var _wg_tilecoord_js__WEBPACK_IMPORTED_MODULE_279__ = __webpack_require__(/*! ./wg/tilecoord.js */ "./build/wg/tilecoord.js");
/* harmony import */ var _wg_tilegrid_common_js__WEBPACK_IMPORTED_MODULE_282__ = __webpack_require__(/*! ./wg/tilegrid/common.js */ "./build/wg/tilegrid/common.js");
/* harmony import */ var _wg_tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_280__ = __webpack_require__(/*! ./wg/tilegrid/TileGrid.js */ "./build/wg/tilegrid/TileGrid.js");
/* harmony import */ var _wg_tilegrid_WMTS_js__WEBPACK_IMPORTED_MODULE_281__ = __webpack_require__(/*! ./wg/tilegrid/WMTS.js */ "./build/wg/tilegrid/WMTS.js");
/* harmony import */ var _wg_tilegrid_js__WEBPACK_IMPORTED_MODULE_283__ = __webpack_require__(/*! ./wg/tilegrid.js */ "./build/wg/tilegrid.js");
/* harmony import */ var _wg_TileQueue_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./wg/TileQueue.js */ "./build/wg/TileQueue.js");
/* harmony import */ var _wg_TileRange_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./wg/TileRange.js */ "./build/wg/TileRange.js");
/* harmony import */ var _wg_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_284__ = __webpack_require__(/*! ./wg/tileurlfunction.js */ "./build/wg/tileurlfunction.js");
/* harmony import */ var _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__ = __webpack_require__(/*! ./wg/transform.js */ "./build/wg/transform.js");
/* harmony import */ var _wg_uri_js__WEBPACK_IMPORTED_MODULE_286__ = __webpack_require__(/*! ./wg/uri.js */ "./build/wg/uri.js");
/* harmony import */ var _wg_util_js__WEBPACK_IMPORTED_MODULE_287__ = __webpack_require__(/*! ./wg/util.js */ "./build/wg/util.js");
/* harmony import */ var _wg_vec_mat4_js__WEBPACK_IMPORTED_MODULE_288__ = __webpack_require__(/*! ./wg/vec/mat4.js */ "./build/wg/vec/mat4.js");
/* harmony import */ var _wg_VectorRenderTile_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./wg/VectorRenderTile.js */ "./build/wg/VectorRenderTile.js");
/* harmony import */ var _wg_VectorTile_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./wg/VectorTile.js */ "./build/wg/VectorTile.js");
/* harmony import */ var _wg_View_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./wg/View.js */ "./build/wg/View.js");
/* harmony import */ var _wg_webgl_Buffer_js__WEBPACK_IMPORTED_MODULE_290__ = __webpack_require__(/*! ./wg/webgl/Buffer.js */ "./build/wg/webgl/Buffer.js");
/* harmony import */ var _wg_webgl_Helper_js__WEBPACK_IMPORTED_MODULE_291__ = __webpack_require__(/*! ./wg/webgl/Helper.js */ "./build/wg/webgl/Helper.js");
/* harmony import */ var _wg_webgl_PaletteTexture_js__WEBPACK_IMPORTED_MODULE_292__ = __webpack_require__(/*! ./wg/webgl/PaletteTexture.js */ "./build/wg/webgl/PaletteTexture.js");
/* harmony import */ var _wg_webgl_PostProcessingPass_js__WEBPACK_IMPORTED_MODULE_293__ = __webpack_require__(/*! ./wg/webgl/PostProcessingPass.js */ "./build/wg/webgl/PostProcessingPass.js");
/* harmony import */ var _wg_webgl_RenderTarget_js__WEBPACK_IMPORTED_MODULE_294__ = __webpack_require__(/*! ./wg/webgl/RenderTarget.js */ "./build/wg/webgl/RenderTarget.js");
/* harmony import */ var _wg_webgl_ShaderBuilder_js__WEBPACK_IMPORTED_MODULE_295__ = __webpack_require__(/*! ./wg/webgl/ShaderBuilder.js */ "./build/wg/webgl/ShaderBuilder.js");
/* harmony import */ var _wg_webgl_TileTexture_js__WEBPACK_IMPORTED_MODULE_296__ = __webpack_require__(/*! ./wg/webgl/TileTexture.js */ "./build/wg/webgl/TileTexture.js");
/* harmony import */ var _wg_webgl_js__WEBPACK_IMPORTED_MODULE_289__ = __webpack_require__(/*! ./wg/webgl.js */ "./build/wg/webgl.js");
/* harmony import */ var _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__ = __webpack_require__(/*! ./wg/xml.js */ "./build/wg/xml.js");






















































































































































































































































































































































































































































































































































































































































































































































































































var wg = {};
wg.AssertionError = _wg_AssertionError_js__WEBPACK_IMPORTED_MODULE_1__["default"];
wg.Collection = _wg_Collection_js__WEBPACK_IMPORTED_MODULE_2__["default"];
wg.Collection.CollectionEvent = _wg_Collection_js__WEBPACK_IMPORTED_MODULE_2__.CollectionEvent;
wg.DataTile = _wg_DataTile_js__WEBPACK_IMPORTED_MODULE_3__["default"];
wg.Disposable = _wg_Disposable_js__WEBPACK_IMPORTED_MODULE_4__["default"];
wg.Feature = _wg_Feature_js__WEBPACK_IMPORTED_MODULE_5__["default"];
wg.Feature.createStyleFunction = _wg_Feature_js__WEBPACK_IMPORTED_MODULE_5__.createStyleFunction;
wg.Geolocation = _wg_Geolocation_js__WEBPACK_IMPORTED_MODULE_6__["default"];
wg.Image = _wg_Image_js__WEBPACK_IMPORTED_MODULE_7__["default"];
wg.Image.listenImage = _wg_Image_js__WEBPACK_IMPORTED_MODULE_7__.listenImage;
wg.ImageBase = _wg_ImageBase_js__WEBPACK_IMPORTED_MODULE_8__["default"];
wg.ImageCanvas = _wg_ImageCanvas_js__WEBPACK_IMPORTED_MODULE_9__["default"];
wg.ImageTile = _wg_ImageTile_js__WEBPACK_IMPORTED_MODULE_10__["default"];
wg.Kinetic = _wg_Kinetic_js__WEBPACK_IMPORTED_MODULE_11__["default"];
wg.Map = _wg_Map_js__WEBPACK_IMPORTED_MODULE_12__["default"];
wg.MapBrowserEvent = _wg_MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_13__["default"];
wg.MapBrowserEventHandler = _wg_MapBrowserEventHandler_js__WEBPACK_IMPORTED_MODULE_14__["default"];
wg.MapEvent = _wg_MapEvent_js__WEBPACK_IMPORTED_MODULE_15__["default"];
wg.Object = _wg_Object_js__WEBPACK_IMPORTED_MODULE_16__["default"];
wg.Object.ObjectEvent = _wg_Object_js__WEBPACK_IMPORTED_MODULE_16__.ObjectEvent;
wg.Observable = _wg_Observable_js__WEBPACK_IMPORTED_MODULE_17__["default"];
wg.Observable.unByKey = _wg_Observable_js__WEBPACK_IMPORTED_MODULE_17__.unByKey;
wg.Overlay = _wg_Overlay_js__WEBPACK_IMPORTED_MODULE_18__["default"];
wg.PluggableMap = _wg_PluggableMap_js__WEBPACK_IMPORTED_MODULE_19__["default"];
wg.Tile = _wg_Tile_js__WEBPACK_IMPORTED_MODULE_20__["default"];
wg.TileCache = _wg_TileCache_js__WEBPACK_IMPORTED_MODULE_21__["default"];
wg.TileQueue = _wg_TileQueue_js__WEBPACK_IMPORTED_MODULE_22__["default"];
wg.TileQueue.getTilePriority = _wg_TileQueue_js__WEBPACK_IMPORTED_MODULE_22__.getTilePriority;
wg.TileRange = _wg_TileRange_js__WEBPACK_IMPORTED_MODULE_23__["default"];
wg.TileRange.createOrUpdate = _wg_TileRange_js__WEBPACK_IMPORTED_MODULE_23__.createOrUpdate;
wg.VectorRenderTile = _wg_VectorRenderTile_js__WEBPACK_IMPORTED_MODULE_24__["default"];
wg.VectorTile = _wg_VectorTile_js__WEBPACK_IMPORTED_MODULE_25__["default"];
wg.View = _wg_View_js__WEBPACK_IMPORTED_MODULE_26__["default"];
wg.View.createCenterConstraint = _wg_View_js__WEBPACK_IMPORTED_MODULE_26__.createCenterConstraint;
wg.View.createResolutionConstraint = _wg_View_js__WEBPACK_IMPORTED_MODULE_26__.createResolutionConstraint;
wg.View.createRotationConstraint = _wg_View_js__WEBPACK_IMPORTED_MODULE_26__.createRotationConstraint;
wg.View.isNoopAnimation = _wg_View_js__WEBPACK_IMPORTED_MODULE_26__.isNoopAnimation;
wg.array = {};
wg.array.binarySearch = _wg_array_js__WEBPACK_IMPORTED_MODULE_27__.binarySearch;
wg.array.equals = _wg_array_js__WEBPACK_IMPORTED_MODULE_27__.equals;
wg.array.extend = _wg_array_js__WEBPACK_IMPORTED_MODULE_27__.extend;
wg.array.find = _wg_array_js__WEBPACK_IMPORTED_MODULE_27__.find;
wg.array.findIndex = _wg_array_js__WEBPACK_IMPORTED_MODULE_27__.findIndex;
wg.array.includes = _wg_array_js__WEBPACK_IMPORTED_MODULE_27__.includes;
wg.array.isSorted = _wg_array_js__WEBPACK_IMPORTED_MODULE_27__.isSorted;
wg.array.linearFindNearest = _wg_array_js__WEBPACK_IMPORTED_MODULE_27__.linearFindNearest;
wg.array.numberSafeCompareFunction = _wg_array_js__WEBPACK_IMPORTED_MODULE_27__.numberSafeCompareFunction;
wg.array.remove = _wg_array_js__WEBPACK_IMPORTED_MODULE_27__.remove;
wg.array.reverseSubArray = _wg_array_js__WEBPACK_IMPORTED_MODULE_27__.reverseSubArray;
wg.array.stableSort = _wg_array_js__WEBPACK_IMPORTED_MODULE_27__.stableSort;
wg.asserts = {};
wg.asserts.assert = _wg_asserts_js__WEBPACK_IMPORTED_MODULE_28__.assert;
wg.centerconstraint = {};
wg.centerconstraint.createExtent = _wg_centerconstraint_js__WEBPACK_IMPORTED_MODULE_29__.createExtent;
wg.centerconstraint.none = _wg_centerconstraint_js__WEBPACK_IMPORTED_MODULE_29__.none;
wg.color = {};
wg.color.asArray = _wg_color_js__WEBPACK_IMPORTED_MODULE_30__.asArray;
wg.color.asString = _wg_color_js__WEBPACK_IMPORTED_MODULE_30__.asString;
wg.color.fromString = _wg_color_js__WEBPACK_IMPORTED_MODULE_30__.fromString;
wg.color.isStringColor = _wg_color_js__WEBPACK_IMPORTED_MODULE_30__.isStringColor;
wg.color.normalize = _wg_color_js__WEBPACK_IMPORTED_MODULE_30__.normalize;
wg.color.toString = _wg_color_js__WEBPACK_IMPORTED_MODULE_30__.toString;
wg.colorlike = {};
wg.colorlike.asColorLike = _wg_colorlike_js__WEBPACK_IMPORTED_MODULE_31__.asColorLike;
wg.control = {};
wg.control.Attribution = _wg_control_Attribution_js__WEBPACK_IMPORTED_MODULE_32__["default"];
wg.control.Control = _wg_control_Control_js__WEBPACK_IMPORTED_MODULE_33__["default"];
wg.control.FullScreen = _wg_control_FullScreen_js__WEBPACK_IMPORTED_MODULE_34__["default"];
wg.control.MousePosition = _wg_control_MousePosition_js__WEBPACK_IMPORTED_MODULE_35__["default"];
wg.control.OverviewMap = _wg_control_OverviewMap_js__WEBPACK_IMPORTED_MODULE_36__["default"];
wg.control.Rotate = _wg_control_Rotate_js__WEBPACK_IMPORTED_MODULE_37__["default"];
wg.control.ScaleLine = _wg_control_ScaleLine_js__WEBPACK_IMPORTED_MODULE_38__["default"];
wg.control.Zoom = _wg_control_Zoom_js__WEBPACK_IMPORTED_MODULE_39__["default"];
wg.control.ZoomSlider = _wg_control_ZoomSlider_js__WEBPACK_IMPORTED_MODULE_40__["default"];
wg.control.ZoomToExtent = _wg_control_ZoomToExtent_js__WEBPACK_IMPORTED_MODULE_41__["default"];
wg.control.defaults = _wg_control_js__WEBPACK_IMPORTED_MODULE_42__.defaults;
wg.coordinate = {};
wg.coordinate.add = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.add;
wg.coordinate.closestOnCircle = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.closestOnCircle;
wg.coordinate.closestOnSegment = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.closestOnSegment;
wg.coordinate.createStringXY = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.createStringXY;
wg.coordinate.degreesToStringHDMS = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.degreesToStringHDMS;
wg.coordinate.distance = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.distance;
wg.coordinate.equals = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.equals;
wg.coordinate.format = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.format;
wg.coordinate.getWorldsAway = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.getWorldsAway;
wg.coordinate.rotate = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.rotate;
wg.coordinate.scale = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.scale;
wg.coordinate.squaredDistance = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.squaredDistance;
wg.coordinate.squaredDistanceToSegment = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.squaredDistanceToSegment;
wg.coordinate.toStringHDMS = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.toStringHDMS;
wg.coordinate.toStringXY = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.toStringXY;
wg.coordinate.wrapX = _wg_coordinate_js__WEBPACK_IMPORTED_MODULE_43__.wrapX;
wg.css = {};
wg.css.CLASS_COLLAPSED = _wg_css_js__WEBPACK_IMPORTED_MODULE_44__.CLASS_COLLAPSED;
wg.css.CLASS_CONTROL = _wg_css_js__WEBPACK_IMPORTED_MODULE_44__.CLASS_CONTROL;
wg.css.CLASS_HIDDEN = _wg_css_js__WEBPACK_IMPORTED_MODULE_44__.CLASS_HIDDEN;
wg.css.CLASS_SELECTABLE = _wg_css_js__WEBPACK_IMPORTED_MODULE_44__.CLASS_SELECTABLE;
wg.css.CLASS_UNSELECTABLE = _wg_css_js__WEBPACK_IMPORTED_MODULE_44__.CLASS_UNSELECTABLE;
wg.css.CLASS_UNSUPPORTED = _wg_css_js__WEBPACK_IMPORTED_MODULE_44__.CLASS_UNSUPPORTED;
wg.css.cssOpacity = _wg_css_js__WEBPACK_IMPORTED_MODULE_44__.cssOpacity;
wg.css.getFontParameters = _wg_css_js__WEBPACK_IMPORTED_MODULE_44__.getFontParameters;
wg.dom = {};
wg.dom.createCanvasContext2D = _wg_dom_js__WEBPACK_IMPORTED_MODULE_45__.createCanvasContext2D;
wg.dom.outerHeight = _wg_dom_js__WEBPACK_IMPORTED_MODULE_45__.outerHeight;
wg.dom.outerWidth = _wg_dom_js__WEBPACK_IMPORTED_MODULE_45__.outerWidth;
wg.dom.removeChildren = _wg_dom_js__WEBPACK_IMPORTED_MODULE_45__.removeChildren;
wg.dom.removeNode = _wg_dom_js__WEBPACK_IMPORTED_MODULE_45__.removeNode;
wg.dom.replaceChildren = _wg_dom_js__WEBPACK_IMPORTED_MODULE_45__.replaceChildren;
wg.dom.replaceNode = _wg_dom_js__WEBPACK_IMPORTED_MODULE_45__.replaceNode;
wg.easing = {};
wg.easing.easeIn = _wg_easing_js__WEBPACK_IMPORTED_MODULE_46__.easeIn;
wg.easing.easeOut = _wg_easing_js__WEBPACK_IMPORTED_MODULE_46__.easeOut;
wg.easing.inAndOut = _wg_easing_js__WEBPACK_IMPORTED_MODULE_46__.inAndOut;
wg.easing.linear = _wg_easing_js__WEBPACK_IMPORTED_MODULE_46__.linear;
wg.easing.upAndDown = _wg_easing_js__WEBPACK_IMPORTED_MODULE_46__.upAndDown;
wg.events = {};
wg.events.Event = _wg_events_Event_js__WEBPACK_IMPORTED_MODULE_47__["default"];
wg.events.Event.preventDefault = _wg_events_Event_js__WEBPACK_IMPORTED_MODULE_47__.preventDefault;
wg.events.Event.stopPropagation = _wg_events_Event_js__WEBPACK_IMPORTED_MODULE_47__.stopPropagation;
wg.events.Target = _wg_events_Target_js__WEBPACK_IMPORTED_MODULE_48__["default"];
wg.events.condition = {};
wg.events.condition.all = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.all;
wg.events.condition.altKeyOnly = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.altKeyOnly;
wg.events.condition.altShiftKeysOnly = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.altShiftKeysOnly;
wg.events.condition.always = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.always;
wg.events.condition.click = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.click;
wg.events.condition.doubleClick = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.doubleClick;
wg.events.condition.focus = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.focus;
wg.events.condition.focusWithTabindex = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.focusWithTabindex;
wg.events.condition.mouseActionButton = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.mouseActionButton;
wg.events.condition.mouseOnly = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.mouseOnly;
wg.events.condition.never = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.never;
wg.events.condition.noModifierKeys = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.noModifierKeys;
wg.events.condition.penOnly = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.penOnly;
wg.events.condition.platformModifierKeyOnly = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.platformModifierKeyOnly;
wg.events.condition.pointerMove = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.pointerMove;
wg.events.condition.primaryAction = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.primaryAction;
wg.events.condition.shiftKeyOnly = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.shiftKeyOnly;
wg.events.condition.singleClick = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.singleClick;
wg.events.condition.targetNotEditable = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.targetNotEditable;
wg.events.condition.touchOnly = _wg_events_condition_js__WEBPACK_IMPORTED_MODULE_49__.touchOnly;
wg.events.listen = _wg_events_js__WEBPACK_IMPORTED_MODULE_50__.listen;
wg.events.listenOnce = _wg_events_js__WEBPACK_IMPORTED_MODULE_50__.listenOnce;
wg.events.unlistenByKey = _wg_events_js__WEBPACK_IMPORTED_MODULE_50__.unlistenByKey;
wg.extent = {};
wg.extent.applyTransform = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.applyTransform;
wg.extent.approximatelyEquals = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.approximatelyEquals;
wg.extent.boundingExtent = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.boundingExtent;
wg.extent.buffer = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.buffer;
wg.extent.clone = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.clone;
wg.extent.closestSquaredDistanceXY = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.closestSquaredDistanceXY;
wg.extent.containsCoordinate = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.containsCoordinate;
wg.extent.containsExtent = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.containsExtent;
wg.extent.containsXY = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.containsXY;
wg.extent.coordinateRelationship = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.coordinateRelationship;
wg.extent.createEmpty = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.createEmpty;
wg.extent.createOrUpdate = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.createOrUpdate;
wg.extent.createOrUpdateEmpty = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.createOrUpdateEmpty;
wg.extent.createOrUpdateFromCoordinate = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.createOrUpdateFromCoordinate;
wg.extent.createOrUpdateFromCoordinates = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.createOrUpdateFromCoordinates;
wg.extent.createOrUpdateFromFlatCoordinates = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.createOrUpdateFromFlatCoordinates;
wg.extent.createOrUpdateFromRings = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.createOrUpdateFromRings;
wg.extent.equals = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.equals;
wg.extent.extend = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.extend;
wg.extent.extendCoordinate = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.extendCoordinate;
wg.extent.extendCoordinates = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.extendCoordinates;
wg.extent.extendFlatCoordinates = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.extendFlatCoordinates;
wg.extent.extendRings = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.extendRings;
wg.extent.extendXY = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.extendXY;
wg.extent.forEachCorner = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.forEachCorner;
wg.extent.getArea = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.getArea;
wg.extent.getBottomLeft = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.getBottomLeft;
wg.extent.getBottomRight = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.getBottomRight;
wg.extent.getCenter = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.getCenter;
wg.extent.getCorner = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.getCorner;
wg.extent.getEnlargedArea = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.getEnlargedArea;
wg.extent.getForViewAndSize = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.getForViewAndSize;
wg.extent.getHeight = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.getHeight;
wg.extent.getIntersection = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.getIntersection;
wg.extent.getIntersectionArea = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.getIntersectionArea;
wg.extent.getMargin = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.getMargin;
wg.extent.getSize = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.getSize;
wg.extent.getTopLeft = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.getTopLeft;
wg.extent.getTopRight = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.getTopRight;
wg.extent.getWidth = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.getWidth;
wg.extent.intersects = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.intersects;
wg.extent.intersectsSegment = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.intersectsSegment;
wg.extent.isEmpty = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.isEmpty;
wg.extent.returnOrUpdate = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.returnOrUpdate;
wg.extent.scaleFromCenter = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.scaleFromCenter;
wg.extent.wrapX = _wg_extent_js__WEBPACK_IMPORTED_MODULE_51__.wrapX;
wg.featureloader = {};
wg.featureloader.loadFeaturesXhr = _wg_featureloader_js__WEBPACK_IMPORTED_MODULE_52__.loadFeaturesXhr;
wg.featureloader.setWithCredentials = _wg_featureloader_js__WEBPACK_IMPORTED_MODULE_52__.setWithCredentials;
wg.featureloader.xhr = _wg_featureloader_js__WEBPACK_IMPORTED_MODULE_52__.xhr;
wg.format = {};
wg.format.EsriJSON = _wg_format_EsriJSON_js__WEBPACK_IMPORTED_MODULE_53__["default"];
wg.format.Feature = _wg_format_Feature_js__WEBPACK_IMPORTED_MODULE_54__["default"];
wg.format.Feature.transformExtentWithOptions = _wg_format_Feature_js__WEBPACK_IMPORTED_MODULE_54__.transformExtentWithOptions;
wg.format.Feature.transformGeometryWithOptions = _wg_format_Feature_js__WEBPACK_IMPORTED_MODULE_54__.transformGeometryWithOptions;
wg.format.GML = _wg_format_GML_js__WEBPACK_IMPORTED_MODULE_55__["default"];
wg.format.GML2 = _wg_format_GML2_js__WEBPACK_IMPORTED_MODULE_56__["default"];
wg.format.GML3 = _wg_format_GML3_js__WEBPACK_IMPORTED_MODULE_57__["default"];
wg.format.GML32 = _wg_format_GML32_js__WEBPACK_IMPORTED_MODULE_58__["default"];
wg.format.GMLBase = _wg_format_GMLBase_js__WEBPACK_IMPORTED_MODULE_59__["default"];
wg.format.GMLBase.GMLNS = _wg_format_GMLBase_js__WEBPACK_IMPORTED_MODULE_59__.GMLNS;
wg.format.GPX = _wg_format_GPX_js__WEBPACK_IMPORTED_MODULE_60__["default"];
wg.format.GeoJSON = _wg_format_GeoJSON_js__WEBPACK_IMPORTED_MODULE_61__["default"];
wg.format.IGC = _wg_format_IGC_js__WEBPACK_IMPORTED_MODULE_62__["default"];
wg.format.IIIFInfo = _wg_format_IIIFInfo_js__WEBPACK_IMPORTED_MODULE_63__["default"];
wg.format.JSONFeature = _wg_format_JSONFeature_js__WEBPACK_IMPORTED_MODULE_64__["default"];
wg.format.KML = _wg_format_KML_js__WEBPACK_IMPORTED_MODULE_65__["default"];
wg.format.KML.getDefaultFillStyle = _wg_format_KML_js__WEBPACK_IMPORTED_MODULE_65__.getDefaultFillStyle;
wg.format.KML.getDefaultImageStyle = _wg_format_KML_js__WEBPACK_IMPORTED_MODULE_65__.getDefaultImageStyle;
wg.format.KML.getDefaultStrokeStyle = _wg_format_KML_js__WEBPACK_IMPORTED_MODULE_65__.getDefaultStrokeStyle;
wg.format.KML.getDefaultStyle = _wg_format_KML_js__WEBPACK_IMPORTED_MODULE_65__.getDefaultStyle;
wg.format.KML.getDefaultStyleArray = _wg_format_KML_js__WEBPACK_IMPORTED_MODULE_65__.getDefaultStyleArray;
wg.format.KML.getDefaultTextStyle = _wg_format_KML_js__WEBPACK_IMPORTED_MODULE_65__.getDefaultTextStyle;
wg.format.KML.readFlatCoordinates = _wg_format_KML_js__WEBPACK_IMPORTED_MODULE_65__.readFlatCoordinates;
wg.format.MVT = _wg_format_MVT_js__WEBPACK_IMPORTED_MODULE_66__["default"];
wg.format.OSMXML = _wg_format_OSMXML_js__WEBPACK_IMPORTED_MODULE_67__["default"];
wg.format.OWS = _wg_format_OWS_js__WEBPACK_IMPORTED_MODULE_68__["default"];
wg.format.Polyline = _wg_format_Polyline_js__WEBPACK_IMPORTED_MODULE_69__["default"];
wg.format.Polyline.decodeDeltas = _wg_format_Polyline_js__WEBPACK_IMPORTED_MODULE_69__.decodeDeltas;
wg.format.Polyline.decodeFloats = _wg_format_Polyline_js__WEBPACK_IMPORTED_MODULE_69__.decodeFloats;
wg.format.Polyline.decodeSignedIntegers = _wg_format_Polyline_js__WEBPACK_IMPORTED_MODULE_69__.decodeSignedIntegers;
wg.format.Polyline.decodeUnsignedIntegers = _wg_format_Polyline_js__WEBPACK_IMPORTED_MODULE_69__.decodeUnsignedIntegers;
wg.format.Polyline.encodeDeltas = _wg_format_Polyline_js__WEBPACK_IMPORTED_MODULE_69__.encodeDeltas;
wg.format.Polyline.encodeFloats = _wg_format_Polyline_js__WEBPACK_IMPORTED_MODULE_69__.encodeFloats;
wg.format.Polyline.encodeSignedIntegers = _wg_format_Polyline_js__WEBPACK_IMPORTED_MODULE_69__.encodeSignedIntegers;
wg.format.Polyline.encodeUnsignedInteger = _wg_format_Polyline_js__WEBPACK_IMPORTED_MODULE_69__.encodeUnsignedInteger;
wg.format.Polyline.encodeUnsignedIntegers = _wg_format_Polyline_js__WEBPACK_IMPORTED_MODULE_69__.encodeUnsignedIntegers;
wg.format.TextFeature = _wg_format_TextFeature_js__WEBPACK_IMPORTED_MODULE_70__["default"];
wg.format.TopoJSON = _wg_format_TopoJSON_js__WEBPACK_IMPORTED_MODULE_71__["default"];
wg.format.WFS = _wg_format_WFS_js__WEBPACK_IMPORTED_MODULE_72__["default"];
wg.format.WFS.writeFilter = _wg_format_WFS_js__WEBPACK_IMPORTED_MODULE_72__.writeFilter;
wg.format.WKB = _wg_format_WKB_js__WEBPACK_IMPORTED_MODULE_73__["default"];
wg.format.WKT = _wg_format_WKT_js__WEBPACK_IMPORTED_MODULE_74__["default"];
wg.format.WMSCapabilities = _wg_format_WMSCapabilities_js__WEBPACK_IMPORTED_MODULE_75__["default"];
wg.format.WMSGetFeatureInfo = _wg_format_WMSGetFeatureInfo_js__WEBPACK_IMPORTED_MODULE_76__["default"];
wg.format.WMTSCapabilities = _wg_format_WMTSCapabilities_js__WEBPACK_IMPORTED_MODULE_77__["default"];
wg.format.XML = _wg_format_XML_js__WEBPACK_IMPORTED_MODULE_78__["default"];
wg.format.XMLFeature = _wg_format_XMLFeature_js__WEBPACK_IMPORTED_MODULE_79__["default"];
wg.format.filter = {};
wg.format.filter.And = _wg_format_filter_And_js__WEBPACK_IMPORTED_MODULE_80__["default"];
wg.format.filter.Bbox = _wg_format_filter_Bbox_js__WEBPACK_IMPORTED_MODULE_81__["default"];
wg.format.filter.Comparison = _wg_format_filter_Comparison_js__WEBPACK_IMPORTED_MODULE_82__["default"];
wg.format.filter.ComparisonBinary = _wg_format_filter_ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_83__["default"];
wg.format.filter.Contains = _wg_format_filter_Contains_js__WEBPACK_IMPORTED_MODULE_84__["default"];
wg.format.filter.DWithin = _wg_format_filter_DWithin_js__WEBPACK_IMPORTED_MODULE_85__["default"];
wg.format.filter.Disjoint = _wg_format_filter_Disjoint_js__WEBPACK_IMPORTED_MODULE_86__["default"];
wg.format.filter.During = _wg_format_filter_During_js__WEBPACK_IMPORTED_MODULE_87__["default"];
wg.format.filter.EqualTo = _wg_format_filter_EqualTo_js__WEBPACK_IMPORTED_MODULE_88__["default"];
wg.format.filter.Filter = _wg_format_filter_Filter_js__WEBPACK_IMPORTED_MODULE_89__["default"];
wg.format.filter.GreaterThan = _wg_format_filter_GreaterThan_js__WEBPACK_IMPORTED_MODULE_90__["default"];
wg.format.filter.GreaterThanOrEqualTo = _wg_format_filter_GreaterThanOrEqualTo_js__WEBPACK_IMPORTED_MODULE_91__["default"];
wg.format.filter.Intersects = _wg_format_filter_Intersects_js__WEBPACK_IMPORTED_MODULE_92__["default"];
wg.format.filter.IsBetween = _wg_format_filter_IsBetween_js__WEBPACK_IMPORTED_MODULE_93__["default"];
wg.format.filter.IsLike = _wg_format_filter_IsLike_js__WEBPACK_IMPORTED_MODULE_94__["default"];
wg.format.filter.IsNull = _wg_format_filter_IsNull_js__WEBPACK_IMPORTED_MODULE_95__["default"];
wg.format.filter.LessThan = _wg_format_filter_LessThan_js__WEBPACK_IMPORTED_MODULE_96__["default"];
wg.format.filter.LessThanOrEqualTo = _wg_format_filter_LessThanOrEqualTo_js__WEBPACK_IMPORTED_MODULE_97__["default"];
wg.format.filter.LogicalNary = _wg_format_filter_LogicalNary_js__WEBPACK_IMPORTED_MODULE_98__["default"];
wg.format.filter.Not = _wg_format_filter_Not_js__WEBPACK_IMPORTED_MODULE_99__["default"];
wg.format.filter.NotEqualTo = _wg_format_filter_NotEqualTo_js__WEBPACK_IMPORTED_MODULE_100__["default"];
wg.format.filter.Or = _wg_format_filter_Or_js__WEBPACK_IMPORTED_MODULE_101__["default"];
wg.format.filter.ResourceId = _wg_format_filter_ResourceId_js__WEBPACK_IMPORTED_MODULE_102__["default"];
wg.format.filter.Spatial = _wg_format_filter_Spatial_js__WEBPACK_IMPORTED_MODULE_103__["default"];
wg.format.filter.Within = _wg_format_filter_Within_js__WEBPACK_IMPORTED_MODULE_104__["default"];
wg.format.filter.and = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.and;
wg.format.filter.bbox = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.bbox;
wg.format.filter.between = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.between;
wg.format.filter.contains = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.contains;
wg.format.filter.disjoint = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.disjoint;
wg.format.filter.during = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.during;
wg.format.filter.dwithin = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.dwithin;
wg.format.filter.equalTo = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.equalTo;
wg.format.filter.greaterThan = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.greaterThan;
wg.format.filter.greaterThanOrEqualTo = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.greaterThanOrEqualTo;
wg.format.filter.intersects = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.intersects;
wg.format.filter.isNull = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.isNull;
wg.format.filter.lessThan = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.lessThan;
wg.format.filter.lessThanOrEqualTo = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.lessThanOrEqualTo;
wg.format.filter.like = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.like;
wg.format.filter.not = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.not;
wg.format.filter.notEqualTo = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.notEqualTo;
wg.format.filter.or = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.or;
wg.format.filter.resourceId = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.resourceId;
wg.format.filter.within = _wg_format_filter_js__WEBPACK_IMPORTED_MODULE_105__.within;
wg.format.xlink = {};
wg.format.xlink.readHref = _wg_format_xlink_js__WEBPACK_IMPORTED_MODULE_106__.readHref;
wg.format.xsd = {};
wg.format.xsd.readBoolean = _wg_format_xsd_js__WEBPACK_IMPORTED_MODULE_107__.readBoolean;
wg.format.xsd.readBooleanString = _wg_format_xsd_js__WEBPACK_IMPORTED_MODULE_107__.readBooleanString;
wg.format.xsd.readDateTime = _wg_format_xsd_js__WEBPACK_IMPORTED_MODULE_107__.readDateTime;
wg.format.xsd.readDecimal = _wg_format_xsd_js__WEBPACK_IMPORTED_MODULE_107__.readDecimal;
wg.format.xsd.readDecimalString = _wg_format_xsd_js__WEBPACK_IMPORTED_MODULE_107__.readDecimalString;
wg.format.xsd.readNonNegativeIntegerString = _wg_format_xsd_js__WEBPACK_IMPORTED_MODULE_107__.readNonNegativeIntegerString;
wg.format.xsd.readPositiveInteger = _wg_format_xsd_js__WEBPACK_IMPORTED_MODULE_107__.readPositiveInteger;
wg.format.xsd.readString = _wg_format_xsd_js__WEBPACK_IMPORTED_MODULE_107__.readString;
wg.format.xsd.writeBooleanTextNode = _wg_format_xsd_js__WEBPACK_IMPORTED_MODULE_107__.writeBooleanTextNode;
wg.format.xsd.writeCDATASection = _wg_format_xsd_js__WEBPACK_IMPORTED_MODULE_107__.writeCDATASection;
wg.format.xsd.writeDateTimeTextNode = _wg_format_xsd_js__WEBPACK_IMPORTED_MODULE_107__.writeDateTimeTextNode;
wg.format.xsd.writeDecimalTextNode = _wg_format_xsd_js__WEBPACK_IMPORTED_MODULE_107__.writeDecimalTextNode;
wg.format.xsd.writeNonNegativeIntegerTextNode = _wg_format_xsd_js__WEBPACK_IMPORTED_MODULE_107__.writeNonNegativeIntegerTextNode;
wg.format.xsd.writeStringTextNode = _wg_format_xsd_js__WEBPACK_IMPORTED_MODULE_107__.writeStringTextNode;
wg.functions = {};
wg.functions.FALSE = _wg_functions_js__WEBPACK_IMPORTED_MODULE_108__.FALSE;
wg.functions.TRUE = _wg_functions_js__WEBPACK_IMPORTED_MODULE_108__.TRUE;
wg.functions.VOID = _wg_functions_js__WEBPACK_IMPORTED_MODULE_108__.VOID;
wg.functions.memoizeOne = _wg_functions_js__WEBPACK_IMPORTED_MODULE_108__.memoizeOne;
wg.functions.toPromise = _wg_functions_js__WEBPACK_IMPORTED_MODULE_108__.toPromise;
wg.geom = {};
wg.geom.Circle = _wg_geom_Circle_js__WEBPACK_IMPORTED_MODULE_109__["default"];
wg.geom.Geometry = _wg_geom_Geometry_js__WEBPACK_IMPORTED_MODULE_110__["default"];
wg.geom.GeometryCollection = _wg_geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_111__["default"];
wg.geom.LineString = _wg_geom_LineString_js__WEBPACK_IMPORTED_MODULE_112__["default"];
wg.geom.LinearRing = _wg_geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_113__["default"];
wg.geom.MultiLineString = _wg_geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_114__["default"];
wg.geom.MultiPoint = _wg_geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_115__["default"];
wg.geom.MultiPolygon = _wg_geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_116__["default"];
wg.geom.Point = _wg_geom_Point_js__WEBPACK_IMPORTED_MODULE_117__["default"];
wg.geom.Polygon = _wg_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_118__["default"];
wg.geom.Polygon.circular = _wg_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_118__.circular;
wg.geom.Polygon.fromCircle = _wg_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_118__.fromCircle;
wg.geom.Polygon.fromExtent = _wg_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_118__.fromExtent;
wg.geom.Polygon.makeRegular = _wg_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_118__.makeRegular;
wg.geom.SimpleGeometry = _wg_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_119__["default"];
wg.geom.SimpleGeometry.getStrideForLayout = _wg_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_119__.getStrideForLayout;
wg.geom.SimpleGeometry.transformGeom2D = _wg_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_119__.transformGeom2D;
wg.geom.flat = {};
wg.geom.flat.area = {};
wg.geom.flat.area.linearRing = _wg_geom_flat_area_js__WEBPACK_IMPORTED_MODULE_120__.linearRing;
wg.geom.flat.area.linearRings = _wg_geom_flat_area_js__WEBPACK_IMPORTED_MODULE_120__.linearRings;
wg.geom.flat.area.linearRingss = _wg_geom_flat_area_js__WEBPACK_IMPORTED_MODULE_120__.linearRingss;
wg.geom.flat.center = {};
wg.geom.flat.center.linearRingss = _wg_geom_flat_center_js__WEBPACK_IMPORTED_MODULE_121__.linearRingss;
wg.geom.flat.closest = {};
wg.geom.flat.closest.arrayMaxSquaredDelta = _wg_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_122__.arrayMaxSquaredDelta;
wg.geom.flat.closest.assignClosestArrayPoint = _wg_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_122__.assignClosestArrayPoint;
wg.geom.flat.closest.assignClosestMultiArrayPoint = _wg_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_122__.assignClosestMultiArrayPoint;
wg.geom.flat.closest.assignClosestPoint = _wg_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_122__.assignClosestPoint;
wg.geom.flat.closest.maxSquaredDelta = _wg_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_122__.maxSquaredDelta;
wg.geom.flat.closest.multiArrayMaxSquaredDelta = _wg_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_122__.multiArrayMaxSquaredDelta;
wg.geom.flat.contains = {};
wg.geom.flat.contains.linearRingContainsExtent = _wg_geom_flat_contains_js__WEBPACK_IMPORTED_MODULE_123__.linearRingContainsExtent;
wg.geom.flat.contains.linearRingContainsXY = _wg_geom_flat_contains_js__WEBPACK_IMPORTED_MODULE_123__.linearRingContainsXY;
wg.geom.flat.contains.linearRingsContainsXY = _wg_geom_flat_contains_js__WEBPACK_IMPORTED_MODULE_123__.linearRingsContainsXY;
wg.geom.flat.contains.linearRingssContainsXY = _wg_geom_flat_contains_js__WEBPACK_IMPORTED_MODULE_123__.linearRingssContainsXY;
wg.geom.flat.deflate = {};
wg.geom.flat.deflate.deflateCoordinate = _wg_geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_124__.deflateCoordinate;
wg.geom.flat.deflate.deflateCoordinates = _wg_geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_124__.deflateCoordinates;
wg.geom.flat.deflate.deflateCoordinatesArray = _wg_geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_124__.deflateCoordinatesArray;
wg.geom.flat.deflate.deflateMultiCoordinatesArray = _wg_geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_124__.deflateMultiCoordinatesArray;
wg.geom.flat.flip = {};
wg.geom.flat.flip.flipXY = _wg_geom_flat_flip_js__WEBPACK_IMPORTED_MODULE_125__.flipXY;
wg.geom.flat.geodesic = {};
wg.geom.flat.geodesic.greatCircleArc = _wg_geom_flat_geodesic_js__WEBPACK_IMPORTED_MODULE_126__.greatCircleArc;
wg.geom.flat.geodesic.meridian = _wg_geom_flat_geodesic_js__WEBPACK_IMPORTED_MODULE_126__.meridian;
wg.geom.flat.geodesic.parallel = _wg_geom_flat_geodesic_js__WEBPACK_IMPORTED_MODULE_126__.parallel;
wg.geom.flat.inflate = {};
wg.geom.flat.inflate.inflateCoordinates = _wg_geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_127__.inflateCoordinates;
wg.geom.flat.inflate.inflateCoordinatesArray = _wg_geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_127__.inflateCoordinatesArray;
wg.geom.flat.inflate.inflateMultiCoordinatesArray = _wg_geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_127__.inflateMultiCoordinatesArray;
wg.geom.flat.interiorpoint = {};
wg.geom.flat.interiorpoint.getInteriorPointOfArray = _wg_geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_128__.getInteriorPointOfArray;
wg.geom.flat.interiorpoint.getInteriorPointsOfMultiArray = _wg_geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_128__.getInteriorPointsOfMultiArray;
wg.geom.flat.interpolate = {};
wg.geom.flat.interpolate.interpolatePoint = _wg_geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_129__.interpolatePoint;
wg.geom.flat.interpolate.lineStringCoordinateAtM = _wg_geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_129__.lineStringCoordinateAtM;
wg.geom.flat.interpolate.lineStringsCoordinateAtM = _wg_geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_129__.lineStringsCoordinateAtM;
wg.geom.flat.intersectsextent = {};
wg.geom.flat.intersectsextent.intersectsLineString = _wg_geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_130__.intersectsLineString;
wg.geom.flat.intersectsextent.intersectsLineStringArray = _wg_geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_130__.intersectsLineStringArray;
wg.geom.flat.intersectsextent.intersectsLinearRing = _wg_geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_130__.intersectsLinearRing;
wg.geom.flat.intersectsextent.intersectsLinearRingArray = _wg_geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_130__.intersectsLinearRingArray;
wg.geom.flat.intersectsextent.intersectsLinearRingMultiArray = _wg_geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_130__.intersectsLinearRingMultiArray;
wg.geom.flat.length = {};
wg.geom.flat.length.lineStringLength = _wg_geom_flat_length_js__WEBPACK_IMPORTED_MODULE_131__.lineStringLength;
wg.geom.flat.length.linearRingLength = _wg_geom_flat_length_js__WEBPACK_IMPORTED_MODULE_131__.linearRingLength;
wg.geom.flat.orient = {};
wg.geom.flat.orient.inflateEnds = _wg_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_132__.inflateEnds;
wg.geom.flat.orient.linearRingIsClockwise = _wg_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_132__.linearRingIsClockwise;
wg.geom.flat.orient.linearRingsAreOriented = _wg_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_132__.linearRingsAreOriented;
wg.geom.flat.orient.linearRingssAreOriented = _wg_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_132__.linearRingssAreOriented;
wg.geom.flat.orient.orientLinearRings = _wg_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_132__.orientLinearRings;
wg.geom.flat.orient.orientLinearRingsArray = _wg_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_132__.orientLinearRingsArray;
wg.geom.flat.reverse = {};
wg.geom.flat.reverse.coordinates = _wg_geom_flat_reverse_js__WEBPACK_IMPORTED_MODULE_133__.coordinates;
wg.geom.flat.segments = {};
wg.geom.flat.segments.forEach = _wg_geom_flat_segments_js__WEBPACK_IMPORTED_MODULE_134__.forEach;
wg.geom.flat.simplify = {};
wg.geom.flat.simplify.douglasPeucker = _wg_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_135__.douglasPeucker;
wg.geom.flat.simplify.douglasPeuckerArray = _wg_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_135__.douglasPeuckerArray;
wg.geom.flat.simplify.douglasPeuckerMultiArray = _wg_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_135__.douglasPeuckerMultiArray;
wg.geom.flat.simplify.quantize = _wg_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_135__.quantize;
wg.geom.flat.simplify.quantizeArray = _wg_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_135__.quantizeArray;
wg.geom.flat.simplify.quantizeMultiArray = _wg_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_135__.quantizeMultiArray;
wg.geom.flat.simplify.radialDistance = _wg_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_135__.radialDistance;
wg.geom.flat.simplify.simplifyLineString = _wg_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_135__.simplifyLineString;
wg.geom.flat.simplify.snap = _wg_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_135__.snap;
wg.geom.flat.straightchunk = {};
wg.geom.flat.straightchunk.matchingChunk = _wg_geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_136__.matchingChunk;
wg.geom.flat.textpath = {};
wg.geom.flat.textpath.drawTextOnPath = _wg_geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_137__.drawTextOnPath;
wg.geom.flat.topology = {};
wg.geom.flat.topology.lineStringIsClosed = _wg_geom_flat_topology_js__WEBPACK_IMPORTED_MODULE_138__.lineStringIsClosed;
wg.geom.flat.transform = {};
wg.geom.flat.transform.rotate = _wg_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_139__.rotate;
wg.geom.flat.transform.scale = _wg_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_139__.scale;
wg.geom.flat.transform.transform2D = _wg_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_139__.transform2D;
wg.geom.flat.transform.translate = _wg_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_139__.translate;
wg.has = {};
wg.has.DEVICE_PIXEL_RATIO = _wg_has_js__WEBPACK_IMPORTED_MODULE_140__.DEVICE_PIXEL_RATIO;
wg.has.FIREFOX = _wg_has_js__WEBPACK_IMPORTED_MODULE_140__.FIREFOX;
wg.has.IMAGE_DECODE = _wg_has_js__WEBPACK_IMPORTED_MODULE_140__.IMAGE_DECODE;
wg.has.MAC = _wg_has_js__WEBPACK_IMPORTED_MODULE_140__.MAC;
wg.has.PASSIVE_EVENT_LISTENERS = _wg_has_js__WEBPACK_IMPORTED_MODULE_140__.PASSIVE_EVENT_LISTENERS;
wg.has.SAFARI = _wg_has_js__WEBPACK_IMPORTED_MODULE_140__.SAFARI;
wg.has.WEBKIT = _wg_has_js__WEBPACK_IMPORTED_MODULE_140__.WEBKIT;
wg.has.WORKER_OFFSCREEN_CANVAS = _wg_has_js__WEBPACK_IMPORTED_MODULE_140__.WORKER_OFFSCREEN_CANVAS;
wg.interaction = {};
wg.interaction.DoubleClickZoom = _wg_interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_141__["default"];
wg.interaction.DragAndDrop = _wg_interaction_DragAndDrop_js__WEBPACK_IMPORTED_MODULE_142__["default"];
wg.interaction.DragAndDrop.DragAndDropEvent = _wg_interaction_DragAndDrop_js__WEBPACK_IMPORTED_MODULE_142__.DragAndDropEvent;
wg.interaction.DragBox = _wg_interaction_DragBox_js__WEBPACK_IMPORTED_MODULE_143__["default"];
wg.interaction.DragBox.DragBoxEvent = _wg_interaction_DragBox_js__WEBPACK_IMPORTED_MODULE_143__.DragBoxEvent;
wg.interaction.DragPan = _wg_interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_144__["default"];
wg.interaction.DragRotate = _wg_interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_145__["default"];
wg.interaction.DragRotateAndZoom = _wg_interaction_DragRotateAndZoom_js__WEBPACK_IMPORTED_MODULE_146__["default"];
wg.interaction.DragZoom = _wg_interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_147__["default"];
wg.interaction.Draw = _wg_interaction_Draw_js__WEBPACK_IMPORTED_MODULE_148__["default"];
wg.interaction.Draw.DrawEvent = _wg_interaction_Draw_js__WEBPACK_IMPORTED_MODULE_148__.DrawEvent;
wg.interaction.Draw.createBox = _wg_interaction_Draw_js__WEBPACK_IMPORTED_MODULE_148__.createBox;
wg.interaction.Draw.createRegularPolygon = _wg_interaction_Draw_js__WEBPACK_IMPORTED_MODULE_148__.createRegularPolygon;
wg.interaction.Extent = _wg_interaction_Extent_js__WEBPACK_IMPORTED_MODULE_149__["default"];
wg.interaction.Extent.ExtentEvent = _wg_interaction_Extent_js__WEBPACK_IMPORTED_MODULE_149__.ExtentEvent;
wg.interaction.Interaction = _wg_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_150__["default"];
wg.interaction.Interaction.pan = _wg_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_150__.pan;
wg.interaction.Interaction.zoomByDelta = _wg_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_150__.zoomByDelta;
wg.interaction.KeyboardPan = _wg_interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_151__["default"];
wg.interaction.KeyboardZoom = _wg_interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_152__["default"];
wg.interaction.Modify = _wg_interaction_Modify_js__WEBPACK_IMPORTED_MODULE_153__["default"];
wg.interaction.Modify.ModifyEvent = _wg_interaction_Modify_js__WEBPACK_IMPORTED_MODULE_153__.ModifyEvent;
wg.interaction.MouseWheelZoom = _wg_interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_154__["default"];
wg.interaction.PinchRotate = _wg_interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_155__["default"];
wg.interaction.PinchZoom = _wg_interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_156__["default"];
wg.interaction.Pointer = _wg_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_157__["default"];
wg.interaction.Pointer.centroid = _wg_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_157__.centroid;
wg.interaction.Select = _wg_interaction_Select_js__WEBPACK_IMPORTED_MODULE_158__["default"];
wg.interaction.Select.SelectEvent = _wg_interaction_Select_js__WEBPACK_IMPORTED_MODULE_158__.SelectEvent;
wg.interaction.Snap = _wg_interaction_Snap_js__WEBPACK_IMPORTED_MODULE_159__["default"];
wg.interaction.Translate = _wg_interaction_Translate_js__WEBPACK_IMPORTED_MODULE_160__["default"];
wg.interaction.Translate.TranslateEvent = _wg_interaction_Translate_js__WEBPACK_IMPORTED_MODULE_160__.TranslateEvent;
wg.interaction.defaults = _wg_interaction_js__WEBPACK_IMPORTED_MODULE_161__.defaults;
wg.layer = {};
wg.layer.Base = _wg_layer_Base_js__WEBPACK_IMPORTED_MODULE_162__["default"];
wg.layer.BaseImage = _wg_layer_BaseImage_js__WEBPACK_IMPORTED_MODULE_163__["default"];
wg.layer.BaseTile = _wg_layer_BaseTile_js__WEBPACK_IMPORTED_MODULE_164__["default"];
wg.layer.BaseVector = _wg_layer_BaseVector_js__WEBPACK_IMPORTED_MODULE_165__["default"];
wg.layer.Graticule = _wg_layer_Graticule_js__WEBPACK_IMPORTED_MODULE_166__["default"];
wg.layer.Group = _wg_layer_Group_js__WEBPACK_IMPORTED_MODULE_167__["default"];
wg.layer.Group.GroupEvent = _wg_layer_Group_js__WEBPACK_IMPORTED_MODULE_167__.GroupEvent;
wg.layer.Heatmap = _wg_layer_Heatmap_js__WEBPACK_IMPORTED_MODULE_168__["default"];
wg.layer.Image = _wg_layer_Image_js__WEBPACK_IMPORTED_MODULE_169__["default"];
wg.layer.Layer = _wg_layer_Layer_js__WEBPACK_IMPORTED_MODULE_170__["default"];
wg.layer.Layer.inView = _wg_layer_Layer_js__WEBPACK_IMPORTED_MODULE_170__.inView;
wg.layer.MapboxVector = _wg_layer_MapboxVector_js__WEBPACK_IMPORTED_MODULE_171__["default"];
wg.layer.MapboxVector.getMapboxPath = _wg_layer_MapboxVector_js__WEBPACK_IMPORTED_MODULE_171__.getMapboxPath;
wg.layer.MapboxVector.normalizeGlyphsUrl = _wg_layer_MapboxVector_js__WEBPACK_IMPORTED_MODULE_171__.normalizeGlyphsUrl;
wg.layer.MapboxVector.normalizeSourceUrl = _wg_layer_MapboxVector_js__WEBPACK_IMPORTED_MODULE_171__.normalizeSourceUrl;
wg.layer.MapboxVector.normalizeSpriteUrl = _wg_layer_MapboxVector_js__WEBPACK_IMPORTED_MODULE_171__.normalizeSpriteUrl;
wg.layer.MapboxVector.normalizeStyleUrl = _wg_layer_MapboxVector_js__WEBPACK_IMPORTED_MODULE_171__.normalizeStyleUrl;
wg.layer.Tile = _wg_layer_Tile_js__WEBPACK_IMPORTED_MODULE_172__["default"];
wg.layer.Vector = _wg_layer_Vector_js__WEBPACK_IMPORTED_MODULE_173__["default"];
wg.layer.VectorImage = _wg_layer_VectorImage_js__WEBPACK_IMPORTED_MODULE_174__["default"];
wg.layer.VectorTile = _wg_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_175__["default"];
wg.layer.WebGLPoints = _wg_layer_WebGLPoints_js__WEBPACK_IMPORTED_MODULE_176__["default"];
wg.layer.WebGLTile = _wg_layer_WebGLTile_js__WEBPACK_IMPORTED_MODULE_177__["default"];
wg.loadingstrategy = {};
wg.loadingstrategy.all = _wg_loadingstrategy_js__WEBPACK_IMPORTED_MODULE_178__.all;
wg.loadingstrategy.bbox = _wg_loadingstrategy_js__WEBPACK_IMPORTED_MODULE_178__.bbox;
wg.loadingstrategy.tile = _wg_loadingstrategy_js__WEBPACK_IMPORTED_MODULE_178__.tile;
wg.math = {};
wg.math.ceil = _wg_math_js__WEBPACK_IMPORTED_MODULE_179__.ceil;
wg.math.clamp = _wg_math_js__WEBPACK_IMPORTED_MODULE_179__.clamp;
wg.math.cosh = _wg_math_js__WEBPACK_IMPORTED_MODULE_179__.cosh;
wg.math.floor = _wg_math_js__WEBPACK_IMPORTED_MODULE_179__.floor;
wg.math.lerp = _wg_math_js__WEBPACK_IMPORTED_MODULE_179__.lerp;
wg.math.log2 = _wg_math_js__WEBPACK_IMPORTED_MODULE_179__.log2;
wg.math.modulo = _wg_math_js__WEBPACK_IMPORTED_MODULE_179__.modulo;
wg.math.round = _wg_math_js__WEBPACK_IMPORTED_MODULE_179__.round;
wg.math.solveLinearSystem = _wg_math_js__WEBPACK_IMPORTED_MODULE_179__.solveLinearSystem;
wg.math.squaredDistance = _wg_math_js__WEBPACK_IMPORTED_MODULE_179__.squaredDistance;
wg.math.squaredSegmentDistance = _wg_math_js__WEBPACK_IMPORTED_MODULE_179__.squaredSegmentDistance;
wg.math.toDegrees = _wg_math_js__WEBPACK_IMPORTED_MODULE_179__.toDegrees;
wg.math.toFixed = _wg_math_js__WEBPACK_IMPORTED_MODULE_179__.toFixed;
wg.math.toRadians = _wg_math_js__WEBPACK_IMPORTED_MODULE_179__.toRadians;
wg.net = {};
wg.net.ClientError = _wg_net_js__WEBPACK_IMPORTED_MODULE_180__.ClientError;
wg.net.ResponseError = _wg_net_js__WEBPACK_IMPORTED_MODULE_180__.ResponseError;
wg.net.getJSON = _wg_net_js__WEBPACK_IMPORTED_MODULE_180__.getJSON;
wg.net.jsonp = _wg_net_js__WEBPACK_IMPORTED_MODULE_180__.jsonp;
wg.net.overrideXHR = _wg_net_js__WEBPACK_IMPORTED_MODULE_180__.overrideXHR;
wg.net.resolveUrl = _wg_net_js__WEBPACK_IMPORTED_MODULE_180__.resolveUrl;
wg.net.restoreXHR = _wg_net_js__WEBPACK_IMPORTED_MODULE_180__.restoreXHR;
wg.obj = {};
wg.obj.assign = _wg_obj_js__WEBPACK_IMPORTED_MODULE_181__.assign;
wg.obj.clear = _wg_obj_js__WEBPACK_IMPORTED_MODULE_181__.clear;
wg.obj.getValues = _wg_obj_js__WEBPACK_IMPORTED_MODULE_181__.getValues;
wg.obj.isEmpty = _wg_obj_js__WEBPACK_IMPORTED_MODULE_181__.isEmpty;
wg.proj = {};
wg.proj.Projection = _wg_proj_Projection_js__WEBPACK_IMPORTED_MODULE_182__["default"];
wg.proj.Units = {};
wg.proj.Units.METERS_PER_UNIT = _wg_proj_Units_js__WEBPACK_IMPORTED_MODULE_183__.METERS_PER_UNIT;
wg.proj.Units.fromCode = _wg_proj_Units_js__WEBPACK_IMPORTED_MODULE_183__.fromCode;
wg.proj.addCommon = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.addCommon;
wg.proj.addCoordinateTransforms = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.addCoordinateTransforms;
wg.proj.addEquivalentProjections = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.addEquivalentProjections;
wg.proj.addEquivalentTransforms = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.addEquivalentTransforms;
wg.proj.addProjection = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.addProjection;
wg.proj.addProjections = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.addProjections;
wg.proj.clearAllProjections = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.clearAllProjections;
wg.proj.clearUserProjection = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.clearUserProjection;
wg.proj.cloneTransform = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.cloneTransform;
wg.proj.createProjection = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.createProjection;
wg.proj.createSafeCoordinateTransform = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.createSafeCoordinateTransform;
wg.proj.createTransformFromCoordinateTransform = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.createTransformFromCoordinateTransform;
wg.proj.disableCoordinateWarning = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.disableCoordinateWarning;
wg.proj.epsg3857 = {};
wg.proj.epsg3857.EXTENT = _wg_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_184__.EXTENT;
wg.proj.epsg3857.HALF_SIZE = _wg_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_184__.HALF_SIZE;
wg.proj.epsg3857.MAX_SAFE_Y = _wg_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_184__.MAX_SAFE_Y;
wg.proj.epsg3857.PROJECTIONS = _wg_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_184__.PROJECTIONS;
wg.proj.epsg3857.RADIUS = _wg_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_184__.RADIUS;
wg.proj.epsg3857.WORLD_EXTENT = _wg_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_184__.WORLD_EXTENT;
wg.proj.epsg3857.fromEPSG4326 = _wg_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_184__.fromEPSG4326;
wg.proj.epsg3857.toEPSG4326 = _wg_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_184__.toEPSG4326;
wg.proj.epsg4326 = {};
wg.proj.epsg4326.EXTENT = _wg_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_185__.EXTENT;
wg.proj.epsg4326.METERS_PER_UNIT = _wg_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_185__.METERS_PER_UNIT;
wg.proj.epsg4326.PROJECTIONS = _wg_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_185__.PROJECTIONS;
wg.proj.epsg4326.RADIUS = _wg_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_185__.RADIUS;
wg.proj.equivalent = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent;
wg.proj.fromLonLat = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromLonLat;
wg.proj.fromUserCoordinate = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate;
wg.proj.fromUserExtent = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent;
wg.proj.fromUserResolution = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserResolution;
wg.proj.get = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.get;
wg.proj.getPointResolution = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.getPointResolution;
wg.proj.getTransform = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform;
wg.proj.getTransformFromProjections = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransformFromProjections;
wg.proj.getUserProjection = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection;
wg.proj.identityTransform = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.identityTransform;
wg.proj.proj4 = {};
wg.proj.proj4.register = _wg_proj_proj4_js__WEBPACK_IMPORTED_MODULE_186__.register;
wg.proj.projections = {};
wg.proj.projections.add = _wg_proj_projections_js__WEBPACK_IMPORTED_MODULE_187__.add;
wg.proj.projections.clear = _wg_proj_projections_js__WEBPACK_IMPORTED_MODULE_187__.clear;
wg.proj.projections.get = _wg_proj_projections_js__WEBPACK_IMPORTED_MODULE_187__.get;
wg.proj.setUserProjection = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.setUserProjection;
wg.proj.toLonLat = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.toLonLat;
wg.proj.toUserCoordinate = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate;
wg.proj.toUserExtent = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent;
wg.proj.toUserResolution = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserResolution;
wg.proj.transform = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.transform;
wg.proj.transformExtent = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.transformExtent;
wg.proj.transformWithProjections = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.transformWithProjections;
wg.proj.transforms = {};
wg.proj.transforms.add = _wg_proj_transforms_js__WEBPACK_IMPORTED_MODULE_188__.add;
wg.proj.transforms.clear = _wg_proj_transforms_js__WEBPACK_IMPORTED_MODULE_188__.clear;
wg.proj.transforms.get = _wg_proj_transforms_js__WEBPACK_IMPORTED_MODULE_188__.get;
wg.proj.transforms.remove = _wg_proj_transforms_js__WEBPACK_IMPORTED_MODULE_188__.remove;
wg.proj.useGeographic = _wg_proj_js__WEBPACK_IMPORTED_MODULE_0__.useGeographic;
wg.render = {};
wg.render.Box = _wg_render_Box_js__WEBPACK_IMPORTED_MODULE_189__["default"];
wg.render.Event = _wg_render_Event_js__WEBPACK_IMPORTED_MODULE_190__["default"];
wg.render.Feature = _wg_render_Feature_js__WEBPACK_IMPORTED_MODULE_191__["default"];
wg.render.Feature.toFeature = _wg_render_Feature_js__WEBPACK_IMPORTED_MODULE_191__.toFeature;
wg.render.Feature.toGeometry = _wg_render_Feature_js__WEBPACK_IMPORTED_MODULE_191__.toGeometry;
wg.render.VectorContext = _wg_render_VectorContext_js__WEBPACK_IMPORTED_MODULE_192__["default"];
wg.render.canvas = {};
wg.render.canvas.Builder = _wg_render_canvas_Builder_js__WEBPACK_IMPORTED_MODULE_193__["default"];
wg.render.canvas.BuilderGroup = _wg_render_canvas_BuilderGroup_js__WEBPACK_IMPORTED_MODULE_194__["default"];
wg.render.canvas.Executor = _wg_render_canvas_Executor_js__WEBPACK_IMPORTED_MODULE_195__["default"];
wg.render.canvas.ExecutorGroup = _wg_render_canvas_ExecutorGroup_js__WEBPACK_IMPORTED_MODULE_196__["default"];
wg.render.canvas.ExecutorGroup.getPixelIndexArray = _wg_render_canvas_ExecutorGroup_js__WEBPACK_IMPORTED_MODULE_196__.getPixelIndexArray;
wg.render.canvas.ImageBuilder = _wg_render_canvas_ImageBuilder_js__WEBPACK_IMPORTED_MODULE_197__["default"];
wg.render.canvas.Immediate = _wg_render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_198__["default"];
wg.render.canvas.Instruction = {};
wg.render.canvas.Instruction.beginPathInstruction = _wg_render_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_199__.beginPathInstruction;
wg.render.canvas.Instruction.closePathInstruction = _wg_render_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_199__.closePathInstruction;
wg.render.canvas.Instruction.fillInstruction = _wg_render_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_199__.fillInstruction;
wg.render.canvas.Instruction.strokeInstruction = _wg_render_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_199__.strokeInstruction;
wg.render.canvas.LineStringBuilder = _wg_render_canvas_LineStringBuilder_js__WEBPACK_IMPORTED_MODULE_200__["default"];
wg.render.canvas.PolygonBuilder = _wg_render_canvas_PolygonBuilder_js__WEBPACK_IMPORTED_MODULE_201__["default"];
wg.render.canvas.TextBuilder = _wg_render_canvas_TextBuilder_js__WEBPACK_IMPORTED_MODULE_202__["default"];
wg.render.canvas.checkedFonts = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.checkedFonts;
wg.render.canvas.defaultFillStyle = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.defaultFillStyle;
wg.render.canvas.defaultFont = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.defaultFont;
wg.render.canvas.defaultLineCap = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.defaultLineCap;
wg.render.canvas.defaultLineDash = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.defaultLineDash;
wg.render.canvas.defaultLineDashOffset = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.defaultLineDashOffset;
wg.render.canvas.defaultLineJoin = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.defaultLineJoin;
wg.render.canvas.defaultLineWidth = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.defaultLineWidth;
wg.render.canvas.defaultMiterLimit = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.defaultMiterLimit;
wg.render.canvas.defaultPadding = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.defaultPadding;
wg.render.canvas.defaultStrokeStyle = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.defaultStrokeStyle;
wg.render.canvas.defaultTextAlign = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.defaultTextAlign;
wg.render.canvas.defaultTextBaseline = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.defaultTextBaseline;
wg.render.canvas.drawImageOrLabel = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.drawImageOrLabel;
wg.render.canvas.getTextDimensions = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.getTextDimensions;
wg.render.canvas.hitdetect = {};
wg.render.canvas.hitdetect.HIT_DETECT_RESOLUTION = _wg_render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_204__.HIT_DETECT_RESOLUTION;
wg.render.canvas.hitdetect.createHitDetectionImageData = _wg_render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_204__.createHitDetectionImageData;
wg.render.canvas.hitdetect.hitDetect = _wg_render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_204__.hitDetect;
wg.render.canvas.labelCache = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.labelCache;
wg.render.canvas.measureAndCacheTextWidth = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.measureAndCacheTextWidth;
wg.render.canvas.measureTextHeight = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.measureTextHeight;
wg.render.canvas.measureTextWidth = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.measureTextWidth;
wg.render.canvas.registerFont = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.registerFont;
wg.render.canvas.rotateAtOffset = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.rotateAtOffset;
wg.render.canvas.textHeights = _wg_render_canvas_js__WEBPACK_IMPORTED_MODULE_203__.textHeights;
wg.render.getRenderPixel = _wg_render_js__WEBPACK_IMPORTED_MODULE_205__.getRenderPixel;
wg.render.getVectorContext = _wg_render_js__WEBPACK_IMPORTED_MODULE_205__.getVectorContext;
wg.render.toContext = _wg_render_js__WEBPACK_IMPORTED_MODULE_205__.toContext;
wg.renderer = {};
wg.renderer.Composite = _wg_renderer_Composite_js__WEBPACK_IMPORTED_MODULE_206__["default"];
wg.renderer.Layer = _wg_renderer_Layer_js__WEBPACK_IMPORTED_MODULE_207__["default"];
wg.renderer.Map = _wg_renderer_Map_js__WEBPACK_IMPORTED_MODULE_208__["default"];
wg.renderer.canvas = {};
wg.renderer.canvas.ImageLayer = _wg_renderer_canvas_ImageLayer_js__WEBPACK_IMPORTED_MODULE_209__["default"];
wg.renderer.canvas.Layer = _wg_renderer_canvas_Layer_js__WEBPACK_IMPORTED_MODULE_210__["default"];
wg.renderer.canvas.TileLayer = _wg_renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_211__["default"];
wg.renderer.canvas.VectorImageLayer = _wg_renderer_canvas_VectorImageLayer_js__WEBPACK_IMPORTED_MODULE_212__["default"];
wg.renderer.canvas.VectorLayer = _wg_renderer_canvas_VectorLayer_js__WEBPACK_IMPORTED_MODULE_213__["default"];
wg.renderer.canvas.VectorTileLayer = _wg_renderer_canvas_VectorTileLayer_js__WEBPACK_IMPORTED_MODULE_214__["default"];
wg.renderer.canvas.common = {};
wg.renderer.canvas.common.IMAGE_SMOOTHING_DISABLED = _wg_renderer_canvas_common_js__WEBPACK_IMPORTED_MODULE_215__.IMAGE_SMOOTHING_DISABLED;
wg.renderer.canvas.common.IMAGE_SMOOTHING_ENABLED = _wg_renderer_canvas_common_js__WEBPACK_IMPORTED_MODULE_215__.IMAGE_SMOOTHING_ENABLED;
wg.renderer.vector = {};
wg.renderer.vector.defaultOrder = _wg_renderer_vector_js__WEBPACK_IMPORTED_MODULE_216__.defaultOrder;
wg.renderer.vector.getSquaredTolerance = _wg_renderer_vector_js__WEBPACK_IMPORTED_MODULE_216__.getSquaredTolerance;
wg.renderer.vector.getTolerance = _wg_renderer_vector_js__WEBPACK_IMPORTED_MODULE_216__.getTolerance;
wg.renderer.vector.renderFeature = _wg_renderer_vector_js__WEBPACK_IMPORTED_MODULE_216__.renderFeature;
wg.renderer.webgl = {};
wg.renderer.webgl.Layer = _wg_renderer_webgl_Layer_js__WEBPACK_IMPORTED_MODULE_217__["default"];
wg.renderer.webgl.Layer.colorDecodeId = _wg_renderer_webgl_Layer_js__WEBPACK_IMPORTED_MODULE_217__.colorDecodeId;
wg.renderer.webgl.Layer.colorEncodeId = _wg_renderer_webgl_Layer_js__WEBPACK_IMPORTED_MODULE_217__.colorEncodeId;
wg.renderer.webgl.Layer.getBlankImageData = _wg_renderer_webgl_Layer_js__WEBPACK_IMPORTED_MODULE_217__.getBlankImageData;
wg.renderer.webgl.Layer.writePointFeatureToBuffers = _wg_renderer_webgl_Layer_js__WEBPACK_IMPORTED_MODULE_217__.writePointFeatureToBuffers;
wg.renderer.webgl.PointsLayer = _wg_renderer_webgl_PointsLayer_js__WEBPACK_IMPORTED_MODULE_218__["default"];
wg.renderer.webgl.TileLayer = _wg_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_219__["default"];
wg.renderer.webgl.TileLayer.Attributes = _wg_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_219__.Attributes;
wg.renderer.webgl.TileLayer.Uniforms = _wg_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_219__.Uniforms;
wg.reproj = {};
wg.reproj.Image = _wg_reproj_Image_js__WEBPACK_IMPORTED_MODULE_220__["default"];
wg.reproj.Tile = _wg_reproj_Tile_js__WEBPACK_IMPORTED_MODULE_221__["default"];
wg.reproj.Triangulation = _wg_reproj_Triangulation_js__WEBPACK_IMPORTED_MODULE_222__["default"];
wg.reproj.calculateSourceExtentResolution = _wg_reproj_js__WEBPACK_IMPORTED_MODULE_223__.calculateSourceExtentResolution;
wg.reproj.calculateSourceResolution = _wg_reproj_js__WEBPACK_IMPORTED_MODULE_223__.calculateSourceResolution;
wg.reproj.common = {};
wg.reproj.common.ENABLE_RASTER_REPROJECTION = _wg_reproj_common_js__WEBPACK_IMPORTED_MODULE_224__.ENABLE_RASTER_REPROJECTION;
wg.reproj.common.ERROR_THRESHOLD = _wg_reproj_common_js__WEBPACK_IMPORTED_MODULE_224__.ERROR_THRESHOLD;
wg.reproj.render = _wg_reproj_js__WEBPACK_IMPORTED_MODULE_223__.render;
wg.resolutionconstraint = {};
wg.resolutionconstraint.createMinMaxResolution = _wg_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_225__.createMinMaxResolution;
wg.resolutionconstraint.createSnapToPower = _wg_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_225__.createSnapToPower;
wg.resolutionconstraint.createSnapToResolutions = _wg_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_225__.createSnapToResolutions;
wg.rotationconstraint = {};
wg.rotationconstraint.createSnapToN = _wg_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_226__.createSnapToN;
wg.rotationconstraint.createSnapToZero = _wg_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_226__.createSnapToZero;
wg.rotationconstraint.disable = _wg_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_226__.disable;
wg.rotationconstraint.none = _wg_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_226__.none;
wg.size = {};
wg.size.buffer = _wg_size_js__WEBPACK_IMPORTED_MODULE_227__.buffer;
wg.size.hasArea = _wg_size_js__WEBPACK_IMPORTED_MODULE_227__.hasArea;
wg.size.scale = _wg_size_js__WEBPACK_IMPORTED_MODULE_227__.scale;
wg.size.toSize = _wg_size_js__WEBPACK_IMPORTED_MODULE_227__.toSize;
wg.source = {};
wg.source.BingMaps = _wg_source_BingMaps_js__WEBPACK_IMPORTED_MODULE_228__["default"];
wg.source.BingMaps.quadKey = _wg_source_BingMaps_js__WEBPACK_IMPORTED_MODULE_228__.quadKey;
wg.source.CartoDB = _wg_source_CartoDB_js__WEBPACK_IMPORTED_MODULE_229__["default"];
wg.source.Cluster = _wg_source_Cluster_js__WEBPACK_IMPORTED_MODULE_230__["default"];
wg.source.DataTile = _wg_source_DataTile_js__WEBPACK_IMPORTED_MODULE_231__["default"];
wg.source.GeoTIFF = _wg_source_GeoTIFF_js__WEBPACK_IMPORTED_MODULE_232__["default"];
wg.source.IIIF = _wg_source_IIIF_js__WEBPACK_IMPORTED_MODULE_233__["default"];
wg.source.Image = _wg_source_Image_js__WEBPACK_IMPORTED_MODULE_234__["default"];
wg.source.Image.ImageSourceEvent = _wg_source_Image_js__WEBPACK_IMPORTED_MODULE_234__.ImageSourceEvent;
wg.source.Image.defaultImageLoadFunction = _wg_source_Image_js__WEBPACK_IMPORTED_MODULE_234__.defaultImageLoadFunction;
wg.source.ImageArcGISRest = _wg_source_ImageArcGISRest_js__WEBPACK_IMPORTED_MODULE_235__["default"];
wg.source.ImageCanvas = _wg_source_ImageCanvas_js__WEBPACK_IMPORTED_MODULE_236__["default"];
wg.source.ImageMapGuide = _wg_source_ImageMapGuide_js__WEBPACK_IMPORTED_MODULE_237__["default"];
wg.source.ImageStatic = _wg_source_ImageStatic_js__WEBPACK_IMPORTED_MODULE_238__["default"];
wg.source.ImageWMS = _wg_source_ImageWMS_js__WEBPACK_IMPORTED_MODULE_239__["default"];
wg.source.OGCMapTile = _wg_source_OGCMapTile_js__WEBPACK_IMPORTED_MODULE_240__["default"];
wg.source.OGCVectorTile = _wg_source_OGCVectorTile_js__WEBPACK_IMPORTED_MODULE_241__["default"];
wg.source.OSM = _wg_source_OSM_js__WEBPACK_IMPORTED_MODULE_242__["default"];
wg.source.OSM.ATTRIBUTION = _wg_source_OSM_js__WEBPACK_IMPORTED_MODULE_242__.ATTRIBUTION;
wg.source.Raster = _wg_source_Raster_js__WEBPACK_IMPORTED_MODULE_243__["default"];
wg.source.Raster.Processor = _wg_source_Raster_js__WEBPACK_IMPORTED_MODULE_243__.Processor;
wg.source.Raster.RasterSourceEvent = _wg_source_Raster_js__WEBPACK_IMPORTED_MODULE_243__.RasterSourceEvent;
wg.source.Raster.newImageData = _wg_source_Raster_js__WEBPACK_IMPORTED_MODULE_243__.newImageData;
wg.source.Source = _wg_source_Source_js__WEBPACK_IMPORTED_MODULE_244__["default"];
wg.source.Stamen = _wg_source_Stamen_js__WEBPACK_IMPORTED_MODULE_245__["default"];
wg.source.Tile = _wg_source_Tile_js__WEBPACK_IMPORTED_MODULE_246__["default"];
wg.source.Tile.TileSourceEvent = _wg_source_Tile_js__WEBPACK_IMPORTED_MODULE_246__.TileSourceEvent;
wg.source.TileArcGISRest = _wg_source_TileArcGISRest_js__WEBPACK_IMPORTED_MODULE_247__["default"];
wg.source.TileDebug = _wg_source_TileDebug_js__WEBPACK_IMPORTED_MODULE_248__["default"];
wg.source.TileImage = _wg_source_TileImage_js__WEBPACK_IMPORTED_MODULE_249__["default"];
wg.source.TileJSON = _wg_source_TileJSON_js__WEBPACK_IMPORTED_MODULE_250__["default"];
wg.source.TileWMS = _wg_source_TileWMS_js__WEBPACK_IMPORTED_MODULE_251__["default"];
wg.source.UTFGrid = _wg_source_UTFGrid_js__WEBPACK_IMPORTED_MODULE_252__["default"];
wg.source.UTFGrid.CustomTile = _wg_source_UTFGrid_js__WEBPACK_IMPORTED_MODULE_252__.CustomTile;
wg.source.UrlTile = _wg_source_UrlTile_js__WEBPACK_IMPORTED_MODULE_253__["default"];
wg.source.Vector = _wg_source_Vector_js__WEBPACK_IMPORTED_MODULE_254__["default"];
wg.source.Vector.VectorSourceEvent = _wg_source_Vector_js__WEBPACK_IMPORTED_MODULE_254__.VectorSourceEvent;
wg.source.VectorTile = _wg_source_VectorTile_js__WEBPACK_IMPORTED_MODULE_255__["default"];
wg.source.VectorTile.defaultLoadFunction = _wg_source_VectorTile_js__WEBPACK_IMPORTED_MODULE_255__.defaultLoadFunction;
wg.source.WMTS = _wg_source_WMTS_js__WEBPACK_IMPORTED_MODULE_256__["default"];
wg.source.WMTS.optionsFromCapabilities = _wg_source_WMTS_js__WEBPACK_IMPORTED_MODULE_256__.optionsFromCapabilities;
wg.source.XYZ = _wg_source_XYZ_js__WEBPACK_IMPORTED_MODULE_257__["default"];
wg.source.Zoomify = _wg_source_Zoomify_js__WEBPACK_IMPORTED_MODULE_258__["default"];
wg.source.Zoomify.CustomTile = _wg_source_Zoomify_js__WEBPACK_IMPORTED_MODULE_258__.CustomTile;
wg.source.common = {};
wg.source.common.DEFAULT_WMS_VERSION = _wg_source_common_js__WEBPACK_IMPORTED_MODULE_259__.DEFAULT_WMS_VERSION;
wg.source.ogcTileUtil = {};
wg.source.ogcTileUtil.getMapTileUrlTemplate = _wg_source_ogcTileUtil_js__WEBPACK_IMPORTED_MODULE_260__.getMapTileUrlTemplate;
wg.source.ogcTileUtil.getTileSetInfo = _wg_source_ogcTileUtil_js__WEBPACK_IMPORTED_MODULE_260__.getTileSetInfo;
wg.source.ogcTileUtil.getVectorTileUrlTemplate = _wg_source_ogcTileUtil_js__WEBPACK_IMPORTED_MODULE_260__.getVectorTileUrlTemplate;
wg.source.sourcesFromTileGrid = _wg_source_js__WEBPACK_IMPORTED_MODULE_261__.sourcesFromTileGrid;
wg.sphere = {};
wg.sphere.DEFAULT_RADIUS = _wg_sphere_js__WEBPACK_IMPORTED_MODULE_262__.DEFAULT_RADIUS;
wg.sphere.getArea = _wg_sphere_js__WEBPACK_IMPORTED_MODULE_262__.getArea;
wg.sphere.getDistance = _wg_sphere_js__WEBPACK_IMPORTED_MODULE_262__.getDistance;
wg.sphere.getLength = _wg_sphere_js__WEBPACK_IMPORTED_MODULE_262__.getLength;
wg.sphere.offset = _wg_sphere_js__WEBPACK_IMPORTED_MODULE_262__.offset;
wg.string = {};
wg.string.compareVersions = _wg_string_js__WEBPACK_IMPORTED_MODULE_263__.compareVersions;
wg.string.padNumber = _wg_string_js__WEBPACK_IMPORTED_MODULE_263__.padNumber;
wg.structs = {};
wg.structs.LRUCache = _wg_structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_264__["default"];
wg.structs.LinkedList = _wg_structs_LinkedList_js__WEBPACK_IMPORTED_MODULE_265__["default"];
wg.structs.PriorityQueue = _wg_structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_266__["default"];
wg.structs.PriorityQueue.DROP = _wg_structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_266__.DROP;
wg.structs.RBush = _wg_structs_RBush_js__WEBPACK_IMPORTED_MODULE_267__["default"];
wg.style = {};
wg.style.Circle = _wg_style_Circle_js__WEBPACK_IMPORTED_MODULE_268__["default"];
wg.style.Fill = _wg_style_Fill_js__WEBPACK_IMPORTED_MODULE_269__["default"];
wg.style.Icon = _wg_style_Icon_js__WEBPACK_IMPORTED_MODULE_270__["default"];
wg.style.IconImage = _wg_style_IconImage_js__WEBPACK_IMPORTED_MODULE_271__["default"];
wg.style.IconImage.get = _wg_style_IconImage_js__WEBPACK_IMPORTED_MODULE_271__.get;
wg.style.IconImageCache = _wg_style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_272__["default"];
wg.style.IconImageCache.shared = _wg_style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_272__.shared;
wg.style.Image = _wg_style_Image_js__WEBPACK_IMPORTED_MODULE_273__["default"];
wg.style.RegularShape = _wg_style_RegularShape_js__WEBPACK_IMPORTED_MODULE_274__["default"];
wg.style.Stroke = _wg_style_Stroke_js__WEBPACK_IMPORTED_MODULE_275__["default"];
wg.style.Style = _wg_style_Style_js__WEBPACK_IMPORTED_MODULE_276__["default"];
wg.style.Style.createDefaultStyle = _wg_style_Style_js__WEBPACK_IMPORTED_MODULE_276__.createDefaultStyle;
wg.style.Style.createEditingStyle = _wg_style_Style_js__WEBPACK_IMPORTED_MODULE_276__.createEditingStyle;
wg.style.Style.toFunction = _wg_style_Style_js__WEBPACK_IMPORTED_MODULE_276__.toFunction;
wg.style.Text = _wg_style_Text_js__WEBPACK_IMPORTED_MODULE_277__["default"];
wg.style.expressions = {};
wg.style.expressions.Operators = _wg_style_expressions_js__WEBPACK_IMPORTED_MODULE_278__.Operators;
wg.style.expressions.PALETTE_TEXTURE_ARRAY = _wg_style_expressions_js__WEBPACK_IMPORTED_MODULE_278__.PALETTE_TEXTURE_ARRAY;
wg.style.expressions.arrayToGlsl = _wg_style_expressions_js__WEBPACK_IMPORTED_MODULE_278__.arrayToGlsl;
wg.style.expressions.colorToGlsl = _wg_style_expressions_js__WEBPACK_IMPORTED_MODULE_278__.colorToGlsl;
wg.style.expressions.expressionToGlsl = _wg_style_expressions_js__WEBPACK_IMPORTED_MODULE_278__.expressionToGlsl;
wg.style.expressions.getStringNumberEquivalent = _wg_style_expressions_js__WEBPACK_IMPORTED_MODULE_278__.getStringNumberEquivalent;
wg.style.expressions.getValueType = _wg_style_expressions_js__WEBPACK_IMPORTED_MODULE_278__.getValueType;
wg.style.expressions.isTypeUnique = _wg_style_expressions_js__WEBPACK_IMPORTED_MODULE_278__.isTypeUnique;
wg.style.expressions.numberToGlsl = _wg_style_expressions_js__WEBPACK_IMPORTED_MODULE_278__.numberToGlsl;
wg.style.expressions.stringToGlsl = _wg_style_expressions_js__WEBPACK_IMPORTED_MODULE_278__.stringToGlsl;
wg.style.expressions.uniformNameForVariable = _wg_style_expressions_js__WEBPACK_IMPORTED_MODULE_278__.uniformNameForVariable;
wg.tilecoord = {};
wg.tilecoord.createOrUpdate = _wg_tilecoord_js__WEBPACK_IMPORTED_MODULE_279__.createOrUpdate;
wg.tilecoord.fromKey = _wg_tilecoord_js__WEBPACK_IMPORTED_MODULE_279__.fromKey;
wg.tilecoord.getCacheKeyForTileKey = _wg_tilecoord_js__WEBPACK_IMPORTED_MODULE_279__.getCacheKeyForTileKey;
wg.tilecoord.getKey = _wg_tilecoord_js__WEBPACK_IMPORTED_MODULE_279__.getKey;
wg.tilecoord.getKeyZXY = _wg_tilecoord_js__WEBPACK_IMPORTED_MODULE_279__.getKeyZXY;
wg.tilecoord.hash = _wg_tilecoord_js__WEBPACK_IMPORTED_MODULE_279__.hash;
wg.tilecoord.withinExtentAndZ = _wg_tilecoord_js__WEBPACK_IMPORTED_MODULE_279__.withinExtentAndZ;
wg.tilegrid = {};
wg.tilegrid.TileGrid = _wg_tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_280__["default"];
wg.tilegrid.WMTS = _wg_tilegrid_WMTS_js__WEBPACK_IMPORTED_MODULE_281__["default"];
wg.tilegrid.WMTS.createFromCapabilitiesMatrixSet = _wg_tilegrid_WMTS_js__WEBPACK_IMPORTED_MODULE_281__.createFromCapabilitiesMatrixSet;
wg.tilegrid.common = {};
wg.tilegrid.common.DEFAULT_MAX_ZOOM = _wg_tilegrid_common_js__WEBPACK_IMPORTED_MODULE_282__.DEFAULT_MAX_ZOOM;
wg.tilegrid.common.DEFAULT_TILE_SIZE = _wg_tilegrid_common_js__WEBPACK_IMPORTED_MODULE_282__.DEFAULT_TILE_SIZE;
wg.tilegrid.createForExtent = _wg_tilegrid_js__WEBPACK_IMPORTED_MODULE_283__.createForExtent;
wg.tilegrid.createForProjection = _wg_tilegrid_js__WEBPACK_IMPORTED_MODULE_283__.createForProjection;
wg.tilegrid.createXYZ = _wg_tilegrid_js__WEBPACK_IMPORTED_MODULE_283__.createXYZ;
wg.tilegrid.extentFromProjection = _wg_tilegrid_js__WEBPACK_IMPORTED_MODULE_283__.extentFromProjection;
wg.tilegrid.getForProjection = _wg_tilegrid_js__WEBPACK_IMPORTED_MODULE_283__.getForProjection;
wg.tilegrid.wrapX = _wg_tilegrid_js__WEBPACK_IMPORTED_MODULE_283__.wrapX;
wg.tileurlfunction = {};
wg.tileurlfunction.createFromTemplate = _wg_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_284__.createFromTemplate;
wg.tileurlfunction.createFromTemplates = _wg_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_284__.createFromTemplates;
wg.tileurlfunction.createFromTileUrlFunctions = _wg_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_284__.createFromTileUrlFunctions;
wg.tileurlfunction.expandUrl = _wg_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_284__.expandUrl;
wg.tileurlfunction.nullTileUrlFunction = _wg_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_284__.nullTileUrlFunction;
wg.transform = {};
wg.transform.apply = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.apply;
wg.transform.compose = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.compose;
wg.transform.composeCssTransform = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.composeCssTransform;
wg.transform.create = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.create;
wg.transform.determinant = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.determinant;
wg.transform.invert = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.invert;
wg.transform.makeInverse = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.makeInverse;
wg.transform.makeScale = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.makeScale;
wg.transform.multiply = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.multiply;
wg.transform.reset = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.reset;
wg.transform.rotate = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.rotate;
wg.transform.scale = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.scale;
wg.transform.set = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.set;
wg.transform.setFromArray = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.setFromArray;
wg.transform.toString = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.toString;
wg.transform.translate = _wg_transform_js__WEBPACK_IMPORTED_MODULE_285__.translate;
wg.uri = {};
wg.uri.appendParams = _wg_uri_js__WEBPACK_IMPORTED_MODULE_286__.appendParams;
wg.util = {};
wg.util.VERSION = _wg_util_js__WEBPACK_IMPORTED_MODULE_287__.VERSION;
wg.util.abstract = _wg_util_js__WEBPACK_IMPORTED_MODULE_287__.abstract;
wg.util.getUid = _wg_util_js__WEBPACK_IMPORTED_MODULE_287__.getUid;
wg.vec = {};
wg.vec.mat4 = {};
wg.vec.mat4.create = _wg_vec_mat4_js__WEBPACK_IMPORTED_MODULE_288__.create;
wg.vec.mat4.fromTransform = _wg_vec_mat4_js__WEBPACK_IMPORTED_MODULE_288__.fromTransform;
wg.webgl = {};
wg.webgl.ARRAY_BUFFER = _wg_webgl_js__WEBPACK_IMPORTED_MODULE_289__.ARRAY_BUFFER;
wg.webgl.Buffer = _wg_webgl_Buffer_js__WEBPACK_IMPORTED_MODULE_290__["default"];
wg.webgl.Buffer.getArrayClassForType = _wg_webgl_Buffer_js__WEBPACK_IMPORTED_MODULE_290__.getArrayClassForType;
wg.webgl.DYNAMIC_DRAW = _wg_webgl_js__WEBPACK_IMPORTED_MODULE_289__.DYNAMIC_DRAW;
wg.webgl.ELEMENT_ARRAY_BUFFER = _wg_webgl_js__WEBPACK_IMPORTED_MODULE_289__.ELEMENT_ARRAY_BUFFER;
wg.webgl.FLOAT = _wg_webgl_js__WEBPACK_IMPORTED_MODULE_289__.FLOAT;
wg.webgl.Helper = _wg_webgl_Helper_js__WEBPACK_IMPORTED_MODULE_291__["default"];
wg.webgl.Helper.computeAttributesStride = _wg_webgl_Helper_js__WEBPACK_IMPORTED_MODULE_291__.computeAttributesStride;
wg.webgl.PaletteTexture = _wg_webgl_PaletteTexture_js__WEBPACK_IMPORTED_MODULE_292__["default"];
wg.webgl.PostProcessingPass = _wg_webgl_PostProcessingPass_js__WEBPACK_IMPORTED_MODULE_293__["default"];
wg.webgl.RenderTarget = _wg_webgl_RenderTarget_js__WEBPACK_IMPORTED_MODULE_294__["default"];
wg.webgl.STATIC_DRAW = _wg_webgl_js__WEBPACK_IMPORTED_MODULE_289__.STATIC_DRAW;
wg.webgl.STREAM_DRAW = _wg_webgl_js__WEBPACK_IMPORTED_MODULE_289__.STREAM_DRAW;
wg.webgl.ShaderBuilder = {};
wg.webgl.ShaderBuilder.ShaderBuilder = _wg_webgl_ShaderBuilder_js__WEBPACK_IMPORTED_MODULE_295__.ShaderBuilder;
wg.webgl.ShaderBuilder.parseLiteralStyle = _wg_webgl_ShaderBuilder_js__WEBPACK_IMPORTED_MODULE_295__.parseLiteralStyle;
wg.webgl.TileTexture = _wg_webgl_TileTexture_js__WEBPACK_IMPORTED_MODULE_296__["default"];
wg.webgl.UNSIGNED_BYTE = _wg_webgl_js__WEBPACK_IMPORTED_MODULE_289__.UNSIGNED_BYTE;
wg.webgl.UNSIGNED_INT = _wg_webgl_js__WEBPACK_IMPORTED_MODULE_289__.UNSIGNED_INT;
wg.webgl.UNSIGNED_SHORT = _wg_webgl_js__WEBPACK_IMPORTED_MODULE_289__.UNSIGNED_SHORT;
wg.webgl.getContext = _wg_webgl_js__WEBPACK_IMPORTED_MODULE_289__.getContext;
wg.webgl.getSupportedExtensions = _wg_webgl_js__WEBPACK_IMPORTED_MODULE_289__.getSupportedExtensions;
wg.xml = {};
wg.xml.OBJECT_PROPERTY_NODE_FACTORY = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.OBJECT_PROPERTY_NODE_FACTORY;
wg.xml.XML_SCHEMA_INSTANCE_URI = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.XML_SCHEMA_INSTANCE_URI;
wg.xml.createElementNS = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.createElementNS;
wg.xml.getAllTextContent = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.getAllTextContent;
wg.xml.getAllTextContent_ = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.getAllTextContent_;
wg.xml.getAttributeNS = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.getAttributeNS;
wg.xml.getDocument = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.getDocument;
wg.xml.getXMLSerializer = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.getXMLSerializer;
wg.xml.isDocument = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.isDocument;
wg.xml.makeArrayExtender = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.makeArrayExtender;
wg.xml.makeArrayPusher = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.makeArrayPusher;
wg.xml.makeArraySerializer = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.makeArraySerializer;
wg.xml.makeChildAppender = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.makeChildAppender;
wg.xml.makeObjectPropertyPusher = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.makeObjectPropertyPusher;
wg.xml.makeObjectPropertySetter = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.makeObjectPropertySetter;
wg.xml.makeReplacer = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.makeReplacer;
wg.xml.makeSequence = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.makeSequence;
wg.xml.makeSimpleNodeFactory = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.makeSimpleNodeFactory;
wg.xml.makeStructureNS = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.makeStructureNS;
wg.xml.parse = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.parse;
wg.xml.parseNode = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.parseNode;
wg.xml.pushParseAndPop = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.pushParseAndPop;
wg.xml.pushSerializeAndPop = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.pushSerializeAndPop;
wg.xml.registerDocument = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.registerDocument;
wg.xml.registerXMLSerializer = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.registerXMLSerializer;
wg.xml.serialize = _wg_xml_js__WEBPACK_IMPORTED_MODULE_297__.serialize;
/* harmony default export */ __webpack_exports__["default"] = (wg);

/***/ }),

/***/ "./build/wg/AssertionError.js":
/*!************************************!*\
  !*** ./build/wg/AssertionError.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./build/wg/util.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/AssertionError
 */



/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
 */

var AssertionError =
/** @class */
function (_super) {
  __extends(AssertionError, _super);
  /**
   * @param {number} code Error code.
   */


  function AssertionError(code) {
    var _this = this;

    var path = _util_js__WEBPACK_IMPORTED_MODULE_0__.VERSION === 'latest' ? _util_js__WEBPACK_IMPORTED_MODULE_0__.VERSION : 'v' + _util_js__WEBPACK_IMPORTED_MODULE_0__.VERSION.split('-')[0];
    var message = 'Assertion failed. See https://openlayers.org/en/' + path + '/doc/errors/#' + code + ' for details.';
    _this = _super.call(this, message) || this;
    /**
     * Error code. The meaning of the code can be found on
     * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
     * the version found in the OpenLayers script's header comment if a version
     * other than the latest is used).
     * @type {number}
     * @api
     */

    _this.code = code;
    /**
     * @type {string}
     */

    _this.name = 'AssertionError'; // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40

    _this.message = message;
    return _this;
  }

  return AssertionError;
}(Error);

/* harmony default export */ __webpack_exports__["default"] = (AssertionError);

/***/ }),

/***/ "./build/wg/Collection.js":
/*!********************************!*\
  !*** ./build/wg/Collection.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CollectionEvent": function() { return /* binding */ CollectionEvent; }
/* harmony export */ });
/* harmony import */ var _AssertionError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AssertionError.js */ "./build/wg/AssertionError.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Object.js */ "./build/wg/Object.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CollectionEventType.js */ "./build/wg/CollectionEventType.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Event.js */ "./build/wg/events/Event.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/Collection
 */






/**
 * @enum {string}
 * @private
 */

var Property = {
  LENGTH: 'length'
};
/**
 * @classdesc
 * Events emitted by {@link module:wg/Collection~Collection} instances are instances of this
 * type.
 */

var CollectionEvent =
/** @class */
function (_super) {
  __extends(CollectionEvent, _super);
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {*} [opt_element] Element.
   * @param {number} [opt_index] The index of the added or removed element.
   */


  function CollectionEvent(type, opt_element, opt_index) {
    var _this = _super.call(this, type) || this;
    /**
     * The element that is added to or removed from the collection.
     * @type {*}
     * @api
     */


    _this.element = opt_element;
    /**
     * The index of the added or removed element.
     * @type {number}
     * @api
     */

    _this.index = opt_index;
    return _this;
  }

  return CollectionEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:length', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'add'|'remove', CollectionEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types|
 *     'change:length'|'add'|'remove',Return>} CollectionOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */

/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */

var Collection =
/** @class */
function (_super) {
  __extends(Collection, _super);
  /**
   * @param {Array<T>} [opt_array] Array.
   * @param {Options} [opt_options] Collection options.
   */


  function Collection(opt_array, opt_options) {
    var _this = _super.call(this) || this;
    /***
     * @type {CollectionOnSignature<import("./events").EventsKey>}
     */


    _this.on;
    /***
     * @type {CollectionOnSignature<import("./events").EventsKey>}
     */

    _this.once;
    /***
     * @type {CollectionOnSignature<void>}
     */

    _this.un;
    var options = opt_options || {};
    /**
     * @private
     * @type {boolean}
     */

    _this.unique_ = !!options.unique;
    /**
     * @private
     * @type {!Array<T>}
     */

    _this.array_ = opt_array ? opt_array : [];

    if (_this.unique_) {
      for (var i = 0, ii = _this.array_.length; i < ii; ++i) {
        _this.assertUnique_(_this.array_[i], i);
      }
    }

    _this.updateLength_();

    return _this;
  }
  /**
   * Remove all elements from the collection.
   * @api
   */


  Collection.prototype.clear = function () {
    while (this.getLength() > 0) {
      this.pop();
    }
  };
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */


  Collection.prototype.extend = function (arr) {
    for (var i = 0, ii = arr.length; i < ii; ++i) {
      this.push(arr[i]);
    }

    return this;
  };
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */


  Collection.prototype.forEach = function (f) {
    var array = this.array_;

    for (var i = 0, ii = array.length; i < ii; ++i) {
      f(array[i], i, array);
    }
  };
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */


  Collection.prototype.getArray = function () {
    return this.array_;
  };
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */


  Collection.prototype.item = function (index) {
    return this.array_[index];
  };
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */


  Collection.prototype.getLength = function () {
    return this.get(Property.LENGTH);
  };
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */


  Collection.prototype.insertAt = function (index, elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }

    this.array_.splice(index, 0, elem);
    this.updateLength_();
    this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD, elem, index));
  };
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */


  Collection.prototype.pop = function () {
    return this.removeAt(this.getLength() - 1);
  };
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */


  Collection.prototype.push = function (elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }

    var n = this.getLength();
    this.insertAt(n, elem);
    return this.getLength();
  };
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */


  Collection.prototype.remove = function (elem) {
    var arr = this.array_;

    for (var i = 0, ii = arr.length; i < ii; ++i) {
      if (arr[i] === elem) {
        return this.removeAt(i);
      }
    }

    return undefined;
  };
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */


  Collection.prototype.removeAt = function (index) {
    var prev = this.array_[index];
    this.array_.splice(index, 1);
    this.updateLength_();
    this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE, prev, index));
    return prev;
  };
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */


  Collection.prototype.setAt = function (index, elem) {
    var n = this.getLength();

    if (index < n) {
      if (this.unique_) {
        this.assertUnique_(elem, index);
      }

      var prev = this.array_[index];
      this.array_[index] = elem;
      this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE, prev, index));
      this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD, elem, index));
    } else {
      for (var j = n; j < index; ++j) {
        this.insertAt(j, undefined);
      }

      this.insertAt(index, elem);
    }
  };
  /**
   * @private
   */


  Collection.prototype.updateLength_ = function () {
    this.set(Property.LENGTH, this.array_.length);
  };
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [opt_except] Optional index to ignore.
   */


  Collection.prototype.assertUnique_ = function (elem, opt_except) {
    for (var i = 0, ii = this.array_.length; i < ii; ++i) {
      if (this.array_[i] === elem && i !== opt_except) {
        throw new _AssertionError_js__WEBPACK_IMPORTED_MODULE_2__["default"](58);
      }
    }
  };

  return Collection;
}(_Object_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Collection);

/***/ }),

/***/ "./build/wg/CollectionEventType.js":
/*!*****************************************!*\
  !*** ./build/wg/CollectionEventType.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/CollectionEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when an item is added to the collection.
   * @event module:wg/Collection.CollectionEvent#add
   * @api
   */
  ADD: 'add',

  /**
   * Triggered when an item is removed from the collection.
   * @event module:wg/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: 'remove'
});

/***/ }),

/***/ "./build/wg/DataTile.js":
/*!******************************!*\
  !*** ./build/wg/DataTile.js ***!
  \******************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Tile.js */ "./build/wg/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileState.js */ "./build/wg/TileState.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/DataTile
 */




/**
 * Data that can be used with a DataTile.  For increased browser compatibility, use
 * Uint8Array instead of Uint8ClampedArray where possible.
 * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} Data
 */

/**
 * @typedef {Object} Options
 * @property {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @property {function(): Promise<Data>} loader Data loader.
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @api
 */

var DataTile =
/** @class */
function (_super) {
  __extends(DataTile, _super);
  /**
   * @param {Options} options Tile options.
   */


  function DataTile(options) {
    var _this = this;

    var state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE;
    _this = _super.call(this, options.tileCoord, state, {
      transition: options.transition,
      interpolate: options.interpolate
    }) || this;
    /**
     * @type {function(): Promise<Data>}
     * @private
     */

    _this.loader_ = options.loader;
    /**
     * @type {Data}
     * @private
     */

    _this.data_ = null;
    /**
     * @type {Error}
     * @private
     */

    _this.error_ = null;
    return _this;
  }
  /**
   * Get the data for the tile.
   * @return {Data} Tile data.
   * @api
   */


  DataTile.prototype.getData = function () {
    return this.data_;
  };
  /**
   * Get any loading error.
   * @return {Error} Loading error.
   * @api
   */


  DataTile.prototype.getError = function () {
    return this.error_;
  };
  /**
   * Load not yet loaded URI.
   * @api
   */


  DataTile.prototype.load = function () {
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADING;
    this.changed();
    var self = this;
    this.loader_().then(function (data) {
      self.data_ = data;
      self.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED;
      self.changed();
    }).catch(function (error) {
      self.error_ = error;
      self.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR;
      self.changed();
    });
  };

  return DataTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (DataTile);

/***/ }),

/***/ "./build/wg/Disposable.js":
/*!********************************!*\
  !*** ./build/wg/Disposable.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/Disposable
 */

/**
 * @classdesc
 * Objects that need to clean up after themselves.
 */
var Disposable =
/** @class */
function () {
  function Disposable() {
    /**
     * The object has already been disposed.
     * @type {boolean}
     * @protected
     */
    this.disposed = false;
  }
  /**
   * Clean up.
   */


  Disposable.prototype.dispose = function () {
    if (!this.disposed) {
      this.disposed = true;
      this.disposeInternal();
    }
  };
  /**
   * Extension point for disposable objects.
   * @protected
   */


  Disposable.prototype.disposeInternal = function () {};

  return Disposable;
}();

/* harmony default export */ __webpack_exports__["default"] = (Disposable);

/***/ }),

/***/ "./build/wg/Feature.js":
/*!*****************************!*\
  !*** ./build/wg/Feature.js ***!
  \*****************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStyleFunction": function() { return /* binding */ createStyleFunction; }
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Object.js */ "./build/wg/Object.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events.js */ "./build/wg/events.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/Feature
 */






/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */

/**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:geometry', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types
 *     |'change:geometry', Return>} FeatureOnSignature
 */

/***
 * @template Geometry
 * @typedef {Object<string, *> & { geometry?: Geometry }} ObjectWithGeometry
 */

/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:wg/Object~BaseObject} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'wg/Feature';
 * import Polygon from 'wg/geom/Polygon';
 * import Point from 'wg/geom/Point';
 *
 * var feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon'
 * });
 *
 * // get the polygon geometry
 * var poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * var point = feature.getGeometry();
 * ```
 *
 * @api
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 */

var Feature =
/** @class */
function (_super) {
  __extends(Feature, _super);
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [opt_geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */


  function Feature(opt_geometryOrProperties) {
    var _this = _super.call(this) || this;
    /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */


    _this.on;
    /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */

    _this.once;
    /***
     * @type {FeatureOnSignature<void>}
     */

    _this.un;
    /**
     * @private
     * @type {number|string|undefined}
     */

    _this.id_ = undefined;
    /**
     * @type {string}
     * @private
     */

    _this.geometryName_ = 'geometry';
    /**
     * User provided style.
     * @private
     * @type {import("./style/Style.js").StyleLike}
     */

    _this.style_ = null;
    /**
     * @private
     * @type {import("./style/Style.js").StyleFunction|undefined}
     */

    _this.styleFunction_ = undefined;
    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */

    _this.geometryChangeKey_ = null;

    _this.addChangeListener(_this.geometryName_, _this.handleGeometryChanged_);

    if (opt_geometryOrProperties) {
      if (typeof
      /** @type {?} */
      opt_geometryOrProperties.getSimplifiedGeometry === 'function') {
        var geometry =
        /** @type {Geometry} */
        opt_geometryOrProperties;

        _this.setGeometry(geometry);
      } else {
        /** @type {Object<string, *>} */
        var properties = opt_geometryOrProperties;

        _this.setProperties(properties);
      }
    }

    return _this;
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */


  Feature.prototype.clone = function () {
    var clone =
    /** @type {Feature<Geometry>} */
    new Feature(this.hasProperties() ? this.getProperties() : null);
    clone.setGeometryName(this.getGeometryName());
    var geometry = this.getGeometry();

    if (geometry) {
      clone.setGeometry(
      /** @type {Geometry} */
      geometry.clone());
    }

    var style = this.getStyle();

    if (style) {
      clone.setStyle(style);
    }

    return clone;
  };
  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:wg/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */


  Feature.prototype.getGeometry = function () {
    return (
      /** @type {Geometry|undefined} */
      this.get(this.geometryName_)
    );
  };
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:wg/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */


  Feature.prototype.getId = function () {
    return this.id_;
  };
  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */


  Feature.prototype.getGeometryName = function () {
    return this.geometryName_;
  };
  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:wg/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */


  Feature.prototype.getStyle = function () {
    return this.style_;
  };
  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */


  Feature.prototype.getStyleFunction = function () {
    return this.styleFunction_;
  };
  /**
   * @private
   */


  Feature.prototype.handleGeometryChange_ = function () {
    this.changed();
  };
  /**
   * @private
   */


  Feature.prototype.handleGeometryChanged_ = function () {
    if (this.geometryChangeKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_0__.unlistenByKey)(this.geometryChangeKey_);
      this.geometryChangeKey_ = null;
    }

    var geometry = this.getGeometry();

    if (geometry) {
      this.geometryChangeKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_0__.listen)(geometry, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, this.handleGeometryChange_, this);
    }

    this.changed();
  };
  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:wg/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */


  Feature.prototype.setGeometry = function (geometry) {
    this.set(this.geometryName_, geometry);
  };
  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [opt_style] Style for this feature.
   * @api
   * @fires module:wg/events/Event~BaseEvent#event:change
   */


  Feature.prototype.setStyle = function (opt_style) {
    this.style_ = opt_style;
    this.styleFunction_ = !opt_style ? undefined : createStyleFunction(opt_style);
    this.changed();
  };
  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:wg/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:wg/events/Event~BaseEvent#event:change
   */


  Feature.prototype.setId = function (id) {
    this.id_ = id;
    this.changed();
  };
  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:wg/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */


  Feature.prototype.setGeometryName = function (name) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.geometryName_ = name;
    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.handleGeometryChanged_();
  };

  return Feature;
}(_Object_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of Style or single style objects wrapped
 * in a new feature style function.
 * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {import("./style/Style.js").StyleFunction} A style function.
 */


function createStyleFunction(obj) {
  if (typeof obj === 'function') {
    return obj;
  } else {
    /**
     * @type {Array<import("./style/Style.js").default>}
     */
    var styles_1;

    if (Array.isArray(obj)) {
      styles_1 = obj;
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(typeof
      /** @type {?} */
      obj.getZIndex === 'function', 41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`

      var style =
      /** @type {import("./style/Style.js").default} */
      obj;
      styles_1 = [style];
    }

    return function () {
      return styles_1;
    };
  }
}
/* harmony default export */ __webpack_exports__["default"] = (Feature);

/***/ }),

/***/ "./build/wg/Geolocation.js":
/*!*********************************!*\
  !*** ./build/wg/Geolocation.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Object.js */ "./build/wg/Object.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./build/wg/proj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math.js */ "./build/wg/math.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/Geolocation
 */








/**
 * @enum {string}
 */

var Property = {
  ACCURACY: 'accuracy',
  ACCURACY_GEOMETRY: 'accuracyGeometry',
  ALTITUDE: 'altitude',
  ALTITUDE_ACCURACY: 'altitudeAccuracy',
  HEADING: 'heading',
  POSITION: 'position',
  PROJECTION: 'projection',
  SPEED: 'speed',
  TRACKING: 'tracking',
  TRACKING_OPTIONS: 'trackingOptions'
};
/**
 * @classdesc
 * Events emitted on Geolocation error.
 */

var GeolocationError =
/** @class */
function (_super) {
  __extends(GeolocationError, _super);
  /**
   * @param {GeolocationPositionError} error error object.
   */


  function GeolocationError(error) {
    var _this = _super.call(this, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) || this;
    /**
     * @type {number}
     */


    _this.code = error.code;
    /**
     * @type {string}
     */

    _this.message = error.message;
    return _this;
  }

  return GeolocationError;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @typedef {Object} Options
 * @property {boolean} [tracking=false] Start Tracking right after
 * instantiation.
 * @property {PositionOptions} [trackingOptions] Tracking options.
 * See https://www.w3.org/TR/geolocation-API/#position_options_interface.
 * @property {import("./proj.js").ProjectionLike} [projection] The projection the position
 * is reported in.
 */

/**
 * @typedef {import("./ObjectEventType").Types|'change:accuracy'|'change:accuracyGeometry'|'change:altitude'|
 *    'change:altitudeAccuracy'|'change:heading'|'change:position'|'change:projection'|'change:speed'|'change:tracking'|
 *    'change:trackingOptions'} GeolocationObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<GeolocationObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'error', GeolocationError, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|GeolocationObjectEventTypes|
 *     'error', Return>} GeolocationOnSignature
 */

/**
 * @classdesc
 * Helper class for providing HTML5 Geolocation capabilities.
 * The [Geolocation API](https://www.w3.org/TR/geolocation-API/)
 * is used to locate a user's position.
 *
 * To get notified of position changes, register a listener for the generic
 * `change` event on your instance of {@link module:wg/Geolocation~Geolocation}.
 *
 * Example:
 *
 *     var geolocation = new Geolocation({
 *       // take the projection to use from the map's view
 *       projection: view.getProjection()
 *     });
 *     // listen to changes in position
 *     geolocation.on('change', function(evt) {
 *       window.console.log(geolocation.getPosition());
 *     });
 *
 * @fires module:wg/events/Event~BaseEvent#event:error
 * @api
 */


var Geolocation =
/** @class */
function (_super) {
  __extends(Geolocation, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function Geolocation(opt_options) {
    var _this = _super.call(this) || this;
    /***
     * @type {GeolocationOnSignature<import("./events").EventsKey>}
     */


    _this.on;
    /***
     * @type {GeolocationOnSignature<import("./events").EventsKey>}
     */

    _this.once;
    /***
     * @type {GeolocationOnSignature<void>}
     */

    _this.un;
    var options = opt_options || {};
    /**
     * The unprojected (EPSG:4326) device position.
     * @private
     * @type {?import("./coordinate.js").Coordinate}
     */

    _this.position_ = null;
    /**
     * @private
     * @type {import("./proj.js").TransformFunction}
     */

    _this.transform_ = _proj_js__WEBPACK_IMPORTED_MODULE_0__.identityTransform;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.watchId_ = undefined;

    _this.addChangeListener(Property.PROJECTION, _this.handleProjectionChanged_);

    _this.addChangeListener(Property.TRACKING, _this.handleTrackingChanged_);

    if (options.projection !== undefined) {
      _this.setProjection(options.projection);
    }

    if (options.trackingOptions !== undefined) {
      _this.setTrackingOptions(options.trackingOptions);
    }

    _this.setTracking(options.tracking !== undefined ? options.tracking : false);

    return _this;
  }
  /**
   * Clean up.
   */


  Geolocation.prototype.disposeInternal = function () {
    this.setTracking(false);

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * @private
   */


  Geolocation.prototype.handleProjectionChanged_ = function () {
    var projection = this.getProjection();

    if (projection) {
      this.transform_ = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransformFromProjections)((0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:4326'), projection);

      if (this.position_) {
        this.set(Property.POSITION, this.transform_(this.position_));
      }
    }
  };
  /**
   * @private
   */


  Geolocation.prototype.handleTrackingChanged_ = function () {
    if ('geolocation' in navigator) {
      var tracking = this.getTracking();

      if (tracking && this.watchId_ === undefined) {
        this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions());
      } else if (!tracking && this.watchId_ !== undefined) {
        navigator.geolocation.clearWatch(this.watchId_);
        this.watchId_ = undefined;
      }
    }
  };
  /**
   * @private
   * @param {GeolocationPosition} position position event.
   */


  Geolocation.prototype.positionChange_ = function (position) {
    var coords = position.coords;
    this.set(Property.ACCURACY, coords.accuracy);
    this.set(Property.ALTITUDE, coords.altitude === null ? undefined : coords.altitude);
    this.set(Property.ALTITUDE_ACCURACY, coords.altitudeAccuracy === null ? undefined : coords.altitudeAccuracy);
    this.set(Property.HEADING, coords.heading === null ? undefined : (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.toRadians)(coords.heading));

    if (!this.position_) {
      this.position_ = [coords.longitude, coords.latitude];
    } else {
      this.position_[0] = coords.longitude;
      this.position_[1] = coords.latitude;
    }

    var projectedPosition = this.transform_(this.position_);
    this.set(Property.POSITION, projectedPosition);
    this.set(Property.SPEED, coords.speed === null ? undefined : coords.speed);
    var geometry = (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_4__.circular)(this.position_, coords.accuracy);
    geometry.applyTransform(this.transform_);
    this.set(Property.ACCURACY_GEOMETRY, geometry);
    this.changed();
  };
  /**
   * @private
   * @param {GeolocationPositionError} error error object.
   */


  Geolocation.prototype.positionError_ = function (error) {
    this.dispatchEvent(new GeolocationError(error));
  };
  /**
   * Get the accuracy of the position in meters.
   * @return {number|undefined} The accuracy of the position measurement in
   *     meters.
   * @observable
   * @api
   */


  Geolocation.prototype.getAccuracy = function () {
    return (
      /** @type {number|undefined} */
      this.get(Property.ACCURACY)
    );
  };
  /**
   * Get a geometry of the position accuracy.
   * @return {?import("./geom/Polygon.js").default} A geometry of the position accuracy.
   * @observable
   * @api
   */


  Geolocation.prototype.getAccuracyGeometry = function () {
    return (
      /** @type {?import("./geom/Polygon.js").default} */
      this.get(Property.ACCURACY_GEOMETRY) || null
    );
  };
  /**
   * Get the altitude associated with the position.
   * @return {number|undefined} The altitude of the position in meters above mean
   *     sea level.
   * @observable
   * @api
   */


  Geolocation.prototype.getAltitude = function () {
    return (
      /** @type {number|undefined} */
      this.get(Property.ALTITUDE)
    );
  };
  /**
   * Get the altitude accuracy of the position.
   * @return {number|undefined} The accuracy of the altitude measurement in
   *     meters.
   * @observable
   * @api
   */


  Geolocation.prototype.getAltitudeAccuracy = function () {
    return (
      /** @type {number|undefined} */
      this.get(Property.ALTITUDE_ACCURACY)
    );
  };
  /**
   * Get the heading as radians clockwise from North.
   * Note: depending on the browser, the heading is only defined if the `enableHighAccuracy`
   * is set to `true` in the tracking options.
   * @return {number|undefined} The heading of the device in radians from north.
   * @observable
   * @api
   */


  Geolocation.prototype.getHeading = function () {
    return (
      /** @type {number|undefined} */
      this.get(Property.HEADING)
    );
  };
  /**
   * Get the position of the device.
   * @return {import("./coordinate.js").Coordinate|undefined} The current position of the device reported
   *     in the current projection.
   * @observable
   * @api
   */


  Geolocation.prototype.getPosition = function () {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Property.POSITION)
    );
  };
  /**
   * Get the projection associated with the position.
   * @return {import("./proj/Projection.js").default|undefined} The projection the position is
   *     reported in.
   * @observable
   * @api
   */


  Geolocation.prototype.getProjection = function () {
    return (
      /** @type {import("./proj/Projection.js").default|undefined} */
      this.get(Property.PROJECTION)
    );
  };
  /**
   * Get the speed in meters per second.
   * @return {number|undefined} The instantaneous speed of the device in meters
   *     per second.
   * @observable
   * @api
   */


  Geolocation.prototype.getSpeed = function () {
    return (
      /** @type {number|undefined} */
      this.get(Property.SPEED)
    );
  };
  /**
   * Determine if the device location is being tracked.
   * @return {boolean} The device location is being tracked.
   * @observable
   * @api
   */


  Geolocation.prototype.getTracking = function () {
    return (
      /** @type {boolean} */
      this.get(Property.TRACKING)
    );
  };
  /**
   * Get the tracking options.
   * See https://www.w3.org/TR/geolocation-API/#position-options.
   * @return {PositionOptions|undefined} PositionOptions as defined by
   *     the [HTML5 Geolocation spec
   *     ](https://www.w3.org/TR/geolocation-API/#position_options_interface).
   * @observable
   * @api
   */


  Geolocation.prototype.getTrackingOptions = function () {
    return (
      /** @type {PositionOptions|undefined} */
      this.get(Property.TRACKING_OPTIONS)
    );
  };
  /**
   * Set the projection to use for transforming the coordinates.
   * @param {import("./proj.js").ProjectionLike} projection The projection the position is
   *     reported in.
   * @observable
   * @api
   */


  Geolocation.prototype.setProjection = function (projection) {
    this.set(Property.PROJECTION, (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection));
  };
  /**
   * Enable or disable tracking.
   * @param {boolean} tracking Enable tracking.
   * @observable
   * @api
   */


  Geolocation.prototype.setTracking = function (tracking) {
    this.set(Property.TRACKING, tracking);
  };
  /**
   * Set the tracking options.
   * See http://www.w3.org/TR/geolocation-API/#position-options.
   * @param {PositionOptions} options PositionOptions as defined by the
   *     [HTML5 Geolocation spec
   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).
   * @observable
   * @api
   */


  Geolocation.prototype.setTrackingOptions = function (options) {
    this.set(Property.TRACKING_OPTIONS, options);
  };

  return Geolocation;
}(_Object_js__WEBPACK_IMPORTED_MODULE_5__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Geolocation);

/***/ }),

/***/ "./build/wg/Image.js":
/*!***************************!*\
  !*** ./build/wg/Image.js ***!
  \***************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "listenImage": function() { return /* binding */ listenImage; }
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _ImageBase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ImageBase.js */ "./build/wg/ImageBase.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageState.js */ "./build/wg/ImageState.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./has.js */ "./build/wg/has.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent.js */ "./build/wg/extent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.js */ "./build/wg/events.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/Image
 */








/**
 * A function that takes an {@link module:wg/Image~ImageWrapper} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:wg/Image~ImageWrapper#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(ImageWrapper, string): void} LoadFunction
 * @api
 */

var ImageWrapper =
/** @class */
function (_super) {
  __extends(ImageWrapper, _super);
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {LoadFunction} imageLoadFunction Image load function.
   */


  function ImageWrapper(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
    var _this = _super.call(this, extent, resolution, pixelRatio, _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE) || this;
    /**
     * @private
     * @type {string}
     */


    _this.src_ = src;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
     */

    _this.image_ = new Image();

    if (crossOrigin !== null) {
      _this.image_.crossOrigin = crossOrigin;
    }
    /**
     * @private
     * @type {?function():void}
     */


    _this.unlisten_ = null;
    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */

    _this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE;
    /**
     * @private
     * @type {LoadFunction}
     */

    _this.imageLoadFunction_ = imageLoadFunction;
    return _this;
  }
  /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */


  ImageWrapper.prototype.getImage = function () {
    return this.image_;
  };
  /**
   * Tracks loading or read errors.
   *
   * @private
   */


  ImageWrapper.prototype.handleImageError_ = function () {
    this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR;
    this.unlistenImage_();
    this.changed();
  };
  /**
   * Tracks successful image load.
   *
   * @private
   */


  ImageWrapper.prototype.handleImageLoad_ = function () {
    if (this.resolution === undefined) {
      this.resolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getHeight)(this.extent) / this.image_.height;
    }

    this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED;
    this.unlistenImage_();
    this.changed();
  };
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @api
   */


  ImageWrapper.prototype.load = function () {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE || this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR) {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADING;
      this.changed();
      this.imageLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
  };
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   */


  ImageWrapper.prototype.setImage = function (image) {
    this.image_ = image;
    this.resolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getHeight)(this.extent) / this.image_.height;
  };
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */


  ImageWrapper.prototype.unlistenImage_ = function () {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  };

  return ImageWrapper;
}(_ImageBase_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image element.
 * @param {function():any} loadHandler Load callback function.
 * @param {function():any} errorHandler Error callback function.
 * @return {function():void} Callback to stop listening.
 */


function listenImage(image, loadHandler, errorHandler) {
  var img =
  /** @type {HTMLImageElement} */
  image;
  var listening = true;
  var decoding = false;
  var loaded = false;
  var listenerKeys = [(0,_events_js__WEBPACK_IMPORTED_MODULE_3__.listenOnce)(img, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOAD, function () {
    loaded = true;

    if (!decoding) {
      loadHandler();
    }
  })];

  if (img.src && _has_js__WEBPACK_IMPORTED_MODULE_5__.IMAGE_DECODE) {
    decoding = true;
    img.decode().then(function () {
      if (listening) {
        loadHandler();
      }
    }).catch(function (error) {
      if (listening) {
        if (loaded) {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
  } else {
    listenerKeys.push((0,_events_js__WEBPACK_IMPORTED_MODULE_3__.listenOnce)(img, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR, errorHandler));
  }

  return function unlisten() {
    listening = false;
    listenerKeys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__.unlistenByKey);
  };
}
/* harmony default export */ __webpack_exports__["default"] = (ImageWrapper);

/***/ }),

/***/ "./build/wg/ImageBase.js":
/*!*******************************!*\
  !*** ./build/wg/ImageBase.js ***!
  \*******************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/Target.js */ "./build/wg/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ "./build/wg/util.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/ImageBase
 */





/**
 * @abstract
 */

var ImageBase =
/** @class */
function (_super) {
  __extends(ImageBase, _super);
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default} state State.
   */


  function ImageBase(extent, resolution, pixelRatio, state) {
    var _this = _super.call(this) || this;
    /**
     * @protected
     * @type {import("./extent.js").Extent}
     */


    _this.extent = extent;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = pixelRatio;
    /**
     * @protected
     * @type {number|undefined}
     */

    _this.resolution = resolution;
    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */

    _this.state = state;
    return _this;
  }
  /**
   * @protected
   */


  ImageBase.prototype.changed = function () {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CHANGE);
  };
  /**
   * @return {import("./extent.js").Extent} Extent.
   */


  ImageBase.prototype.getExtent = function () {
    return this.extent;
  };
  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */


  ImageBase.prototype.getImage = function () {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * @return {number} PixelRatio.
   */


  ImageBase.prototype.getPixelRatio = function () {
    return this.pixelRatio_;
  };
  /**
   * @return {number} Resolution.
   */


  ImageBase.prototype.getResolution = function () {
    return (
      /** @type {number} */
      this.resolution
    );
  };
  /**
   * @return {import("./ImageState.js").default} State.
   */


  ImageBase.prototype.getState = function () {
    return this.state;
  };
  /**
   * Load not yet loaded URI.
   * @abstract
   */


  ImageBase.prototype.load = function () {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };

  return ImageBase;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (ImageBase);

/***/ }),

/***/ "./build/wg/ImageCanvas.js":
/*!*********************************!*\
  !*** ./build/wg/ImageCanvas.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ImageBase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageBase.js */ "./build/wg/ImageBase.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageState.js */ "./build/wg/ImageState.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/ImageCanvas
 */




/**
 * A function that is called to trigger asynchronous canvas drawing.  It is
 * called with a "done" callback that should be called when drawing is done.
 * If any error occurs during drawing, the "done" callback should be called with
 * that error.
 *
 * @typedef {function(function(Error=): void): void} Loader
 */

var ImageCanvas =
/** @class */
function (_super) {
  __extends(ImageCanvas, _super);
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {HTMLCanvasElement} canvas Canvas.
   * @param {Loader} [opt_loader] Optional loader function to
   *     support asynchronous canvas drawing.
   */


  function ImageCanvas(extent, resolution, pixelRatio, canvas, opt_loader) {
    var _this = this;

    var state = opt_loader !== undefined ? _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE : _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED;
    _this = _super.call(this, extent, resolution, pixelRatio, state) || this;
    /**
     * Optional canvas loader function.
     * @type {?Loader}
     * @private
     */

    _this.loader_ = opt_loader !== undefined ? opt_loader : null;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.canvas_ = canvas;
    /**
     * @private
     * @type {?Error}
     */

    _this.error_ = null;
    return _this;
  }
  /**
   * Get any error associated with asynchronous rendering.
   * @return {?Error} Any error that occurred during rendering.
   */


  ImageCanvas.prototype.getError = function () {
    return this.error_;
  };
  /**
   * Handle async drawing complete.
   * @param {Error} [err] Any error during drawing.
   * @private
   */


  ImageCanvas.prototype.handleLoad_ = function (err) {
    if (err) {
      this.error_ = err;
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR;
    } else {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED;
    }

    this.changed();
  };
  /**
   * Load not yet loaded URI.
   */


  ImageCanvas.prototype.load = function () {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE) {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADING;
      this.changed();
      this.loader_(this.handleLoad_.bind(this));
    }
  };
  /**
   * @return {HTMLCanvasElement} Canvas element.
   */


  ImageCanvas.prototype.getImage = function () {
    return this.canvas_;
  };

  return ImageCanvas;
}(_ImageBase_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (ImageCanvas);

/***/ }),

/***/ "./build/wg/ImageState.js":
/*!********************************!*\
  !*** ./build/wg/ImageState.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/ImageState
 */

/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
});

/***/ }),

/***/ "./build/wg/ImageTile.js":
/*!*******************************!*\
  !*** ./build/wg/ImageTile.js ***!
  \*******************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Tile.js */ "./build/wg/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileState.js */ "./build/wg/TileState.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom.js */ "./build/wg/dom.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Image.js */ "./build/wg/Image.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/ImageTile
 */







var ImageTile =
/** @class */
function (_super) {
  __extends(ImageTile, _super);
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [opt_options] Tile options.
   */


  function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
    var _this = _super.call(this, tileCoord, state, opt_options) || this;
    /**
     * @private
     * @type {?string}
     */


    _this.crossOrigin_ = crossOrigin;
    /**
     * Image URI
     *
     * @private
     * @type {string}
     */

    _this.src_ = src;
    _this.key = src;
    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */

    _this.image_ = new Image();

    if (crossOrigin !== null) {
      _this.image_.crossOrigin = crossOrigin;
    }
    /**
     * @private
     * @type {?function():void}
     */


    _this.unlisten_ = null;
    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */

    _this.tileLoadFunction_ = tileLoadFunction;
    return _this;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */


  ImageTile.prototype.getImage = function () {
    return this.image_;
  };
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */


  ImageTile.prototype.setImage = function (element) {
    this.image_ = element;
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED;
    this.unlistenImage_();
    this.changed();
  };
  /**
   * Tracks loading or read errors.
   *
   * @private
   */


  ImageTile.prototype.handleImageError_ = function () {
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  };
  /**
   * Tracks successful image load.
   *
   * @private
   */


  ImageTile.prototype.handleImageLoad_ = function () {
    var image =
    /** @type {HTMLImageElement} */
    this.image_;

    if (image.naturalWidth && image.naturalHeight) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED;
    } else {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].EMPTY;
    }

    this.unlistenImage_();
    this.changed();
  };
  /**
   * Load not yet loaded URI.
   * @api
   */


  ImageTile.prototype.load = function () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE;
      this.image_ = new Image();

      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }

    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADING;
      this.changed();
      this.tileLoadFunction_(this, this.src_);
      this.unlisten_ = (0,_Image_js__WEBPACK_IMPORTED_MODULE_1__.listenImage)(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
  };
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */


  ImageTile.prototype.unlistenImage_ = function () {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  };

  return ImageTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */


function getBlankImage() {
  var ctx = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.createCanvasContext2D)(1, 1);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}

/* harmony default export */ __webpack_exports__["default"] = (ImageTile);

/***/ }),

/***/ "./build/wg/Kinetic.js":
/*!*****************************!*\
  !*** ./build/wg/Kinetic.js ***!
  \*****************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/Kinetic
 */

/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */
var Kinetic =
/** @class */
function () {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  function Kinetic(decay, minVelocity, delay) {
    /**
     * @private
     * @type {number}
     */
    this.decay_ = decay;
    /**
     * @private
     * @type {number}
     */

    this.minVelocity_ = minVelocity;
    /**
     * @private
     * @type {number}
     */

    this.delay_ = delay;
    /**
     * @private
     * @type {Array<number>}
     */

    this.points_ = [];
    /**
     * @private
     * @type {number}
     */

    this.angle_ = 0;
    /**
     * @private
     * @type {number}
     */

    this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */


  Kinetic.prototype.begin = function () {
    this.points_.length = 0;
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */


  Kinetic.prototype.update = function (x, y) {
    this.points_.push(x, y, Date.now());
  };
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */


  Kinetic.prototype.end = function () {
    if (this.points_.length < 6) {
      // at least 2 points are required (i.e. there must be at least 6 elements
      // in the array)
      return false;
    }

    var delay = Date.now() - this.delay_;
    var lastIndex = this.points_.length - 3;

    if (this.points_[lastIndex + 2] < delay) {
      // the last tracked point is too old, which means that the user stopped
      // panning before releasing the map
      return false;
    } // get the first point which still falls into the delay time


    var firstIndex = lastIndex - 3;

    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
      firstIndex -= 3;
    }

    var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2]; // we don't want a duration of 0 (divide by zero)
    // we also make sure the user panned for a duration of at least one frame
    // (1/60s) to compute sane displacement values

    if (duration < 1000 / 60) {
      return false;
    }

    var dx = this.points_[lastIndex] - this.points_[firstIndex];
    var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
    this.angle_ = Math.atan2(dy, dx);
    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
    return this.initialVelocity_ > this.minVelocity_;
  };
  /**
   * @return {number} Total distance travelled (pixels).
   */


  Kinetic.prototype.getDistance = function () {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  };
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */


  Kinetic.prototype.getAngle = function () {
    return this.angle_;
  };

  return Kinetic;
}();

/* harmony default export */ __webpack_exports__["default"] = (Kinetic);

/***/ }),

/***/ "./build/wg/Map.js":
/*!*************************!*\
  !*** ./build/wg/Map.js ***!
  \*************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _renderer_Composite_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderer/Composite.js */ "./build/wg/renderer/Composite.js");
/* harmony import */ var _PluggableMap_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PluggableMap.js */ "./build/wg/PluggableMap.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./obj.js */ "./build/wg/obj.js");
/* harmony import */ var _control_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./control.js */ "./build/wg/control.js");
/* harmony import */ var _interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interaction.js */ "./build/wg/interaction.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/Map
 */







/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'wg/Map';
 *     import View from 'wg/View';
 *     import TileLayer from 'wg/layer/Tile';
 *     import OSM from 'wg/source/OSM';
 *
 *     var map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM()
 *         })
 *       ],
 *       target: 'map'
 *     });
 *
 * The above snippet creates a map using a {@link module:wg/layer/Tile~TileLayer} to
 * display {@link module:wg/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:wg/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:wg/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:wg/layer/Group~LayerGroup}
 * is a subclass of {@link module:wg/layer/Base~BaseLayer}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @api
 */

var Map =
/** @class */
function (_super) {
  __extends(Map, _super);
  /**
   * @param {import("./PluggableMap.js").MapOptions} options Map options.
   */


  function Map(options) {
    options = (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options);

    if (!options.controls) {
      options.controls = (0,_control_js__WEBPACK_IMPORTED_MODULE_1__.defaults)();
    }

    if (!options.interactions) {
      options.interactions = (0,_interaction_js__WEBPACK_IMPORTED_MODULE_2__.defaults)({
        onFocusOnly: true
      });
    }

    return _super.call(this, options) || this;
  }

  Map.prototype.createRenderer = function () {
    return new _renderer_Composite_js__WEBPACK_IMPORTED_MODULE_3__["default"](this);
  };

  return Map;
}(_PluggableMap_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Map);

/***/ }),

/***/ "./build/wg/MapBrowserEvent.js":
/*!*************************************!*\
  !*** ./build/wg/MapBrowserEvent.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MapEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MapEvent.js */ "./build/wg/MapEvent.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/MapBrowserEvent
 */



/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:wg/PluggableMap~PluggableMap} for which events trigger a map browser event.
 * @template {UIEvent} EVENT
 */

var MapBrowserEvent =
/** @class */
function (_super) {
  __extends(MapBrowserEvent, _super);
  /**
   * @param {string} type Event type.
   * @param {import("./PluggableMap.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [opt_dragging] Is the map currently being dragged?
   * @param {?import("./PluggableMap.js").FrameState} [opt_frameState] Frame state.
   */


  function MapBrowserEvent(type, map, originalEvent, opt_dragging, opt_frameState) {
    var _this = _super.call(this, type, map, opt_frameState) || this;
    /**
     * The original browser event.
     * @const
     * @type {EVENT}
     * @api
     */


    _this.originalEvent = originalEvent;
    /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {?import("./pixel.js").Pixel}
     */

    _this.pixel_ = null;
    /**
     * The coordinate in the user projection corresponding to the original browser event.
     * @type {?import("./coordinate.js").Coordinate}
     */

    _this.coordinate_ = null;
    /**
     * Indicates if the map is currently being dragged. Only set for
     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
     *
     * @type {boolean}
     * @api
     */

    _this.dragging = opt_dragging !== undefined ? opt_dragging : false;
    return _this;
  }

  Object.defineProperty(MapBrowserEvent.prototype, "pixel", {
    /**
     * The map pixel relative to the viewport corresponding to the original event.
     * @type {import("./pixel.js").Pixel}
     * @api
     */
    get: function get() {
      if (!this.pixel_) {
        this.pixel_ = this.map.getEventPixel(this.originalEvent);
      }

      return this.pixel_;
    },
    set: function set(pixel) {
      this.pixel_ = pixel;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MapBrowserEvent.prototype, "coordinate", {
    /**
     * The coordinate corresponding to the original browser event.  This will be in the user
     * projection if one is set.  Otherwise it will be in the view projection.
     * @type {import("./coordinate.js").Coordinate}
     * @api
     */
    get: function get() {
      if (!this.coordinate_) {
        this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
      }

      return this.coordinate_;
    },
    set: function set(coordinate) {
      this.coordinate_ = coordinate;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */

  MapBrowserEvent.prototype.preventDefault = function () {
    _super.prototype.preventDefault.call(this);

    if ('preventDefault' in this.originalEvent) {
      /** @type {UIEvent} */
      this.originalEvent.preventDefault();
    }
  };
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */


  MapBrowserEvent.prototype.stopPropagation = function () {
    _super.prototype.stopPropagation.call(this);

    if ('stopPropagation' in this.originalEvent) {
      /** @type {UIEvent} */
      this.originalEvent.stopPropagation();
    }
  };

  return MapBrowserEvent;
}(_MapEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (MapBrowserEvent);

/***/ }),

/***/ "./build/wg/MapBrowserEventHandler.js":
/*!********************************************!*\
  !*** ./build/wg/MapBrowserEventHandler.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MapBrowserEvent.js */ "./build/wg/MapBrowserEvent.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MapBrowserEventType.js */ "./build/wg/MapBrowserEventType.js");
/* harmony import */ var _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pointer/EventType.js */ "./build/wg/pointer/EventType.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./events/Target.js */ "./build/wg/events/Target.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./has.js */ "./build/wg/has.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./functions.js */ "./build/wg/functions.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events.js */ "./build/wg/events.js");
/**
 * @module wg/MapBrowserEventHandler
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();










var MapBrowserEventHandler =
/** @class */
function (_super) {
  __extends(MapBrowserEventHandler, _super);
  /**
   * @param {import("./PluggableMap.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */


  function MapBrowserEventHandler(map, moveTolerance) {
    var _this = _super.call(this, map) || this;
    /**
     * This is the element that we will listen to the real events on.
     * @type {import("./PluggableMap.js").default}
     * @private
     */


    _this.map_ = map;
    /**
     * @type {any}
     * @private
     */

    _this.clickTimeoutId_;
    /**
     * Emulate dblclick and singleclick. Will be true when only one pointer is active.
     * @type {boolean}
     */

    _this.emulateClicks_ = false;
    /**
     * @type {boolean}
     * @private
     */

    _this.dragging_ = false;
    /**
     * @type {!Array<import("./events.js").EventsKey>}
     * @private
     */

    _this.dragListenerKeys_ = [];
    /**
     * @type {number}
     * @private
     */

    _this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;
    /**
     * The most recent "down" type event (or null if none have occurred).
     * Set on pointerdown.
     * @type {PointerEvent|null}
     * @private
     */

    _this.down_ = null;

    var element = _this.map_.getViewport();
    /**
     * @type {number}
     * @private
     */


    _this.activePointers_ = 0;
    /**
     * @type {!Object<number, boolean>}
     * @private
     */

    _this.trackedTouches_ = {};
    _this.element_ = element;
    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */

    _this.pointerdownListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_0__.listen)(element, _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN, _this.handlePointerDown_, _this);
    /**
     * @type {PointerEvent}
     * @private
     */

    _this.originalPointerMoveEvent_;
    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */

    _this.relayedListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_0__.listen)(element, _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERMOVE, _this.relayEvent_, _this);
    /**
     * @private
     */

    _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);

    _this.element_.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].TOUCHMOVE, _this.boundHandleTouchMove_, _has_js__WEBPACK_IMPORTED_MODULE_3__.PASSIVE_EVENT_LISTENERS ? {
      passive: false
    } : false);

    return _this;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.emulateClick_ = function (pointerEvent) {
    var newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_4__["default"](_MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLICK, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);

    if (this.clickTimeoutId_ !== undefined) {
      // double-click
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = undefined;
      newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_4__["default"](_MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].DBLCLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);
    } else {
      // click
      this.clickTimeoutId_ = setTimeout(
      /** @this {MapBrowserEventHandler} */
      function () {
        this.clickTimeoutId_ = undefined;
        var newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_4__["default"](_MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].SINGLECLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
      }.bind(this), 250);
    }
  };
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.updateActivePointers_ = function (pointerEvent) {
    var event = pointerEvent;

    if (event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERUP || event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERCANCEL) {
      delete this.trackedTouches_[event.pointerId];
    } else if (event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERDOWN) {
      this.trackedTouches_[event.pointerId] = true;
    }

    this.activePointers_ = Object.keys(this.trackedTouches_).length;
  };
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.handlePointerUp_ = function (pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    var newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_4__["default"](_MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERUP, this.map_, pointerEvent);
    this.dispatchEvent(newEvent); // We emulate click events on left mouse button click, touch contact, and pen
    // contact. isMouseActionButton returns true in these cases (evt.button is set
    // to 0).
    // See http://www.w3.org/TR/pointerevents/#button-states
    // We only fire click, singleclick, and doubleclick if nobody has called
    // event.preventDefault().

    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }

    if (this.activePointers_ === 0) {
      this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_0__.unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
    }
  };
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */


  MapBrowserEventHandler.prototype.isMouseActionButton_ = function (pointerEvent) {
    return pointerEvent.button === 0;
  };
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.handlePointerDown_ = function (pointerEvent) {
    this.emulateClicks_ = this.activePointers_ === 0;
    this.updateActivePointers_(pointerEvent);
    var newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_4__["default"](_MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERDOWN, this.map_, pointerEvent);
    this.dispatchEvent(newEvent); // Store a copy of the down event

    this.down_ =
    /** @type {PointerEvent} */
    {};

    for (var property in pointerEvent) {
      var value = pointerEvent[property];
      this.down_[property] = typeof value === 'function' ? _functions_js__WEBPACK_IMPORTED_MODULE_6__.VOID : value;
    }

    if (this.dragListenerKeys_.length === 0) {
      var doc = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push((0,_events_js__WEBPACK_IMPORTED_MODULE_0__.listen)(doc, _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERMOVE, this.handlePointerMove_, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_0__.listen)(doc, _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERUP, this.handlePointerUp_, this),
      /* Note that the listener for `pointercancel is set up on
       * `pointerEventHandler_` and not `documentPointerEventHandler_` like
       * the `pointerup` and `pointermove` listeners.
       *
       * The reason for this is the following: `TouchSource.vacuumTouches_()`
       * issues `pointercancel` events, when there was no `touchend` for a
       * `touchstart`. Now, let's say a first `touchstart` is registered on
       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
       * But `documentPointerEventHandler_` doesn't know about the first
       * `touchstart`. If there is no `touchend` for the `touchstart`, we can
       * only receive a `touchcancel` from `pointerEventHandler_`, because it is
       * only registered there.
       */
      (0,_events_js__WEBPACK_IMPORTED_MODULE_0__.listen)(this.element_, _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERCANCEL, this.handlePointerUp_, this));

      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
        this.dragListenerKeys_.push((0,_events_js__WEBPACK_IMPORTED_MODULE_0__.listen)(this.element_.getRootNode(), _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERUP, this.handlePointerUp_, this));
      }
    }
  };
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.handlePointerMove_ = function (pointerEvent) {
    // Between pointerdown and pointerup, pointermove events are triggered.
    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
    // moved a significant distance.
    if (this.isMoving_(pointerEvent)) {
      this.dragging_ = true;
      var newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_4__["default"](_MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERDRAG, this.map_, pointerEvent, this.dragging_);
      this.dispatchEvent(newEvent);
    }
  };
  /**
   * Wrap and relay a pointer event.  Note that this requires that the type
   * string for the MapBrowserEvent matches the PointerEvent type.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.relayEvent_ = function (pointerEvent) {
    this.originalPointerMoveEvent_ = pointerEvent;
    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_4__["default"](pointerEvent.type, this.map_, pointerEvent, dragging));
  };
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */


  MapBrowserEventHandler.prototype.handleTouchMove_ = function (event) {
    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
    // may not be initialized yet when we get here on a platform without native pointer events.
    var originalEvent = this.originalPointerMoveEvent_;

    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== 'boolean' || event.cancelable === true)) {
      event.preventDefault();
    }
  };
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */


  MapBrowserEventHandler.prototype.isMoving_ = function (pointerEvent) {
    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  };
  /**
   * Clean up.
   */


  MapBrowserEventHandler.prototype.disposeInternal = function () {
    if (this.relayedListenerKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_0__.unlistenByKey)(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }

    this.element_.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].TOUCHMOVE, this.boundHandleTouchMove_);

    if (this.pointerdownListenerKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_0__.unlistenByKey)(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }

    this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_0__.unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.element_ = null;

    _super.prototype.disposeInternal.call(this);
  };

  return MapBrowserEventHandler;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_7__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (MapBrowserEventHandler);

/***/ }),

/***/ "./build/wg/MapBrowserEventType.js":
/*!*****************************************!*\
  !*** ./build/wg/MapBrowserEventType.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/EventType.js */ "./build/wg/events/EventType.js");
/**
 * @module wg/MapBrowserEventType
 */

/**
 * Constants for event names.
 * @enum {string}
 */

/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:wg/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: 'singleclick',

  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:wg/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK,

  /**
   * A true double click, with no dragging.
   * @event module:wg/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DBLCLICK,

  /**
   * Triggered when a pointer is dragged.
   * @event module:wg/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: 'pointerdrag',

  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:wg/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
});
/***
 * @typedef {'singleclick'|'click'|'dblclick'|'pointerdrag'|'pointermove'} Types
 */

/***/ }),

/***/ "./build/wg/MapEvent.js":
/*!******************************!*\
  !*** ./build/wg/MapEvent.js ***!
  \******************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Event.js */ "./build/wg/events/Event.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/MapEvent
 */



/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:wg/PluggableMap~PluggableMap} for which events trigger a map event.
 */

var MapEvent =
/** @class */
function (_super) {
  __extends(MapEvent, _super);
  /**
   * @param {string} type Event type.
   * @param {import("./PluggableMap.js").default} map Map.
   * @param {?import("./PluggableMap.js").FrameState} [opt_frameState] Frame state.
   */


  function MapEvent(type, map, opt_frameState) {
    var _this = _super.call(this, type) || this;
    /**
     * The map where the event occurred.
     * @type {import("./PluggableMap.js").default}
     * @api
     */


    _this.map = map;
    /**
     * The frame state at the time of the event.
     * @type {?import("./PluggableMap.js").FrameState}
     * @api
     */

    _this.frameState = opt_frameState !== undefined ? opt_frameState : null;
    return _this;
  }

  return MapEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (MapEvent);

/***/ }),

/***/ "./build/wg/MapEventType.js":
/*!**********************************!*\
  !*** ./build/wg/MapEventType.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/MapEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered after a map frame is rendered.
   * @event module:wg/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered when the map starts moving.
   * @event module:wg/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: 'movestart',

  /**
   * Triggered after the map is moved.
   * @event module:wg/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: 'moveend'
});
/***
 * @typedef {'postrender'|'movestart'|'moveend'} Types
 */

/***/ }),

/***/ "./build/wg/MapProperty.js":
/*!*********************************!*\
  !*** ./build/wg/MapProperty.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/MapProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  LAYERGROUP: 'layergroup',
  SIZE: 'size',
  TARGET: 'target',
  VIEW: 'view'
});

/***/ }),

/***/ "./build/wg/Object.js":
/*!****************************!*\
  !*** ./build/wg/Object.js ***!
  \****************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObjectEvent": function() { return /* binding */ ObjectEvent; }
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ObjectEventType.js */ "./build/wg/ObjectEventType.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Observable.js */ "./build/wg/Observable.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./obj.js */ "./build/wg/obj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ "./build/wg/util.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/Object
 */







/**
 * @classdesc
 * Events emitted by {@link module:wg/Object~BaseObject} instances are instances of this type.
 */

var ObjectEvent =
/** @class */
function (_super) {
  __extends(ObjectEvent, _super);
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */


  function ObjectEvent(type, key, oldValue) {
    var _this = _super.call(this, type) || this;
    /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */


    _this.key = key;
    /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */

    _this.oldValue = oldValue;
    return _this;
  }

  return ObjectEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<import("./ObjectEventType").Types, ObjectEvent, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types, Return>} ObjectOnSignature
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:wg/Observable~Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:wg/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:wg/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:wg/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */

var BaseObject =
/** @class */
function (_super) {
  __extends(BaseObject, _super);
  /**
   * @param {Object<string, *>} [opt_values] An object with key-value pairs.
   */


  function BaseObject(opt_values) {
    var _this = _super.call(this) || this;
    /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */


    _this.on;
    /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */

    _this.once;
    /***
     * @type {ObjectOnSignature<void>}
     */

    _this.un; // Call {@link module:wg/util.getUid} to ensure that the order of objects' ids is
    // the same as the order in which they were created.  This also helps to
    // ensure that object properties are always added in the same order, which
    // helps many JavaScript engines generate faster code.

    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(_this);
    /**
     * @private
     * @type {Object<string, *>}
     */

    _this.values_ = null;

    if (opt_values !== undefined) {
      _this.setProperties(opt_values);
    }

    return _this;
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */


  BaseObject.prototype.get = function (key) {
    var value;

    if (this.values_ && this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }

    return value;
  };
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */


  BaseObject.prototype.getKeys = function () {
    return this.values_ && Object.keys(this.values_) || [];
  };
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */


  BaseObject.prototype.getProperties = function () {
    return this.values_ && (0,_obj_js__WEBPACK_IMPORTED_MODULE_2__.assign)({}, this.values_) || {};
  };
  /**
   * @return {boolean} The object has properties.
   */


  BaseObject.prototype.hasProperties = function () {
    return !!this.values_;
  };
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */


  BaseObject.prototype.notify = function (key, oldValue) {
    var eventType;
    eventType = "change:".concat(key);

    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }

    eventType = _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].PROPERTYCHANGE;

    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
  };
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */


  BaseObject.prototype.addChangeListener = function (key, listener) {
    this.addEventListener("change:".concat(key), listener);
  };
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */


  BaseObject.prototype.removeChangeListener = function (key, listener) {
    this.removeEventListener("change:".concat(key), listener);
  };
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [opt_silent] Update without triggering an event.
   * @api
   */


  BaseObject.prototype.set = function (key, value, opt_silent) {
    var values = this.values_ || (this.values_ = {});

    if (opt_silent) {
      values[key] = value;
    } else {
      var oldValue = values[key];
      values[key] = value;

      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  };
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [opt_silent] Update without triggering an event.
   * @api
   */


  BaseObject.prototype.setProperties = function (values, opt_silent) {
    for (var key in values) {
      this.set(key, values[key], opt_silent);
    }
  };
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */


  BaseObject.prototype.applyProperties = function (source) {
    if (!source.values_) {
      return;
    }

    (0,_obj_js__WEBPACK_IMPORTED_MODULE_2__.assign)(this.values_ || (this.values_ = {}), source.values_);
  };
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [opt_silent] Unset without triggering an event.
   * @api
   */


  BaseObject.prototype.unset = function (key, opt_silent) {
    if (this.values_ && key in this.values_) {
      var oldValue = this.values_[key];
      delete this.values_[key];

      if ((0,_obj_js__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(this.values_)) {
        this.values_ = null;
      }

      if (!opt_silent) {
        this.notify(key, oldValue);
      }
    }
  };

  return BaseObject;
}(_Observable_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (BaseObject);

/***/ }),

/***/ "./build/wg/ObjectEventType.js":
/*!*************************************!*\
  !*** ./build/wg/ObjectEventType.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/ObjectEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when a property is changed.
   * @event module:wg/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange'
});
/**
 * @typedef {'propertychange'} Types
 */

/***/ }),

/***/ "./build/wg/Observable.js":
/*!********************************!*\
  !*** ./build/wg/Observable.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unByKey": function() { return /* binding */ unByKey; }
/* harmony export */ });
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/Target.js */ "./build/wg/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./build/wg/events.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/Observable
 */





/***
 * @template {string} Type
 * @template {Event|import("./events/Event.js").default} EventClass
 * @template Return
 * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature
 */

/***
 * @template {string} Type
 * @template Return
 * @typedef {(type: Type[], listener: (event: Event|import("./events/Event").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature
 */

/**
 * @typedef {'change'|'error'} EventTypes
 */

/***
 * @template Return
 * @typedef {OnSignature<EventTypes, import("./events/Event.js").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:wg/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").default
 * @api
 */

var Observable =
/** @class */
function (_super) {
  __extends(Observable, _super);

  function Observable() {
    var _this = _super.call(this) || this;

    _this.on =
    /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    _this.onInternal;
    _this.once =
    /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    _this.onceInternal;
    _this.un =
    /** @type {ObservableOnSignature<void>} */
    _this.unInternal;
    /**
     * @private
     * @type {number}
     */

    _this.revision_ = 0;
    return _this;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */


  Observable.prototype.changed = function () {
    ++this.revision_;
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CHANGE);
  };
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */


  Observable.prototype.getRevision = function () {
    return this.revision_;
  };
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */


  Observable.prototype.onInternal = function (type, listener) {
    if (Array.isArray(type)) {
      var len = type.length;
      var keys = new Array(len);

      for (var i = 0; i < len; ++i) {
        keys[i] = (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(this, type[i], listener);
      }

      return keys;
    } else {
      return (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(this,
      /** @type {string} */
      type, listener);
    }
  };
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */


  Observable.prototype.onceInternal = function (type, listener) {
    var key;

    if (Array.isArray(type)) {
      var len = type.length;
      key = new Array(len);

      for (var i = 0; i < len; ++i) {
        key[i] = (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listenOnce)(this, type[i], listener);
      }
    } else {
      key = (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listenOnce)(this,
      /** @type {string} */
      type, listener);
    }
    /** @type {Object} */


    listener.wg_key = key;
    return key;
  };
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */


  Observable.prototype.unInternal = function (type, listener) {
    var key =
    /** @type {Object} */
    listener.wg_key;

    if (key) {
      unByKey(key);
    } else if (Array.isArray(type)) {
      for (var i = 0, ii = type.length; i < ii; ++i) {
        this.removeEventListener(type[i], listener);
      }
    } else {
      this.removeEventListener(type, listener);
    }
  };

  return Observable;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * Listen for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */


Observable.prototype.on;
/**
 * Listen once for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */

Observable.prototype.once;
/**
 * Unlisten for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @api
 */

Observable.prototype.un;
/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */

function unByKey(key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey)(key[i]);
    }
  } else {
    (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey)(
    /** @type {import("./events.js").EventsKey} */
    key);
  }
}
/* harmony default export */ __webpack_exports__["default"] = (Observable);

/***/ }),

/***/ "./build/wg/Overlay.js":
/*!*****************************!*\
  !*** ./build/wg/Overlay.js ***!
  \*****************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Object.js */ "./build/wg/Object.js");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MapEventType.js */ "./build/wg/MapEventType.js");
/* harmony import */ var _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OverlayPositioning.js */ "./build/wg/OverlayPositioning.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css.js */ "./build/wg/css.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extent.js */ "./build/wg/extent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.js */ "./build/wg/events.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom.js */ "./build/wg/dom.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/Overlay
 */









/**
 * @typedef {Object} Options
 * @property {number|string} [id] Set the overlay id. The overlay id can be used
 * with the {@link module:wg/Map~Map#getOverlayById} method.
 * @property {HTMLElement} [element] The overlay element.
 * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning
 * the overlay. The first element in the
 * array is the horizontal offset. A positive value shifts the overlay right.
 * The second element in the array is the vertical offset. A positive value
 * shifts the overlay down.
 * @property {import("./coordinate.js").Coordinate} [position] The overlay position
 * in map projection.
 * @property {import("./OverlayPositioning.js").default} [positioning='top-left'] Defines how
 * the overlay is actually positioned with respect to its `position` property.
 * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, and `'top-right'`.
 * @property {boolean} [stopEvent=true] Whether event propagation to the map
 * viewport should be stopped. If `true` the overlay is placed in the same
 * container as that of the controls (CSS class name
 * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container
 * with CSS class name specified by the `className` property.
 * @property {boolean} [insertFirst=true] Whether the overlay is inserted first
 * in the overlay container, or appended. If the overlay is placed in the same
 * container as that of the controls (see the `stopEvent` option) you will
 * probably set `insertFirst` to `true` so the overlay is displayed below the
 * controls.
 * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling
 * `setPosition`, so that the overlay is entirely visible in the current viewport?
 * If `true` (deprecated), then `autoPanAnimation` and `autoPanMargin` will be
 * used to determine the panning parameters; if an object is supplied then other
 * parameters are ignored.
 * @property {PanOptions} [autoPanAnimation] The animation options used to pan
 * the overlay into view. This animation is only used when `autoPan` is enabled.
 * A `duration` and `easing` may be provided to customize the animation.
 * Deprecated and ignored if `autoPan` is supplied as an object.
 * @property {number} [autoPanMargin=20] The margin (in pixels) between the
 * overlay and the borders of the map when autopanning. Deprecated and ignored
 * if `autoPan` is supplied as an object.
 * @property {PanIntoViewOptions} [autoPanOptions] The options to use for the
 * autoPan. This is only used when `autoPan` is enabled and has preference over
 * the individual `autoPanMargin` and `autoPanOptions`.
 * @property {string} [className='wg-overlay-container wg-selectable'] CSS class
 * name.
 */

/**
 * @typedef {Object} PanOptions
 * @property {number} [duration=1000] The duration of the animation in
 * milliseconds.
 * @property {function(number):number} [easing] The easing function to use. Can
 * be one from {@link module:wg/easing} or a custom function.
 * Default is {@link module:wg/easing.inAndOut}.
 */

/**
 * @typedef {Object} PanIntoViewOptions
 * @property {PanOptions} [animation={}] The animation parameters for the pan
 * @property {number} [margin=20] The margin (in pixels) between the
 * overlay and the borders of the map when panning into view.
 */

/**
 * @enum {string}
 * @protected
 */

var Property = {
  ELEMENT: 'element',
  MAP: 'map',
  OFFSET: 'offset',
  POSITION: 'position',
  POSITIONING: 'positioning'
};
/**
 * @typedef {import("./ObjectEventType").Types|'change:element'|'change:map'|'change:offset'|'change:position'|
 *   'change:positioning'} OverlayObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<OverlayObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|OverlayObjectEventTypes, Return>} OverlayOnSignature
 */

/**
 * @classdesc
 * An element to be displayed over the map and attached to a single map
 * location.  Like {@link module:wg/control/Control~Control}, Overlays are
 * visible widgets. Unlike Controls, they are not in a fixed position on the
 * screen, but are tied to a geographical coordinate, so panning the map will
 * move an Overlay but not a Control.
 *
 * Example:
 *
 *     import Overlay from 'wg/Overlay';
 *
 *     var popup = new Overlay({
 *       element: document.getElementById('popup')
 *     });
 *     popup.setPosition(coordinate);
 *     map.addOverlay(popup);
 *
 * @api
 */

var Overlay =
/** @class */
function (_super) {
  __extends(Overlay, _super);
  /**
   * @param {Options} options Overlay options.
   */


  function Overlay(options) {
    var _this = _super.call(this) || this;
    /***
     * @type {OverlayOnSignature<import("./events").EventsKey>}
     */


    _this.on;
    /***
     * @type {OverlayOnSignature<import("./events").EventsKey>}
     */

    _this.once;
    /***
     * @type {OverlayOnSignature<void>}
     */

    _this.un;
    /**
     * @protected
     * @type {Options}
     */

    _this.options = options;
    /**
     * @protected
     * @type {number|string|undefined}
     */

    _this.id = options.id;
    /**
     * @protected
     * @type {boolean}
     */

    _this.insertFirst = options.insertFirst !== undefined ? options.insertFirst : true;
    /**
     * @protected
     * @type {boolean}
     */

    _this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;
    /**
     * @protected
     * @type {HTMLElement}
     */

    _this.element = document.createElement('div');
    _this.element.className = options.className !== undefined ? options.className : 'wg-overlay-container ' + _css_js__WEBPACK_IMPORTED_MODULE_0__.CLASS_SELECTABLE;
    _this.element.style.position = 'absolute';
    _this.element.style.pointerEvents = 'auto';
    var autoPan = options.autoPan;

    if (autoPan && 'object' !== _typeof(autoPan)) {
      autoPan = {
        animation: options.autoPanAnimation,
        margin: options.autoPanMargin
      };
    }
    /**
     * @protected
     * @type {PanIntoViewOptions|false}
     */


    _this.autoPan =
    /** @type {PanIntoViewOptions} */
    autoPan || false;
    /**
     * @protected
     * @type {{transform_: string,
     *         visible: boolean}}
     */

    _this.rendered = {
      transform_: '',
      visible: true
    };
    /**
     * @protected
     * @type {?import("./events.js").EventsKey}
     */

    _this.mapPostrenderListenerKey = null;

    _this.addChangeListener(Property.ELEMENT, _this.handleElementChanged);

    _this.addChangeListener(Property.MAP, _this.handleMapChanged);

    _this.addChangeListener(Property.OFFSET, _this.handleOffsetChanged);

    _this.addChangeListener(Property.POSITION, _this.handlePositionChanged);

    _this.addChangeListener(Property.POSITIONING, _this.handlePositioningChanged);

    if (options.element !== undefined) {
      _this.setElement(options.element);
    }

    _this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);

    _this.setPositioning(options.positioning !== undefined ?
    /** @type {import("./OverlayPositioning.js").default} */
    options.positioning : _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_1__["default"].TOP_LEFT);

    if (options.position !== undefined) {
      _this.setPosition(options.position);
    }

    return _this;
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */


  Overlay.prototype.getElement = function () {
    return (
      /** @type {HTMLElement|undefined} */
      this.get(Property.ELEMENT)
    );
  };
  /**
   * Get the overlay identifier which is set on constructor.
   * @return {number|string|undefined} Id.
   * @api
   */


  Overlay.prototype.getId = function () {
    return this.id;
  };
  /**
   * Get the map associated with this overlay.
   * @return {import("./PluggableMap.js").default|null} The map that the
   * overlay is part of.
   * @observable
   * @api
   */


  Overlay.prototype.getMap = function () {
    return (
      /** @type {import("./PluggableMap.js").default|null} */
      this.get(Property.MAP) || null
    );
  };
  /**
   * Get the offset of this overlay.
   * @return {Array<number>} The offset.
   * @observable
   * @api
   */


  Overlay.prototype.getOffset = function () {
    return (
      /** @type {Array<number>} */
      this.get(Property.OFFSET)
    );
  };
  /**
   * Get the current position of this overlay.
   * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
   *     anchored at.
   * @observable
   * @api
   */


  Overlay.prototype.getPosition = function () {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Property.POSITION)
    );
  };
  /**
   * Get the current positioning of this overlay.
   * @return {import("./OverlayPositioning.js").default} How the overlay is positioned
   *     relative to its point on the map.
   * @observable
   * @api
   */


  Overlay.prototype.getPositioning = function () {
    return (
      /** @type {import("./OverlayPositioning.js").default} */
      this.get(Property.POSITIONING)
    );
  };
  /**
   * @protected
   */


  Overlay.prototype.handleElementChanged = function () {
    (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.removeChildren)(this.element);
    var element = this.getElement();

    if (element) {
      this.element.appendChild(element);
    }
  };
  /**
   * @protected
   */


  Overlay.prototype.handleMapChanged = function () {
    if (this.mapPostrenderListenerKey) {
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.removeNode)(this.element);
      (0,_events_js__WEBPACK_IMPORTED_MODULE_3__.unlistenByKey)(this.mapPostrenderListenerKey);
      this.mapPostrenderListenerKey = null;
    }

    var map = this.getMap();

    if (map) {
      this.mapPostrenderListenerKey = (0,_events_js__WEBPACK_IMPORTED_MODULE_3__.listen)(map, _MapEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POSTRENDER, this.render, this);
      this.updatePixelPosition();
      var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();

      if (this.insertFirst) {
        container.insertBefore(this.element, container.childNodes[0] || null);
      } else {
        container.appendChild(this.element);
      }

      this.performAutoPan();
    }
  };
  /**
   * @protected
   */


  Overlay.prototype.render = function () {
    this.updatePixelPosition();
  };
  /**
   * @protected
   */


  Overlay.prototype.handleOffsetChanged = function () {
    this.updatePixelPosition();
  };
  /**
   * @protected
   */


  Overlay.prototype.handlePositionChanged = function () {
    this.updatePixelPosition();
    this.performAutoPan();
  };
  /**
   * @protected
   */


  Overlay.prototype.handlePositioningChanged = function () {
    this.updatePixelPosition();
  };
  /**
   * Set the DOM element to be associated with this overlay.
   * @param {HTMLElement|undefined} element The Element containing the overlay.
   * @observable
   * @api
   */


  Overlay.prototype.setElement = function (element) {
    this.set(Property.ELEMENT, element);
  };
  /**
   * Set the map to be associated with this overlay.
   * @param {import("./PluggableMap.js").default|null} map The map that the
   * overlay is part of. Pass `null` to just remove the overlay from the current map.
   * @observable
   * @api
   */


  Overlay.prototype.setMap = function (map) {
    this.set(Property.MAP, map);
  };
  /**
   * Set the offset for this overlay.
   * @param {Array<number>} offset Offset.
   * @observable
   * @api
   */


  Overlay.prototype.setOffset = function (offset) {
    this.set(Property.OFFSET, offset);
  };
  /**
   * Set the position for this overlay. If the position is `undefined` the
   * overlay is hidden.
   * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
   *     is anchored at.
   * @observable
   * @api
   */


  Overlay.prototype.setPosition = function (position) {
    this.set(Property.POSITION, position);
  };
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary) using the configured autoPan parameters
   * @protected
   */


  Overlay.prototype.performAutoPan = function () {
    if (this.autoPan) {
      this.panIntoView(this.autoPan);
    }
  };
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary).
   * @param {PanIntoViewOptions} [opt_panIntoViewOptions] Options for the pan action
   * @api
   */


  Overlay.prototype.panIntoView = function (opt_panIntoViewOptions) {
    var map = this.getMap();

    if (!map || !map.getTargetElement() || !this.get(Property.POSITION)) {
      return;
    }

    var mapRect = this.getRect(map.getTargetElement(), map.getSize());
    var element = this.getElement();
    var overlayRect = this.getRect(element, [(0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.outerWidth)(element), (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.outerHeight)(element)]);
    var panIntoViewOptions = opt_panIntoViewOptions || {};
    var myMargin = panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;

    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.containsExtent)(mapRect, overlayRect)) {
      // the overlay is not completely inside the viewport, so pan the map
      var offsetLeft = overlayRect[0] - mapRect[0];
      var offsetRight = mapRect[2] - overlayRect[2];
      var offsetTop = overlayRect[1] - mapRect[1];
      var offsetBottom = mapRect[3] - overlayRect[3];
      var delta = [0, 0];

      if (offsetLeft < 0) {
        // move map to the left
        delta[0] = offsetLeft - myMargin;
      } else if (offsetRight < 0) {
        // move map to the right
        delta[0] = Math.abs(offsetRight) + myMargin;
      }

      if (offsetTop < 0) {
        // move map up
        delta[1] = offsetTop - myMargin;
      } else if (offsetBottom < 0) {
        // move map down
        delta[1] = Math.abs(offsetBottom) + myMargin;
      }

      if (delta[0] !== 0 || delta[1] !== 0) {
        var center =
        /** @type {import("./coordinate.js").Coordinate} */
        map.getView().getCenterInternal();
        var centerPx = map.getPixelFromCoordinateInternal(center);

        if (!centerPx) {
          return;
        }

        var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
        var panOptions = panIntoViewOptions.animation || {};
        map.getView().animateInternal({
          center: map.getCoordinateFromPixelInternal(newCenterPx),
          duration: panOptions.duration,
          easing: panOptions.easing
        });
      }
    }
  };
  /**
   * Get the extent of an element relative to the document
   * @param {HTMLElement} element The element.
   * @param {import("./size.js").Size} size The size of the element.
   * @return {import("./extent.js").Extent} The extent.
   * @protected
   */


  Overlay.prototype.getRect = function (element, size) {
    var box = element.getBoundingClientRect();
    var offsetX = box.left + window.pageXOffset;
    var offsetY = box.top + window.pageYOffset;
    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
  };
  /**
   * Set the positioning for this overlay.
   * @param {import("./OverlayPositioning.js").default} positioning how the overlay is
   *     positioned relative to its point on the map.
   * @observable
   * @api
   */


  Overlay.prototype.setPositioning = function (positioning) {
    this.set(Property.POSITIONING, positioning);
  };
  /**
   * Modify the visibility of the element.
   * @param {boolean} visible Element visibility.
   * @protected
   */


  Overlay.prototype.setVisible = function (visible) {
    if (this.rendered.visible !== visible) {
      this.element.style.display = visible ? '' : 'none';
      this.rendered.visible = visible;
    }
  };
  /**
   * Update pixel position.
   * @protected
   */


  Overlay.prototype.updatePixelPosition = function () {
    var map = this.getMap();
    var position = this.getPosition();

    if (!map || !map.isRendered() || !position) {
      this.setVisible(false);
      return;
    }

    var pixel = map.getPixelFromCoordinate(position);
    var mapSize = map.getSize();
    this.updateRenderedPosition(pixel, mapSize);
  };
  /**
   * @param {import("./pixel.js").Pixel} pixel The pixel location.
   * @param {import("./size.js").Size|undefined} mapSize The map size.
   * @protected
   */


  Overlay.prototype.updateRenderedPosition = function (pixel, mapSize) {
    var style = this.element.style;
    var offset = this.getOffset();
    var positioning = this.getPositioning();
    this.setVisible(true);
    var x = Math.round(pixel[0] + offset[0]) + 'px';
    var y = Math.round(pixel[1] + offset[1]) + 'px';
    var posX = '0%';
    var posY = '0%';

    if (positioning == _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_RIGHT || positioning == _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_1__["default"].CENTER_RIGHT || positioning == _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_1__["default"].TOP_RIGHT) {
      posX = '-100%';
    } else if (positioning == _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_CENTER || positioning == _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_1__["default"].CENTER_CENTER || positioning == _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_1__["default"].TOP_CENTER) {
      posX = '-50%';
    }

    if (positioning == _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_LEFT || positioning == _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_CENTER || positioning == _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_RIGHT) {
      posY = '-100%';
    } else if (positioning == _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_1__["default"].CENTER_LEFT || positioning == _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_1__["default"].CENTER_CENTER || positioning == _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_1__["default"].CENTER_RIGHT) {
      posY = '-50%';
    }

    var transform = "translate(".concat(posX, ", ").concat(posY, ") translate(").concat(x, ", ").concat(y, ")");

    if (this.rendered.transform_ != transform) {
      this.rendered.transform_ = transform;
      style.transform = transform; // @ts-ignore IE9

      style.msTransform = transform;
    }
  };
  /**
   * returns the options this Overlay has been created with
   * @return {Options} overlay options
   */


  Overlay.prototype.getOptions = function () {
    return this.options;
  };

  return Overlay;
}(_Object_js__WEBPACK_IMPORTED_MODULE_6__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Overlay);

/***/ }),

/***/ "./build/wg/OverlayPositioning.js":
/*!****************************************!*\
  !*** ./build/wg/OverlayPositioning.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/OverlayPositioning
 */

/**
 * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, `'top-right'`
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_CENTER: 'bottom-center',
  BOTTOM_RIGHT: 'bottom-right',
  CENTER_LEFT: 'center-left',
  CENTER_CENTER: 'center-center',
  CENTER_RIGHT: 'center-right',
  TOP_LEFT: 'top-left',
  TOP_CENTER: 'top-center',
  TOP_RIGHT: 'top-right'
});

/***/ }),

/***/ "./build/wg/PluggableMap.js":
/*!**********************************!*\
  !*** ./build/wg/PluggableMap.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./Object.js */ "./build/wg/Object.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Collection.js */ "./build/wg/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./CollectionEventType.js */ "./build/wg/CollectionEventType.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layer/Layer.js */ "./build/wg/layer/Layer.js");
/* harmony import */ var _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layer/Group.js */ "./build/wg/layer/Group.js");
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./MapBrowserEvent.js */ "./build/wg/MapBrowserEvent.js");
/* harmony import */ var _MapBrowserEventHandler_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./MapBrowserEventHandler.js */ "./build/wg/MapBrowserEventHandler.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./MapBrowserEventType.js */ "./build/wg/MapBrowserEventType.js");
/* harmony import */ var _MapEvent_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./MapEvent.js */ "./build/wg/MapEvent.js");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./MapEventType.js */ "./build/wg/MapEventType.js");
/* harmony import */ var _MapProperty_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MapProperty.js */ "./build/wg/MapProperty.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./ObjectEventType.js */ "./build/wg/ObjectEventType.js");
/* harmony import */ var _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./pointer/EventType.js */ "./build/wg/pointer/EventType.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./render/EventType.js */ "./build/wg/render/EventType.js");
/* harmony import */ var _TileQueue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TileQueue.js */ "./build/wg/TileQueue.js");
/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./View.js */ "./build/wg/View.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ViewHint.js */ "./build/wg/ViewHint.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./has.js */ "./build/wg/has.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./functions.js */ "./build/wg/functions.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transform.js */ "./build/wg/transform.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./extent.js */ "./build/wg/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./build/wg/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./util.js */ "./build/wg/util.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./size.js */ "./build/wg/size.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./events.js */ "./build/wg/events.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./dom.js */ "./build/wg/dom.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/PluggableMap
 */






























/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 * @typedef {Object} FrameState
 * @property {number} pixelRatio The pixel ratio of the frame.
 * @property {number} time The time when rendering of the frame was requested.
 * @property {import("./View.js").State} viewState The state of the current view.
 * @property {boolean} animate Animate.
 * @property {import("./transform.js").Transform} coordinateToPixelTransform CoordinateToPixelTransform.
 * @property {import("rbush").default} declutterTree DeclutterTree.
 * @property {null|import("./extent.js").Extent} extent Extent.
 * @property {import("./extent.js").Extent} [nextExtent] Next extent during an animation series.
 * @property {number} index Index.
 * @property {Array<import("./layer/Layer.js").State>} layerStatesArray LayerStatesArray.
 * @property {number} layerIndex LayerIndex.
 * @property {import("./transform.js").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.
 * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.
 * @property {import("./size.js").Size} size Size.
 * @property {TileQueue} tileQueue TileQueue.
 * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.
 * @property {Array<number>} viewHints ViewHints.
 * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.
 * @property {string} mapId The id of the map.
 * @property {Object<string, boolean>} renderTargets Identifiers of previously rendered elements.
 */

/**
 * @typedef {function(PluggableMap, ?FrameState): any} PostRenderFunction
 */

/**
 * @typedef {Object} AtPixelOptions
 * @property {undefined|function(import("./layer/Layer.js").default<import("./source/Source").default>): boolean} [layerFilter] Layer filter
 * function. The filter function will receive one argument, the
 * {@link module:wg/layer/Layer~Layer layer-candidate} and it should return a boolean value.
 * Only layers which are visible and for which this function returns `true`
 * will be tested for features. By default, all visible layers will be tested.
 * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels
 * inside the radius around the given position will be checked for features.
 * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for for wrapped geometries inside the range of
 *   +/- 1 world width. Works only if a projection is used that can be wrapped.
 */

/**
 * @typedef {Object} MapOptionsInternal
 * @property {Collection<import("./control/Control.js").default>} [controls] Controls.
 * @property {Collection<import("./interaction/Interaction.js").default>} [interactions] Interactions.
 * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.
 * @property {Collection<import("./Overlay.js").default>} overlays Overlays.
 * @property {Object<string, *>} values Values.
 */

/**
 * @typedef {import("./ObjectEventType").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<MapObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *    import("./Observable").OnSignature<import("./MapBrowserEventType").Types, import("./MapBrowserEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./MapEventType").Types, import("./MapEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./render/EventType").MapRenderEventTypes, import("./render/Event").default, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|MapObjectEventTypes|
 *      import("./MapBrowserEventType").Types|import("./MapEventType").Types|
 *      import("./render/EventType").MapRenderEventTypes, Return>} PluggableMapOnSignature
 */

/**
 * Object literal with config options for the map.
 * @typedef {Object} MapOptions
 * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
 * Controls initially added to the map. If not specified,
 * {@link module:wg/control.defaults} is used.
 * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
 * physical pixels and device-independent pixels (dips) on the device.
 * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
 * Interactions that are initially added to the map. If not specified,
 * {@link module:wg/interaction.defaults} is used.
 * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
 * listen to keyboard events on. This determines when the `KeyboardPan` and
 * `KeyboardZoom` interactions trigger. For example, if this option is set to
 * `document` the keyboard interactions will always trigger. If this option is
 * not specified, the element the library listens to keyboard events on is the
 * map target (i.e. the user-provided div for the map). If this is not
 * `document`, the target element needs to be focused for key events to be
 * emitted, requiring that the target element has a `tabindex` attribute.
 * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
 * Layers. If this is not defined, a map with no layers will be rendered. Note
 * that layers are rendered in the order supplied, so if you want, for example,
 * a vector layer to appear on top of a tile layer, it must come after the tile
 * layer.
 * @property {number} [maxTilesLoading=16] Maximum number tiles to load
 * simultaneously.
 * @property {number} [moveTolerance=1] The minimum distance in pixels the
 * cursor must move to be detected as a map move event instead of a click.
 * Increasing this value can make it easier to click on the map.
 * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
 * Overlays initially added to the map. By default, no overlays are added.
 * @property {HTMLElement|string} [target] The container for the map, either the
 * element itself or the `id` of the element. If not specified at construction
 * time, {@link module:wg/Map~Map#setTarget} must be called for the map to be
 * rendered. If passed by element, the container can be in a secondary document.
 * @property {View|Promise<import("./View.js").ViewOptions>} [view] The map's view.  No layer sources will be
 * fetched unless this is specified at construction time or through
 * {@link module:wg/Map~Map#setView}.
 */

/**
 * @param {import("./layer/Base.js").default} layer Layer.
 */

function removeLayerMapProperty(layer) {
  if (layer instanceof _layer_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
    layer.setMapInternal(null);
    return;
  }

  if (layer instanceof _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    layer.getLayers().forEach(removeLayerMapProperty);
  }
}
/**
 * @param {import("./layer/Base.js").default} layer Layer.
 * @param {PluggableMap} map Map.
 */


function setLayerMapProperty(layer, map) {
  if (layer instanceof _layer_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
    layer.setMapInternal(map);
    return;
  }

  if (layer instanceof _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    var layers = layer.getLayers().getArray();

    for (var i = 0, ii = layers.length; i < ii; ++i) {
      setLayerMapProperty(layers[i], map);
    }
  }
}
/**
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires import("./render/Event.js").default#precompose
 * @fires import("./render/Event.js").default#postcompose
 * @fires import("./render/Event.js").default#rendercomplete
 * @api
 */


var PluggableMap =
/** @class */
function (_super) {
  __extends(PluggableMap, _super);
  /**
   * @param {MapOptions} options Map options.
   */


  function PluggableMap(options) {
    var _this = _super.call(this) || this;
    /***
     * @type {PluggableMapOnSignature<import("./events").EventsKey>}
     */


    _this.on;
    /***
     * @type {PluggableMapOnSignature<import("./events").EventsKey>}
     */

    _this.once;
    /***
     * @type {PluggableMapOnSignature<void>}
     */

    _this.un;
    var optionsInternal = createOptionsInternal(options);
    /**
     * @private
     * @type {boolean}
     */

    _this.renderComplete_;
    /** @private */

    _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);
    /**
     * @type {number}
     * @private
     */

    _this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : _has_js__WEBPACK_IMPORTED_MODULE_3__.DEVICE_PIXEL_RATIO;
    /**
     * @private
     * @type {*}
     */

    _this.postRenderTimeoutHandle_;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.animationDelayKey_;
    /**
     * @private
     */

    _this.animationDelay_ =
    /** @this {PluggableMap} */
    function () {
      this.animationDelayKey_ = undefined;
      this.renderFrame_(Date.now());
    }.bind(_this);
    /**
     * @private
     * @type {import("./transform.js").Transform}
     */


    _this.coordinateToPixelTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.create)();
    /**
     * @private
     * @type {import("./transform.js").Transform}
     */

    _this.pixelToCoordinateTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.create)();
    /**
     * @private
     * @type {number}
     */

    _this.frameIndex_ = 0;
    /**
     * @private
     * @type {?FrameState}
     */

    _this.frameState_ = null;
    /**
     * The extent at the previous 'moveend' event.
     * @private
     * @type {import("./extent.js").Extent}
     */

    _this.previousExtent_ = null;
    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */

    _this.viewPropertyListenerKey_ = null;
    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */

    _this.viewChangeListenerKey_ = null;
    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */

    _this.layerGroupPropertyListenerKeys_ = null;
    /**
     * @private
     * @type {!HTMLElement}
     */

    _this.viewport_ = document.createElement('div');
    _this.viewport_.className = 'wg-viewport' + ('ontouchstart' in window ? ' wg-touch' : '');
    _this.viewport_.style.position = 'relative';
    _this.viewport_.style.overflow = 'hidden';
    _this.viewport_.style.width = '100%';
    _this.viewport_.style.height = '100%';
    /**
     * @private
     * @type {!HTMLElement}
     */

    _this.overlayContainer_ = document.createElement('div');
    _this.overlayContainer_.style.position = 'absolute';
    _this.overlayContainer_.style.zIndex = '0';
    _this.overlayContainer_.style.width = '100%';
    _this.overlayContainer_.style.height = '100%';
    _this.overlayContainer_.style.pointerEvents = 'none';
    _this.overlayContainer_.className = 'wg-overlaycontainer';

    _this.viewport_.appendChild(_this.overlayContainer_);
    /**
     * @private
     * @type {!HTMLElement}
     */


    _this.overlayContainerStopEvent_ = document.createElement('div');
    _this.overlayContainerStopEvent_.style.position = 'absolute';
    _this.overlayContainerStopEvent_.style.zIndex = '0';
    _this.overlayContainerStopEvent_.style.width = '100%';
    _this.overlayContainerStopEvent_.style.height = '100%';
    _this.overlayContainerStopEvent_.style.pointerEvents = 'none';
    _this.overlayContainerStopEvent_.className = 'wg-overlaycontainer-stopevent';

    _this.viewport_.appendChild(_this.overlayContainerStopEvent_);
    /**
     * @private
     * @type {MapBrowserEventHandler}
     */


    _this.mapBrowserEventHandler_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.moveTolerance_ = options.moveTolerance;
    /**
     * @private
     * @type {HTMLElement|Document}
     */

    _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */

    _this.targetChangeHandlerKeys_ = null;
    /**
     * @type {Collection<import("./control/Control.js").default>}
     * @protected
     */

    _this.controls = optionsInternal.controls || new _Collection_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
    /**
     * @type {Collection<import("./interaction/Interaction.js").default>}
     * @protected
     */

    _this.interactions = optionsInternal.interactions || new _Collection_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
    /**
     * @type {Collection<import("./Overlay.js").default>}
     * @private
     */

    _this.overlays_ = optionsInternal.overlays;
    /**
     * A lookup of overlays by id.
     * @private
     * @type {Object<string, import("./Overlay.js").default>}
     */

    _this.overlayIdIndex_ = {};
    /**
     * @type {import("./renderer/Map.js").default|null}
     * @private
     */

    _this.renderer_ = null;
    /**
     * @private
     * @type {!Array<PostRenderFunction>}
     */

    _this.postRenderFunctions_ = [];
    /**
     * @private
     * @type {TileQueue}
     */

    _this.tileQueue_ = new _TileQueue_js__WEBPACK_IMPORTED_MODULE_6__["default"](_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));

    _this.addChangeListener(_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].LAYERGROUP, _this.handleLayerGroupChanged_);

    _this.addChangeListener(_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].VIEW, _this.handleViewChanged_);

    _this.addChangeListener(_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].SIZE, _this.handleSizeChanged_);

    _this.addChangeListener(_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].TARGET, _this.handleTargetChanged_); // setProperties will trigger the rendering of the map if the map
    // is "defined" already.


    _this.setProperties(optionsInternal.values);

    var map = _this;

    if (options.view && !(options.view instanceof _View_js__WEBPACK_IMPORTED_MODULE_8__["default"])) {
      options.view.then(function (viewOptions) {
        map.setView(new _View_js__WEBPACK_IMPORTED_MODULE_8__["default"](viewOptions));
      });
    }

    _this.controls.addEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADD,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(this);
    }.bind(_this));

    _this.controls.addEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].REMOVE,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(null);
    }.bind(_this));

    _this.interactions.addEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADD,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(this);
    }.bind(_this));

    _this.interactions.addEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].REMOVE,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(null);
    }.bind(_this));

    _this.overlays_.addEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADD,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      this.addOverlayInternal_(
      /** @type {import("./Overlay.js").default} */
      event.element);
    }.bind(_this));

    _this.overlays_.addEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].REMOVE,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      var overlay =
      /** @type {import("./Overlay.js").default} */
      event.element;
      var id = overlay.getId();

      if (id !== undefined) {
        delete this.overlayIdIndex_[id.toString()];
      }

      event.element.setMap(null);
    }.bind(_this));

    _this.controls.forEach(
    /**
     * @param {import("./control/Control.js").default} control Control.
     * @this {PluggableMap}
     */
    function (control) {
      control.setMap(this);
    }.bind(_this));

    _this.interactions.forEach(
    /**
     * @param {import("./interaction/Interaction.js").default} interaction Interaction.
     * @this {PluggableMap}
     */
    function (interaction) {
      interaction.setMap(this);
    }.bind(_this));

    _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));

    return _this;
  }
  /**
   * @abstract
   * @return {import("./renderer/Map.js").default} The map renderer
   */


  PluggableMap.prototype.createRenderer = function () {
    throw new Error('Use a map type that has a createRenderer method');
  };
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */


  PluggableMap.prototype.addControl = function (control) {
    this.getControls().push(control);
  };
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteraction()` and the methods
   * available on {@link module:wg/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */


  PluggableMap.prototype.addInteraction = function (interaction) {
    this.getInteractions().push(interaction);
  };
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:wg/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */


  PluggableMap.prototype.addLayer = function (layer) {
    var layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  };
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */


  PluggableMap.prototype.handleLayerAdd_ = function (event) {
    setLayerMapProperty(event.layer, this);
  };
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */


  PluggableMap.prototype.addOverlay = function (overlay) {
    this.getOverlays().push(overlay);
  };
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */


  PluggableMap.prototype.addOverlayInternal_ = function (overlay) {
    var id = overlay.getId();

    if (id !== undefined) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }

    overlay.setMap(this);
  };
  /**
   *
   * Clean up.
   */


  PluggableMap.prototype.disposeInternal = function () {
    this.setTarget(null);

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `opt_options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:wg/Feature~Feature feature} or
   *     {@link module:wg/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:wg/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [opt_options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */


  PluggableMap.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }

    var coordinate = this.getCoordinateFromPixelInternal(pixel);
    opt_options = opt_options !== undefined ? opt_options : {};
    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;
    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functions_js__WEBPACK_IMPORTED_MODULE_10__.TRUE;
    var checkWrapped = opt_options.checkWrapped !== false;
    return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
  };
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [opt_options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */


  PluggableMap.prototype.getFeaturesAtPixel = function (pixel, opt_options) {
    var features = [];
    this.forEachFeatureAtPixel(pixel, function (feature) {
      features.push(feature);
    }, opt_options);
    return features;
  };
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */


  PluggableMap.prototype.getAllLayers = function () {
    var layers = [];

    function addLayersFrom(layerGroup) {
      layerGroup.forEach(function (layer) {
        if (layer instanceof _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          addLayersFrom(layer.getLayers());
        } else {
          layers.push(layer);
        }
      });
    }

    addLayersFrom(this.getLayers());
    return layers;
  };
  /**
   * Please the `layer.getData()` method for {@link module:wg/layer/Tile~TileLayer#getData tile layers} or
   * {@link module:wg/layer/Image~ImageLayer#getData image layers} instead of using this method.
   *
   * Detect layers that have a color value at a pixel on the viewport, and
   * execute a callback with each matching layer. Layers included in the
   * detection can be configured through `opt_layerFilter`.
   *
   * Note: In maps with more than one layer, this method will typically return pixel data
   * representing the composed image of all layers visible at the given pixel – because layers
   * will generally share the same rendering context.  To force layers to render separately, and
   * to get pixel data representing only one layer at a time, you can assign each layer a unique
   * `className` in its constructor.
   *
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(this: S, import("./layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback
   *     Layer callback. This callback will receive two arguments: first is the
   *     {@link module:wg/layer/Layer~Layer layer}, second argument is an array representing
   *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
   *     that do not currently support this argument. To stop detection, callback
   *     functions can return a truthy value.
   * @param {AtPixelOptions} [opt_options] Configuration options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template S,T
   * @api
   * @deprecated
   */


  PluggableMap.prototype.forEachLayerAtPixel = function (pixel, callback, opt_options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }

    var options = opt_options || {};
    var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
    var layerFilter = options.layerFilter || _functions_js__WEBPACK_IMPORTED_MODULE_10__.TRUE;
    return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);
  };
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through `opt_layerFilter`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [opt_options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */


  PluggableMap.prototype.hasFeatureAtPixel = function (pixel, opt_options) {
    if (!this.frameState_ || !this.renderer_) {
      return false;
    }

    var coordinate = this.getCoordinateFromPixelInternal(pixel);
    opt_options = opt_options !== undefined ? opt_options : {};
    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functions_js__WEBPACK_IMPORTED_MODULE_10__.TRUE;
    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;
    var checkWrapped = opt_options.checkWrapped !== false;
    return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
  };
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */


  PluggableMap.prototype.getEventCoordinate = function (event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  };
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */


  PluggableMap.prototype.getEventCoordinateInternal = function (event) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
  };
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */


  PluggableMap.prototype.getEventPixel = function (event) {
    var viewportPosition = this.viewport_.getBoundingClientRect();
    var eventPosition = //FIXME Are we really calling this with a TouchEvent anywhere?
    'changedTouches' in event ?
    /** @type {TouchEvent} */
    event.changedTouches[0] :
    /** @type {MouseEvent} */
    event;
    return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];
  };
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */


  PluggableMap.prototype.getTarget = function () {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].TARGET)
    );
  };
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */


  PluggableMap.prototype.getTargetElement = function () {
    var target = this.getTarget();

    if (target !== undefined) {
      return typeof target === 'string' ? document.getElementById(target) : target;
    } else {
      return null;
    }
  };
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */


  PluggableMap.prototype.getCoordinateFromPixel = function (pixel) {
    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
  };
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */


  PluggableMap.prototype.getCoordinateFromPixelInternal = function (pixel) {
    var frameState = this.frameState_;

    if (!frameState) {
      return null;
    } else {
      return (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
    }
  };
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */


  PluggableMap.prototype.getControls = function () {
    return this.controls;
  };
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */


  PluggableMap.prototype.getOverlays = function () {
    return this.overlays_;
  };
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default} Overlay.
   * @api
   */


  PluggableMap.prototype.getOverlayById = function (id) {
    var overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== undefined ? overlay : null;
  };
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */


  PluggableMap.prototype.getInteractions = function () {
    return this.interactions;
  };
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */


  PluggableMap.prototype.getLayerGroup = function () {
    return (
      /** @type {LayerGroup} */
      this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].LAYERGROUP)
    );
  };
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */


  PluggableMap.prototype.setLayers = function (layers) {
    var group = this.getLayerGroup();

    if (layers instanceof _Collection_js__WEBPACK_IMPORTED_MODULE_5__["default"]) {
      group.setLayers(layers);
      return;
    }

    var collection = group.getLayers();
    collection.clear();
    collection.extend(layers);
  };
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */


  PluggableMap.prototype.getLayers = function () {
    var layers = this.getLayerGroup().getLayers();
    return layers;
  };
  /**
   * @return {boolean} Layers have sources that are still loading.
   */


  PluggableMap.prototype.getLoadingOrNotReady = function () {
    var layerStatesArray = this.getLayerGroup().getLayerStatesArray();

    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var state = layerStatesArray[i];

      if (!state.visible) {
        continue;
      }

      var renderer = state.layer.getRenderer();

      if (renderer && !renderer.ready) {
        return true;
      }

      var source =
      /** @type {import("./layer/Layer.js").default} */
      state.layer.getSource();

      if (source && source.loading) {
        return true;
      }
    }

    return false;
  };
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */


  PluggableMap.prototype.getPixelFromCoordinate = function (coordinate) {
    var viewCoordinate = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(coordinate, this.getView().getProjection());
    return this.getPixelFromCoordinateInternal(viewCoordinate);
  };
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */


  PluggableMap.prototype.getPixelFromCoordinateInternal = function (coordinate) {
    var frameState = this.frameState_;

    if (!frameState) {
      return null;
    } else {
      return (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.apply)(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
    }
  };
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */


  PluggableMap.prototype.getRenderer = function () {
    return this.renderer_;
  };
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */


  PluggableMap.prototype.getSize = function () {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].SIZE)
    );
  };
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */


  PluggableMap.prototype.getView = function () {
    return (
      /** @type {View} */
      this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].VIEW)
    );
  };
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */


  PluggableMap.prototype.getViewport = function () {
    return this.viewport_;
  };
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:wg/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */


  PluggableMap.prototype.getOverlayContainer = function () {
    return this.overlayContainer_;
  };
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:wg/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */


  PluggableMap.prototype.getOverlayContainerStopEvent = function () {
    return this.overlayContainerStopEvent_;
  };
  /**
   * @return {!Document} The document where the map is displayed.
   */


  PluggableMap.prototype.getOwnerDocument = function () {
    var targetElement = this.getTargetElement();
    return targetElement ? targetElement.ownerDocument : document;
  };
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */


  PluggableMap.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {
    return (0,_TileQueue_js__WEBPACK_IMPORTED_MODULE_6__.getTilePriority)(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
  };
  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [opt_type] Type.
   */


  PluggableMap.prototype.handleBrowserEvent = function (browserEvent, opt_type) {
    var type = opt_type || browserEvent.type;
    var mapBrowserEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_11__["default"](type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  };
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */


  PluggableMap.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {
    if (!this.frameState_) {
      // With no view defined, we cannot translate pixels into geographical
      // coordinates so interactions cannot be used.
      return;
    }

    var originalEvent =
    /** @type {PointerEvent} */
    mapBrowserEvent.originalEvent;
    var eventType = originalEvent.type;

    if (eventType === _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POINTERDOWN || eventType === _events_EventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].WHEEL || eventType === _events_EventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].KEYDOWN) {
      var doc = this.getOwnerDocument();
      var rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
      var target =
      /** @type {Node} */
      originalEvent.target;

      if ( // Abort if the target is a child of the container for elements whose events are not meant
      // to be handled by map interactions.
      this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
      // It's possible for the target to no longer be in the page if it has been removed in an
      // event listener, this might happen in a Control that recreates it's content based on
      // user interaction either manually or via a render in something like https://reactjs.org/
      !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {
        return;
      }
    }

    mapBrowserEvent.frameState = this.frameState_;

    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      var interactionsArray = this.getInteractions().getArray().slice();

      for (var i = interactionsArray.length - 1; i >= 0; i--) {
        var interaction = interactionsArray[i];

        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
          continue;
        }

        var cont = interaction.handleEvent(mapBrowserEvent);

        if (!cont || mapBrowserEvent.propagationStopped) {
          break;
        }
      }
    }
  };
  /**
   * @protected
   */


  PluggableMap.prototype.handlePostRender = function () {
    var frameState = this.frameState_; // Manage the tile queue
    // Image loads are expensive and a limited resource, so try to use them
    // efficiently:
    // * When the view is static we allow a large number of parallel tile loads
    //   to complete the frame as quickly as possible.
    // * When animating or interacting, image loads can cause janks, so we reduce
    //   the maximum number of loads per frame and limit the number of parallel
    //   tile loads to remain reactive to view changes and to reduce the chance of
    //   loading tiles that will quickly disappear from view.

    var tileQueue = this.tileQueue_;

    if (!tileQueue.isEmpty()) {
      var maxTotalLoading = this.maxTilesLoading_;
      var maxNewLoads = maxTotalLoading;

      if (frameState) {
        var hints = frameState.viewHints;

        if (hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_14__["default"].ANIMATING] || hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_14__["default"].INTERACTING]) {
          var lowOnFrameBudget = Date.now() - frameState.time > 8;
          maxTotalLoading = lowOnFrameBudget ? 0 : 8;
          maxNewLoads = lowOnFrameBudget ? 0 : 2;
        }
      }

      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize(); // FIXME only call if view has changed

        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }

    if (frameState && this.renderer_ && this.hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_15__["default"].RENDERCOMPLETE) && !frameState.animate && this.renderComplete_) {
      this.renderer_.dispatchRenderEvent(_render_EventType_js__WEBPACK_IMPORTED_MODULE_15__["default"].RENDERCOMPLETE, frameState);
    }

    var postRenderFunctions = this.postRenderFunctions_;

    for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
      postRenderFunctions[i](this, frameState);
    }

    postRenderFunctions.length = 0;
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleSizeChanged_ = function () {
    if (this.getView() && !this.getView().getAnimating()) {
      this.getView().resolveConstraints(0);
    }

    this.render();
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleTargetChanged_ = function () {
    if (this.mapBrowserEventHandler_) {
      for (var i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
        (0,_events_js__WEBPACK_IMPORTED_MODULE_16__.unlistenByKey)(this.targetChangeHandlerKeys_[i]);
      }

      this.targetChangeHandlerKeys_ = null;
      this.viewport_.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].CONTEXTMENU, this.boundHandleBrowserEvent_);
      this.viewport_.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].WHEEL, this.boundHandleBrowserEvent_);
      this.mapBrowserEventHandler_.dispose();
      this.mapBrowserEventHandler_ = null;
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_17__.removeNode)(this.viewport_);
    } // target may be undefined, null, a string or an Element.
    // If it's a string we convert it to an Element before proceeding.
    // If it's not now an Element we remove the viewport from the DOM.
    // If it's an Element we append the viewport element to it.


    var targetElement = this.getTargetElement();

    if (!targetElement) {
      if (this.renderer_) {
        clearTimeout(this.postRenderTimeoutHandle_);
        this.postRenderTimeoutHandle_ = undefined;
        this.postRenderFunctions_.length = 0;
        this.renderer_.dispose();
        this.renderer_ = null;
      }

      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelayKey_ = undefined;
      }
    } else {
      targetElement.appendChild(this.viewport_);

      if (!this.renderer_) {
        this.renderer_ = this.createRenderer();
      }

      this.mapBrowserEventHandler_ = new _MapBrowserEventHandler_js__WEBPACK_IMPORTED_MODULE_18__["default"](this, this.moveTolerance_);

      for (var key in _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_19__["default"]) {
        this.mapBrowserEventHandler_.addEventListener(_MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_19__["default"][key], this.handleMapBrowserEvent.bind(this));
      }

      this.viewport_.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].CONTEXTMENU, this.boundHandleBrowserEvent_, false);
      this.viewport_.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].WHEEL, this.boundHandleBrowserEvent_, _has_js__WEBPACK_IMPORTED_MODULE_3__.PASSIVE_EVENT_LISTENERS ? {
        passive: false
      } : false);
      var defaultView = this.getOwnerDocument().defaultView;
      var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
      this.targetChangeHandlerKeys_ = [(0,_events_js__WEBPACK_IMPORTED_MODULE_16__.listen)(keyboardEventTarget, _events_EventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].KEYDOWN, this.handleBrowserEvent, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_16__.listen)(keyboardEventTarget, _events_EventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].KEYPRESS, this.handleBrowserEvent, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_16__.listen)(defaultView, _events_EventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].RESIZE, this.updateSize, this)];
    }

    this.updateSize(); // updateSize calls setSize, so no need to call this.render
    // ourselves here.
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleTileChange_ = function () {
    this.render();
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleViewPropertyChanged_ = function () {
    this.render();
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleViewChanged_ = function () {
    if (this.viewPropertyListenerKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_16__.unlistenByKey)(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }

    if (this.viewChangeListenerKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_16__.unlistenByKey)(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }

    var view = this.getView();

    if (view) {
      this.updateViewportSize_();
      this.viewPropertyListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_16__.listen)(view, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
      this.viewChangeListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_16__.listen)(view, _events_EventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].CHANGE, this.handleViewPropertyChanged_, this);
      view.resolveConstraints(0);
    }

    this.render();
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleLayerGroupChanged_ = function () {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_16__.unlistenByKey);
      this.layerGroupPropertyListenerKeys_ = null;
    }

    var layerGroup = this.getLayerGroup();

    if (layerGroup) {
      this.handleLayerAdd_(new _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__.GroupEvent('addlayer', layerGroup));
      this.layerGroupPropertyListenerKeys_ = [(0,_events_js__WEBPACK_IMPORTED_MODULE_16__.listen)(layerGroup, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].PROPERTYCHANGE, this.render, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_16__.listen)(layerGroup, _events_EventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].CHANGE, this.render, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_16__.listen)(layerGroup, 'addlayer', this.handleLayerAdd_, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_16__.listen)(layerGroup, 'removelayer', this.handleLayerRemove_, this)];
    }

    this.render();
  };
  /**
   * @return {boolean} Is rendered.
   */


  PluggableMap.prototype.isRendered = function () {
    return !!this.frameState_;
  };
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */


  PluggableMap.prototype.renderSync = function () {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }

    this.animationDelay_();
  };
  /**
   * Redraws all text after new fonts have loaded
   */


  PluggableMap.prototype.redrawText = function () {
    var layerStates = this.getLayerGroup().getLayerStatesArray();

    for (var i = 0, ii = layerStates.length; i < ii; ++i) {
      var layer = layerStates[i].layer;

      if (layer.hasRenderer()) {
        layer.getRenderer().handleFontsChanged();
      }
    }
  };
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */


  PluggableMap.prototype.render = function () {
    if (this.renderer_ && this.animationDelayKey_ === undefined) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  };
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */


  PluggableMap.prototype.removeControl = function (control) {
    return this.getControls().remove(control);
  };
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */


  PluggableMap.prototype.removeInteraction = function (interaction) {
    return this.getInteractions().remove(interaction);
  };
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */


  PluggableMap.prototype.removeLayer = function (layer) {
    var layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  };
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */


  PluggableMap.prototype.handleLayerRemove_ = function (event) {
    removeLayerMapProperty(event.layer);
  };
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */


  PluggableMap.prototype.removeOverlay = function (overlay) {
    return this.getOverlays().remove(overlay);
  };
  /**
   * @param {number} time Time.
   * @private
   */


  PluggableMap.prototype.renderFrame_ = function (time) {
    var _this = this;

    var size = this.getSize();
    var view = this.getView();
    var previousFrameState = this.frameState_;
    /** @type {?FrameState} */

    var frameState = null;

    if (size !== undefined && (0,_size_js__WEBPACK_IMPORTED_MODULE_21__.hasArea)(size) && view && view.isDef()) {
      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
      var viewState = view.getState();
      frameState = {
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutterTree: null,
        extent: (0,_extent_js__WEBPACK_IMPORTED_MODULE_22__.getForViewAndSize)(viewState.center, viewState.resolution, viewState.rotation, size),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: size,
        tileQueue: this.tileQueue_,
        time: time,
        usedTiles: {},
        viewState: viewState,
        viewHints: viewHints,
        wantedTiles: {},
        mapId: (0,_util_js__WEBPACK_IMPORTED_MODULE_23__.getUid)(this),
        renderTargets: {}
      };

      if (viewState.nextCenter && viewState.nextResolution) {
        var rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
        frameState.nextExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_22__.getForViewAndSize)(viewState.nextCenter, viewState.nextResolution, rotation, size);
      }
    }

    this.frameState_ = frameState;
    /** @type {import("./renderer/Map.js").default} */

    this.renderer_.renderFrame(frameState);

    if (frameState) {
      if (frameState.animate) {
        this.render();
      }

      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);

      if (previousFrameState) {
        var moveStart = !this.previousExtent_ || !(0,_extent_js__WEBPACK_IMPORTED_MODULE_22__.isEmpty)(this.previousExtent_) && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_22__.equals)(frameState.extent, this.previousExtent_);

        if (moveStart) {
          this.dispatchEvent(new _MapEvent_js__WEBPACK_IMPORTED_MODULE_24__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_25__["default"].MOVESTART, this, previousFrameState));
          this.previousExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_22__.createOrUpdateEmpty)(this.previousExtent_);
        }
      }

      var idle = this.previousExtent_ && !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_14__["default"].ANIMATING] && !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_14__["default"].INTERACTING] && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_22__.equals)(frameState.extent, this.previousExtent_);

      if (idle) {
        this.dispatchEvent(new _MapEvent_js__WEBPACK_IMPORTED_MODULE_24__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_25__["default"].MOVEEND, this, frameState));
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_22__.clone)(frameState.extent, this.previousExtent_);
      }
    }

    this.dispatchEvent(new _MapEvent_js__WEBPACK_IMPORTED_MODULE_24__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_25__["default"].POSTRENDER, this, frameState));
    this.renderComplete_ = !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady();

    if (!this.postRenderTimeoutHandle_) {
      this.postRenderTimeoutHandle_ = setTimeout(function () {
        _this.postRenderTimeoutHandle_ = undefined;

        _this.handlePostRender();
      }, 0);
    }
  };
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */


  PluggableMap.prototype.setLayerGroup = function (layerGroup) {
    var oldLayerGroup = this.getLayerGroup();

    if (oldLayerGroup) {
      this.handleLayerRemove_(new _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__.GroupEvent('removelayer', oldLayerGroup));
    }

    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].LAYERGROUP, layerGroup);
  };
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */


  PluggableMap.prototype.setSize = function (size) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].SIZE, size);
  };
  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */


  PluggableMap.prototype.setTarget = function (target) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].TARGET, target);
  };
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */


  PluggableMap.prototype.setView = function (view) {
    if (!view || view instanceof _View_js__WEBPACK_IMPORTED_MODULE_8__["default"]) {
      this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].VIEW, view);
      return;
    }

    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].VIEW, new _View_js__WEBPACK_IMPORTED_MODULE_8__["default"]());
    var map = this;
    view.then(function (viewOptions) {
      map.setView(new _View_js__WEBPACK_IMPORTED_MODULE_8__["default"](viewOptions));
    });
  };
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */


  PluggableMap.prototype.updateSize = function () {
    var targetElement = this.getTargetElement();
    var size = undefined;

    if (targetElement) {
      var computedStyle = getComputedStyle(targetElement);
      var width = targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']);
      var height = targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth']);

      if (!isNaN(width) && !isNaN(height)) {
        size = [width, height];

        if (!(0,_size_js__WEBPACK_IMPORTED_MODULE_21__.hasArea)(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
          // eslint-disable-next-line
          console.warn("No map visible because the map container's width or height are 0.");
        }
      }
    }

    this.setSize(size);
    this.updateViewportSize_();
  };
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @private
   */


  PluggableMap.prototype.updateViewportSize_ = function () {
    var view = this.getView();

    if (view) {
      var size = undefined;
      var computedStyle = getComputedStyle(this.viewport_);

      if (computedStyle.width && computedStyle.height) {
        size = [parseInt(computedStyle.width, 10), parseInt(computedStyle.height, 10)];
      }

      view.setViewportSize(size);
    }
  };

  return PluggableMap;
}(_Object_js__WEBPACK_IMPORTED_MODULE_26__["default"]);
/**
 * @param {MapOptions} options Map options.
 * @return {MapOptionsInternal} Internal map options.
 */


function createOptionsInternal(options) {
  /**
   * @type {HTMLElement|Document}
   */
  var keyboardEventTarget = null;

  if (options.keyboardEventTarget !== undefined) {
    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  /**
   * @type {Object<string, *>}
   */


  var values = {};
  var layerGroup = options.layers && typeof
  /** @type {?} */
  options.layers.getLayers === 'function' ?
  /** @type {LayerGroup} */
  options.layers : new _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
    layers:
    /** @type {Collection} */
    options.layers
  });
  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].LAYERGROUP] = layerGroup;
  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].TARGET] = options.target;
  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_7__["default"].VIEW] = options.view instanceof _View_js__WEBPACK_IMPORTED_MODULE_8__["default"] ? options.view : new _View_js__WEBPACK_IMPORTED_MODULE_8__["default"]();
  var controls;

  if (options.controls !== undefined) {
    if (Array.isArray(options.controls)) {
      controls = new _Collection_js__WEBPACK_IMPORTED_MODULE_5__["default"](options.controls.slice());
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_27__.assert)(typeof
      /** @type {?} */
      options.controls.getArray === 'function', 47); // Expected `controls` to be an array or an `import("./Collection.js").Collection`

      controls =
      /** @type {Collection} */
      options.controls;
    }
  }

  var interactions;

  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new _Collection_js__WEBPACK_IMPORTED_MODULE_5__["default"](options.interactions.slice());
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_27__.assert)(typeof
      /** @type {?} */
      options.interactions.getArray === 'function', 48); // Expected `interactions` to be an array or an `import("./Collection.js").Collection`

      interactions =
      /** @type {Collection} */
      options.interactions;
    }
  }

  var overlays;

  if (options.overlays !== undefined) {
    if (Array.isArray(options.overlays)) {
      overlays = new _Collection_js__WEBPACK_IMPORTED_MODULE_5__["default"](options.overlays.slice());
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_27__.assert)(typeof
      /** @type {?} */
      options.overlays.getArray === 'function', 49); // Expected `overlays` to be an array or an `import("./Collection.js").Collection`

      overlays = options.overlays;
    }
  } else {
    overlays = new _Collection_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
  }

  return {
    controls: controls,
    interactions: interactions,
    keyboardEventTarget: keyboardEventTarget,
    overlays: overlays,
    values: values
  };
}

/* harmony default export */ __webpack_exports__["default"] = (PluggableMap);

/***/ }),

/***/ "./build/wg/Tile.js":
/*!**************************!*\
  !*** ./build/wg/Tile.js ***!
  \**************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events/Target.js */ "./build/wg/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileState.js */ "./build/wg/TileState.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ "./build/wg/util.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./easing.js */ "./build/wg/easing.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/Tile
 */







/**
 * A function that takes an {@link module:wg/Tile~Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'wg/TileState';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   var xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     var data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string): void} LoadFunction
 * @api
 */

/**
 * {@link module:wg/source/Tile~TileSource} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:wg/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:wg/proj/Projection~Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */

/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @api
 */

/**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */

var Tile =
/** @class */
function (_super) {
  __extends(Tile, _super);
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [opt_options] Tile options.
   */


  function Tile(tileCoord, state, opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @type {import("./tilecoord.js").TileCoord}
     */

    _this.tileCoord = tileCoord;
    /**
     * @protected
     * @type {import("./TileState.js").default}
     */

    _this.state = state;
    /**
     * An "interim" tile for this tile. The interim tile may be used while this
     * one is loading, for "smooth" transitions when changing params/dimensions
     * on the source.
     * @type {Tile}
     */

    _this.interimTile = null;
    /**
     * A key assigned to the tile. This is used by the tile source to determine
     * if this tile can effectively be used, or if a new tile should be created
     * and this one be used as an interim tile for this new tile.
     * @type {string}
     */

    _this.key = '';
    /**
     * The duration for the opacity transition.
     * @type {number}
     */

    _this.transition_ = options.transition === undefined ? 250 : options.transition;
    /**
     * Lookup of start times for rendering transitions.  If the start time is
     * equal to -1, the transition is complete.
     * @type {Object<string, number>}
     */

    _this.transitionStarts_ = {};
    /**
     * @type {boolean}
     */

    _this.interpolate = !!options.interpolate;
    return _this;
  }
  /**
   * @protected
   */


  Tile.prototype.changed = function () {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CHANGE);
  };
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */


  Tile.prototype.release = function () {};
  /**
   * @return {string} Key.
   */


  Tile.prototype.getKey = function () {
    return this.key + '/' + this.tileCoord;
  };
  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */


  Tile.prototype.getInterimTile = function () {
    if (!this.interimTile) {
      //empty chain
      return this;
    }

    var tile = this.interimTile; // find the first loaded tile and return it. Since the chain is sorted in
    // decreasing order of creation time, there is no need to search the remainder
    // of the list (all those tiles correspond to older requests and will be
    // cleaned up by refreshInterimChain)

    do {
      if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
        // Show tile immediately instead of fading it in after loading, because
        // the interim tile is in place already
        this.transition_ = 0;
        return tile;
      }

      tile = tile.interimTile;
    } while (tile); // we can not find a better tile


    return this;
  };
  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */


  Tile.prototype.refreshInterimChain = function () {
    if (!this.interimTile) {
      return;
    }

    var tile = this.interimTile;
    /**
     * @type {Tile}
     */

    var prev = this;

    do {
      if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
        //we have a loaded tile, we can discard the rest of the list
        //we would could abort any LOADING tile request
        //older than this tile (i.e. any LOADING tile following this entry in the chain)
        tile.interimTile = null;
        break;
      } else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
        //keep this LOADING tile any loaded tiles later in the chain are
        //older than this tile, so we're still interested in the request
        prev = tile;
      } else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
        //the head of the list is the most current tile, we don't need
        //to start any other requests for this chain
        prev.interimTile = tile.interimTile;
      } else {
        prev = tile;
      }

      tile = prev.interimTile;
    } while (tile);
  };
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */


  Tile.prototype.getTileCoord = function () {
    return this.tileCoord;
  };
  /**
   * @return {import("./TileState.js").default} State.
   */


  Tile.prototype.getState = function () {
    return this.state;
  };
  /**
   * Sets the state of this tile. If you write your own {@link module:wg/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:wg/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */


  Tile.prototype.setState = function (state) {
    if (this.state !== _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR && this.state > state) {
      throw new Error('Tile load sequence violation');
    }

    this.state = state;
    this.changed();
  };
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */


  Tile.prototype.load = function () {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.abstract)();
  };
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */


  Tile.prototype.getAlpha = function (id, time) {
    if (!this.transition_) {
      return 1;
    }

    var start = this.transitionStarts_[id];

    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }

    var delta = time - start + 1000 / 60; // avoid rendering at 0

    if (delta >= this.transition_) {
      return 1;
    }

    return (0,_easing_js__WEBPACK_IMPORTED_MODULE_3__.easeIn)(delta / this.transition_);
  };
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */


  Tile.prototype.inTransition = function (id) {
    if (!this.transition_) {
      return false;
    }

    return this.transitionStarts_[id] !== -1;
  };
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */


  Tile.prototype.endTransition = function (id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  };

  return Tile;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Tile);

/***/ }),

/***/ "./build/wg/TileCache.js":
/*!*******************************!*\
  !*** ./build/wg/TileCache.js ***!
  \*******************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./structs/LRUCache.js */ "./build/wg/structs/LRUCache.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tilecoord.js */ "./build/wg/tilecoord.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/TileCache
 */





var TileCache =
/** @class */
function (_super) {
  __extends(TileCache, _super);

  function TileCache() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */


  TileCache.prototype.expireCache = function (usedTiles) {
    while (this.canExpireCache()) {
      var tile = this.peekLast();

      if (tile.getKey() in usedTiles) {
        break;
      } else {
        this.pop().release();
      }
    }
  };
  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */


  TileCache.prototype.pruneExceptNewestZ = function () {
    if (this.getCount() === 0) {
      return;
    }

    var key = this.peekFirstKey();
    var tileCoord = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_0__.fromKey)(key);
    var z = tileCoord[0];
    this.forEach(function (tile) {
      if (tile.tileCoord[0] !== z) {
        this.remove((0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_0__.getKey)(tile.tileCoord));
        tile.release();
      }
    }.bind(this));
  };

  return TileCache;
}(_structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (TileCache);

/***/ }),

/***/ "./build/wg/TileQueue.js":
/*!*******************************!*\
  !*** ./build/wg/TileQueue.js ***!
  \*******************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTilePriority": function() { return /* binding */ getTilePriority; }
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./structs/PriorityQueue.js */ "./build/wg/structs/PriorityQueue.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileState.js */ "./build/wg/TileState.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/TileQueue
 */





/**
 * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
 */

var TileQueue =
/** @class */
function (_super) {
  __extends(TileQueue, _super);
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */


  function TileQueue(tilePriorityFunction, tileChangeCallback) {
    var _this = _super.call(this,
    /**
     * @param {Array} element Element.
     * @return {number} Priority.
     */
    function (element) {
      return tilePriorityFunction.apply(null, element);
    },
    /**
     * @param {Array} element Element.
     * @return {string} Key.
     */
    function (element) {
      return (
        /** @type {import("./Tile.js").default} */
        element[0].getKey()
      );
    }) || this;
    /** @private */


    _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);
    /**
     * @private
     * @type {function(): ?}
     */

    _this.tileChangeCallback_ = tileChangeCallback;
    /**
     * @private
     * @type {number}
     */

    _this.tilesLoading_ = 0;
    /**
     * @private
     * @type {!Object<string,boolean>}
     */

    _this.tilesLoadingKeys_ = {};
    return _this;
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */


  TileQueue.prototype.enqueue = function (element) {
    var added = _super.prototype.enqueue.call(this, element);

    if (added) {
      var tile = element[0];
      tile.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CHANGE, this.boundHandleTileChange_);
    }

    return added;
  };
  /**
   * @return {number} Number of tiles loading.
   */


  TileQueue.prototype.getTilesLoading = function () {
    return this.tilesLoading_;
  };
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */


  TileQueue.prototype.handleTileChange = function (event) {
    var tile =
    /** @type {import("./Tile.js").default} */
    event.target;
    var state = tile.getState();

    if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED || state === _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR || state === _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY) {
      tile.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CHANGE, this.boundHandleTileChange_);
      var tileKey = tile.getKey();

      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }

      this.tileChangeCallback_();
    }
  };
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */


  TileQueue.prototype.loadMoreTiles = function (maxTotalLoading, maxNewLoads) {
    var newLoads = 0;
    var state, tile, tileKey;

    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
      tile =
      /** @type {import("./Tile.js").default} */
      this.dequeue()[0];
      tileKey = tile.getKey();
      state = tile.getState();

      if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
  };

  return TileQueue;
}(_structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (TileQueue);
/**
 * @param {import('./PluggableMap.js').FrameState} frameState Frame state.
 * @param {import("./Tile.js").default} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */

function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
  // Filter out tiles at higher zoom levels than the current zoom level, or that
  // are outside the visible extent.
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_2__.DROP;
  }

  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_2__.DROP;
  } // Prioritize the highest zoom level tiles closest to the focus.
  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
  // Within a zoom level, tiles are prioritized by the distance in pixels between
  // the center of the tile and the center of the viewport.  The factor of 65536
  // means that the prioritization should behave as desired for tiles up to
  // 65536 * Math.log(2) = 45426 pixels from the focus.


  var center = frameState.viewState.center;
  var deltaX = tileCenter[0] - center[0];
  var deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}

/***/ }),

/***/ "./build/wg/TileRange.js":
/*!*******************************!*\
  !*** ./build/wg/TileRange.js ***!
  \*******************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createOrUpdate": function() { return /* binding */ createOrUpdate; }
/* harmony export */ });
/**
 * @module wg/TileRange
 */

/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */
var TileRange =
/** @class */
function () {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  function TileRange(minX, maxX, minY, maxY) {
    /**
     * @type {number}
     */
    this.minX = minX;
    /**
     * @type {number}
     */

    this.maxX = maxX;
    /**
     * @type {number}
     */

    this.minY = minY;
    /**
     * @type {number}
     */

    this.maxY = maxY;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */


  TileRange.prototype.contains = function (tileCoord) {
    return this.containsXY(tileCoord[1], tileCoord[2]);
  };
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */


  TileRange.prototype.containsTileRange = function (tileRange) {
    return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
  };
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */


  TileRange.prototype.containsXY = function (x, y) {
    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
  };
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */


  TileRange.prototype.equals = function (tileRange) {
    return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
  };
  /**
   * @param {TileRange} tileRange Tile range.
   */


  TileRange.prototype.extend = function (tileRange) {
    if (tileRange.minX < this.minX) {
      this.minX = tileRange.minX;
    }

    if (tileRange.maxX > this.maxX) {
      this.maxX = tileRange.maxX;
    }

    if (tileRange.minY < this.minY) {
      this.minY = tileRange.minY;
    }

    if (tileRange.maxY > this.maxY) {
      this.maxY = tileRange.maxY;
    }
  };
  /**
   * @return {number} Height.
   */


  TileRange.prototype.getHeight = function () {
    return this.maxY - this.minY + 1;
  };
  /**
   * @return {import("./size.js").Size} Size.
   */


  TileRange.prototype.getSize = function () {
    return [this.getWidth(), this.getHeight()];
  };
  /**
   * @return {number} Width.
   */


  TileRange.prototype.getWidth = function () {
    return this.maxX - this.minX + 1;
  };
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */


  TileRange.prototype.intersects = function (tileRange) {
    return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
  };

  return TileRange;
}();
/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {TileRange} [tileRange] TileRange.
 * @return {TileRange} Tile range.
 */


function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new TileRange(minX, maxX, minY, maxY);
  }
}
/* harmony default export */ __webpack_exports__["default"] = (TileRange);

/***/ }),

/***/ "./build/wg/TileState.js":
/*!*******************************!*\
  !*** ./build/wg/TileState.js ***!
  \*******************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/TileState
 */

/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,

  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
});

/***/ }),

/***/ "./build/wg/VectorRenderTile.js":
/*!**************************************!*\
  !*** ./build/wg/VectorRenderTile.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Tile.js */ "./build/wg/Tile.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom.js */ "./build/wg/dom.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./build/wg/util.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/VectorRenderTile
 */





/**
 * @typedef {Object} ReplayState
 * @property {boolean} dirty Dirty.
 * @property {null|import("./render.js").OrderFunction} renderedRenderOrder RenderedRenderOrder.
 * @property {number} renderedTileRevision RenderedTileRevision.
 * @property {number} renderedResolution RenderedResolution.
 * @property {number} renderedRevision RenderedRevision.
 * @property {number} renderedTileResolution RenderedTileResolution.
 * @property {number} renderedTileZ RenderedTileZ.
 */

/**
 * @type {Array<HTMLCanvasElement>}
 */

var canvasPool = [];

var VectorRenderTile =
/** @class */
function (_super) {
  __extends(VectorRenderTile, _super);
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {import("./tilecoord.js").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.
   * @param {function(VectorRenderTile):Array<import("./VectorTile").default>} getSourceTiles Function
   * to get source tiles for this tile.
   */


  function VectorRenderTile(tileCoord, state, urlTileCoord, getSourceTiles) {
    var _this = _super.call(this, tileCoord, state, {
      transition: 0
    }) || this;
    /**
     * @private
     * @type {!Object<string, CanvasRenderingContext2D>}
     */


    _this.context_ = {};
    /**
     * Executor groups by layer uid. Entries are read/written by the renderer.
     * @type {Object<string, Array<import("./render/canvas/ExecutorGroup.js").default>>}
     */

    _this.executorGroups = {};
    /**
     * Executor groups for decluttering, by layer uid. Entries are read/written by the renderer.
     * @type {Object<string, Array<import("./render/canvas/ExecutorGroup.js").default>>}
     */

    _this.declutterExecutorGroups = {};
    /**
     * Number of loading source tiles. Read/written by the source.
     * @type {number}
     */

    _this.loadingSourceTiles = 0;
    /**
     * @type {Object<number, ImageData>}
     */

    _this.hitDetectionImageData = {};
    /**
     * @private
     * @type {!Object<string, ReplayState>}
     */

    _this.replayState_ = {};
    /**
     * @type {Array<import("./VectorTile.js").default>}
     */

    _this.sourceTiles = [];
    /**
     * @type {Object<string, boolean>}
     */

    _this.errorTileKeys = {};
    /**
     * @type {number}
     */

    _this.wantedResolution;
    /**
     * @type {!function():Array<import("./VectorTile.js").default>}
     */

    _this.getSourceTiles = getSourceTiles.bind(undefined, _this);
    /**
     * @type {import("./tilecoord.js").TileCoord}
     */

    _this.wrappedTileCoord = urlTileCoord;
    return _this;
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {CanvasRenderingContext2D} The rendering context.
   */


  VectorRenderTile.prototype.getContext = function (layer) {
    var key = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getUid)(layer);

    if (!(key in this.context_)) {
      this.context_[key] = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(1, 1, canvasPool);
    }

    return this.context_[key];
  };
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {boolean} Tile has a rendering context for the given layer.
   */


  VectorRenderTile.prototype.hasContext = function (layer) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getUid)(layer) in this.context_;
  };
  /**
   * Get the Canvas for this tile.
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {HTMLCanvasElement} Canvas.
   */


  VectorRenderTile.prototype.getImage = function (layer) {
    return this.hasContext(layer) ? this.getContext(layer).canvas : null;
  };
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {ReplayState} The replay state.
   */


  VectorRenderTile.prototype.getReplayState = function (layer) {
    var key = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getUid)(layer);

    if (!(key in this.replayState_)) {
      this.replayState_[key] = {
        dirty: false,
        renderedRenderOrder: null,
        renderedResolution: NaN,
        renderedRevision: -1,
        renderedTileResolution: NaN,
        renderedTileRevision: -1,
        renderedTileZ: -1
      };
    }

    return this.replayState_[key];
  };
  /**
   * Load the tile.
   */


  VectorRenderTile.prototype.load = function () {
    this.getSourceTiles();
  };
  /**
   * Remove from the cache due to expiry
   */


  VectorRenderTile.prototype.release = function () {
    for (var key in this.context_) {
      canvasPool.push(this.context_[key].canvas);
      delete this.context_[key];
    }

    _super.prototype.release.call(this);
  };

  return VectorRenderTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VectorRenderTile);

/***/ }),

/***/ "./build/wg/VectorTile.js":
/*!********************************!*\
  !*** ./build/wg/VectorTile.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Tile.js */ "./build/wg/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileState.js */ "./build/wg/TileState.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/VectorTile
 */





var VectorTile =
/** @class */
function (_super) {
  __extends(VectorTile, _super);
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Data source url.
   * @param {import("./format/Feature.js").default} format Feature format.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [opt_options] Tile options.
   */


  function VectorTile(tileCoord, state, src, format, tileLoadFunction, opt_options) {
    var _this = _super.call(this, tileCoord, state, opt_options) || this;
    /**
     * Extent of this tile; set by the source.
     * @type {import("./extent.js").Extent}
     */


    _this.extent = null;
    /**
     * @private
     * @type {import("./format/Feature.js").default}
     */

    _this.format_ = format;
    /**
     * @private
     * @type {Array<import("./Feature.js").default>}
     */

    _this.features_ = null;
    /**
     * @private
     * @type {import("./featureloader.js").FeatureLoader}
     */

    _this.loader_;
    /**
     * Feature projection of this tile; set by the source.
     * @type {import("./proj/Projection.js").default}
     */

    _this.projection = null;
    /**
     * Resolution of this tile; set by the source.
     * @type {number}
     */

    _this.resolution;
    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */

    _this.tileLoadFunction_ = tileLoadFunction;
    /**
     * @private
     * @type {string}
     */

    _this.url_ = src;
    _this.key = src;
    return _this;
  }
  /**
   * Get the feature format assigned for reading this tile's features.
   * @return {import("./format/Feature.js").default} Feature format.
   * @api
   */


  VectorTile.prototype.getFormat = function () {
    return this.format_;
  };
  /**
   * Get the features for this tile. Geometries will be in the view projection.
   * @return {Array<import("./Feature.js").FeatureLike>} Features.
   * @api
   */


  VectorTile.prototype.getFeatures = function () {
    return this.features_;
  };
  /**
   * Load not yet loaded URI.
   */


  VectorTile.prototype.load = function () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE) {
      this.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADING);
      this.tileLoadFunction_(this, this.url_);

      if (this.loader_) {
        this.loader_(this.extent, this.resolution, this.projection);
      }
    }
  };
  /**
   * Handler for successful tile load.
   * @param {Array<import("./Feature.js").default>} features The loaded features.
   * @param {import("./proj/Projection.js").default} dataProjection Data projection.
   */


  VectorTile.prototype.onLoad = function (features, dataProjection) {
    this.setFeatures(features);
  };
  /**
   * Handler for tile load errors.
   */


  VectorTile.prototype.onError = function () {
    this.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR);
  };
  /**
   * Function for use in an {@link module:wg/source/VectorTile~VectorTile}'s `tileLoadFunction`.
   * Sets the features for the tile.
   * @param {Array<import("./Feature.js").default>} features Features.
   * @api
   */


  VectorTile.prototype.setFeatures = function (features) {
    this.features_ = features;
    this.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED);
  };
  /**
   * Set the feature loader for reading this tile's features.
   * @param {import("./featureloader.js").FeatureLoader} loader Feature loader.
   * @api
   */


  VectorTile.prototype.setLoader = function (loader) {
    this.loader_ = loader;
  };

  return VectorTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VectorTile);

/***/ }),

/***/ "./build/wg/View.js":
/*!**************************!*\
  !*** ./build/wg/View.js ***!
  \**************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCenterConstraint": function() { return /* binding */ createCenterConstraint; },
/* harmony export */   "createResolutionConstraint": function() { return /* binding */ createResolutionConstraint; },
/* harmony export */   "createRotationConstraint": function() { return /* binding */ createRotationConstraint; },
/* harmony export */   "isNoopAnimation": function() { return /* binding */ isNoopAnimation; }
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Object.js */ "./build/wg/Object.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./proj/Units.js */ "./build/wg/proj/Units.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ViewHint.js */ "./build/wg/ViewHint.js");
/* harmony import */ var _ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ViewProperty.js */ "./build/wg/ViewProperty.js");
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./tilegrid/common.js */ "./build/wg/tilegrid/common.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./build/wg/proj.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./functions.js */ "./build/wg/functions.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coordinate.js */ "./build/wg/coordinate.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./obj.js */ "./build/wg/obj.js");
/* harmony import */ var _centerconstraint_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./centerconstraint.js */ "./build/wg/centerconstraint.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./math.js */ "./build/wg/math.js");
/* harmony import */ var _resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./resolutionconstraint.js */ "./build/wg/resolutionconstraint.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./rotationconstraint.js */ "./build/wg/rotationconstraint.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./easing.js */ "./build/wg/easing.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./extent.js */ "./build/wg/extent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./array.js */ "./build/wg/array.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./geom/Polygon.js */ "./build/wg/geom/Polygon.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/View
 */





















/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {import("./coordinate.js").Coordinate} [sourceCenter] Source center.
 * @property {import("./coordinate.js").Coordinate} [targetCenter] Target center.
 * @property {number} [sourceResolution] Source resolution.
 * @property {number} [targetResolution] Target resolution.
 * @property {number} [sourceRotation] Source rotation.
 * @property {number} [targetRotation] Target rotation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Anchor.
 * @property {number} start Start.
 * @property {number} duration Duration.
 * @property {boolean} complete Complete.
 * @property {function(number):number} easing Easing.
 * @property {function(boolean):void} callback Callback.
 */

/**
 * @typedef {Object} Constraints
 * @property {import("./centerconstraint.js").Type} center Center.
 * @property {import("./resolutionconstraint.js").Type} resolution Resolution.
 * @property {import("./rotationconstraint.js").Type} rotation Rotation.
 */

/**
 * @typedef {Object} FitOptions
 * @property {import("./size.js").Size} [size] The size in pixels of the box to fit
 * the extent into. Default is the current size of the first map in the DOM that
 * uses this view, or `[100, 100]` if no such map is found.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
 * get the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:wg/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean):void} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */

/**
 * @typedef {Object} ViewOptions
 * @property {import("./coordinate.js").Coordinate} [center] The initial center for
 * the view. If a user projection is not set, the coordinate system for the center is
 * specified with the `projection` option. Layer sources will not be fetched if this
 * is not set, but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {import("./extent.js").Extent} [extent] The extent that constrains the
 * view, in other words, nothing outside of this extent can be visible on the map.
 * @property {boolean} [constrainOnlyCenter=false] If true, the extent
 * constraint will only apply to the view center and not the whole extent.
 * @property {boolean} [smoothExtentConstraint=true] If true, the extent
 * constraint will be applied smoothly, i.e. allow the view to go slightly outside
 * of the given `extent`.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {boolean} [multiWorld=false] If `false` the view is constrained so
 * only one world is visible, and you cannot pan off the edge.  If `true` the map
 * may show multiple worlds at low zoom levels.  Only used if the `projection` is
 * global.  Note that if `extent` is also provided it is given precedence.
 * @property {boolean} [constrainResolution=false] If true, the view will always
 * animate to the closest zoom level after an interaction; false means
 * intermediary zoom levels are allowed.
 * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
 * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
 * the given resolution or zoom bounds.
 * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
 * show the full configured extent. By default, when a view is configured with an
 * extent, users will not be able to zoom out so the viewport exceeds the extent in
 * either dimension. This means the full extent may not be visible if the viewport
 * is taller or wider than the aspect ratio of the configured extent. If
 * showFullExtent is true, the user will be able to zoom out so that the viewport
 * exceeds the height or width of the configured extent, but not both, allowing the
 * full extent to be shown.
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array<number>} [resolutions] Resolutions that determine the
 * zoom levels if specified. The index in the array corresponds to the zoom level,
 * therefore the resolution values have to be in descending order. It also constrains
 * the resolution by the minimum and maximum value. If set the `maxResolution`,
 * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view.
 * @property {number} [zoomFactor=2] The zoom factor used to compute the
 * corresponding resolution.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).
 * If the map viewport is partially covered with other content (overlays) along
 * its edges, this setting allows to shift the center of the viewport away from
 * that content. The order of the values is top, right, bottom, left.
 */

/**
 * @typedef {Object} AnimationOptions
 * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
 * the animation.
 * @property {number} [zoom] The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number} [resolution] The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number} [rotation] The rotation of the view at the end of
 * the animation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:wg/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */

/**
 * @typedef {Object} State
 * @property {import("./coordinate.js").Coordinate} center Center.
 * @property {import("./proj/Projection.js").default} projection Projection.
 * @property {number} resolution Resolution.
 * @property {import("./coordinate.js").Coordinate} [nextCenter] The next center during an animation series.
 * @property {number} [nextResolution] The next resolution during an animation series.
 * @property {number} [nextRotation] The next rotation during an animation series.
 * @property {number} rotation Rotation.
 * @property {number} zoom Zoom.
 */

/**
 * Default min zoom level for the map view.
 * @type {number}
 */

var DEFAULT_MIN_ZOOM = 0;
/**
 * @typedef {import("./ObjectEventType").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<ViewObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature
 */

/**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * A View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Web Mercator (EPSG:3857).
 *
 * ### The view states
 *
 * A View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * The `zoom` state is actually not saved on the view: all computations
 * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
 * methods are available, as well as `getResolutionForZoom` and
 * `getZoomForResolution` to switch from one system to the other.
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view, but any constraint defined in the constructor will
 * be applied along the way.
 *
 * A View object can have a *resolution constraint*, a *rotation constraint*
 * and a *center constraint*.
 *
 * The *resolution constraint* typically restricts min/max values and
 * snaps to specific resolutions. It is determined by the following
 * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
 * If `resolutions` is set, the other three options are ignored. See
 * documentation for each option for more information. By default, the view
 * only has a min/max restriction and allow intermediary zoom levels when
 * pinch-zooming for example.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default rotation is allowed and its value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the view center is not constrained at all.
 *
 * ### Changing the view state
 *
 * It is important to note that `setZoom`, `setResolution`, `setCenter` and
 * `setRotation` are subject to the above mentioned constraints. As such, it
 * may sometimes not be possible to know in advance the resulting state of the
 * View. For example, calling `setResolution(10)` does not guarantee that
 * `getResolution()` will return `10`.
 *
 * A consequence of this is that, when applying a delta on the view state, one
 * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
 * rather than the corresponding setters. This will let view do its internal
 * computations. Besides, the `adjust*` methods also take an `opt_anchor`
 * argument which allows specifying an origin for the transformation.
 *
 * ### Interacting with the view
 *
 * View constraints are usually only applied when the view is *at rest*, meaning that
 * no interaction or animation is ongoing. As such, if the user puts the view in a
 * state that is not equivalent to a constrained one (e.g. rotating the view when
 * the snap angle is 0), an animation will be triggered at the interaction end to
 * put back the view to a stable state;
 *
 * @api
 */

var View =
/** @class */
function (_super) {
  __extends(View, _super);
  /**
   * @param {ViewOptions} [opt_options] View options.
   */


  function View(opt_options) {
    var _this = _super.call(this) || this;
    /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */


    _this.on;
    /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */

    _this.once;
    /***
     * @type {ViewOnSignature<void>}
     */

    _this.un;
    var options = (0,_obj_js__WEBPACK_IMPORTED_MODULE_1__.assign)({}, opt_options);
    /**
     * @private
     * @type {Array<number>}
     */

    _this.hints_ = [0, 0];
    /**
     * @private
     * @type {Array<Array<Animation>>}
     */

    _this.animations_ = [];
    /**
     * @private
     * @type {number|undefined}
     */

    _this.updateAnimationKey_;
    /**
     * @private
     * @const
     * @type {import("./proj/Projection.js").default}
     */

    _this.projection_ = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.createProjection)(options.projection, 'EPSG:3857');
    /**
     * @private
     * @type {import("./size.js").Size}
     */

    _this.viewportSize_ = [100, 100];
    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */

    _this.targetCenter_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.targetResolution_;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.targetRotation_;
    /**
     * @private
     * @type {import("./coordinate.js").Coordinate}
     */

    _this.nextCenter_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.nextResolution_;
    /**
     * @private
     * @type {number}
     */

    _this.nextRotation_;
    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */

    _this.cancelAnchor_ = undefined;

    if (options.center) {
      options.center = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(options.center, _this.projection_);
    }

    if (options.extent) {
      options.extent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(options.extent, _this.projection_);
    }

    if (options.projection) {
      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.disableCoordinateWarning)();
    }

    _this.applyOptions_(options);

    return _this;
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */


  View.prototype.applyOptions_ = function (options) {
    var properties = (0,_obj_js__WEBPACK_IMPORTED_MODULE_1__.assign)({}, options);

    for (var key in _ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      delete properties[key];
    }

    this.setProperties(properties, true);
    var resolutionConstraintInfo = createResolutionConstraint(options);
    /**
     * @private
     * @type {number}
     */

    this.maxResolution_ = resolutionConstraintInfo.maxResolution;
    /**
     * @private
     * @type {number}
     */

    this.minResolution_ = resolutionConstraintInfo.minResolution;
    /**
     * @private
     * @type {number}
     */

    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
    /**
     * @private
     * @type {Array<number>|undefined}
     */

    this.resolutions_ = options.resolutions;
    /**
     * @type {Array<number>|undefined}
     * @private
     */

    this.padding_ = options.padding;
    /**
     * @private
     * @type {number}
     */

    this.minZoom_ = resolutionConstraintInfo.minZoom;
    var centerConstraint = createCenterConstraint(options);
    var resolutionConstraint = resolutionConstraintInfo.constraint;
    var rotationConstraint = createRotationConstraint(options);
    /**
     * @private
     * @type {Constraints}
     */

    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint
    };
    this.setRotation(options.rotation !== undefined ? options.rotation : 0);
    this.setCenterInternal(options.center !== undefined ? options.center : null);

    if (options.resolution !== undefined) {
      this.setResolution(options.resolution);
    } else if (options.zoom !== undefined) {
      this.setZoom(options.zoom);
    }
  };

  Object.defineProperty(View.prototype, "padding", {
    /**
     * Padding (in css pixels).
     * If the map viewport is partially covered with other content (overlays) along
     * its edges, this setting allows to shift the center of the viewport away from that
     * content. The order of the values in the array is top, right, bottom, left.
     * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
     * @type {Array<number>|undefined}
     * @api
     */
    get: function get() {
      return this.padding_;
    },
    set: function set(padding) {
      var oldPadding = this.padding_;
      this.padding_ = padding;
      var center = this.getCenter();

      if (center) {
        var newPadding = padding || [0, 0, 0, 0];
        oldPadding = oldPadding || [0, 0, 0, 0];
        var resolution = this.getResolution();
        var offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
        var offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
        this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
      }
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */

  View.prototype.getUpdatedOptions_ = function (newOptions) {
    var options = this.getProperties(); // preserve resolution (or zoom)

    if (options.resolution !== undefined) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    } // preserve center


    options.center = this.getCenterInternal(); // preserve rotation

    options.rotation = this.getRotation();
    return (0,_obj_js__WEBPACK_IMPORTED_MODULE_1__.assign)({}, options, newOptions);
  };
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:wg/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */


  View.prototype.animate = function (var_args) {
    if (this.isDef() && !this.getAnimating()) {
      this.resolveConstraints(0);
    }

    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; ++i) {
      var options = arguments[i];

      if (options.center) {
        options = (0,_obj_js__WEBPACK_IMPORTED_MODULE_1__.assign)({}, options);
        options.center = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(options.center, this.getProjection());
      }

      if (options.anchor) {
        options = (0,_obj_js__WEBPACK_IMPORTED_MODULE_1__.assign)({}, options);
        options.anchor = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(options.anchor, this.getProjection());
      }

      args[i] = options;
    }

    this.animateInternal.apply(this, args);
  };
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */


  View.prototype.animateInternal = function (var_args) {
    var animationCount = arguments.length;
    var callback;

    if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
      callback = arguments[animationCount - 1];
      --animationCount;
    }

    var i = 0;

    for (; i < animationCount && !this.isDef(); ++i) {
      // if view properties are not yet set, shortcut to the final state
      var state = arguments[i];

      if (state.center) {
        this.setCenterInternal(state.center);
      }

      if (state.zoom !== undefined) {
        this.setZoom(state.zoom);
      } else if (state.resolution) {
        this.setResolution(state.resolution);
      }

      if (state.rotation !== undefined) {
        this.setRotation(state.rotation);
      }
    }

    if (i === animationCount) {
      if (callback) {
        animationCallback(callback, true);
      }

      return;
    }

    var start = Date.now();
    var center = this.targetCenter_.slice();
    var resolution = this.targetResolution_;
    var rotation = this.targetRotation_;
    var series = [];

    for (; i < animationCount; ++i) {
      var options =
      /** @type {AnimationOptions} */
      arguments[i];
      var animation = {
        start: start,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== undefined ? options.duration : 1000,
        easing: options.easing || _easing_js__WEBPACK_IMPORTED_MODULE_3__.inAndOut,
        callback: callback
      };

      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center.slice();
        center = animation.targetCenter;
      }

      if (options.zoom !== undefined) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this.getResolutionForZoom(options.zoom);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }

      if (options.rotation !== undefined) {
        animation.sourceRotation = rotation;
        var delta = (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.modulo)(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      } // check if animation is a no-op


      if (isNoopAnimation(animation)) {
        animation.complete = true; // we still push it onto the series for callback handling
      } else {
        start += animation.duration;
      }

      series.push(animation);
    }

    this.animations_.push(series);
    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING, 1);
    this.updateAnimations_();
  };
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */


  View.prototype.getAnimating = function () {
    return this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING] > 0;
  };
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */


  View.prototype.getInteracting = function () {
    return this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].INTERACTING] > 0;
  };
  /**
   * Cancel any ongoing animations.
   * @api
   */


  View.prototype.cancelAnimations = function () {
    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING, -this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING]);
    var anchor;

    for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
      var series = this.animations_[i];

      if (series[0].callback) {
        animationCallback(series[0].callback, false);
      }

      if (!anchor) {
        for (var j = 0, jj = series.length; j < jj; ++j) {
          var animation = series[j];

          if (!animation.complete) {
            anchor = animation.anchor;
            break;
          }
        }
      }
    }

    this.animations_.length = 0;
    this.cancelAnchor_ = anchor;
    this.nextCenter_ = null;
    this.nextResolution_ = NaN;
    this.nextRotation_ = NaN;
  };
  /**
   * Update all animations.
   */


  View.prototype.updateAnimations_ = function () {
    if (this.updateAnimationKey_ !== undefined) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = undefined;
    }

    if (!this.getAnimating()) {
      return;
    }

    var now = Date.now();
    var more = false;

    for (var i = this.animations_.length - 1; i >= 0; --i) {
      var series = this.animations_[i];
      var seriesComplete = true;

      for (var j = 0, jj = series.length; j < jj; ++j) {
        var animation = series[j];

        if (animation.complete) {
          continue;
        }

        var elapsed = now - animation.start;
        var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;

        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }

        var progress = animation.easing(fraction);

        if (animation.sourceCenter) {
          var x0 = animation.sourceCenter[0];
          var y0 = animation.sourceCenter[1];
          var x1 = animation.targetCenter[0];
          var y1 = animation.targetCenter[1];
          this.nextCenter_ = animation.targetCenter;
          var x = x0 + progress * (x1 - x0);
          var y = y0 + progress * (y1 - y0);
          this.targetCenter_ = [x, y];
        }

        if (animation.sourceResolution && animation.targetResolution) {
          var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);

          if (animation.anchor) {
            var size = this.getViewportSize_(this.getRotation());
            var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
            this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
          }

          this.nextResolution_ = animation.targetResolution;
          this.targetResolution_ = resolution;
          this.applyTargetState_(true);
        }

        if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
          var rotation = progress === 1 ? (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.modulo)(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);

          if (animation.anchor) {
            var constrainedRotation = this.constraints_.rotation(rotation, true);
            this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
          }

          this.nextRotation_ = animation.targetRotation;
          this.targetRotation_ = rotation;
        }

        this.applyTargetState_(true);
        more = true;

        if (!animation.complete) {
          break;
        }
      }

      if (seriesComplete) {
        this.animations_[i] = null;
        this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING, -1);
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
        var callback = series[0].callback;

        if (callback) {
          animationCallback(callback, true);
        }
      }
    } // prune completed series


    this.animations_ = this.animations_.filter(Boolean);

    if (more && this.updateAnimationKey_ === undefined) {
      this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
    }
  };
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */


  View.prototype.calculateCenterRotate = function (rotation, anchor) {
    var center;
    var currentCenter = this.getCenterInternal();

    if (currentCenter !== undefined) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_6__.rotate)(center, rotation - this.getRotation());
      (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_6__.add)(center, anchor);
    }

    return center;
  };
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */


  View.prototype.calculateCenterZoom = function (resolution, anchor) {
    var center;
    var currentCenter = this.getCenterInternal();
    var currentResolution = this.getResolution();

    if (currentCenter !== undefined && currentResolution !== undefined) {
      var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
      var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
      center = [x, y];
    }

    return center;
  };
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [opt_rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */


  View.prototype.getViewportSize_ = function (opt_rotation) {
    var size = this.viewportSize_;

    if (opt_rotation) {
      var w = size[0];
      var h = size[1];
      return [Math.abs(w * Math.cos(opt_rotation)) + Math.abs(h * Math.sin(opt_rotation)), Math.abs(w * Math.sin(opt_rotation)) + Math.abs(h * Math.cos(opt_rotation))];
    } else {
      return size;
    }
  };
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [opt_size] Viewport size; if undefined, [100, 100] is assumed
   */


  View.prototype.setViewportSize = function (opt_size) {
    this.viewportSize_ = Array.isArray(opt_size) ? opt_size.slice() : [100, 100];

    if (!this.getAnimating()) {
      this.resolveConstraints(0);
    }
  };
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */


  View.prototype.getCenter = function () {
    var center = this.getCenterInternal();

    if (!center) {
      return center;
    }

    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)(center, this.getProjection());
  };
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */


  View.prototype.getCenterInternal = function () {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].CENTER)
    );
  };
  /**
   * @return {Constraints} Constraints.
   */


  View.prototype.getConstraints = function () {
    return this.constraints_;
  };
  /**
   * @return {boolean} Resolution constraint is set
   */


  View.prototype.getConstrainResolution = function () {
    return this.get('constrainResolution');
  };
  /**
   * @param {Array<number>} [opt_hints] Destination array.
   * @return {Array<number>} Hint.
   */


  View.prototype.getHints = function (opt_hints) {
    if (opt_hints !== undefined) {
      opt_hints[0] = this.hints_[0];
      opt_hints[1] = this.hints_[1];
      return opt_hints;
    } else {
      return this.hints_.slice();
    }
  };
  /**
   * Calculate the extent for the current view state and the passed size.
   * The size is the pixel dimensions of the box into which the calculated extent
   * should fit. In most cases you want to get the extent of the entire map,
   * that is `map.getSize()`.
   * @param {import("./size.js").Size} [opt_size] Box pixel size. If not provided, the size
   * of the map that uses this view will be used.
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */


  View.prototype.calculateExtent = function (opt_size) {
    var extent = this.calculateExtentInternal(opt_size);
    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)(extent, this.getProjection());
  };
  /**
   * @param {import("./size.js").Size} [opt_size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */


  View.prototype.calculateExtentInternal = function (opt_size) {
    var size = opt_size || this.getViewportSizeMinusPadding_();
    var center =
    /** @type {!import("./coordinate.js").Coordinate} */
    this.getCenterInternal();
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(center, 1); // The view center is not defined

    var resolution =
    /** @type {!number} */
    this.getResolution();
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(resolution !== undefined, 2); // The view resolution is not defined

    var rotation =
    /** @type {!number} */
    this.getRotation();
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(rotation !== undefined, 3); // The view rotation is not defined

    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getForViewAndSize)(center, resolution, rotation, size);
  };
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */


  View.prototype.getMaxResolution = function () {
    return this.maxResolution_;
  };
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */


  View.prototype.getMinResolution = function () {
    return this.minResolution_;
  };
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */


  View.prototype.getMaxZoom = function () {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  };
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */


  View.prototype.setMaxZoom = function (zoom) {
    this.applyOptions_(this.getUpdatedOptions_({
      maxZoom: zoom
    }));
  };
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */


  View.prototype.getMinZoom = function () {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  };
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */


  View.prototype.setMinZoom = function (zoom) {
    this.applyOptions_(this.getUpdatedOptions_({
      minZoom: zoom
    }));
  };
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */


  View.prototype.setConstrainResolution = function (enabled) {
    this.applyOptions_(this.getUpdatedOptions_({
      constrainResolution: enabled
    }));
  };
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */


  View.prototype.getProjection = function () {
    return this.projection_;
  };
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */


  View.prototype.getResolution = function () {
    return (
      /** @type {number|undefined} */
      this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].RESOLUTION)
    );
  };
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */


  View.prototype.getResolutions = function () {
    return this.resolutions_;
  };
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [opt_size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */


  View.prototype.getResolutionForExtent = function (extent, opt_size) {
    return this.getResolutionForExtentInternal((0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(extent, this.getProjection()), opt_size);
  };
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [opt_size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */


  View.prototype.getResolutionForExtentInternal = function (extent, opt_size) {
    var size = opt_size || this.getViewportSizeMinusPadding_();
    var xResolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getWidth)(extent) / size[0];
    var yResolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getHeight)(extent) / size[1];
    return Math.max(xResolution, yResolution);
  };
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [opt_power] Power.
   * @return {function(number): number} Resolution for value function.
   */


  View.prototype.getResolutionForValueFunction = function (opt_power) {
    var power = opt_power || 2;
    var maxResolution = this.getConstrainedResolution(this.maxResolution_);
    var minResolution = this.minResolution_;
    var max = Math.log(maxResolution / minResolution) / Math.log(power);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function (value) {
        var resolution = maxResolution / Math.pow(power, value * max);
        return resolution;
      }
    );
  };
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */


  View.prototype.getRotation = function () {
    return (
      /** @type {number} */
      this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].ROTATION)
    );
  };
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [opt_power] Power.
   * @return {function(number): number} Value for resolution function.
   */


  View.prototype.getValueForResolutionFunction = function (opt_power) {
    var logPower = Math.log(opt_power || 2);
    var maxResolution = this.getConstrainedResolution(this.maxResolution_);
    var minResolution = this.minResolution_;
    var max = Math.log(maxResolution / minResolution) / logPower;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function (resolution) {
        var value = Math.log(maxResolution / resolution) / logPower / max;
        return value;
      }
    );
  };
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [opt_rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */


  View.prototype.getViewportSizeMinusPadding_ = function (opt_rotation) {
    var size = this.getViewportSize_(opt_rotation);
    var padding = this.padding_;

    if (padding) {
      size = [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]];
    }

    return size;
  };
  /**
   * @return {State} View state.
   */


  View.prototype.getState = function () {
    var projection = this.getProjection();
    var resolution = this.getResolution();
    var rotation = this.getRotation();
    var center =
    /** @type {import("./coordinate.js").Coordinate} */
    this.getCenterInternal();
    var padding = this.padding_;

    if (padding) {
      var reducedSize = this.getViewportSizeMinusPadding_();
      center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
    }

    return {
      center: center.slice(0),
      projection: projection !== undefined ? projection : null,
      resolution: resolution,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: rotation,
      zoom: this.getZoom()
    };
  };
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */


  View.prototype.getZoom = function () {
    var zoom;
    var resolution = this.getResolution();

    if (resolution !== undefined) {
      zoom = this.getZoomForResolution(resolution);
    }

    return zoom;
  };
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */


  View.prototype.getZoomForResolution = function (resolution) {
    var offset = this.minZoom_ || 0;
    var max, zoomFactor;

    if (this.resolutions_) {
      var nearest = (0,_array_js__WEBPACK_IMPORTED_MODULE_9__.linearFindNearest)(this.resolutions_, resolution, 1);
      offset = nearest;
      max = this.resolutions_[nearest];

      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max / this.resolutions_[nearest + 1];
      }
    } else {
      max = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }

    return offset + Math.log(max / resolution) / Math.log(zoomFactor);
  };
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */


  View.prototype.getResolutionForZoom = function (zoom) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1) {
        return 0;
      }

      var baseLevel = (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.clamp)(Math.floor(zoom), 0, this.resolutions_.length - 2);
      var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
      return this.resolutions_[baseLevel] / Math.pow(zoomFactor, (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.clamp)(zoom - baseLevel, 0, 1));
    } else {
      return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
    }
  };
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [opt_options] Options.
   * @api
   */


  View.prototype.fit = function (geometryOrExtent, opt_options) {
    /** @type {import("./geom/SimpleGeometry.js").default} */
    var geometry;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(Array.isArray(geometryOrExtent) || typeof
    /** @type {?} */
    geometryOrExtent.getSimplifiedGeometry === 'function', 24); // Invalid extent or geometry provided as `geometry`

    if (Array.isArray(geometryOrExtent)) {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(!(0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.isEmpty)(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`

      var extent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(geometryOrExtent, this.getProjection());
      geometry = (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_10__.fromExtent)(extent);
    } else if (geometryOrExtent.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].CIRCLE) {
      var extent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(geometryOrExtent.getExtent(), this.getProjection());
      geometry = (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_10__.fromExtent)(extent);
      geometry.rotate(this.getRotation(), (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getCenter)(extent));
    } else {
      var userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();

      if (userProjection) {
        geometry =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometryOrExtent.clone().transform(userProjection, this.getProjection());
      } else {
        geometry = geometryOrExtent;
      }
    }

    this.fitInternal(geometry, opt_options);
  };
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */


  View.prototype.rotatedExtentForGeometry = function (geometry) {
    var rotation = this.getRotation();
    var cosAngle = Math.cos(rotation);
    var sinAngle = Math.sin(-rotation);
    var coords = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    var minRotX = +Infinity;
    var minRotY = +Infinity;
    var maxRotX = -Infinity;
    var maxRotY = -Infinity;

    for (var i = 0, ii = coords.length; i < ii; i += stride) {
      var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
      var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    }

    return [minRotX, minRotY, maxRotX, maxRotY];
  };
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [opt_options] Options.
   */


  View.prototype.fitInternal = function (geometry, opt_options) {
    var options = opt_options || {};
    var size = options.size;

    if (!size) {
      size = this.getViewportSizeMinusPadding_();
    }

    var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
    var nearest = options.nearest !== undefined ? options.nearest : false;
    var minResolution;

    if (options.minResolution !== undefined) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== undefined) {
      minResolution = this.getResolutionForZoom(options.maxZoom);
    } else {
      minResolution = 0;
    }

    var rotatedExtent = this.rotatedExtentForGeometry(geometry); // calculate resolution

    var resolution = this.getResolutionForExtentInternal(rotatedExtent, [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
    resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1); // calculate center

    var rotation = this.getRotation();
    var sinAngle = Math.sin(rotation);
    var cosAngle = Math.cos(rotation);
    var centerRot = (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getCenter)(rotatedExtent);
    centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
    centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
    var centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
    var centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
    var center = this.getConstrainedCenter([centerX, centerY], resolution);
    var callback = options.callback ? options.callback : _functions_js__WEBPACK_IMPORTED_MODULE_12__.VOID;

    if (options.duration !== undefined) {
      this.animateInternal({
        resolution: resolution,
        center: center,
        duration: options.duration,
        easing: options.easing
      }, callback);
    } else {
      this.targetResolution_ = resolution;
      this.targetCenter_ = center;
      this.applyTargetState_(false, true);
      animationCallback(callback, true);
    }
  };
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */


  View.prototype.centerOn = function (coordinate, size, position) {
    this.centerOnInternal((0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(coordinate, this.getProjection()), size, position);
  };
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */


  View.prototype.centerOnInternal = function (coordinate, size, position) {
    this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
  };
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */


  View.prototype.calculateCenterShift = function (center, resolution, rotation, size) {
    var centerShift;
    var padding = this.padding_;

    if (padding && center) {
      var reducedSize = this.getViewportSizeMinusPadding_(-rotation);
      var shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
      centerShift = [center[0] - shiftedCenter[0], center[1] - shiftedCenter[1]];
    }

    return centerShift;
  };
  /**
   * @return {boolean} Is defined.
   */


  View.prototype.isDef = function () {
    return !!this.getCenterInternal() && this.getResolution() !== undefined;
  };
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */


  View.prototype.adjustCenter = function (deltaCoordinates) {
    var center = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)(this.targetCenter_, this.getProjection());
    this.setCenter([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);
  };
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */


  View.prototype.adjustCenterInternal = function (deltaCoordinates) {
    var center = this.targetCenter_;
    this.setCenterInternal([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);
  };
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
   * @api
   */


  View.prototype.adjustResolution = function (ratio, opt_anchor) {
    var anchor = opt_anchor && (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(opt_anchor, this.getProjection());
    this.adjustResolutionInternal(ratio, anchor);
  };
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
   */


  View.prototype.adjustResolutionInternal = function (ratio, opt_anchor) {
    var isMoving = this.getAnimating() || this.getInteracting();
    var size = this.getViewportSize_(this.getRotation());
    var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);

    if (opt_anchor) {
      this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);
    }

    this.targetResolution_ *= ratio;
    this.applyTargetState_();
  };
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
   * @api
   */


  View.prototype.adjustZoom = function (delta, opt_anchor) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);
  };
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [opt_anchor] The rotation center.
   * @api
   */


  View.prototype.adjustRotation = function (delta, opt_anchor) {
    if (opt_anchor) {
      opt_anchor = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(opt_anchor, this.getProjection());
    }

    this.adjustRotationInternal(delta, opt_anchor);
  };
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [opt_anchor] The rotation center.
   */


  View.prototype.adjustRotationInternal = function (delta, opt_anchor) {
    var isMoving = this.getAnimating() || this.getInteracting();
    var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);

    if (opt_anchor) {
      this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);
    }

    this.targetRotation_ += delta;
    this.applyTargetState_();
  };
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */


  View.prototype.setCenter = function (center) {
    this.setCenterInternal(center ? (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(center, this.getProjection()) : center);
  };
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */


  View.prototype.setCenterInternal = function (center) {
    this.targetCenter_ = center;
    this.applyTargetState_();
  };
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */


  View.prototype.setHint = function (hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  };
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */


  View.prototype.setResolution = function (resolution) {
    this.targetResolution_ = resolution;
    this.applyTargetState_();
  };
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */


  View.prototype.setRotation = function (rotation) {
    this.targetRotation_ = rotation;
    this.applyTargetState_();
  };
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */


  View.prototype.setZoom = function (zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  };
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [opt_doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [opt_forceMoving] Apply constraints as if the view is moving.
   * @private
   */


  View.prototype.applyTargetState_ = function (opt_doNotCancelAnims, opt_forceMoving) {
    var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving; // compute rotation

    var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
    var size = this.getViewportSize_(newRotation);
    var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
    var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));

    if (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].ROTATION) !== newRotation) {
      this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].ROTATION, newRotation);
    }

    if (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].RESOLUTION) !== newResolution) {
      this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].RESOLUTION, newResolution);
      this.set('zoom', this.getZoom(), true);
    }

    if (!newCenter || !this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].CENTER) || !(0,_coordinate_js__WEBPACK_IMPORTED_MODULE_6__.equals)(this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].CENTER), newCenter)) {
      this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].CENTER, newCenter);
    }

    if (this.getAnimating() && !opt_doNotCancelAnims) {
      this.cancelAnimations();
    }

    this.cancelAnchor_ = undefined;
  };
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [opt_duration] The animation duration in ms.
   * @param {number} [opt_resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
   */


  View.prototype.resolveConstraints = function (opt_duration, opt_resolutionDirection, opt_anchor) {
    var duration = opt_duration !== undefined ? opt_duration : 200;
    var direction = opt_resolutionDirection || 0;
    var newRotation = this.constraints_.rotation(this.targetRotation_);
    var size = this.getViewportSize_(newRotation);
    var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
    var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));

    if (duration === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = newResolution;
      this.targetRotation_ = newRotation;
      this.targetCenter_ = newCenter;
      this.applyTargetState_();
      return;
    }

    var anchor = opt_anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
    this.cancelAnchor_ = undefined;

    if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !(0,_coordinate_js__WEBPACK_IMPORTED_MODULE_6__.equals)(this.getCenterInternal(), newCenter)) {
      if (this.getAnimating()) {
        this.cancelAnimations();
      }

      this.animateInternal({
        rotation: newRotation,
        center: newCenter,
        resolution: newResolution,
        duration: duration,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_3__.easeOut,
        anchor: anchor
      });
    }
  };
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */


  View.prototype.beginInteraction = function () {
    this.resolveConstraints(0);
    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].INTERACTING, 1);
  };
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [opt_duration] Animation duration in ms.
   * @param {number} [opt_resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
   * @api
   */


  View.prototype.endInteraction = function (opt_duration, opt_resolutionDirection, opt_anchor) {
    var anchor = opt_anchor && (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(opt_anchor, this.getProjection());
    this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);
  };
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [opt_duration] Animation duration in ms.
   * @param {number} [opt_resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
   */


  View.prototype.endInteractionInternal = function (opt_duration, opt_resolutionDirection, opt_anchor) {
    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].INTERACTING, -1);
    this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);
  };
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [opt_targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */


  View.prototype.getConstrainedCenter = function (targetCenter, opt_targetResolution) {
    var size = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);
  };
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [opt_direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */


  View.prototype.getConstrainedZoom = function (targetZoom, opt_direction) {
    var targetRes = this.getResolutionForZoom(targetZoom);
    return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));
  };
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [opt_direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */


  View.prototype.getConstrainedResolution = function (targetResolution, opt_direction) {
    var direction = opt_direction || 0;
    var size = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(targetResolution, direction, size);
  };

  return View;
}(_Object_js__WEBPACK_IMPORTED_MODULE_13__["default"]);
/**
 * @param {Function} callback Callback.
 * @param {*} returnValue Return value.
 */


function animationCallback(callback, returnValue) {
  setTimeout(function () {
    callback(returnValue);
  }, 0);
}
/**
 * @param {ViewOptions} options View options.
 * @return {import("./centerconstraint.js").Type} The constraint.
 */


function createCenterConstraint(options) {
  if (options.extent !== undefined) {
    var smooth = options.smoothExtentConstraint !== undefined ? options.smoothExtentConstraint : true;
    return (0,_centerconstraint_js__WEBPACK_IMPORTED_MODULE_14__.createExtent)(options.extent, options.constrainOnlyCenter, smooth);
  }

  var projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.createProjection)(options.projection, 'EPSG:3857');

  if (options.multiWorld !== true && projection.isGlobal()) {
    var extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return (0,_centerconstraint_js__WEBPACK_IMPORTED_MODULE_14__.createExtent)(extent, false, false);
  }

  return _centerconstraint_js__WEBPACK_IMPORTED_MODULE_14__.none;
}
/**
 * @param {ViewOptions} options View options.
 * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
 *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
 */

function createResolutionConstraint(options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution; // TODO: move these to be ol constants
  // see https://github.com/openlayers/openlayers/issues/2076

  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;
  var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
  var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
  var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
  var multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
  var smooth = options.smoothResolutionConstraint !== undefined ? options.smoothResolutionConstraint : true;
  var showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
  var projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.createProjection)(options.projection, 'EPSG:3857');
  var projExtent = projection.getExtent();
  var constrainOnlyCenter = options.constrainOnlyCenter;
  var extent = options.extent;

  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }

  if (options.resolutions !== undefined) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];

    if (options.constrainResolution) {
      resolutionConstraint = (0,_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_15__.createSnapToResolutions)(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
      resolutionConstraint = (0,_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_15__.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
  } else {
    // calculate the default min and max resolution
    var size = !projExtent ? // use an extent that can fit the whole world if need be
    360 * _proj_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[_proj_Units_js__WEBPACK_IMPORTED_MODULE_16__["default"].DEGREES] / projection.getMetersPerUnit() : Math.max((0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getWidth)(projExtent), (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getHeight)(projExtent));
    var defaultMaxResolution = size / _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_17__.DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM); // user provided maxResolution takes precedence

    maxResolution = options.maxResolution;

    if (maxResolution !== undefined) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    } // user provided minResolution takes precedence


    minResolution = options.minResolution;

    if (minResolution === undefined) {
      if (options.maxZoom !== undefined) {
        if (options.maxResolution !== undefined) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    } // given discrete zoom levels, minResolution may be different than provided


    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);

    if (options.constrainResolution) {
      resolutionConstraint = (0,_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_15__.createSnapToPower)(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
      resolutionConstraint = (0,_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_15__.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
  }

  return {
    constraint: resolutionConstraint,
    maxResolution: maxResolution,
    minResolution: minResolution,
    minZoom: minZoom,
    zoomFactor: zoomFactor
  };
}
/**
 * @param {ViewOptions} options View options.
 * @return {import("./rotationconstraint.js").Type} Rotation constraint.
 */

function createRotationConstraint(options) {
  var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;

  if (enableRotation) {
    var constrainRotation = options.constrainRotation;

    if (constrainRotation === undefined || constrainRotation === true) {
      return (0,_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_18__.createSnapToZero)();
    } else if (constrainRotation === false) {
      return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_18__.none;
    } else if (typeof constrainRotation === 'number') {
      return (0,_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_18__.createSnapToN)(constrainRotation);
    } else {
      return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_18__.none;
    }
  } else {
    return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_18__.disable;
  }
}
/**
 * Determine if an animation involves no view change.
 * @param {Animation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */

function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!(0,_coordinate_js__WEBPACK_IMPORTED_MODULE_6__.equals)(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }

  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }

  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }

  return true;
}
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {import("./size.js").Size} size Box pixel size.
 * @param {import("./pixel.js").Pixel} position Position on the view to center on.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {import("./coordinate.js").Coordinate} Shifted center.
 */

function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  // calculate rotated position
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution; // go back to original angle

  sinAngle = -sinAngle; // go back to original rotation

  var centerX = rotX * cosAngle - rotY * sinAngle;
  var centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}

/* harmony default export */ __webpack_exports__["default"] = (View);

/***/ }),

/***/ "./build/wg/ViewHint.js":
/*!******************************!*\
  !*** ./build/wg/ViewHint.js ***!
  \******************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/ViewHint
 */

/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  ANIMATING: 0,
  INTERACTING: 1
});

/***/ }),

/***/ "./build/wg/ViewProperty.js":
/*!**********************************!*\
  !*** ./build/wg/ViewProperty.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/ViewProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  CENTER: 'center',
  RESOLUTION: 'resolution',
  ROTATION: 'rotation'
});

/***/ }),

/***/ "./build/wg/array.js":
/*!***************************!*\
  !*** ./build/wg/array.js ***!
  \***************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "binarySearch": function() { return /* binding */ binarySearch; },
/* harmony export */   "numberSafeCompareFunction": function() { return /* binding */ numberSafeCompareFunction; },
/* harmony export */   "includes": function() { return /* binding */ includes; },
/* harmony export */   "linearFindNearest": function() { return /* binding */ linearFindNearest; },
/* harmony export */   "reverseSubArray": function() { return /* binding */ reverseSubArray; },
/* harmony export */   "extend": function() { return /* binding */ extend; },
/* harmony export */   "remove": function() { return /* binding */ remove; },
/* harmony export */   "find": function() { return /* binding */ find; },
/* harmony export */   "equals": function() { return /* binding */ equals; },
/* harmony export */   "stableSort": function() { return /* binding */ stableSort; },
/* harmony export */   "findIndex": function() { return /* binding */ findIndex; },
/* harmony export */   "isSorted": function() { return /* binding */ isSorted; }
/* harmony export */ });
/**
 * @module wg/array
 */

/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function} [opt_comparator] Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function binarySearch(haystack, needle, opt_comparator) {
  var mid, cmp;
  var comparator = opt_comparator || numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) {
      /* Too low. */
      low = mid + 1;
    } else {
      /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }
  /* Key not found. */


  return found ? low : ~low;
}
/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */

function numberSafeCompareFunction(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
/**
 * Whether the array contains the given object.
 * @param {Array<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */

function includes(arr, obj) {
  return arr.indexOf(obj) >= 0;
}
/**
 * {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function
 * of this type to determine which nearest resolution to use.
 *
 * This function takes a `{number}` representing a value between two array entries,
 * a `{number}` representing the value of the nearest higher entry and
 * a `{number}` representing the value of the nearest lower entry
 * as arguments and returns a `{number}`. If a negative number or zero is returned
 * the lower value will be used, if a positive number is returned the higher value
 * will be used.
 * @typedef {function(number, number, number): number} NearestDirectionFunction
 * @api
 */

/**
 * @param {Array<number>} arr Array in descending order.
 * @param {number} target Target.
 * @param {number|NearestDirectionFunction} direction
 *    0 means return the nearest,
 *    > 0 means return the largest nearest,
 *    < 0 means return the smallest nearest.
 * @return {number} Index.
 */

function linearFindNearest(arr, target, direction) {
  var n = arr.length;

  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n - 1]) {
    return n - 1;
  } else {
    var i = void 0;

    if (direction > 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] < target) {
          return i - 1;
        }
      }
    } else if (direction < 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] <= target) {
          return i;
        }
      }
    } else {
      for (i = 1; i < n; ++i) {
        if (arr[i] == target) {
          return i;
        } else if (arr[i] < target) {
          if (typeof direction === 'function') {
            if (direction(target, arr[i - 1], arr[i]) > 0) {
              return i - 1;
            } else {
              return i;
            }
          } else if (arr[i - 1] - target < target - arr[i]) {
            return i - 1;
          } else {
            return i;
          }
        }
      }
    }

    return n - 1;
  }
}
/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */

function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */

function extend(arr, data) {
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;

  for (var i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */

function remove(arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;

  if (found) {
    arr.splice(i, 1);
  }

  return found;
}
/**
 * @param {Array<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE|null} The element found or null.
 */

function find(arr, func) {
  var length = arr.length >>> 0;
  var value;

  for (var i = 0; i < length; i++) {
    value = arr[i];

    if (func(value, i, arr)) {
      return value;
    }
  }

  return null;
}
/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */

function equals(arr1, arr2) {
  var len1 = arr1.length;

  if (len1 !== arr2.length) {
    return false;
  }

  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
}
/**
 * Sort the passed array such that the relative order of equal elements is preserved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */

function stableSort(arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i;

  for (i = 0; i < length; i++) {
    tmp[i] = {
      index: i,
      value: arr[i]
    };
  }

  tmp.sort(function (a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });

  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}
/**
 * @param {Array<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */

function findIndex(arr, func) {
  var index;
  var found = !arr.every(function (el, idx) {
    index = idx;
    return !func(el, idx, arr);
  });
  return found ? index : -1;
}
/**
 * @param {Array<*>} arr The array to test.
 * @param {Function} [opt_func] Comparison function.
 * @param {boolean} [opt_strict] Strictly sorted (default false).
 * @return {boolean} Return index.
 */

function isSorted(arr, opt_func, opt_strict) {
  var compare = opt_func || numberSafeCompareFunction;
  return arr.every(function (currentVal, index) {
    if (index === 0) {
      return true;
    }

    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
}

/***/ }),

/***/ "./build/wg/asserts.js":
/*!*****************************!*\
  !*** ./build/wg/asserts.js ***!
  \*****************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": function() { return /* binding */ assert; }
/* harmony export */ });
/* harmony import */ var _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AssertionError.js */ "./build/wg/AssertionError.js");
/**
 * @module wg/asserts
 */

/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */

function assert(assertion, errorCode) {
  if (!assertion) {
    throw new _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__["default"](errorCode);
  }
}

/***/ }),

/***/ "./build/wg/centerconstraint.js":
/*!**************************************!*\
  !*** ./build/wg/centerconstraint.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createExtent": function() { return /* binding */ createExtent; },
/* harmony export */   "none": function() { return /* binding */ none; }
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./build/wg/math.js");
/**
 * @module wg/centerconstraint
 */

/**
 * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=, Array<number>=): (import("./coordinate.js").Coordinate|undefined)} Type
 */

/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
 * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
 * (only during interaction and animation).
 * @return {Type} The constraint.
 */

function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [opt_centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function (center, resolution, size, opt_isMoving, opt_centerShift) {
      if (!center) {
        return undefined;
      }

      if (!resolution && !onlyCenter) {
        return center;
      }

      var viewWidth = onlyCenter ? 0 : size[0] * resolution;
      var viewHeight = onlyCenter ? 0 : size[1] * resolution;
      var shiftX = opt_centerShift ? opt_centerShift[0] : 0;
      var shiftY = opt_centerShift ? opt_centerShift[1] : 0;
      var minX = extent[0] + viewWidth / 2 + shiftX;
      var maxX = extent[2] - viewWidth / 2 + shiftX;
      var minY = extent[1] + viewHeight / 2 + shiftY;
      var maxY = extent[3] - viewHeight / 2 + shiftY; // note: when zooming out of bounds, min and max values for x and y may
      // end up inverted (min > max); this has to be accounted for

      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }

      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }

      var x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.clamp)(center[0], minX, maxX);
      var y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.clamp)(center[1], minY, maxY); // during an interaction, allow some overscroll

      if (opt_isMoving && smooth && resolution) {
        var ratio = 30 * resolution;
        x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }

      return [x, y];
    }
  );
}
/**
 * @param {import("./coordinate.js").Coordinate} [center] Center.
 * @return {import("./coordinate.js").Coordinate|undefined} Center.
 */

function none(center) {
  return center;
}

/***/ }),

/***/ "./build/wg/color.js":
/*!***************************!*\
  !*** ./build/wg/color.js ***!
  \***************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "asString": function() { return /* binding */ asString; },
/* harmony export */   "fromString": function() { return /* binding */ fromString; },
/* harmony export */   "asArray": function() { return /* binding */ asArray; },
/* harmony export */   "normalize": function() { return /* binding */ normalize; },
/* harmony export */   "toString": function() { return /* binding */ toString; },
/* harmony export */   "isStringColor": function() { return /* binding */ isStringColor; }
/* harmony export */ });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./build/wg/math.js");
/**
 * @module wg/color
 */


/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */

/**
 * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */

var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */

var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
/**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */

function asString(color) {
  if (typeof color === 'string') {
    return color;
  } else {
    return toString(color);
  }
}
/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */

function fromNamed(color) {
  var el = document.createElement('div');
  el.style.color = color;

  if (el.style.color !== '') {
    document.body.appendChild(el);
    var rgb = getComputedStyle(el).color;
    document.body.removeChild(el);
    return rgb;
  } else {
    return '';
  }
}
/**
 * @param {string} s String.
 * @return {Color} Color.
 */


var fromString = function () {
  // We maintain a small cache of parsed strings.  To provide cheap LRU-like
  // semantics, whenever the cache grows too large we simply delete an
  // arbitrary 25% of the entries.

  /**
   * @const
   * @type {number}
   */
  var MAX_CACHE_SIZE = 1024;
  /**
   * @type {Object<string, Color>}
   */

  var cache = {};
  /**
   * @type {number}
   */

  var cacheSize = 0;
  return (
    /**
     * @param {string} s String.
     * @return {Color} Color.
     */
    function (s) {
      var color;

      if (cache.hasOwnProperty(s)) {
        color = cache[s];
      } else {
        if (cacheSize >= MAX_CACHE_SIZE) {
          var i = 0;

          for (var key in cache) {
            if ((i++ & 3) === 0) {
              delete cache[key];
              --cacheSize;
            }
          }
        }

        color = fromStringInternal_(s);
        cache[s] = color;
        ++cacheSize;
      }

      return color;
    }
  );
}();
/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */

function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    return fromString(color);
  }
}
/**
 * @param {string} s String.
 * @private
 * @return {Color} Color.
 */

function fromStringInternal_(s) {
  var r, g, b, a, color;

  if (NAMED_COLOR_RE_.exec(s)) {
    s = fromNamed(s);
  }

  if (HEX_COLOR_RE_.exec(s)) {
    // hex
    var n = s.length - 1; // number of hex digits

    var d = // number of digits per channel
    void 0; // number of digits per channel

    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }

    var hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);

    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }

    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;

      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }

    color = [r, g, b, a / 255];
  } else if (s.indexOf('rgba(') == 0) {
    // rgba()
    color = s.slice(5, -1).split(',').map(Number);
    normalize(color);
  } else if (s.indexOf('rgb(') == 0) {
    // rgb()
    color = s.slice(4, -1).split(',').map(Number);
    color.push(1);
    normalize(color);
  } else {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 14); // Invalid color
  }

  return color;
}
/**
 * TODO this function is only used in the test, we probably shouldn't export it
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */


function normalize(color) {
  color[0] = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(color[0] + 0.5 | 0, 0, 255);
  color[1] = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(color[1] + 0.5 | 0, 0, 255);
  color[2] = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(color[2] + 0.5 | 0, 0, 255);
  color[3] = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(color[3], 0, 1);
  return color;
}
/**
 * @param {Color} color Color.
 * @return {string} String.
 */

function toString(color) {
  var r = color[0];

  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }

  var g = color[1];

  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }

  var b = color[2];

  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }

  var a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}
/**
 * @param {string} s String.
 * @return {boolean} Whether the string is actually a valid color
 */

function isStringColor(s) {
  if (NAMED_COLOR_RE_.test(s)) {
    s = fromNamed(s);
  }

  return HEX_COLOR_RE_.test(s) || s.indexOf('rgba(') === 0 || s.indexOf('rgb(') === 0;
}

/***/ }),

/***/ "./build/wg/colorlike.js":
/*!*******************************!*\
  !*** ./build/wg/colorlike.js ***!
  \*******************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "asColorLike": function() { return /* binding */ asColorLike; }
/* harmony export */ });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./build/wg/color.js");
/**
 * @module wg/colorlike
 */

/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */

/**
 * @param {import("./color.js").Color|ColorLike} color Color.
 * @return {ColorLike} The color as an {@link wg/colorlike~ColorLike}.
 * @api
 */

function asColorLike(color) {
  if (Array.isArray(color)) {
    return (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.toString)(color);
  } else {
    return color;
  }
}

/***/ }),

/***/ "./build/wg/control.js":
/*!*****************************!*\
  !*** ./build/wg/control.js ***!
  \*****************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Attribution": function() { return /* reexport safe */ _control_Attribution_js__WEBPACK_IMPORTED_MODULE_0__["default"]; },
/* harmony export */   "Control": function() { return /* reexport safe */ _control_Control_js__WEBPACK_IMPORTED_MODULE_1__["default"]; },
/* harmony export */   "FullScreen": function() { return /* reexport safe */ _control_FullScreen_js__WEBPACK_IMPORTED_MODULE_2__["default"]; },
/* harmony export */   "MousePosition": function() { return /* reexport safe */ _control_MousePosition_js__WEBPACK_IMPORTED_MODULE_3__["default"]; },
/* harmony export */   "OverviewMap": function() { return /* reexport safe */ _control_OverviewMap_js__WEBPACK_IMPORTED_MODULE_4__["default"]; },
/* harmony export */   "Rotate": function() { return /* reexport safe */ _control_Rotate_js__WEBPACK_IMPORTED_MODULE_5__["default"]; },
/* harmony export */   "ScaleLine": function() { return /* reexport safe */ _control_ScaleLine_js__WEBPACK_IMPORTED_MODULE_6__["default"]; },
/* harmony export */   "Zoom": function() { return /* reexport safe */ _control_Zoom_js__WEBPACK_IMPORTED_MODULE_7__["default"]; },
/* harmony export */   "ZoomSlider": function() { return /* reexport safe */ _control_ZoomSlider_js__WEBPACK_IMPORTED_MODULE_8__["default"]; },
/* harmony export */   "ZoomToExtent": function() { return /* reexport safe */ _control_ZoomToExtent_js__WEBPACK_IMPORTED_MODULE_9__["default"]; },
/* harmony export */   "defaults": function() { return /* binding */ defaults; }
/* harmony export */ });
/* harmony import */ var _control_Attribution_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./control/Attribution.js */ "./build/wg/control/Attribution.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Collection.js */ "./build/wg/Collection.js");
/* harmony import */ var _control_Rotate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./control/Rotate.js */ "./build/wg/control/Rotate.js");
/* harmony import */ var _control_Zoom_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./control/Zoom.js */ "./build/wg/control/Zoom.js");
/* harmony import */ var _control_Control_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./control/Control.js */ "./build/wg/control/Control.js");
/* harmony import */ var _control_FullScreen_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./control/FullScreen.js */ "./build/wg/control/FullScreen.js");
/* harmony import */ var _control_MousePosition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./control/MousePosition.js */ "./build/wg/control/MousePosition.js");
/* harmony import */ var _control_OverviewMap_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./control/OverviewMap.js */ "./build/wg/control/OverviewMap.js");
/* harmony import */ var _control_ScaleLine_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./control/ScaleLine.js */ "./build/wg/control/ScaleLine.js");
/* harmony import */ var _control_ZoomSlider_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./control/ZoomSlider.js */ "./build/wg/control/ZoomSlider.js");
/* harmony import */ var _control_ZoomToExtent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./control/ZoomToExtent.js */ "./build/wg/control/ZoomToExtent.js");
/**
 * @module wg/control
 */














/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [attribution=true] Include
 * {@link module:wg/control/Attribution~Attribution}.
 * @property {import("./control/Attribution.js").Options} [attributionOptions]
 * Options for {@link module:wg/control/Attribution~Attribution}.
 * @property {boolean} [rotate=true] Include
 * {@link module:wg/control/Rotate~Rotate}.
 * @property {import("./control/Rotate.js").Options} [rotateOptions] Options
 * for {@link module:wg/control/Rotate~Rotate}.
 * @property {boolean} [zoom] Include {@link module:wg/control/Zoom~Zoom}.
 * @property {import("./control/Zoom.js").Options} [zoomOptions] Options for
 * {@link module:wg/control/Zoom~Zoom}.
 * @api
 */

/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link module:wg/control/Zoom~Zoom}
 * * {@link module:wg/control/Rotate~Rotate}
 * * {@link module:wg/control/Attribution~Attribution}
 *
 * @param {DefaultsOptions} [opt_options]
 * Defaults options.
 * @return {Collection<import("./control/Control.js").default>}
 * Controls.
 * @api
 */

function defaults(opt_options) {
  var options = opt_options ? opt_options : {};
  var controls = new _Collection_js__WEBPACK_IMPORTED_MODULE_10__["default"]();
  var zoomControl = options.zoom !== undefined ? options.zoom : true;

  if (zoomControl) {
    controls.push(new _control_Zoom_js__WEBPACK_IMPORTED_MODULE_7__["default"](options.zoomOptions));
  }

  var rotateControl = options.rotate !== undefined ? options.rotate : true;

  if (rotateControl) {
    controls.push(new _control_Rotate_js__WEBPACK_IMPORTED_MODULE_5__["default"](options.rotateOptions));
  }

  var attributionControl = options.attribution !== undefined ? options.attribution : true;

  if (attributionControl) {
    controls.push(new _control_Attribution_js__WEBPACK_IMPORTED_MODULE_0__["default"](options.attributionOptions));
  }

  return controls;
}

/***/ }),

/***/ "./build/wg/control/Attribution.js":
/*!*****************************************!*\
  !*** ./build/wg/control/Attribution.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Control.js */ "./build/wg/control/Control.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css.js */ "./build/wg/css.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../layer/Layer.js */ "./build/wg/layer/Layer.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom.js */ "./build/wg/dom.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/control/Attribution
 */








/**
 * @typedef {Object} Options
 * @property {string} [className='wg-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible] Specify if attributions can
 * be collapsed. If not specified, sources control this behavior with their
 * `attributionsCollapsible` setting.
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string|HTMLElement} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [expandClassName=className + '-expand'] CSS class name for the
 * collapsed attributions button.
 * @property {string|HTMLElement} [collapseLabel='›'] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the
 * expanded attributions button.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 */

/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */

var Attribution =
/** @class */
function (_super) {
  __extends(Attribution, _super);
  /**
   * @param {Options} [opt_options] Attribution options.
   */


  function Attribution(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render,
      target: options.target
    }) || this;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.ulElement_ = document.createElement('ul');
    /**
     * @private
     * @type {boolean}
     */

    _this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
    /**
     * @private
     * @type {boolean}
     */

    _this.userCollapsed_ = _this.collapsed_;
    /**
     * @private
     * @type {boolean}
     */

    _this.overrideCollapsible_ = options.collapsible !== undefined;
    /**
     * @private
     * @type {boolean}
     */

    _this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;

    if (!_this.collapsible_) {
      _this.collapsed_ = false;
    }

    var className = options.className !== undefined ? options.className : 'wg-attribution';
    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
    var expandClassName = options.expandClassName !== undefined ? options.expandClassName : className + '-expand';
    var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : "\u203A";
    var collapseClassName = options.collapseClassName !== undefined ? options.collapseClassName : className + '-collapse';

    if (typeof collapseLabel === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.collapseLabel_ = document.createElement('span');
      _this.collapseLabel_.textContent = collapseLabel;
      _this.collapseLabel_.className = collapseClassName;
    } else {
      _this.collapseLabel_ = collapseLabel;
    }

    var label = options.label !== undefined ? options.label : 'i';

    if (typeof label === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.label_ = document.createElement('span');
      _this.label_.textContent = label;
      _this.label_.className = expandClassName;
    } else {
      _this.label_ = label;
    }

    var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.toggleButton_ = document.createElement('button');

    _this.toggleButton_.setAttribute('type', 'button');

    _this.toggleButton_.setAttribute('aria-expanded', String(!_this.collapsed_));

    _this.toggleButton_.title = tipLabel;

    _this.toggleButton_.appendChild(activeLabel);

    _this.toggleButton_.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK, _this.handleClick_.bind(_this), false);

    var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_COLLAPSED : '') + (_this.collapsible_ ? '' : ' ol-uncollapsible');
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(_this.toggleButton_);
    element.appendChild(_this.ulElement_);
    /**
     * A list of currently rendered resolutions.
     * @type {Array<string>}
     * @private
     */

    _this.renderedAttributions_ = [];
    /**
     * @private
     * @type {boolean}
     */

    _this.renderedVisible_ = true;
    return _this;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */


  Attribution.prototype.collectSourceAttributions_ = function (frameState) {
    /**
     * Used to determine if an attribution already exists.
     * @type {!Object<string, boolean>}
     */
    var lookup = {};
    /**
     * A list of visible attributions.
     * @type {Array<string>}
     */

    var visibleAttributions = [];
    var collapsible = true;
    var layerStatesArray = frameState.layerStatesArray;

    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layerState = layerStatesArray[i];

      if (!(0,_layer_Layer_js__WEBPACK_IMPORTED_MODULE_2__.inView)(layerState, frameState.viewState)) {
        continue;
      }

      var source =
      /** @type {import("../layer/Layer.js").default} */
      layerState.layer.getSource();

      if (!source) {
        continue;
      }

      var attributionGetter = source.getAttributions();

      if (!attributionGetter) {
        continue;
      }

      var attributions = attributionGetter(frameState);

      if (!attributions) {
        continue;
      }

      collapsible = collapsible && source.getAttributionsCollapsible() !== false;

      if (Array.isArray(attributions)) {
        for (var j = 0, jj = attributions.length; j < jj; ++j) {
          if (!(attributions[j] in lookup)) {
            visibleAttributions.push(attributions[j]);
            lookup[attributions[j]] = true;
          }
        }
      } else {
        if (!(attributions in lookup)) {
          visibleAttributions.push(attributions);
          lookup[attributions] = true;
        }
      }
    }

    if (!this.overrideCollapsible_) {
      this.setCollapsible(collapsible);
    }

    return visibleAttributions;
  };
  /**
   * @private
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  Attribution.prototype.updateElement_ = function (frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
      }

      return;
    }

    var attributions = this.collectSourceAttributions_(frameState);
    var visible = attributions.length > 0;

    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? '' : 'none';
      this.renderedVisible_ = visible;
    }

    if ((0,_array_js__WEBPACK_IMPORTED_MODULE_3__.equals)(attributions, this.renderedAttributions_)) {
      return;
    }

    (0,_dom_js__WEBPACK_IMPORTED_MODULE_4__.removeChildren)(this.ulElement_); // append the attributions

    for (var i = 0, ii = attributions.length; i < ii; ++i) {
      var element = document.createElement('li');
      element.innerHTML = attributions[i];
      this.ulElement_.appendChild(element);
    }

    this.renderedAttributions_ = attributions;
  };
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  Attribution.prototype.handleClick_ = function (event) {
    event.preventDefault();
    this.handleToggle_();
    this.userCollapsed_ = this.collapsed_;
  };
  /**
   * @private
   */


  Attribution.prototype.handleToggle_ = function () {
    this.element.classList.toggle(_css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_COLLAPSED);

    if (this.collapsed_) {
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_4__.replaceNode)(this.collapseLabel_, this.label_);
    } else {
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_4__.replaceNode)(this.label_, this.collapseLabel_);
    }

    this.collapsed_ = !this.collapsed_;
    this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));
  };
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */


  Attribution.prototype.getCollapsible = function () {
    return this.collapsible_;
  };
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */


  Attribution.prototype.setCollapsible = function (collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }

    this.collapsible_ = collapsible;
    this.element.classList.toggle('wg-uncollapsible');

    if (this.userCollapsed_) {
      this.handleToggle_();
    }
  };
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */


  Attribution.prototype.setCollapsed = function (collapsed) {
    this.userCollapsed_ = collapsed;

    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }

    this.handleToggle_();
  };
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */


  Attribution.prototype.getCollapsed = function () {
    return this.collapsed_;
  };
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */


  Attribution.prototype.render = function (mapEvent) {
    this.updateElement_(mapEvent.frameState);
  };

  return Attribution;
}(_Control_js__WEBPACK_IMPORTED_MODULE_5__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Attribution);

/***/ }),

/***/ "./build/wg/control/Control.js":
/*!*************************************!*\
  !*** ./build/wg/control/Control.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Object.js */ "./build/wg/Object.js");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MapEventType.js */ "./build/wg/MapEventType.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./build/wg/events.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom.js */ "./build/wg/dom.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/control/Control
 */







/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * var myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:wg/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */

var Control =
/** @class */
function (_super) {
  __extends(Control, _super);
  /**
   * @param {Options} options Control options.
   */


  function Control(options) {
    var _this = _super.call(this) || this;

    var element = options.element;

    if (element && !options.target && !element.style.pointerEvents) {
      element.style.pointerEvents = 'auto';
    }
    /**
     * @protected
     * @type {HTMLElement}
     */


    _this.element = element ? element : null;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.target_ = null;
    /**
     * @private
     * @type {import("../PluggableMap.js").default|null}
     */

    _this.map_ = null;
    /**
     * @protected
     * @type {!Array<import("../events.js").EventsKey>}
     */

    _this.listenerKeys = [];

    if (options.render) {
      _this.render = options.render;
    }

    if (options.target) {
      _this.setTarget(options.target);
    }

    return _this;
  }
  /**
   * Clean up.
   */


  Control.prototype.disposeInternal = function () {
    (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.removeNode)(this.element);

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * Get the map associated with this control.
   * @return {import("../PluggableMap.js").default|null} Map.
   * @api
   */


  Control.prototype.getMap = function () {
    return this.map_;
  };
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default|null} map Map.
   * @api
   */


  Control.prototype.setMap = function (map) {
    if (this.map_) {
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.removeNode)(this.element);
    }

    for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey)(this.listenerKeys[i]);
    }

    this.listenerKeys.length = 0;
    this.map_ = map;

    if (map) {
      var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
      target.appendChild(this.element);

      if (this.render !== _functions_js__WEBPACK_IMPORTED_MODULE_2__.VOID) {
        this.listenerKeys.push((0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(map, _MapEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POSTRENDER, this.render, this));
      }

      map.render();
    }
  };
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */


  Control.prototype.render = function (mapEvent) {};
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */


  Control.prototype.setTarget = function (target) {
    this.target_ = typeof target === 'string' ? document.getElementById(target) : target;
  };

  return Control;
}(_Object_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Control);

/***/ }),

/***/ "./build/wg/control/FullScreen.js":
/*!****************************************!*\
  !*** ./build/wg/control/FullScreen.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Control.js */ "./build/wg/control/Control.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _MapProperty_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MapProperty.js */ "./build/wg/MapProperty.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css.js */ "./build/wg/css.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./build/wg/events.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom.js */ "./build/wg/dom.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/control/FullScreen
 */








var events = ['fullscreenchange', 'webkitfullscreenchange', 'MSFullscreenChange'];
/**
 * @enum {string}
 */

var FullScreenEventType = {
  /**
   * Triggered after the map entered fullscreen.
   * @event FullScreenEventType#enterfullscreen
   * @api
   */
  ENTERFULLSCREEN: 'enterfullscreen',

  /**
   * Triggered after the map leave fullscreen.
   * @event FullScreenEventType#leavefullscreen
   * @api
   */
  LEAVEFULLSCREEN: 'leavefullscreen'
};
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes|
 *     'enterfullscreen'|'leavefullscreen', import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|
 *     'enterfullscreen'|'leavefullscreen'|import("../ObjectEventType").Types, Return>} FullScreenOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='wg-full-screen'] CSS class name.
 * @property {string|Text|HTMLElement} [label='\u2922'] Text label to use for the button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|Text|HTMLElement} [labelActive='\u00d7'] Text label to use for the
 * button when full-screen is active.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [activeClassName=className + '-true'] CSS class name for the button
 * when full-screen is active.
 * @property {string} [inactiveClassName=className + '-false'] CSS class name for the button
 * when full-screen is inactive.
 * @property {string} [tipLabel='Toggle full-screen'] Text label to use for the button tip.
 * @property {boolean} [keys=false] Full keyboard access.
 * @property {HTMLElement|string} [target] Specify a target if you want the
 * control to be rendered outside of the map's viewport.
 * @property {HTMLElement|string} [source] The element to be displayed
 * fullscreen. When not provided, the element containing the map viewport will
 * be displayed fullscreen.
 */

/**
 * @classdesc
 * Provides a button that when clicked fills up the full screen with the map.
 * The full screen source element is by default the element containing the map viewport unless
 * overridden by providing the `source` option. In which case, the dom
 * element introduced using this parameter will be displayed in full screen.
 *
 * When in full screen mode, a close button is shown to exit full screen mode.
 * The [Fullscreen API](https://www.w3.org/TR/fullscreen/) is used to
 * toggle the map in full screen mode.
 *
 * @fires FullScreenEventType#enterfullscreen
 * @fires FullScreenEventType#leavefullscreen
 * @api
 */

var FullScreen =
/** @class */
function (_super) {
  __extends(FullScreen, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function FullScreen(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      target: options.target
    }) || this;
    /***
     * @type {FullScreenOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {FullScreenOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {FullScreenOnSignature<void>}
     */

    _this.un;
    /**
     * @private
     * @type {string}
     */

    _this.cssClassName_ = options.className !== undefined ? options.className : 'wg-full-screen';
    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */

    _this.documentListeners_ = [];
    /**
     * @private
     * @type {Array<string>}
     */

    _this.activeClassName_ = options.activeClassName !== undefined ? options.activeClassName.split(' ') : [_this.cssClassName_ + '-true'];
    /**
     * @private
     * @type {Array<string>}
     */

    _this.inactiveClassName_ = options.inactiveClassName !== undefined ? options.inactiveClassName.split(' ') : [_this.cssClassName_ + '-false'];
    var label = options.label !== undefined ? options.label : "\u2922";
    /**
     * @private
     * @type {Text|HTMLElement}
     */

    _this.labelNode_ = typeof label === 'string' ? document.createTextNode(label) : label;
    var labelActive = options.labelActive !== undefined ? options.labelActive : "\xD7";
    /**
     * @private
     * @type {Text|HTMLElement}
     */

    _this.labelActiveNode_ = typeof labelActive === 'string' ? document.createTextNode(labelActive) : labelActive;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.button_ = document.createElement('button');
    var tipLabel = options.tipLabel ? options.tipLabel : 'Toggle full-screen';

    _this.button_.setAttribute('type', 'button');

    _this.button_.title = tipLabel;

    _this.button_.appendChild(_this.labelNode_);

    _this.button_.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK, _this.handleClick_.bind(_this), false);

    _this.element.className = "".concat(_this.cssClassName_, " ").concat(_css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_UNSELECTABLE, " ").concat(_css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_CONTROL);

    _this.element.appendChild(_this.button_);
    /**
     * @private
     * @type {boolean}
     */


    _this.keys_ = options.keys !== undefined ? options.keys : false;
    /**
     * @private
     * @type {HTMLElement|string|undefined}
     */

    _this.source_ = options.source;
    /**
     * @type {boolean}
     * @private
     */

    _this.isInFullscreen_ = false;
    /**
     * @private
     */

    _this.boundHandleMapTargetChange_ = _this.handleMapTargetChange_.bind(_this);
    return _this;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  FullScreen.prototype.handleClick_ = function (event) {
    event.preventDefault();
    this.handleFullScreen_();
  };
  /**
   * @private
   */


  FullScreen.prototype.handleFullScreen_ = function () {
    var map = this.getMap();

    if (!map) {
      return;
    }

    var doc = map.getOwnerDocument();

    if (!isFullScreenSupported(doc)) {
      return;
    }

    if (isFullScreen(doc)) {
      exitFullScreen(doc);
    } else {
      var element = void 0;

      if (this.source_) {
        element = typeof this.source_ === 'string' ? doc.getElementById(this.source_) : this.source_;
      } else {
        element = map.getTargetElement();
      }

      if (this.keys_) {
        requestFullScreenWithKeys(element);
      } else {
        requestFullScreen(element);
      }
    }
  };
  /**
   * @private
   */


  FullScreen.prototype.handleFullScreenChange_ = function () {
    var map = this.getMap();

    if (!map) {
      return;
    }

    var wasInFullscreen = this.isInFullscreen_;
    this.isInFullscreen_ = isFullScreen(map.getOwnerDocument());

    if (wasInFullscreen !== this.isInFullscreen_) {
      this.setClassName_(this.button_, this.isInFullscreen_);

      if (this.isInFullscreen_) {
        (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.replaceNode)(this.labelActiveNode_, this.labelNode_);
        this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);
      } else {
        (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.replaceNode)(this.labelNode_, this.labelActiveNode_);
        this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);
      }

      map.updateSize();
    }
  };
  /**
   * @param {HTMLElement} element Target element
   * @param {boolean} fullscreen True if fullscreen class name should be active
   * @private
   */


  FullScreen.prototype.setClassName_ = function (element, fullscreen) {
    var _a, _b, _c;

    var activeClassName = this.activeClassName_;
    var inactiveClassName = this.inactiveClassName_;
    var nextClassName = fullscreen ? activeClassName : inactiveClassName;

    (_a = element.classList).remove.apply(_a, activeClassName);

    (_b = element.classList).remove.apply(_b, inactiveClassName);

    (_c = element.classList).add.apply(_c, nextClassName);
  };
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default|null} map Map.
   * @api
   */


  FullScreen.prototype.setMap = function (map) {
    var oldMap = this.getMap();

    if (oldMap) {
      oldMap.removeChangeListener(_MapProperty_js__WEBPACK_IMPORTED_MODULE_3__["default"].TARGET, this.boundHandleMapTargetChange_);
    }

    _super.prototype.setMap.call(this, map);

    this.handleMapTargetChange_();

    if (map) {
      map.addChangeListener(_MapProperty_js__WEBPACK_IMPORTED_MODULE_3__["default"].TARGET, this.boundHandleMapTargetChange_);
    }
  };
  /**
   * @private
   */


  FullScreen.prototype.handleMapTargetChange_ = function () {
    var listeners = this.documentListeners_;

    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.unlistenByKey)(listeners[i]);
    }

    listeners.length = 0;
    var map = this.getMap();

    if (map) {
      var doc = map.getOwnerDocument();

      if (isFullScreenSupported(doc)) {
        this.element.classList.remove(_css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_UNSUPPORTED);
      } else {
        this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_UNSUPPORTED);
      }

      for (var i = 0, ii = events.length; i < ii; ++i) {
        listeners.push((0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(doc, events[i], this.handleFullScreenChange_, this));
      }

      this.handleFullScreenChange_();
    }
  };

  return FullScreen;
}(_Control_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * @param {Document} doc The root document to check.
 * @return {boolean} Fullscreen is supported by the current platform.
 */


function isFullScreenSupported(doc) {
  var body = doc.body;
  return !!(body['webkitRequestFullscreen'] || body['msRequestFullscreen'] && doc['msFullscreenEnabled'] || body.requestFullscreen && doc.fullscreenEnabled);
}
/**
 * @param {Document} doc The root document to check.
 * @return {boolean} Element is currently in fullscreen.
 */


function isFullScreen(doc) {
  return !!(doc['webkitIsFullScreen'] || doc['msFullscreenElement'] || doc.fullscreenElement);
}
/**
 * Request to fullscreen an element.
 * @param {HTMLElement} element Element to request fullscreen
 */


function requestFullScreen(element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element['msRequestFullscreen']) {
    element['msRequestFullscreen']();
  } else if (element['webkitRequestFullscreen']) {
    element['webkitRequestFullscreen']();
  }
}
/**
 * Request to fullscreen an element with keyboard input.
 * @param {HTMLElement} element Element to request fullscreen
 */


function requestFullScreenWithKeys(element) {
  if (element['webkitRequestFullscreen']) {
    element['webkitRequestFullscreen']();
  } else {
    requestFullScreen(element);
  }
}
/**
 * Exit fullscreen.
 * @param {Document} doc The document to exit fullscren from
 */


function exitFullScreen(doc) {
  if (doc.exitFullscreen) {
    doc.exitFullscreen();
  } else if (doc['msExitFullscreen']) {
    doc['msExitFullscreen']();
  } else if (doc['webkitExitFullscreen']) {
    doc['webkitExitFullscreen']();
  }
}

/* harmony default export */ __webpack_exports__["default"] = (FullScreen);

/***/ }),

/***/ "./build/wg/control/MousePosition.js":
/*!*******************************************!*\
  !*** ./build/wg/control/MousePosition.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Control.js */ "./build/wg/control/Control.js");
/* harmony import */ var _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pointer/EventType.js */ "./build/wg/pointer/EventType.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./build/wg/events.js");
/**
 * @module wg/control/MousePosition
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();





/**
 * @type {string}
 */

var PROJECTION = 'projection';
/**
 * @type {string}
 */

var COORDINATE_FORMAT = 'coordinateFormat';
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:coordinateFormat'|'change:projection', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:coordinateFormat'|'change:projection', Return>} MousePositionOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='wg-mouse-position'] CSS class name.
 * @property {import("../coordinate.js").CoordinateFormat} [coordinateFormat] Coordinate format.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the
 * control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want the
 * control to be rendered outside of the map's viewport.
 * @property {string|boolean} [placeholder] Markup to show when the mouse position is not
 * available (e.g. when the pointer leaves the map viewport).  By default, a non-breaking space
 * is rendered when the mouse leaves the viewport.  To render something else, provide a string
 * to be used as the text content (e.g. 'no position' or '' for an empty string).  Set the placeholder
 * to `false` to retain the last position when the mouse leaves the viewport.  In a future release, this
 * will be the default behavior.
 * @property {string} [undefinedHTML='&#160;'] This option is deprecated.  Use the `placeholder` option instead.
 */

/**
 * @classdesc
 * A control to show the 2D coordinates of the mouse cursor. By default, these
 * are in the view projection, but can be in any supported projection.
 * By default the control is shown in the top right corner of the map, but this
 * can be changed by using the css selector `.ol-mouse-position`.
 *
 * On touch devices, which usually do not have a mouse cursor, the coordinates
 * of the currently touched position are shown.
 *
 * @api
 */

var MousePosition =
/** @class */
function (_super) {
  __extends(MousePosition, _super);
  /**
   * @param {Options} [opt_options] Mouse position options.
   */


  function MousePosition(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var element = document.createElement('div');
    element.className = options.className !== undefined ? options.className : 'wg-mouse-position';
    _this = _super.call(this, {
      element: element,
      render: options.render,
      target: options.target
    }) || this;
    /***
     * @type {MousePositionOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {MousePositionOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {MousePositionOnSignature<void>}
     */

    _this.un;

    _this.addChangeListener(PROJECTION, _this.handleProjectionChanged_);

    if (options.coordinateFormat) {
      _this.setCoordinateFormat(options.coordinateFormat);
    }

    if (options.projection) {
      _this.setProjection(options.projection);
    }
    /**
     * Change this to `false` when removing the deprecated `undefinedHTML` option.
     * @type {boolean}
     */


    var renderOnMouseOut = true;
    /**
     * @type {string}
     */

    var placeholder = '&#160;';

    if ('undefinedHTML' in options) {
      // deprecated behavior
      if (options.undefinedHTML !== undefined) {
        placeholder = options.undefinedHTML;
      }

      renderOnMouseOut = !!placeholder;
    } else if ('placeholder' in options) {
      if (options.placeholder === false) {
        renderOnMouseOut = false;
      } else {
        placeholder = String(options.placeholder);
      }
    }
    /**
     * @private
     * @type {string}
     */


    _this.placeholder_ = placeholder;
    /**
     * @private
     * @type {boolean}
     */

    _this.renderOnMouseOut_ = renderOnMouseOut;
    /**
     * @private
     * @type {string}
     */

    _this.renderedHTML_ = element.innerHTML;
    /**
     * @private
     * @type {?import("../proj/Projection.js").default}
     */

    _this.mapProjection_ = null;
    /**
     * @private
     * @type {?import("../proj.js").TransformFunction}
     */

    _this.transform_ = null;
    return _this;
  }
  /**
   * @private
   */


  MousePosition.prototype.handleProjectionChanged_ = function () {
    this.transform_ = null;
  };
  /**
   * Return the coordinate format type used to render the current position or
   * undefined.
   * @return {import("../coordinate.js").CoordinateFormat|undefined} The format to render the current
   *     position in.
   * @observable
   * @api
   */


  MousePosition.prototype.getCoordinateFormat = function () {
    return (
      /** @type {import("../coordinate.js").CoordinateFormat|undefined} */
      this.get(COORDINATE_FORMAT)
    );
  };
  /**
   * Return the projection that is used to report the mouse position.
   * @return {import("../proj/Projection.js").default|undefined} The projection to report mouse
   *     position in.
   * @observable
   * @api
   */


  MousePosition.prototype.getProjection = function () {
    return (
      /** @type {import("../proj/Projection.js").default|undefined} */
      this.get(PROJECTION)
    );
  };
  /**
   * @param {MouseEvent} event Browser event.
   * @protected
   */


  MousePosition.prototype.handleMouseMove = function (event) {
    var map = this.getMap();
    this.updateHTML_(map.getEventPixel(event));
  };
  /**
   * @param {Event} event Browser event.
   * @protected
   */


  MousePosition.prototype.handleMouseOut = function (event) {
    this.updateHTML_(null);
  };
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default|null} map Map.
   * @api
   */


  MousePosition.prototype.setMap = function (map) {
    _super.prototype.setMap.call(this, map);

    if (map) {
      var viewport = map.getViewport();
      this.listenerKeys.push((0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(viewport, _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERMOVE, this.handleMouseMove, this));

      if (this.renderOnMouseOut_) {
        this.listenerKeys.push((0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(viewport, _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTEROUT, this.handleMouseOut, this));
      }

      this.updateHTML_(null);
    }
  };
  /**
   * Set the coordinate format type used to render the current position.
   * @param {import("../coordinate.js").CoordinateFormat} format The format to render the current
   *     position in.
   * @observable
   * @api
   */


  MousePosition.prototype.setCoordinateFormat = function (format) {
    this.set(COORDINATE_FORMAT, format);
  };
  /**
   * Set the projection that is used to report the mouse position.
   * @param {import("../proj.js").ProjectionLike} projection The projection to report mouse
   *     position in.
   * @observable
   * @api
   */


  MousePosition.prototype.setProjection = function (projection) {
    this.set(PROJECTION, (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection));
  };
  /**
   * @param {?import("../pixel.js").Pixel} pixel Pixel.
   * @private
   */


  MousePosition.prototype.updateHTML_ = function (pixel) {
    var html = this.placeholder_;

    if (pixel && this.mapProjection_) {
      if (!this.transform_) {
        var projection = this.getProjection();

        if (projection) {
          this.transform_ = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransformFromProjections)(this.mapProjection_, projection);
        } else {
          this.transform_ = _proj_js__WEBPACK_IMPORTED_MODULE_0__.identityTransform;
        }
      }

      var map = this.getMap();
      var coordinate = map.getCoordinateFromPixelInternal(pixel);

      if (coordinate) {
        var userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();

        if (userProjection) {
          this.transform_ = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransformFromProjections)(this.mapProjection_, userProjection);
        }

        this.transform_(coordinate, coordinate);
        var coordinateFormat = this.getCoordinateFormat();

        if (coordinateFormat) {
          html = coordinateFormat(coordinate);
        } else {
          html = coordinate.toString();
        }
      }
    }

    if (!this.renderedHTML_ || html !== this.renderedHTML_) {
      this.element.innerHTML = html;
      this.renderedHTML_ = html;
    }
  };
  /**
   * Update the projection. Rendering of the coordinates is done in
   * `handleMouseMove` and `handleMouseUp`.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */


  MousePosition.prototype.render = function (mapEvent) {
    var frameState = mapEvent.frameState;

    if (!frameState) {
      this.mapProjection_ = null;
    } else {
      if (this.mapProjection_ != frameState.viewState.projection) {
        this.mapProjection_ = frameState.viewState.projection;
        this.transform_ = null;
      }
    }
  };

  return MousePosition;
}(_Control_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (MousePosition);

/***/ }),

/***/ "./build/wg/control/OverviewMap.js":
/*!*****************************************!*\
  !*** ./build/wg/control/OverviewMap.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _renderer_Composite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer/Composite.js */ "./build/wg/renderer/Composite.js");
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Control.js */ "./build/wg/control/Control.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../MapEventType.js */ "./build/wg/MapEventType.js");
/* harmony import */ var _MapProperty_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../MapProperty.js */ "./build/wg/MapProperty.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../ObjectEventType.js */ "./build/wg/ObjectEventType.js");
/* harmony import */ var _Overlay_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Overlay.js */ "./build/wg/Overlay.js");
/* harmony import */ var _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../OverlayPositioning.js */ "./build/wg/OverlayPositioning.js");
/* harmony import */ var _PluggableMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../PluggableMap.js */ "./build/wg/PluggableMap.js");
/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../View.js */ "./build/wg/View.js");
/* harmony import */ var _ViewProperty_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../ViewProperty.js */ "./build/wg/ViewProperty.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../css.js */ "./build/wg/css.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./build/wg/events.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../dom.js */ "./build/wg/dom.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/control/OverviewMap
 */


















/**
 * Maximum width and/or height extent ratio that determines when the overview
 * map should be zoomed out.
 * @type {number}
 */

var MAX_RATIO = 0.75;
/**
 * Minimum width and/or height extent ratio that determines when the overview
 * map should be zoomed in.
 * @type {number}
 */

var MIN_RATIO = 0.1;

var ControlledMap =
/** @class */
function (_super) {
  __extends(ControlledMap, _super);

  function ControlledMap() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ControlledMap.prototype.createRenderer = function () {
    return new _renderer_Composite_js__WEBPACK_IMPORTED_MODULE_0__["default"](this);
  };

  return ControlledMap;
}(_PluggableMap_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @typedef {Object} Options
 * @property {string} [className='wg-overviewmap'] CSS class name.
 * @property {boolean} [collapsed=true] Whether the control should start collapsed or not (expanded).
 * @property {string|HTMLElement} [collapseLabel='‹'] Text label to use for the
 * expanded overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {boolean} [collapsible=true] Whether the control can be collapsed or not.
 * @property {string|HTMLElement} [label='›'] Text label to use for the collapsed
 * overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {Array<import("../layer/Base.js").default>|import("../Collection.js").default<import("../layer/Base.js").default>} [layers]
 * Layers for the overview map.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {boolean} [rotateWithView=false] Whether the control view should rotate with the main map view.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {string} [tipLabel='Overview map'] Text label to use for the button tip.
 * @property {View} [view] Custom view for the overview map (should use same projection as main map). If not provided,
 * a default view with the same projection as the main map will be used.
 */

/**
 * Create a new control with a map acting as an overview map for another
 * defined map.
 *
 * @api
 */


var OverviewMap =
/** @class */
function (_super) {
  __extends(OverviewMap, _super);
  /**
   * @param {Options} [opt_options] OverviewMap options.
   */


  function OverviewMap(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render,
      target: options.target
    }) || this;
    /**
     * @private
     */

    _this.boundHandleRotationChanged_ = _this.handleRotationChanged_.bind(_this);
    /**
     * @type {boolean}
     * @private
     */

    _this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
    /**
     * @private
     * @type {boolean}
     */

    _this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;

    if (!_this.collapsible_) {
      _this.collapsed_ = false;
    }
    /**
     * @private
     * @type {boolean}
     */


    _this.rotateWithView_ = options.rotateWithView !== undefined ? options.rotateWithView : false;
    /**
     * @private
     * @type {import("../extent.js").Extent|undefined}
     */

    _this.viewExtent_ = undefined;
    var className = options.className !== undefined ? options.className : 'wg-overviewmap';
    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Overview map';
    var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : "\u2039";

    if (typeof collapseLabel === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.collapseLabel_ = document.createElement('span');
      _this.collapseLabel_.textContent = collapseLabel;
    } else {
      _this.collapseLabel_ = collapseLabel;
    }

    var label = options.label !== undefined ? options.label : "\u203A";

    if (typeof label === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.label_ = document.createElement('span');
      _this.label_.textContent = label;
    } else {
      _this.label_ = label;
    }

    var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
    var button = document.createElement('button');
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(activeLabel);
    button.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CLICK, _this.handleClick_.bind(_this), false);
    /**
     * @type {HTMLElement}
     * @private
     */

    _this.ovmapDiv_ = document.createElement('div');
    _this.ovmapDiv_.className = 'wg-overviewmap-map';
    /**
     * Explicitly given view to be used instead of a view derived from the main map.
     * @type {View}
     * @private
     */

    _this.view_ = options.view;
    /**
     * @type {ControlledMap}
     * @private
     */

    _this.ovmap_ = new ControlledMap({
      view: options.view
    });
    var ovmap = _this.ovmap_;

    if (options.layers) {
      options.layers.forEach(function (layer) {
        ovmap.addLayer(layer);
      });
    }

    var box = document.createElement('div');
    box.className = 'wg-overviewmap-box';
    box.style.boxSizing = 'border-box';
    /**
     * @type {import("../Overlay.js").default}
     * @private
     */

    _this.boxOverlay_ = new _Overlay_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      position: [0, 0],
      positioning: _OverlayPositioning_js__WEBPACK_IMPORTED_MODULE_4__["default"].CENTER_CENTER,
      element: box
    });

    _this.ovmap_.addOverlay(_this.boxOverlay_);

    var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_5__.CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_5__.CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? ' ' + _css_js__WEBPACK_IMPORTED_MODULE_5__.CLASS_COLLAPSED : '') + (_this.collapsible_ ? '' : ' ol-uncollapsible');
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(_this.ovmapDiv_);
    element.appendChild(button);
    /* Interactive map */

    var scope = _this;
    var overlay = _this.boxOverlay_;

    var overlayBox = _this.boxOverlay_.getElement();
    /* Functions definition */


    var computeDesiredMousePosition = function computeDesiredMousePosition(mousePosition) {
      return {
        clientX: mousePosition.clientX,
        clientY: mousePosition.clientY
      };
    };

    var move = function move(event) {
      var position =
      /** @type {?} */
      computeDesiredMousePosition(event);
      var coordinates = ovmap.getEventCoordinateInternal(
      /** @type {MouseEvent} */
      position);
      overlay.setPosition(coordinates);
    };

    var endMoving = function endMoving(event) {
      var coordinates = ovmap.getEventCoordinateInternal(event);
      scope.getMap().getView().setCenterInternal(coordinates);
      window.removeEventListener('mousemove', move);
      window.removeEventListener('mouseup', endMoving);
    };
    /* Binding */


    overlayBox.addEventListener('mousedown', function () {
      window.addEventListener('mousemove', move);
      window.addEventListener('mouseup', endMoving);
    });
    return _this;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default|null} map Map.
   * @api
   */


  OverviewMap.prototype.setMap = function (map) {
    var oldMap = this.getMap();

    if (map === oldMap) {
      return;
    }

    if (oldMap) {
      var oldView = oldMap.getView();

      if (oldView) {
        this.unbindView_(oldView);
      }

      this.ovmap_.setTarget(null);
    }

    _super.prototype.setMap.call(this, map);

    if (map) {
      this.ovmap_.setTarget(this.ovmapDiv_);
      this.listenerKeys.push((0,_events_js__WEBPACK_IMPORTED_MODULE_6__.listen)(map, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].PROPERTYCHANGE, this.handleMapPropertyChange_, this));
      var view = map.getView();

      if (view) {
        this.bindView_(view);

        if (view.isDef()) {
          this.ovmap_.updateSize();
          this.resetExtent_();
        }
      }

      if (!this.ovmap_.isRendered()) {
        this.updateBoxAfterOvmapIsRendered_();
      }
    }
  };
  /**
   * Handle map property changes.  This only deals with changes to the map's view.
   * @param {import("../Object.js").ObjectEvent} event The propertychange event.
   * @private
   */


  OverviewMap.prototype.handleMapPropertyChange_ = function (event) {
    if (event.key === _MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW) {
      var oldView =
      /** @type {import("../View.js").default} */
      event.oldValue;

      if (oldView) {
        this.unbindView_(oldView);
      }

      var newView = this.getMap().getView();
      this.bindView_(newView);
    } else if (!this.ovmap_.isRendered() && (event.key === _MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET || event.key === _MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].SIZE)) {
      this.ovmap_.updateSize();
    }
  };
  /**
   * Register listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */


  OverviewMap.prototype.bindView_ = function (view) {
    if (!this.view_) {
      // Unless an explicit view definition was given, derive default from whatever main map uses.
      var newView = new _View_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
        projection: view.getProjection()
      });
      this.ovmap_.setView(newView);
    }

    view.addChangeListener(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_10__["default"].ROTATION, this.boundHandleRotationChanged_); // Sync once with the new view

    this.handleRotationChanged_();
  };
  /**
   * Unregister listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */


  OverviewMap.prototype.unbindView_ = function (view) {
    view.removeChangeListener(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_10__["default"].ROTATION, this.boundHandleRotationChanged_);
  };
  /**
   * Handle rotation changes to the main map.
   * @private
   */


  OverviewMap.prototype.handleRotationChanged_ = function () {
    if (this.rotateWithView_) {
      this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
    }
  };
  /**
   * Reset the overview map extent if the box size (width or
   * height) is less than the size of the overview map size times minRatio
   * or is greater than the size of the overview size times maxRatio.
   *
   * If the map extent was not reset, the box size can fits in the defined
   * ratio sizes. This method then checks if is contained inside the overview
   * map current extent. If not, recenter the overview map to the current
   * main map center location.
   * @private
   */


  OverviewMap.prototype.validateExtent_ = function () {
    var map = this.getMap();
    var ovmap = this.ovmap_;

    if (!map.isRendered() || !ovmap.isRendered()) {
      return;
    }

    var mapSize =
    /** @type {import("../size.js").Size} */
    map.getSize();
    var view = map.getView();
    var extent = view.calculateExtentInternal(mapSize);

    if (this.viewExtent_ && (0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.equals)(extent, this.viewExtent_)) {
      // repeats of the same extent may indicate constraint conflicts leading to an endless cycle
      return;
    }

    this.viewExtent_ = extent;
    var ovmapSize =
    /** @type {import("../size.js").Size} */
    ovmap.getSize();
    var ovview = ovmap.getView();
    var ovextent = ovview.calculateExtentInternal(ovmapSize);
    var topLeftPixel = ovmap.getPixelFromCoordinateInternal((0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.getTopLeft)(extent));
    var bottomRightPixel = ovmap.getPixelFromCoordinateInternal((0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.getBottomRight)(extent));
    var boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);
    var boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);
    var ovmapWidth = ovmapSize[0];
    var ovmapHeight = ovmapSize[1];

    if (boxWidth < ovmapWidth * MIN_RATIO || boxHeight < ovmapHeight * MIN_RATIO || boxWidth > ovmapWidth * MAX_RATIO || boxHeight > ovmapHeight * MAX_RATIO) {
      this.resetExtent_();
    } else if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.containsExtent)(ovextent, extent)) {
      this.recenter_();
    }
  };
  /**
   * Reset the overview map extent to half calculated min and max ratio times
   * the extent of the main map.
   * @private
   */


  OverviewMap.prototype.resetExtent_ = function () {
    if (MAX_RATIO === 0 || MIN_RATIO === 0) {
      return;
    }

    var map = this.getMap();
    var ovmap = this.ovmap_;
    var mapSize =
    /** @type {import("../size.js").Size} */
    map.getSize();
    var view = map.getView();
    var extent = view.calculateExtentInternal(mapSize);
    var ovview = ovmap.getView(); // get how many times the current map overview could hold different
    // box sizes using the min and max ratio, pick the step in the middle used
    // to calculate the extent from the main map to set it to the overview map,

    var steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;
    var ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.scaleFromCenter)(extent, ratio);
    ovview.fitInternal((0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_12__.fromExtent)(extent));
  };
  /**
   * Set the center of the overview map to the map center without changing its
   * resolution.
   * @private
   */


  OverviewMap.prototype.recenter_ = function () {
    var map = this.getMap();
    var ovmap = this.ovmap_;
    var view = map.getView();
    var ovview = ovmap.getView();
    ovview.setCenterInternal(view.getCenterInternal());
  };
  /**
   * Update the box using the main map extent
   * @private
   */


  OverviewMap.prototype.updateBox_ = function () {
    var map = this.getMap();
    var ovmap = this.ovmap_;

    if (!map.isRendered() || !ovmap.isRendered()) {
      return;
    }

    var mapSize =
    /** @type {import("../size.js").Size} */
    map.getSize();
    var view = map.getView();
    var ovview = ovmap.getView();
    var rotation = this.rotateWithView_ ? 0 : -view.getRotation();
    var overlay = this.boxOverlay_;
    var box = this.boxOverlay_.getElement();
    var center = view.getCenterInternal();
    var resolution = view.getResolution();
    var ovresolution = ovview.getResolution();
    var width = mapSize[0] * resolution / ovresolution;
    var height = mapSize[1] * resolution / ovresolution; // set position using center coordinates

    overlay.setPosition(center); // set box size calculated from map extent size and overview map resolution

    if (box) {
      box.style.width = width + 'px';
      box.style.height = height + 'px';
      var transform = 'rotate(' + rotation + 'rad)';
      box.style.transform = transform;
    }
  };
  /**
   * @private
   */


  OverviewMap.prototype.updateBoxAfterOvmapIsRendered_ = function () {
    if (this.ovmapPostrenderKey_) {
      return;
    }

    this.ovmapPostrenderKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_6__.listenOnce)(this.ovmap_, _MapEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POSTRENDER, function (event) {
      delete this.ovmapPostrenderKey_;
      this.updateBox_();
    }, this);
  };
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  OverviewMap.prototype.handleClick_ = function (event) {
    event.preventDefault();
    this.handleToggle_();
  };
  /**
   * @private
   */


  OverviewMap.prototype.handleToggle_ = function () {
    this.element.classList.toggle(_css_js__WEBPACK_IMPORTED_MODULE_5__.CLASS_COLLAPSED);

    if (this.collapsed_) {
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_14__.replaceNode)(this.collapseLabel_, this.label_);
    } else {
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_14__.replaceNode)(this.label_, this.collapseLabel_);
    }

    this.collapsed_ = !this.collapsed_; // manage overview map if it had not been rendered before and control
    // is expanded

    var ovmap = this.ovmap_;

    if (!this.collapsed_) {
      if (ovmap.isRendered()) {
        this.viewExtent_ = undefined;
        ovmap.render();
        return;
      }

      ovmap.updateSize();
      this.resetExtent_();
      this.updateBoxAfterOvmapIsRendered_();
    }
  };
  /**
   * Return `true` if the overview map is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */


  OverviewMap.prototype.getCollapsible = function () {
    return this.collapsible_;
  };
  /**
   * Set whether the overview map should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */


  OverviewMap.prototype.setCollapsible = function (collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }

    this.collapsible_ = collapsible;
    this.element.classList.toggle('wg-uncollapsible');

    if (!collapsible && this.collapsed_) {
      this.handleToggle_();
    }
  };
  /**
   * Collapse or expand the overview map according to the passed parameter. Will
   * not do anything if the overview map isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */


  OverviewMap.prototype.setCollapsed = function (collapsed) {
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }

    this.handleToggle_();
  };
  /**
   * Determine if the overview map is collapsed.
   * @return {boolean} The overview map is collapsed.
   * @api
   */


  OverviewMap.prototype.getCollapsed = function () {
    return this.collapsed_;
  };
  /**
   * Return `true` if the overview map view can rotate, `false` otherwise.
   * @return {boolean} True if the control view can rotate.
   * @api
   */


  OverviewMap.prototype.getRotateWithView = function () {
    return this.rotateWithView_;
  };
  /**
   * Set whether the overview map view should rotate with the main map view.
   * @param {boolean} rotateWithView True if the control view should rotate.
   * @api
   */


  OverviewMap.prototype.setRotateWithView = function (rotateWithView) {
    if (this.rotateWithView_ === rotateWithView) {
      return;
    }

    this.rotateWithView_ = rotateWithView;

    if (this.getMap().getView().getRotation() !== 0) {
      if (this.rotateWithView_) {
        this.handleRotationChanged_();
      } else {
        this.ovmap_.getView().setRotation(0);
      }

      this.viewExtent_ = undefined;
      this.validateExtent_();
      this.updateBox_();
    }
  };
  /**
   * Return the overview map.
   * @return {import("../PluggableMap.js").default} Overview map.
   * @api
   */


  OverviewMap.prototype.getOverviewMap = function () {
    return this.ovmap_;
  };
  /**
   * Update the overview map element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */


  OverviewMap.prototype.render = function (mapEvent) {
    this.validateExtent_();
    this.updateBox_();
  };

  return OverviewMap;
}(_Control_js__WEBPACK_IMPORTED_MODULE_15__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (OverviewMap);

/***/ }),

/***/ "./build/wg/control/Rotate.js":
/*!************************************!*\
  !*** ./build/wg/control/Rotate.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Control.js */ "./build/wg/control/Control.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css.js */ "./build/wg/css.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./build/wg/easing.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/control/Rotate
 */






/**
 * @typedef {Object} Options
 * @property {string} [className='wg-rotate'] CSS class name.
 * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {string} [compassClassName='wg-compass'] CSS class name for the compass.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function():void} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */

var Rotate =
/** @class */
function (_super) {
  __extends(Rotate, _super);
  /**
   * @param {Options} [opt_options] Rotate options.
   */


  function Rotate(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render,
      target: options.target
    }) || this;
    var className = options.className !== undefined ? options.className : 'wg-rotate';
    var label = options.label !== undefined ? options.label : "\u21E7";
    var compassClassName = options.compassClassName !== undefined ? options.compassClassName : 'wg-compass';
    /**
     * @type {HTMLElement}
     * @private
     */

    _this.label_ = null;

    if (typeof label === 'string') {
      _this.label_ = document.createElement('span');
      _this.label_.className = compassClassName;
      _this.label_.textContent = label;
    } else {
      _this.label_ = label;

      _this.label_.classList.add(compassClassName);
    }

    var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
    var button = document.createElement('button');
    button.className = className + '-reset';
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(_this.label_);
    button.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK, _this.handleClick_.bind(_this), false);
    var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(button);
    _this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;
    /**
     * @type {number}
     * @private
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    /**
     * @type {boolean}
     * @private
     */

    _this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.rotation_ = undefined;

    if (_this.autoHide_) {
      _this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_HIDDEN);
    }

    return _this;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  Rotate.prototype.handleClick_ = function (event) {
    event.preventDefault();

    if (this.callResetNorth_ !== undefined) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  };
  /**
   * @private
   */


  Rotate.prototype.resetNorth_ = function () {
    var map = this.getMap();
    var view = map.getView();

    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }

    var rotation = view.getRotation();

    if (rotation !== undefined) {
      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__.easeOut
        });
      } else {
        view.setRotation(0);
      }
    }
  };
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */


  Rotate.prototype.render = function (mapEvent) {
    var frameState = mapEvent.frameState;

    if (!frameState) {
      return;
    }

    var rotation = frameState.viewState.rotation;

    if (rotation != this.rotation_) {
      var transform = 'rotate(' + rotation + 'rad)';

      if (this.autoHide_) {
        var contains = this.element.classList.contains(_css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_HIDDEN);

        if (!contains && rotation === 0) {
          this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_HIDDEN);
        } else if (contains && rotation !== 0) {
          this.element.classList.remove(_css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_HIDDEN);
        }
      }

      this.label_.style.transform = transform;
    }

    this.rotation_ = rotation;
  };

  return Rotate;
}(_Control_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Rotate);

/***/ }),

/***/ "./build/wg/control/ScaleLine.js":
/*!***************************************!*\
  !*** ./build/wg/control/ScaleLine.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Units": function() { return /* binding */ Units; }
/* harmony export */ });
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Control.js */ "./build/wg/control/Control.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj/Units.js */ "./build/wg/proj/Units.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css.js */ "./build/wg/css.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/control/ScaleLine
 */







/**
 * @type {string}
 */

var UNITS_PROP = 'units';
/**
 * Units for the scale line. Supported values are `'degrees'`, `'imperial'`,
 * `'nautical'`, `'metric'`, `'us'`.
 * @enum {string}
 */

var Units = {
  DEGREES: 'degrees',
  IMPERIAL: 'imperial',
  NAUTICAL: 'nautical',
  METRIC: 'metric',
  US: 'us'
};
/**
 * @const
 * @type {Array<number>}
 */

var LEADING_DIGITS = [1, 2, 5];
/**
 * @const
 * @type {number}
 */

var DEFAULT_DPI = 25.4 / 0.28;
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:units', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types
 *     |'change:units', Return>} ScaleLineOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='wg-scale-line'] CSS Class name.
 * @property {number} [minWidth=64] Minimum width in pixels at the OGC default dpi. The width will be
 * adjusted to match the dpi used.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {import("./ScaleLine.js").Units|string} [units='metric'] Units.
 * @property {boolean} [bar=false] Render scalebars instead of a line.
 * @property {number} [steps=4] Number of steps the scalebar should use. Use even numbers
 * for best results. Only applies when `bar` is `true`.
 * @property {boolean} [text=false] Render the text scale above of the scalebar. Only applies
 * when `bar` is `true`.
 * @property {number|undefined} [dpi=undefined] dpi of output device such as printer. Only applies
 * when `bar` is `true`. If undefined the OGC default screen pixel size of 0.28mm will be assumed.
 */

/**
 * @classdesc
 * A control displaying rough y-axis distances, calculated for the center of the
 * viewport. For conformal projections (e.g. EPSG:3857, the default view
 * projection in OpenLayers), the scale is valid for all directions.
 * No scale line will be shown when the y-axis distance of a pixel at the
 * viewport center cannot be calculated in the view projection.
 * By default the scale line will show in the bottom left portion of the map,
 * but this can be changed by using the css selector `.ol-scale-line`.
 * When specifying `bar` as `true`, a scalebar will be rendered instead
 * of a scaleline.
 *
 * @api
 */

var ScaleLine =
/** @class */
function (_super) {
  __extends(ScaleLine, _super);
  /**
   * @param {Options} [opt_options] Scale line options.
   */


  function ScaleLine(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var className = options.className !== undefined ? options.className : options.bar ? 'wg-scale-bar' : 'wg-scale-line';
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render,
      target: options.target
    }) || this;
    /***
     * @type {ScaleLineOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {ScaleLineOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {ScaleLineOnSignature<void>}
     */

    _this.un;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.innerElement_ = document.createElement('div');
    _this.innerElement_.className = className + '-inner';
    _this.element.className = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_UNSELECTABLE;

    _this.element.appendChild(_this.innerElement_);
    /**
     * @private
     * @type {?import("../View.js").State}
     */


    _this.viewState_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.minWidth_ = options.minWidth !== undefined ? options.minWidth : 64;
    /**
     * @private
     * @type {boolean}
     */

    _this.renderedVisible_ = false;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.renderedWidth_ = undefined;
    /**
     * @private
     * @type {string}
     */

    _this.renderedHTML_ = '';

    _this.addChangeListener(UNITS_PROP, _this.handleUnitsChanged_);

    _this.setUnits(options.units || Units.METRIC);
    /**
     * @private
     * @type {boolean}
     */


    _this.scaleBar_ = options.bar || false;
    /**
     * @private
     * @type {number}
     */

    _this.scaleBarSteps_ = options.steps || 4;
    /**
     * @private
     * @type {boolean}
     */

    _this.scaleBarText_ = options.text || false;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.dpi_ = options.dpi || undefined;
    return _this;
  }
  /**
   * Return the units to use in the scale line.
   * @return {import("./ScaleLine.js").Units} The units
   * to use in the scale line.
   * @observable
   * @api
   */


  ScaleLine.prototype.getUnits = function () {
    return this.get(UNITS_PROP);
  };
  /**
   * @private
   */


  ScaleLine.prototype.handleUnitsChanged_ = function () {
    this.updateElement_();
  };
  /**
   * Set the units to use in the scale line.
   * @param {import("./ScaleLine.js").Units} units The units to use in the scale line.
   * @observable
   * @api
   */


  ScaleLine.prototype.setUnits = function (units) {
    this.set(UNITS_PROP, units);
  };
  /**
   * Specify the dpi of output device such as printer.
   * @param {number|undefined} dpi The dpi of output device.
   * @api
   */


  ScaleLine.prototype.setDpi = function (dpi) {
    this.dpi_ = dpi;
  };
  /**
   * @private
   */


  ScaleLine.prototype.updateElement_ = function () {
    var viewState = this.viewState_;

    if (!viewState) {
      if (this.renderedVisible_) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
      }

      return;
    }

    var center = viewState.center;
    var projection = viewState.projection;
    var units = this.getUnits();
    var pointResolutionUnits = units == Units.DEGREES ? _proj_Units_js__WEBPACK_IMPORTED_MODULE_2__["default"].DEGREES : _proj_Units_js__WEBPACK_IMPORTED_MODULE_2__["default"].METERS;
    var pointResolution = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getPointResolution)(projection, viewState.resolution, center, pointResolutionUnits);
    var minWidth = this.minWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI;
    var nominalCount = minWidth * pointResolution;
    var suffix = '';

    if (units == Units.DEGREES) {
      var metersPerDegree = _proj_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[_proj_Units_js__WEBPACK_IMPORTED_MODULE_2__["default"].DEGREES];
      nominalCount *= metersPerDegree;

      if (nominalCount < metersPerDegree / 60) {
        suffix = "\u2033"; // seconds

        pointResolution *= 3600;
      } else if (nominalCount < metersPerDegree) {
        suffix = "\u2032"; // minutes

        pointResolution *= 60;
      } else {
        suffix = "\xB0"; // degrees
      }
    } else if (units == Units.IMPERIAL) {
      if (nominalCount < 0.9144) {
        suffix = 'in';
        pointResolution /= 0.0254;
      } else if (nominalCount < 1609.344) {
        suffix = 'ft';
        pointResolution /= 0.3048;
      } else {
        suffix = 'mi';
        pointResolution /= 1609.344;
      }
    } else if (units == Units.NAUTICAL) {
      pointResolution /= 1852;
      suffix = 'nm';
    } else if (units == Units.METRIC) {
      if (nominalCount < 0.001) {
        suffix = 'μm';
        pointResolution *= 1000000;
      } else if (nominalCount < 1) {
        suffix = 'mm';
        pointResolution *= 1000;
      } else if (nominalCount < 1000) {
        suffix = 'm';
      } else {
        suffix = 'km';
        pointResolution /= 1000;
      }
    } else if (units == Units.US) {
      if (nominalCount < 0.9144) {
        suffix = 'in';
        pointResolution *= 39.37;
      } else if (nominalCount < 1609.344) {
        suffix = 'ft';
        pointResolution /= 0.30480061;
      } else {
        suffix = 'mi';
        pointResolution /= 1609.3472;
      }
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, 33); // Invalid units
    }

    var i = 3 * Math.floor(Math.log(minWidth * pointResolution) / Math.log(10));
    var count, width, decimalCount;

    while (true) {
      decimalCount = Math.floor(i / 3);
      var decimal = Math.pow(10, decimalCount);
      count = LEADING_DIGITS[(i % 3 + 3) % 3] * decimal;
      width = Math.round(count / pointResolution);

      if (isNaN(width)) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
        return;
      } else if (width >= minWidth) {
        break;
      }

      ++i;
    }

    var html;

    if (this.scaleBar_) {
      html = this.createScaleBar(width, count, suffix);
    } else {
      html = count.toFixed(decimalCount < 0 ? -decimalCount : 0) + ' ' + suffix;
    }

    if (this.renderedHTML_ != html) {
      this.innerElement_.innerHTML = html;
      this.renderedHTML_ = html;
    }

    if (this.renderedWidth_ != width) {
      this.innerElement_.style.width = width + 'px';
      this.renderedWidth_ = width;
    }

    if (!this.renderedVisible_) {
      this.element.style.display = '';
      this.renderedVisible_ = true;
    }
  };
  /**
   * @private
   * @param {number} width The current width of the scalebar.
   * @param {number} scale The current scale.
   * @param {string} suffix The suffix to append to the scale text.
   * @return {string} The stringified HTML of the scalebar.
   */


  ScaleLine.prototype.createScaleBar = function (width, scale, suffix) {
    var mapScale = '1 : ' + Math.round(this.getScaleForResolution()).toLocaleString();
    var scaleSteps = [];
    var stepWidth = width / this.scaleBarSteps_;
    var backgroundColor = '#ffffff';

    for (var i = 0; i < this.scaleBarSteps_; i++) {
      if (i === 0) {
        // create the first marker at position 0
        scaleSteps.push(this.createMarker('absolute', i));
      }

      scaleSteps.push('<div>' + '<div ' + 'class="wg-scale-singlebar" ' + 'style=' + '"width: ' + stepWidth + 'px;' + 'background-color: ' + backgroundColor + ';"' + '>' + '</div>' + this.createMarker('relative', i) + (
      /*render text every second step, except when only 2 steps */
      i % 2 === 0 || this.scaleBarSteps_ === 2 ? this.createStepText(i, width, false, scale, suffix) : '') + '</div>');

      if (i === this.scaleBarSteps_ - 1) {
        {
          /*render text at the end */
        }
        scaleSteps.push(this.createStepText(i + 1, width, true, scale, suffix));
      } // switch colors of steps between black and white


      if (backgroundColor === '#ffffff') {
        backgroundColor = '#000000';
      } else {
        backgroundColor = '#ffffff';
      }
    }

    var scaleBarText;

    if (this.scaleBarText_) {
      scaleBarText = '<div ' + 'class="wg-scale-text" ' + 'style="width: ' + width + 'px;">' + mapScale + '</div>';
    } else {
      scaleBarText = '';
    }

    var container = '<div ' + 'style="display: flex;">' + scaleBarText + scaleSteps.join('') + '</div>';
    return container;
  };
  /**
   * Creates a marker at given position
   * @param {string} position The position, absolute or relative
   * @param {number} i The iterator
   * @return {string} The stringified div containing the marker
   */


  ScaleLine.prototype.createMarker = function (position, i) {
    var top = position === 'absolute' ? 3 : -10;
    return '<div ' + 'class="wg-scale-step-marker" ' + 'style="position: ' + position + ';' + 'top: ' + top + 'px;"' + '></div>';
  };
  /**
   * Creates the label for a marker marker at given position
   * @param {number} i The iterator
   * @param {number} width The width the scalebar will currently use
   * @param {boolean} isLast Flag indicating if we add the last step text
   * @param {number} scale The current scale for the whole scalebar
   * @param {string} suffix The suffix for the scale
   * @return {string} The stringified div containing the step text
   */


  ScaleLine.prototype.createStepText = function (i, width, isLast, scale, suffix) {
    var length = i === 0 ? 0 : Math.round(scale / this.scaleBarSteps_ * i * 100) / 100;
    var lengthString = length + (i === 0 ? '' : ' ' + suffix);
    var margin = i === 0 ? -3 : width / this.scaleBarSteps_ * -1;
    var minWidth = i === 0 ? 0 : width / this.scaleBarSteps_ * 2;
    return '<div ' + 'class="wg-scale-step-text" ' + 'style="' + 'margin-left: ' + margin + 'px;' + 'text-align: ' + (i === 0 ? 'left' : 'center') + '; ' + 'min-width: ' + minWidth + 'px;' + 'left: ' + (isLast ? width + 'px' : 'unset') + ';"' + '>' + lengthString + '</div>';
  };
  /**
   * Returns the appropriate scale for the given resolution and units.
   * @return {number} The appropriate scale.
   */


  ScaleLine.prototype.getScaleForResolution = function () {
    var resolution = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getPointResolution)(this.viewState_.projection, this.viewState_.resolution, this.viewState_.center, _proj_Units_js__WEBPACK_IMPORTED_MODULE_2__["default"].METERS);
    var dpi = this.dpi_ || DEFAULT_DPI;
    var inchesPerMeter = 1000 / 25.4;
    return parseFloat(resolution.toString()) * inchesPerMeter * dpi;
  };
  /**
   * Update the scale line element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */


  ScaleLine.prototype.render = function (mapEvent) {
    var frameState = mapEvent.frameState;

    if (!frameState) {
      this.viewState_ = null;
    } else {
      this.viewState_ = frameState.viewState;
    }

    this.updateElement_();
  };

  return ScaleLine;
}(_Control_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (ScaleLine);

/***/ }),

/***/ "./build/wg/control/Zoom.js":
/*!**********************************!*\
  !*** ./build/wg/control/Zoom.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Control.js */ "./build/wg/control/Control.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css.js */ "./build/wg/css.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./build/wg/easing.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/control/Zoom
 */






/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='wg-zoom'] CSS class name.
 * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.
 * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel='–'] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */

var Zoom =
/** @class */
function (_super) {
  __extends(Zoom, _super);
  /**
   * @param {Options} [opt_options] Zoom options.
   */


  function Zoom(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      target: options.target
    }) || this;
    var className = options.className !== undefined ? options.className : 'wg-zoom';
    var delta = options.delta !== undefined ? options.delta : 1;
    var zoomInClassName = options.zoomInClassName !== undefined ? options.zoomInClassName : className + '-in';
    var zoomOutClassName = options.zoomOutClassName !== undefined ? options.zoomOutClassName : className + '-out';
    var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
    var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : "\u2013";
    var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
    var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out';
    var inElement = document.createElement('button');
    inElement.className = zoomInClassName;
    inElement.setAttribute('type', 'button');
    inElement.title = zoomInTipLabel;
    inElement.appendChild(typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel);
    inElement.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK, _this.handleClick_.bind(_this, delta), false);
    var outElement = document.createElement('button');
    outElement.className = zoomOutClassName;
    outElement.setAttribute('type', 'button');
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
    outElement.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK, _this.handleClick_.bind(_this, -delta), false);
    var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);
    /**
     * @type {number}
     * @private
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */


  Zoom.prototype.handleClick_ = function (delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  };
  /**
   * @param {number} delta Zoom delta.
   * @private
   */


  Zoom.prototype.zoomByDelta_ = function (delta) {
    var map = this.getMap();
    var view = map.getView();

    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }

    var currentZoom = view.getZoom();

    if (currentZoom !== undefined) {
      var newZoom = view.getConstrainedZoom(currentZoom + delta);

      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }

        view.animate({
          zoom: newZoom,
          duration: this.duration_,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__.easeOut
        });
      } else {
        view.setZoom(newZoom);
      }
    }
  };

  return Zoom;
}(_Control_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Zoom);

/***/ }),

/***/ "./build/wg/control/ZoomSlider.js":
/*!****************************************!*\
  !*** ./build/wg/control/ZoomSlider.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Control.js */ "./build/wg/control/Control.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pointer/EventType.js */ "./build/wg/pointer/EventType.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css.js */ "./build/wg/css.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../easing.js */ "./build/wg/easing.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events.js */ "./build/wg/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/Event.js */ "./build/wg/events/Event.js");
/**
 * @module wg/control/ZoomSlider
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();









/**
 * The enum for available directions.
 *
 * @enum {number}
 */

var Direction = {
  VERTICAL: 0,
  HORIZONTAL: 1
};
/**
 * @typedef {Object} Options
 * @property {string} [className='wg-zoomslider'] CSS class name.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 */

/**
 * @classdesc
 * A slider type of control for zooming.
 *
 * Example:
 *
 *     map.addControl(new ZoomSlider());
 *
 * @api
 */

var ZoomSlider =
/** @class */
function (_super) {
  __extends(ZoomSlider, _super);
  /**
   * @param {Options} [opt_options] Zoom slider options.
   */


  function ZoomSlider(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render
    }) || this;
    /**
     * @type {!Array<import("../events.js").EventsKey>}
     * @private
     */

    _this.dragListenerKeys_ = [];
    /**
     * Will hold the current resolution of the view.
     *
     * @type {number|undefined}
     * @private
     */

    _this.currentResolution_ = undefined;
    /**
     * The direction of the slider. Will be determined from actual display of the
     * container and defaults to Direction.VERTICAL.
     *
     * @type {Direction}
     * @private
     */

    _this.direction_ = Direction.VERTICAL;
    /**
     * @type {boolean}
     * @private
     */

    _this.dragging_;
    /**
     * @type {number}
     * @private
     */

    _this.heightLimit_ = 0;
    /**
     * @type {number}
     * @private
     */

    _this.widthLimit_ = 0;
    /**
     * @type {number|undefined}
     * @private
     */

    _this.startX_;
    /**
     * @type {number|undefined}
     * @private
     */

    _this.startY_;
    /**
     * The calculated thumb size (border box plus margins).  Set when initSlider_
     * is called.
     * @type {import("../size.js").Size}
     * @private
     */

    _this.thumbSize_ = null;
    /**
     * Whether the slider is initialized.
     * @type {boolean}
     * @private
     */

    _this.sliderInitialized_ = false;
    /**
     * @type {number}
     * @private
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 200;
    var className = options.className !== undefined ? options.className : 'wg-zoomslider';
    var thumbElement = document.createElement('button');
    thumbElement.setAttribute('type', 'button');
    thumbElement.className = className + '-thumb ' + _css_js__WEBPACK_IMPORTED_MODULE_0__.CLASS_UNSELECTABLE;
    var containerElement = _this.element;
    containerElement.className = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_0__.CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_0__.CLASS_CONTROL;
    containerElement.appendChild(thumbElement);
    containerElement.addEventListener(_pointer_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN, _this.handleDraggerStart_.bind(_this), false);
    containerElement.addEventListener(_pointer_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERMOVE, _this.handleDraggerDrag_.bind(_this), false);
    containerElement.addEventListener(_pointer_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP, _this.handleDraggerEnd_.bind(_this), false);
    containerElement.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CLICK, _this.handleContainerClick_.bind(_this), false);
    thumbElement.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CLICK, _events_Event_js__WEBPACK_IMPORTED_MODULE_3__.stopPropagation, false);
    return _this;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default|null} map Map.
   * @api
   */


  ZoomSlider.prototype.setMap = function (map) {
    _super.prototype.setMap.call(this, map);

    if (map) {
      map.render();
    }
  };
  /**
   * Initializes the slider element. This will determine and set this controls
   * direction_ and also constrain the dragging of the thumb to always be within
   * the bounds of the container.
   *
   * @return {boolean} Initialization successful
   * @private
   */


  ZoomSlider.prototype.initSlider_ = function () {
    var container = this.element;
    var containerWidth = container.offsetWidth;
    var containerHeight = container.offsetHeight;

    if (containerWidth === 0 && containerHeight === 0) {
      return this.sliderInitialized_ = false;
    }

    var containerStyle = getComputedStyle(container);
    containerWidth -= parseFloat(containerStyle['paddingRight']) + parseFloat(containerStyle['paddingLeft']);
    containerHeight -= parseFloat(containerStyle['paddingTop']) + parseFloat(containerStyle['paddingBottom']);
    var thumb =
    /** @type {HTMLElement} */
    container.firstElementChild;
    var thumbStyle = getComputedStyle(thumb);
    var thumbWidth = thumb.offsetWidth + parseFloat(thumbStyle['marginRight']) + parseFloat(thumbStyle['marginLeft']);
    var thumbHeight = thumb.offsetHeight + parseFloat(thumbStyle['marginTop']) + parseFloat(thumbStyle['marginBottom']);
    this.thumbSize_ = [thumbWidth, thumbHeight];

    if (containerWidth > containerHeight) {
      this.direction_ = Direction.HORIZONTAL;
      this.widthLimit_ = containerWidth - thumbWidth;
    } else {
      this.direction_ = Direction.VERTICAL;
      this.heightLimit_ = containerHeight - thumbHeight;
    }

    return this.sliderInitialized_ = true;
  };
  /**
   * @param {PointerEvent} event The browser event to handle.
   * @private
   */


  ZoomSlider.prototype.handleContainerClick_ = function (event) {
    var view = this.getMap().getView();
    var relativePosition = this.getRelativePosition_(event.offsetX - this.thumbSize_[0] / 2, event.offsetY - this.thumbSize_[1] / 2);
    var resolution = this.getResolutionForPosition_(relativePosition);
    var zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));
    view.animateInternal({
      zoom: zoom,
      duration: this.duration_,
      easing: _easing_js__WEBPACK_IMPORTED_MODULE_4__.easeOut
    });
  };
  /**
   * Handle dragger start events.
   * @param {PointerEvent} event The drag event.
   * @private
   */


  ZoomSlider.prototype.handleDraggerStart_ = function (event) {
    if (!this.dragging_ && event.target === this.element.firstElementChild) {
      var element =
      /** @type {HTMLElement} */
      this.element.firstElementChild;
      this.getMap().getView().beginInteraction();
      this.startX_ = event.clientX - parseFloat(element.style.left);
      this.startY_ = event.clientY - parseFloat(element.style.top);
      this.dragging_ = true;

      if (this.dragListenerKeys_.length === 0) {
        var drag = this.handleDraggerDrag_;
        var end = this.handleDraggerEnd_;
        var doc = this.getMap().getOwnerDocument();
        this.dragListenerKeys_.push((0,_events_js__WEBPACK_IMPORTED_MODULE_5__.listen)(doc, _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERMOVE, drag, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_5__.listen)(doc, _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP, end, this));
      }
    }
  };
  /**
   * Handle dragger drag events.
   *
   * @param {PointerEvent} event The drag event.
   * @private
   */


  ZoomSlider.prototype.handleDraggerDrag_ = function (event) {
    if (this.dragging_) {
      var deltaX = event.clientX - this.startX_;
      var deltaY = event.clientY - this.startY_;
      var relativePosition = this.getRelativePosition_(deltaX, deltaY);
      this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
      this.getMap().getView().setResolution(this.currentResolution_);
    }
  };
  /**
   * Handle dragger end events.
   * @param {PointerEvent} event The drag event.
   * @private
   */


  ZoomSlider.prototype.handleDraggerEnd_ = function (event) {
    if (this.dragging_) {
      var view = this.getMap().getView();
      view.endInteraction();
      this.dragging_ = false;
      this.startX_ = undefined;
      this.startY_ = undefined;
      this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_5__.unlistenByKey);
      this.dragListenerKeys_.length = 0;
    }
  };
  /**
   * Positions the thumb inside its container according to the given resolution.
   *
   * @param {number} res The res.
   * @private
   */


  ZoomSlider.prototype.setThumbPosition_ = function (res) {
    var position = this.getPositionForResolution_(res);
    var thumb =
    /** @type {HTMLElement} */
    this.element.firstElementChild;

    if (this.direction_ == Direction.HORIZONTAL) {
      thumb.style.left = this.widthLimit_ * position + 'px';
    } else {
      thumb.style.top = this.heightLimit_ * position + 'px';
    }
  };
  /**
   * Calculates the relative position of the thumb given x and y offsets.  The
   * relative position scales from 0 to 1.  The x and y offsets are assumed to be
   * in pixel units within the dragger limits.
   *
   * @param {number} x Pixel position relative to the left of the slider.
   * @param {number} y Pixel position relative to the top of the slider.
   * @return {number} The relative position of the thumb.
   * @private
   */


  ZoomSlider.prototype.getRelativePosition_ = function (x, y) {
    var amount;

    if (this.direction_ === Direction.HORIZONTAL) {
      amount = x / this.widthLimit_;
    } else {
      amount = y / this.heightLimit_;
    }

    return (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(amount, 0, 1);
  };
  /**
   * Calculates the corresponding resolution of the thumb given its relative
   * position (where 0 is the minimum and 1 is the maximum).
   *
   * @param {number} position The relative position of the thumb.
   * @return {number} The corresponding resolution.
   * @private
   */


  ZoomSlider.prototype.getResolutionForPosition_ = function (position) {
    var fn = this.getMap().getView().getResolutionForValueFunction();
    return fn(1 - position);
  };
  /**
   * Determines the relative position of the slider for the given resolution.  A
   * relative position of 0 corresponds to the minimum view resolution.  A
   * relative position of 1 corresponds to the maximum view resolution.
   *
   * @param {number} res The resolution.
   * @return {number} The relative position value (between 0 and 1).
   * @private
   */


  ZoomSlider.prototype.getPositionForResolution_ = function (res) {
    var fn = this.getMap().getView().getValueForResolutionFunction();
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(1 - fn(res), 0, 1);
  };
  /**
   * Update the zoomslider element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */


  ZoomSlider.prototype.render = function (mapEvent) {
    if (!mapEvent.frameState) {
      return;
    }

    if (!this.sliderInitialized_ && !this.initSlider_()) {
      return;
    }

    var res = mapEvent.frameState.viewState.resolution;
    this.currentResolution_ = res;
    this.setThumbPosition_(res);
  };

  return ZoomSlider;
}(_Control_js__WEBPACK_IMPORTED_MODULE_7__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (ZoomSlider);

/***/ }),

/***/ "./build/wg/control/ZoomToExtent.js":
/*!******************************************!*\
  !*** ./build/wg/control/ZoomToExtent.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Control.js */ "./build/wg/control/Control.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css.js */ "./build/wg/css.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/control/ZoomToExtent
 */






/**
 * @typedef {Object} Options
 * @property {string} [className='wg-zoom-extent'] Class name.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {string|HTMLElement} [label='E'] Text label to use for the button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Fit to extent'] Text label to use for the button tip.
 * @property {import("../extent.js").Extent} [extent] The extent to zoom to. If undefined the validity
 * extent of the view projection is used.
 */

/**
 * @classdesc
 * A button control which, when pressed, changes the map view to a specific
 * extent. To style this control use the css selector `.ol-zoom-extent`.
 *
 * @api
 */

var ZoomToExtent =
/** @class */
function (_super) {
  __extends(ZoomToExtent, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function ZoomToExtent(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      target: options.target
    }) || this;
    /**
     * @type {?import("../extent.js").Extent|null}
     * @protected
     */

    _this.extent = options.extent ? options.extent : null;
    var className = options.className !== undefined ? options.className : 'wg-zoom-extent';
    var label = options.label !== undefined ? options.label : 'E';
    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Fit to extent';
    var button = document.createElement('button');
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(typeof label === 'string' ? document.createTextNode(label) : label);
    button.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK, _this.handleClick_.bind(_this), false);
    var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(button);
    return _this;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  ZoomToExtent.prototype.handleClick_ = function (event) {
    event.preventDefault();
    this.handleZoomToExtent();
  };
  /**
   * @protected
   */


  ZoomToExtent.prototype.handleZoomToExtent = function () {
    var map = this.getMap();
    var view = map.getView();
    var extent = !this.extent ? view.getProjection().getExtent() : this.extent;
    view.fitInternal((0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_2__.fromExtent)(extent));
  };

  return ZoomToExtent;
}(_Control_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (ZoomToExtent);

/***/ }),

/***/ "./build/wg/coordinate.js":
/*!********************************!*\
  !*** ./build/wg/coordinate.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "add": function() { return /* binding */ add; },
/* harmony export */   "closestOnCircle": function() { return /* binding */ closestOnCircle; },
/* harmony export */   "closestOnSegment": function() { return /* binding */ closestOnSegment; },
/* harmony export */   "createStringXY": function() { return /* binding */ createStringXY; },
/* harmony export */   "degreesToStringHDMS": function() { return /* binding */ degreesToStringHDMS; },
/* harmony export */   "format": function() { return /* binding */ format; },
/* harmony export */   "equals": function() { return /* binding */ equals; },
/* harmony export */   "rotate": function() { return /* binding */ rotate; },
/* harmony export */   "scale": function() { return /* binding */ scale; },
/* harmony export */   "squaredDistance": function() { return /* binding */ squaredDistance; },
/* harmony export */   "distance": function() { return /* binding */ distance; },
/* harmony export */   "squaredDistanceToSegment": function() { return /* binding */ squaredDistanceToSegment; },
/* harmony export */   "toStringHDMS": function() { return /* binding */ toStringHDMS; },
/* harmony export */   "toStringXY": function() { return /* binding */ toStringXY; },
/* harmony export */   "wrapX": function() { return /* binding */ wrapX; },
/* harmony export */   "getWorldsAway": function() { return /* binding */ getWorldsAway; }
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent.js */ "./build/wg/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./build/wg/math.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ "./build/wg/string.js");
/**
 * @module wg/coordinate
 */



/**
 * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */

/**
 * A function that takes a {@link module:wg/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */

/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'wg/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */

function add(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */

function closestOnCircle(coordinate, circle) {
  var r = circle.getRadius();
  var center = circle.getCenter();
  var x0 = center[0];
  var y0 = center[1];
  var x1 = coordinate[0];
  var y1 = coordinate[1];
  var dx = x1 - x0;
  var dy = y1 - y0;

  if (dx === 0 && dy === 0) {
    dx = 1;
  }

  var d = Math.sqrt(dx * dx + dy * dy);
  var x = x0 + r * dx / d;
  var y = y0 + r * dy / d;
  return [x, y];
}
/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */

function closestOnSegment(coordinate, segment) {
  var x0 = coordinate[0];
  var y0 = coordinate[1];
  var start = segment[0];
  var end = segment[1];
  var x1 = start[0];
  var y1 = start[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  var x, y;

  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }

  return [x, y];
}
/**
 * Returns a {@link module:wg/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'wg/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'wg/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */

function createStringXY(opt_fractionDigits) {
  return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function (coordinate) {
      return toStringXY(coordinate, opt_fractionDigits);
    }
  );
}
/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */

function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {
  var normalizedDegrees = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.modulo)(degrees + 180, 360) - 180;
  var x = Math.abs(3600 * normalizedDegrees);
  var dflPrecision = opt_fractionDigits || 0;
  var precision = Math.pow(10, dflPrecision);
  var deg = Math.floor(x / 3600);
  var min = Math.floor((x - deg * 3600) / 60);
  var sec = x - deg * 3600 - min * 60;
  sec = Math.ceil(sec * precision) / precision;

  if (sec >= 60) {
    sec = 0;
    min += 1;
  }

  if (min >= 60) {
    min = 0;
    deg += 1;
  }

  return deg + "\xB0 " + (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.padNumber)(min, 2) + "\u2032 " + (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.padNumber)(sec, 2, dflPrecision) + "\u2033" + (normalizedDegrees == 0 ? '' : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));
}
/**
 * Transforms the given {@link module:wg/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'wg/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'wg/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */

function format(coordinate, template, opt_fractionDigits) {
  if (coordinate) {
    return template.replace('{x}', coordinate[0].toFixed(opt_fractionDigits)).replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
  } else {
    return '';
  }
}
/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */

function equals(coordinate1, coordinate2) {
  var equals = true;

  for (var i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }

  return equals;
}
/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'wg/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */

function rotate(coordinate, angle) {
  var cosAngle = Math.cos(angle);
  var sinAngle = Math.sin(angle);
  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}
/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'wg/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */

function scale(coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
}
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */

function squaredDistance(coord1, coord2) {
  var dx = coord1[0] - coord2[0];
  var dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */

function distance(coord1, coord2) {
  return Math.sqrt(squaredDistance(coord1, coord2));
}
/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */

function squaredDistanceToSegment(coordinate, segment) {
  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}
/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'wg/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'wg/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */

function toStringHDMS(coordinate, opt_fractionDigits) {
  if (coordinate) {
    return degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) + ' ' + degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits);
  } else {
    return '';
  }
}
/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'wg/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'wg/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */

function toStringXY(coordinate, opt_fractionDigits) {
  return format(coordinate, '{x}, {y}', opt_fractionDigits);
}
/**
 * Modifies the provided coordinate in-place to be within the real world
 * extent. The lower projection extent boundary is inclusive, the upper one
 * exclusive.
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {Coordinate} The coordinate within the real world extent.
 */

function wrapX(coordinate, projection) {
  if (projection.canWrapX()) {
    var worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projection.getExtent());
    var worldsAway = getWorldsAway(coordinate, projection, worldWidth);

    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }

  return coordinate;
}
/**
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {number} [opt_sourceExtentWidth] Width of the source extent.
 * @return {number} Offset in world widths.
 */

function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {
  var projectionExtent = projection.getExtent();
  var worldsAway = 0;

  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
    var sourceExtentWidth = opt_sourceExtentWidth || (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projectionExtent);
    worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
  }

  return worldsAway;
}

/***/ }),

/***/ "./build/wg/css.js":
/*!*************************!*\
  !*** ./build/wg/css.js ***!
  \*************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CLASS_HIDDEN": function() { return /* binding */ CLASS_HIDDEN; },
/* harmony export */   "CLASS_SELECTABLE": function() { return /* binding */ CLASS_SELECTABLE; },
/* harmony export */   "CLASS_UNSELECTABLE": function() { return /* binding */ CLASS_UNSELECTABLE; },
/* harmony export */   "CLASS_UNSUPPORTED": function() { return /* binding */ CLASS_UNSUPPORTED; },
/* harmony export */   "CLASS_CONTROL": function() { return /* binding */ CLASS_CONTROL; },
/* harmony export */   "CLASS_COLLAPSED": function() { return /* binding */ CLASS_COLLAPSED; },
/* harmony export */   "getFontParameters": function() { return /* binding */ getFontParameters; },
/* harmony export */   "cssOpacity": function() { return /* binding */ cssOpacity; }
/* harmony export */ });
/**
 * @module wg/css
 */

/**
 * @typedef {Object} FontParameters
 * @property {string} style Style.
 * @property {string} variant Variant.
 * @property {string} weight Weight.
 * @property {string} size Size.
 * @property {string} lineHeight LineHeight.
 * @property {string} family Family.
 * @property {Array<string>} families Families.
 */

/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */
var CLASS_HIDDEN = 'wg-hidden';
/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */

var CLASS_SELECTABLE = 'wg-selectable';
/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */

var CLASS_UNSELECTABLE = 'wg-unselectable';
/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */

var CLASS_UNSUPPORTED = 'wg-unsupported';
/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */

var CLASS_CONTROL = 'wg-control';
/**
 * The CSS class that we'll give the DOM elements that are collapsed, i.e.
 * to those elements which usually can be expanded.
 *
 * @const
 * @type {string}
 */

var CLASS_COLLAPSED = 'wg-collapsed';
/**
 * From https://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
 * @type {RegExp}
 */

var fontRegEx = new RegExp(['^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)', '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)', '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)', '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?', '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))', '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))', '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$'].join(''), 'i');
var fontRegExMatchIndex = ['style', 'variant', 'weight', 'size', 'lineHeight', 'family'];
/**
 * Get the list of font families from a font spec.  Note that this doesn't work
 * for font families that have commas in them.
 * @param {string} fontSpec The CSS font property.
 * @return {FontParameters|null} The font parameters (or null if the input spec is invalid).
 */

var getFontParameters = function getFontParameters(fontSpec) {
  var match = fontSpec.match(fontRegEx);

  if (!match) {
    return null;
  }

  var style =
  /** @type {FontParameters} */
  {
    lineHeight: 'normal',
    size: '1.2em',
    style: 'normal',
    weight: 'normal',
    variant: 'normal'
  };

  for (var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
    var value = match[i + 1];

    if (value !== undefined) {
      style[fontRegExMatchIndex[i]] = value;
    }
  }

  style.families = style.family.split(/,\s?/);
  return style;
};
/**
 * @param {number} opacity Opacity (0..1).
 * @return {string} CSS opacity.
 */

function cssOpacity(opacity) {
  return opacity === 1 ? '' : String(Math.round(opacity * 100) / 100);
}

/***/ }),

/***/ "./build/wg/dom.js":
/*!*************************!*\
  !*** ./build/wg/dom.js ***!
  \*************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCanvasContext2D": function() { return /* binding */ createCanvasContext2D; },
/* harmony export */   "outerWidth": function() { return /* binding */ outerWidth; },
/* harmony export */   "outerHeight": function() { return /* binding */ outerHeight; },
/* harmony export */   "replaceNode": function() { return /* binding */ replaceNode; },
/* harmony export */   "removeNode": function() { return /* binding */ removeNode; },
/* harmony export */   "removeChildren": function() { return /* binding */ removeChildren; },
/* harmony export */   "replaceChildren": function() { return /* binding */ replaceChildren; }
/* harmony export */ });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./has.js */ "./build/wg/has.js");

/**
 * @module wg/dom
 */
//FIXME Move this function to the canvas module

/**
 * Create an html canvas element and returns its 2d context.
 * @param {number} [opt_width] Canvas width.
 * @param {number} [opt_height] Canvas height.
 * @param {Array<HTMLCanvasElement>} [opt_canvasPool] Canvas pool to take existing canvas from.
 * @param {CanvasRenderingContext2DSettings} [opt_Context2DSettings] CanvasRenderingContext2DSettings
 * @return {CanvasRenderingContext2D} The context.
 */

function createCanvasContext2D(opt_width, opt_height, opt_canvasPool, opt_Context2DSettings) {
  /** @type {HTMLCanvasElement|OffscreenCanvas} */
  var canvas;

  if (opt_canvasPool && opt_canvasPool.length) {
    canvas = opt_canvasPool.shift();
  } else if (_has_js__WEBPACK_IMPORTED_MODULE_0__.WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(opt_width || 300, opt_height || 300);
  } else {
    canvas = document.createElement('canvas');
  }

  if (opt_width) {
    canvas.width = opt_width;
  }

  if (opt_height) {
    canvas.height = opt_height;
  } //FIXME Allow OffscreenCanvasRenderingContext2D as return type


  return (
    /** @type {CanvasRenderingContext2D} */
    canvas.getContext('2d', opt_Context2DSettings)
  );
}
/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */

function outerWidth(element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
  return width;
}
/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */

function outerHeight(element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
  return height;
}
/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */

function replaceNode(newNode, oldNode) {
  var parent = oldNode.parentNode;

  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}
/**
 * @param {Node} node The node to remove.
 * @return {Node|null} The node that was removed or null.
 */

function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}
/**
 * @param {Node} node The node to remove the children from.
 */

function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}
/**
 * Transform the children of a parent node so they match the
 * provided list of children.  This function aims to efficiently
 * remove, add, and reorder child nodes while maintaining a simple
 * implementation (it is not guaranteed to minimize DOM operations).
 * @param {Node} node The parent node whose children need reworking.
 * @param {Array<Node>} children The desired children.
 */

function replaceChildren(node, children) {
  var oldChildren = node.childNodes;

  for (var i = 0; true; ++i) {
    var oldChild = oldChildren[i];
    var newChild = children[i]; // check if our work is done

    if (!oldChild && !newChild) {
      break;
    } // check if children match


    if (oldChild === newChild) {
      continue;
    } // check if a new child needs to be added


    if (!oldChild) {
      node.appendChild(newChild);
      continue;
    } // check if an old child needs to be removed


    if (!newChild) {
      node.removeChild(oldChild);
      --i;
      continue;
    } // reorder


    node.insertBefore(newChild, oldChild);
  }
}

/***/ }),

/***/ "./build/wg/easing.js":
/*!****************************!*\
  !*** ./build/wg/easing.js ***!
  \****************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "easeIn": function() { return /* binding */ easeIn; },
/* harmony export */   "easeOut": function() { return /* binding */ easeOut; },
/* harmony export */   "inAndOut": function() { return /* binding */ inAndOut; },
/* harmony export */   "linear": function() { return /* binding */ linear; },
/* harmony export */   "upAndDown": function() { return /* binding */ upAndDown; }
/* harmony export */ });
/**
 * @module wg/easing
 */

/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeIn(t) {
  return Math.pow(t, 3);
}
/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */

function easeOut(t) {
  return 1 - easeIn(1 - t);
}
/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */

function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}
/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */

function linear(t) {
  return t;
}
/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:wg/easing.inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */

function upAndDown(t) {
  if (t < 0.5) {
    return inAndOut(2 * t);
  } else {
    return 1 - inAndOut(2 * (t - 0.5));
  }
}

/***/ }),

/***/ "./build/wg/events.js":
/*!****************************!*\
  !*** ./build/wg/events.js ***!
  \****************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "listen": function() { return /* binding */ listen; },
/* harmony export */   "listenOnce": function() { return /* binding */ listenOnce; },
/* harmony export */   "unlistenByKey": function() { return /* binding */ unlistenByKey; }
/* harmony export */ });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./obj.js */ "./build/wg/obj.js");
/**
 * @module wg/events
 */

/**
 * Key to use with {@link module:wg/Observable.unByKey}.
 * @typedef {Object} EventsKey
 * @property {ListenerFunction} listener Listener.
 * @property {import("./events/Target.js").EventTargetLike} target Target.
 * @property {string} type Type.
 * @api
 */

/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */

/**
 * @typedef {Object} ListenerObject
 * @property {ListenerFunction} handleEvent HandleEvent listener function.
 */

/**
 * @typedef {ListenerFunction|ListenerObject} Listener
 */

/**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:wg/events.unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [opt_this] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean} [opt_once] If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */

function listen(target, type, _listener, opt_this, opt_once) {
  if (opt_this && opt_this !== target) {
    _listener = _listener.bind(opt_this);
  }

  if (opt_once) {
    var originalListener_1 = _listener;

    _listener = function listener() {
      target.removeEventListener(type, _listener);
      originalListener_1.apply(this, arguments);
    };
  }

  var eventsKey = {
    target: target,
    type: type,
    listener: _listener
  };
  target.addEventListener(type, _listener);
  return eventsKey;
}
/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:wg/events.unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:wg/events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [opt_this] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */

function listenOnce(target, type, listener, opt_this) {
  return listen(target, type, listener, opt_this, true);
}
/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:wg/events.listen} or {@link module:wg/events.listenOnce}.
 *
 * @param {EventsKey} key The key.
 */

function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.clear)(key);
  }
}

/***/ }),

/***/ "./build/wg/events/Event.js":
/*!**********************************!*\
  !*** ./build/wg/events/Event.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stopPropagation": function() { return /* binding */ stopPropagation; },
/* harmony export */   "preventDefault": function() { return /* binding */ preventDefault; }
/* harmony export */ });
/**
 * @module wg/events/Event
 */

/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:wg/events/Target~Target}.
 */
var BaseEvent =
/** @class */
function () {
  /**
   * @param {string} type Type.
   */
  function BaseEvent(type) {
    /**
     * @type {boolean}
     */
    this.propagationStopped;
    /**
     * @type {boolean}
     */

    this.defaultPrevented;
    /**
     * The event type.
     * @type {string}
     * @api
     */

    this.type = type;
    /**
     * The event target.
     * @type {Object}
     * @api
     */

    this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */


  BaseEvent.prototype.preventDefault = function () {
    this.defaultPrevented = true;
  };
  /**
   * Stop event propagation.
   * @api
   */


  BaseEvent.prototype.stopPropagation = function () {
    this.propagationStopped = true;
  };

  return BaseEvent;
}();
/**
 * @param {Event|import("./Event.js").default} evt Event
 */


function stopPropagation(evt) {
  evt.stopPropagation();
}
/**
 * @param {Event|import("./Event.js").default} evt Event
 */

function preventDefault(evt) {
  evt.preventDefault();
}
/* harmony default export */ __webpack_exports__["default"] = (BaseEvent);

/***/ }),

/***/ "./build/wg/events/EventType.js":
/*!**************************************!*\
  !*** ./build/wg/events/EventType.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/events/EventType
 */

/**
 * @enum {string}
 * @const
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:wg/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: 'change',

  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:wg/events/Event~BaseEvent#error
   * @api
   */
  ERROR: 'error',
  BLUR: 'blur',
  CLEAR: 'clear',
  CONTEXTMENU: 'contextmenu',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  FOCUS: 'focus',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  RESIZE: 'resize',
  TOUCHMOVE: 'touchmove',
  WHEEL: 'wheel'
});

/***/ }),

/***/ "./build/wg/events/KeyCode.js":
/*!************************************!*\
  !*** ./build/wg/events/KeyCode.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/events/KeyCode
 */

/**
 * @enum {number}
 * @const
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
});

/***/ }),

/***/ "./build/wg/events/Target.js":
/*!***********************************!*\
  !*** ./build/wg/events/Target.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Disposable.js */ "./build/wg/Disposable.js");
/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/events/Target
 */






/**
 * @typedef {EventTarget|Target} EventTargetLike
 */

/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */

var Target =
/** @class */
function (_super) {
  __extends(Target, _super);
  /**
   * @param {*} [opt_target] Default event target for dispatched events.
   */


  function Target(opt_target) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {*}
     */


    _this.eventTarget_ = opt_target;
    /**
     * @private
     * @type {Object<string, number>}
     */

    _this.pendingRemovals_ = null;
    /**
     * @private
     * @type {Object<string, number>}
     */

    _this.dispatching_ = null;
    /**
     * @private
     * @type {Object<string, Array<import("../events.js").Listener>>}
     */

    _this.listeners_ = null;
    return _this;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */


  Target.prototype.addEventListener = function (type, listener) {
    if (!type || !listener) {
      return;
    }

    var listeners = this.listeners_ || (this.listeners_ = {});
    var listenersForType = listeners[type] || (listeners[type] = []);

    if (listenersForType.indexOf(listener) === -1) {
      listenersForType.push(listener);
    }
  };
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */


  Target.prototype.dispatchEvent = function (event) {
    var isString = typeof event === 'string';
    var type = isString ? event : event.type;
    var listeners = this.listeners_ && this.listeners_[type];

    if (!listeners) {
      return;
    }

    var evt = isString ? new _Event_js__WEBPACK_IMPORTED_MODULE_0__["default"](event) :
    /** @type {Event} */
    event;

    if (!evt.target) {
      evt.target = this.eventTarget_ || this;
    }

    var dispatching = this.dispatching_ || (this.dispatching_ = {});
    var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});

    if (!(type in dispatching)) {
      dispatching[type] = 0;
      pendingRemovals[type] = 0;
    }

    ++dispatching[type];
    var propagate;

    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      if ('handleEvent' in listeners[i]) {
        propagate =
        /** @type {import("../events.js").ListenerObject} */
        listeners[i].handleEvent(evt);
      } else {
        propagate =
        /** @type {import("../events.js").ListenerFunction} */
        listeners[i].call(this, evt);
      }

      if (propagate === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }

    if (--dispatching[type] === 0) {
      var pr = pendingRemovals[type];
      delete pendingRemovals[type];

      while (pr--) {
        this.removeEventListener(type, _functions_js__WEBPACK_IMPORTED_MODULE_1__.VOID);
      }

      delete dispatching[type];
    }

    return propagate;
  };
  /**
   * Clean up.
   */


  Target.prototype.disposeInternal = function () {
    this.listeners_ && (0,_obj_js__WEBPACK_IMPORTED_MODULE_2__.clear)(this.listeners_);
  };
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */


  Target.prototype.getListeners = function (type) {
    return this.listeners_ && this.listeners_[type] || undefined;
  };
  /**
   * @param {string} [opt_type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */


  Target.prototype.hasListener = function (opt_type) {
    if (!this.listeners_) {
      return false;
    }

    return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
  };
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */


  Target.prototype.removeEventListener = function (type, listener) {
    var listeners = this.listeners_ && this.listeners_[type];

    if (listeners) {
      var index = listeners.indexOf(listener);

      if (index !== -1) {
        if (this.pendingRemovals_ && type in this.pendingRemovals_) {
          // make listener a no-op, and remove later in #dispatchEvent()
          listeners[index] = _functions_js__WEBPACK_IMPORTED_MODULE_1__.VOID;
          ++this.pendingRemovals_[type];
        } else {
          listeners.splice(index, 1);

          if (listeners.length === 0) {
            delete this.listeners_[type];
          }
        }
      }
    }
  };

  return Target;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Target);

/***/ }),

/***/ "./build/wg/events/condition.js":
/*!**************************************!*\
  !*** ./build/wg/events/condition.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "all": function() { return /* binding */ all; },
/* harmony export */   "altKeyOnly": function() { return /* binding */ altKeyOnly; },
/* harmony export */   "altShiftKeysOnly": function() { return /* binding */ altShiftKeysOnly; },
/* harmony export */   "focus": function() { return /* binding */ focus; },
/* harmony export */   "focusWithTabindex": function() { return /* binding */ focusWithTabindex; },
/* harmony export */   "always": function() { return /* binding */ always; },
/* harmony export */   "click": function() { return /* binding */ click; },
/* harmony export */   "mouseActionButton": function() { return /* binding */ mouseActionButton; },
/* harmony export */   "never": function() { return /* binding */ never; },
/* harmony export */   "pointerMove": function() { return /* binding */ pointerMove; },
/* harmony export */   "singleClick": function() { return /* binding */ singleClick; },
/* harmony export */   "doubleClick": function() { return /* binding */ doubleClick; },
/* harmony export */   "noModifierKeys": function() { return /* binding */ noModifierKeys; },
/* harmony export */   "platformModifierKeyOnly": function() { return /* binding */ platformModifierKeyOnly; },
/* harmony export */   "shiftKeyOnly": function() { return /* binding */ shiftKeyOnly; },
/* harmony export */   "targetNotEditable": function() { return /* binding */ targetNotEditable; },
/* harmony export */   "mouseOnly": function() { return /* binding */ mouseOnly; },
/* harmony export */   "touchOnly": function() { return /* binding */ touchOnly; },
/* harmony export */   "penOnly": function() { return /* binding */ penOnly; },
/* harmony export */   "primaryAction": function() { return /* binding */ primaryAction; }
/* harmony export */ });
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./build/wg/MapBrowserEventType.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../has.js */ "./build/wg/has.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/**
 * @module wg/events/condition
 */




/**
 * A function that takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
 */

/**
 * Creates a condition function that passes when all provided conditions pass.
 * @param {...Condition} var_args Conditions to check.
 * @return {Condition} Condition function.
 */

function all(var_args) {
  var conditions = arguments;
  /**
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} All conditions passed.
   */

  return function (event) {
    var pass = true;

    for (var i = 0, ii = conditions.length; i < ii; ++i) {
      pass = pass && conditions[i](event);

      if (!pass) {
        break;
      }
    }

    return pass;
  };
}
/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */

var altKeyOnly = function altKeyOnly(mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */

var altShiftKeysOnly = function altShiftKeysOnly(mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
/**
 * Return `true` if the map has the focus. This condition requires a map target
 * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map has the focus.
 * @api
 */

var focus = function focus(event) {
  var targetElement = event.map.getTargetElement();
  var activeElement = event.map.getOwnerDocument().activeElement;
  return targetElement.contains(activeElement);
};
/**
 * Return `true` if the map has the focus or no 'tabindex' attribute set.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map container has the focus or no 'tabindex' attribute.
 */

var focusWithTabindex = function focusWithTabindex(event) {
  return event.map.getTargetElement().hasAttribute('tabindex') ? focus(event) : true;
};
/**
 * Return always true.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @api
 */

var always = _functions_js__WEBPACK_IMPORTED_MODULE_0__.TRUE;
/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */

var click = function click(mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK;
};
/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */

var mouseActionButton = function mouseActionButton(mapBrowserEvent) {
  var originalEvent =
  /** @type {MouseEvent} */
  mapBrowserEvent.originalEvent;
  return originalEvent.button == 0 && !(_has_js__WEBPACK_IMPORTED_MODULE_2__.WEBKIT && _has_js__WEBPACK_IMPORTED_MODULE_2__.MAC && originalEvent.ctrlKey);
};
/**
 * Return always false.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @api
 */

var never = _functions_js__WEBPACK_IMPORTED_MODULE_0__.FALSE;
/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */

var pointerMove = function pointerMove(mapBrowserEvent) {
  return mapBrowserEvent.type == 'pointermove';
};
/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */

var singleClick = function singleClick(mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].SINGLECLICK;
};
/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */

var doubleClick = function doubleClick(mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].DBLCLICK;
};
/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */

var noModifierKeys = function noModifierKeys(mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */

var platformModifierKeyOnly = function platformModifierKeyOnly(mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && (_has_js__WEBPACK_IMPORTED_MODULE_2__.MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */

var shiftKeyOnly = function shiftKeyOnly(mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
/**
 * Return `true` if the target element is not editable, i.e. not a `<input>`-,
 * `<select>`- or `<textarea>`-element, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */

var targetNotEditable = function targetNotEditable(mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  var tagName =
  /** @type {Element} */
  originalEvent.target.tagName;
  return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';
};
/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */

var mouseOnly = function mouseOnly(mapBrowserEvent) {
  var pointerEvent =
  /** @type {import("../MapBrowserEvent").default} */
  mapBrowserEvent.originalEvent;
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType

  return pointerEvent.pointerType == 'mouse';
};
/**
 * Return `true` if the event originates from a touchable device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a touchable device.
 * @api
 */

var touchOnly = function touchOnly(mapBrowserEvent) {
  var pointerEvt =
  /** @type {import("../MapBrowserEvent").default} */
  mapBrowserEvent.originalEvent;
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType

  return pointerEvt.pointerType === 'touch';
};
/**
 * Return `true` if the event originates from a digital pen.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a digital pen.
 * @api
 */

var penOnly = function penOnly(mapBrowserEvent) {
  var pointerEvt =
  /** @type {import("../MapBrowserEvent").default} */
  mapBrowserEvent.originalEvent;
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType

  return pointerEvt.pointerType === 'pen';
};
/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * See https://www.w3.org/TR/pointerevents/#button-states.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */

var primaryAction = function primaryAction(mapBrowserEvent) {
  var pointerEvent =
  /** @type {import("../MapBrowserEvent").default} */
  mapBrowserEvent.originalEvent;
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event

  return pointerEvent.isPrimary && pointerEvent.button === 0;
};

/***/ }),

/***/ "./build/wg/extent.js":
/*!****************************!*\
  !*** ./build/wg/extent.js ***!
  \****************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "boundingExtent": function() { return /* binding */ boundingExtent; },
/* harmony export */   "buffer": function() { return /* binding */ buffer; },
/* harmony export */   "clone": function() { return /* binding */ clone; },
/* harmony export */   "closestSquaredDistanceXY": function() { return /* binding */ closestSquaredDistanceXY; },
/* harmony export */   "containsCoordinate": function() { return /* binding */ containsCoordinate; },
/* harmony export */   "containsExtent": function() { return /* binding */ containsExtent; },
/* harmony export */   "containsXY": function() { return /* binding */ containsXY; },
/* harmony export */   "coordinateRelationship": function() { return /* binding */ coordinateRelationship; },
/* harmony export */   "createEmpty": function() { return /* binding */ createEmpty; },
/* harmony export */   "createOrUpdate": function() { return /* binding */ createOrUpdate; },
/* harmony export */   "createOrUpdateEmpty": function() { return /* binding */ createOrUpdateEmpty; },
/* harmony export */   "createOrUpdateFromCoordinate": function() { return /* binding */ createOrUpdateFromCoordinate; },
/* harmony export */   "createOrUpdateFromCoordinates": function() { return /* binding */ createOrUpdateFromCoordinates; },
/* harmony export */   "createOrUpdateFromFlatCoordinates": function() { return /* binding */ createOrUpdateFromFlatCoordinates; },
/* harmony export */   "createOrUpdateFromRings": function() { return /* binding */ createOrUpdateFromRings; },
/* harmony export */   "equals": function() { return /* binding */ equals; },
/* harmony export */   "approximatelyEquals": function() { return /* binding */ approximatelyEquals; },
/* harmony export */   "extend": function() { return /* binding */ extend; },
/* harmony export */   "extendCoordinate": function() { return /* binding */ extendCoordinate; },
/* harmony export */   "extendCoordinates": function() { return /* binding */ extendCoordinates; },
/* harmony export */   "extendFlatCoordinates": function() { return /* binding */ extendFlatCoordinates; },
/* harmony export */   "extendRings": function() { return /* binding */ extendRings; },
/* harmony export */   "extendXY": function() { return /* binding */ extendXY; },
/* harmony export */   "forEachCorner": function() { return /* binding */ forEachCorner; },
/* harmony export */   "getArea": function() { return /* binding */ getArea; },
/* harmony export */   "getBottomLeft": function() { return /* binding */ getBottomLeft; },
/* harmony export */   "getBottomRight": function() { return /* binding */ getBottomRight; },
/* harmony export */   "getCenter": function() { return /* binding */ getCenter; },
/* harmony export */   "getCorner": function() { return /* binding */ getCorner; },
/* harmony export */   "getEnlargedArea": function() { return /* binding */ getEnlargedArea; },
/* harmony export */   "getForViewAndSize": function() { return /* binding */ getForViewAndSize; },
/* harmony export */   "getHeight": function() { return /* binding */ getHeight; },
/* harmony export */   "getIntersectionArea": function() { return /* binding */ getIntersectionArea; },
/* harmony export */   "getIntersection": function() { return /* binding */ getIntersection; },
/* harmony export */   "getMargin": function() { return /* binding */ getMargin; },
/* harmony export */   "getSize": function() { return /* binding */ getSize; },
/* harmony export */   "getTopLeft": function() { return /* binding */ getTopLeft; },
/* harmony export */   "getTopRight": function() { return /* binding */ getTopRight; },
/* harmony export */   "getWidth": function() { return /* binding */ getWidth; },
/* harmony export */   "intersects": function() { return /* binding */ intersects; },
/* harmony export */   "isEmpty": function() { return /* binding */ isEmpty; },
/* harmony export */   "returnOrUpdate": function() { return /* binding */ returnOrUpdate; },
/* harmony export */   "scaleFromCenter": function() { return /* binding */ scaleFromCenter; },
/* harmony export */   "intersectsSegment": function() { return /* binding */ intersectsSegment; },
/* harmony export */   "applyTransform": function() { return /* binding */ applyTransform; },
/* harmony export */   "wrapX": function() { return /* binding */ wrapX; }
/* harmony export */ });
/* harmony import */ var _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent/Corner.js */ "./build/wg/extent/Corner.js");
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extent/Relationship.js */ "./build/wg/extent/Relationship.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./asserts.js */ "./build/wg/asserts.js");
/**
 * @module wg/extent
 */



/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */

function boundingExtent(coordinates) {
  var extent = createEmpty();

  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }

  return extent;
}
/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent} [opt_extent] Destination extent.
 * @private
 * @return {Extent} Extent.
 */

function _boundingExtentXYs(xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
}
/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 * @api
 */


function buffer(extent, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0] - value;
    opt_extent[1] = extent[1] - value;
    opt_extent[2] = extent[2] + value;
    opt_extent[3] = extent[3] + value;
    return opt_extent;
  } else {
    return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];
  }
}
/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} The clone.
 */

function clone(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent.slice();
  }
}
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */

function closestSquaredDistanceXY(extent, x, y) {
  var dx, dy;

  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }

  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }

  return dx * dx + dy * dy;
}
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */

function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}
/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */

function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */

function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */

function coordinateRelationship(extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].UNKNOWN;

  if (x < minX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].LEFT;
  } else if (x > maxX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].RIGHT;
  }

  if (y < minY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].BELOW;
  } else if (y > maxY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABOVE;
  }

  if (relationship === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].UNKNOWN) {
    relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERSECTING;
  }

  return relationship;
}
/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */

function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent} [opt_extent] Destination extent.
 * @return {Extent} Extent.
 */

function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
}
/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */

function createOrUpdateEmpty(opt_extent) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
}
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */

function createOrUpdateFromCoordinate(coordinate, opt_extent) {
  var x = coordinate[0];
  var y = coordinate[1];
  return createOrUpdate(x, y, x, y, opt_extent);
}
/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */

function createOrUpdateFromCoordinates(coordinates, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendCoordinates(extent, coordinates);
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */

function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */

function createOrUpdateFromRings(rings, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendRings(extent, rings);
}
/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */

function equals(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
/**
 * Determine if two extents are approximately equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {number} tolerance Tolerance in extent coordinate units.
 * @return {boolean} The two extents differ by less than the tolerance.
 */

function approximatelyEquals(extent1, extent2, tolerance) {
  return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
}
/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */

function extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }

  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }

  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }

  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }

  return extent1;
}
/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */

function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }

  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }

  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }

  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */

function extendCoordinates(extent, coordinates) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }

  return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */

function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }

  return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */

function extendRings(extent, rings) {
  for (var i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }

  return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */

function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}
/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
 * @return {S|boolean} Value.
 * @template S
 */

function forEachCorner(extent, callback) {
  var val;
  val = callback(getBottomLeft(extent));

  if (val) {
    return val;
  }

  val = callback(getBottomRight(extent));

  if (val) {
    return val;
  }

  val = callback(getTopRight(extent));

  if (val) {
    return val;
  }

  val = callback(getTopLeft(extent));

  if (val) {
    return val;
  }

  return false;
}
/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */

function getArea(extent) {
  var area = 0;

  if (!isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }

  return area;
}
/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */

function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}
/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */

function getBottomRight(extent) {
  return [extent[2], extent[1]];
}
/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */

function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {import("./extent/Corner.js").default} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */

function getCorner(extent, corner) {
  var coordinate;

  if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_LEFT) {
    coordinate = getBottomLeft(extent);
  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_RIGHT) {
    coordinate = getBottomRight(extent);
  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].TOP_LEFT) {
    coordinate = getTopLeft(extent);
  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].TOP_RIGHT) {
    coordinate = getTopRight(extent);
  } else {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 13); // Invalid corner
  }

  return coordinate;
}
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */

function getEnlargedArea(extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent} [opt_extent] Destination extent.
 * @return {Extent} Extent.
 */

function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  var x0 = x - xCos + ySin;
  var x1 = x - xCos - ySin;
  var x2 = x + xCos - ySin;
  var x3 = x + xCos + ySin;
  var y0 = y - xSin - yCos;
  var y1 = y - xSin + yCos;
  var y2 = y + xSin + yCos;
  var y3 = y + xSin - yCos;
  return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
}
/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */

function getHeight(extent) {
  return extent[3] - extent[1];
}
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */

function getIntersectionArea(extent1, extent2) {
  var intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}
/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent} [opt_extent] Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */

function getIntersection(extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : createEmpty();

  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }

    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }

    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }

    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }

  return intersection;
}
/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */

function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}
/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */

function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}
/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */

function getTopLeft(extent) {
  return [extent[0], extent[3]];
}
/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */

function getTopRight(extent) {
  return [extent[2], extent[3]];
}
/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */

function getWidth(extent) {
  return extent[2] - extent[0];
}
/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */

function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */

function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}
/**
 * @param {Extent} extent Extent.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */

function returnOrUpdate(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent;
  }
}
/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */

function scaleFromCenter(extent, value) {
  var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
  var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}
/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */

function intersectsSegment(extent, start, end) {
  var intersects = false;
  var startRel = coordinateRelationship(extent, start);
  var endRel = coordinateRelationship(extent, end);

  if (startRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERSECTING || endRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x = void 0,
        y = void 0;

    if (!!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABOVE) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABOVE)) {
      // potentially intersects top
      x = endX - (endY - maxY) / slope;
      intersects = x >= minX && x <= maxX;
    }

    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].RIGHT) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].RIGHT)) {
      // potentially intersects right
      y = endY - (endX - maxX) * slope;
      intersects = y >= minY && y <= maxY;
    }

    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].BELOW) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].BELOW)) {
      // potentially intersects bottom
      x = endX - (endY - minY) / slope;
      intersects = x >= minX && x <= maxX;
    }

    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].LEFT) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].LEFT)) {
      // potentially intersects left
      y = endY - (endX - minX) * slope;
      intersects = y >= minY && y <= maxY;
    }
  }

  return intersects;
}
/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent} [opt_extent] Destination extent.
 * @param {number} [opt_stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {Extent} Extent.
 * @api
 */

function applyTransform(extent, transformFn, opt_extent, opt_stops) {
  var coordinates = [];

  if (opt_stops > 1) {
    var width = extent[2] - extent[0];
    var height = extent[3] - extent[1];

    for (var i = 0; i < opt_stops; ++i) {
      coordinates.push(extent[0] + width * i / opt_stops, extent[1], extent[2], extent[1] + height * i / opt_stops, extent[2] - width * i / opt_stops, extent[3], extent[0], extent[3] - height * i / opt_stops);
    }
  } else {
    coordinates = [extent[0], extent[1], extent[2], extent[1], extent[2], extent[3], extent[0], extent[3]];
  }

  transformFn(coordinates, coordinates, 2);
  var xs = [];
  var ys = [];

  for (var i = 0, l = coordinates.length; i < l; i += 2) {
    xs.push(coordinates[i]);
    ys.push(coordinates[i + 1]);
  }

  return _boundingExtentXYs(xs, ys, opt_extent);
}
/**
 * Modifies the provided extent in-place to be within the real world
 * extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Extent} The extent within the real world extent.
 */

function wrapX(extent, projection) {
  var projectionExtent = projection.getExtent();
  var center = getCenter(extent);

  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    var worldWidth = getWidth(projectionExtent);
    var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
    var offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }

  return extent;
}

/***/ }),

/***/ "./build/wg/extent/Corner.js":
/*!***********************************!*\
  !*** ./build/wg/extent/Corner.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/extent/Corner
 */

/**
 * Extent corner.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
});

/***/ }),

/***/ "./build/wg/extent/Relationship.js":
/*!*****************************************!*\
  !*** ./build/wg/extent/Relationship.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/extent/Relationship
 */

/**
 * Relationship to an extent.
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
});

/***/ }),

/***/ "./build/wg/featureloader.js":
/*!***********************************!*\
  !*** ./build/wg/featureloader.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadFeaturesXhr": function() { return /* binding */ loadFeaturesXhr; },
/* harmony export */   "xhr": function() { return /* binding */ xhr; },
/* harmony export */   "setWithCredentials": function() { return /* binding */ setWithCredentials; }
/* harmony export */ });
/* harmony import */ var _format_FormatType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format/FormatType.js */ "./build/wg/format/FormatType.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functions.js */ "./build/wg/functions.js");
/**
 * @module wg/featureloader
 */


/**
 *
 * @type {boolean}
 * @private
 */

var withCredentials = false;
/**
 * {@link module:wg/source/Vector~VectorSource} sources use a function of this type to
 * load features.
 *
 * This function takes up to 5 arguments. These are an {@link module:wg/extent~Extent} representing
 * the area to be loaded, a `{number}` representing the resolution (map units per pixel), an
 * {@link module:wg/proj/Projection~Projection} for the projection, an optional success callback that should get
 * the loaded features passed as an argument and an optional failure callback with no arguments. If
 * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and
 * `'featuresloaderror'` events. `this` within the function is bound to the
 * {@link module:wg/source/Vector~VectorSource} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default),
 *           import("./extent.js").Extent,
 *           number,
 *           import("./proj/Projection.js").default,
 *           function(Array<import("./Feature.js").default>): void=,
 *           function(): void=): void} FeatureLoader
 * @api
 */

/**
 * {@link module:wg/source/Vector~VectorSource} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:wg/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:wg/proj/Projection~Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */

/**
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {function(Array<import("./Feature.js").default>, import("./proj/Projection.js").default): void} success Success
 *      Function called with the loaded features and optionally with the data projection.
 * @param {function(): void} failure Failure
 *      Function called when loading failed.
 */

function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);

  if (format.getType() == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_0__["default"].ARRAY_BUFFER) {
    xhr.responseType = 'arraybuffer';
  }

  xhr.withCredentials = withCredentials;
  /**
   * @param {Event} event Event.
   * @private
   */

  xhr.onload = function (event) {
    // status will be 0 for file:// urls
    if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
      var type = format.getType();
      /** @type {Document|Node|Object|string|undefined} */

      var source = void 0;

      if (type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_0__["default"].JSON || type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_0__["default"].TEXT) {
        source = xhr.responseText;
      } else if (type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_0__["default"].XML) {
        source = xhr.responseXML;

        if (!source) {
          source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
        }
      } else if (type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_0__["default"].ARRAY_BUFFER) {
        source =
        /** @type {ArrayBuffer} */
        xhr.response;
      }

      if (source) {
        success(
        /** @type {Array<import("./Feature.js").default>} */
        format.readFeatures(source, {
          extent: extent,
          featureProjection: projection
        }), format.readProjection(source));
      } else {
        failure();
      }
    } else {
      failure();
    }
  };
  /**
   * @private
   */


  xhr.onerror = failure;
  xhr.send();
}
/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @return {FeatureLoader} The feature loader.
 * @api
 */

function xhr(url, format) {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @param {function(Array<import("./Feature.js").default>): void} [success] Success
   *      Function called when loading succeeded.
   * @param {function(): void} [failure] Failure
   *      Function called when loading failed.
   * @this {import("./source/Vector").default}
   */
  return function (extent, resolution, projection, success, failure) {
    var source =
    /** @type {import("./source/Vector").default} */
    this;
    loadFeaturesXhr(url, format, extent, resolution, projection,
    /**
     * @param {Array<import("./Feature.js").default>} features The loaded features.
     * @param {import("./proj/Projection.js").default} dataProjection Data
     * projection.
     */
    function (features, dataProjection) {
      source.addFeatures(features);

      if (success !== undefined) {
        success(features);
      }
    },
    /* FIXME handle error */
    failure ? failure : _functions_js__WEBPACK_IMPORTED_MODULE_1__.VOID);
  };
}
/**
 * Setter for the withCredentials configuration for the XHR.
 *
 * @param {boolean} xhrWithCredentials The value of withCredentials to set.
 * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/
 * @api
 */

function setWithCredentials(xhrWithCredentials) {
  withCredentials = xhrWithCredentials;
}

/***/ }),

/***/ "./build/wg/format/EsriJSON.js":
/*!*************************************!*\
  !*** ./build/wg/format/EsriJSON.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _JSONFeature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./JSONFeature.js */ "./build/wg/format/JSONFeature.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/LinearRing.js */ "./build/wg/geom/LinearRing.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./build/wg/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./build/wg/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./build/wg/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./build/wg/geom/flat/deflate.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/flat/orient.js */ "./build/wg/geom/flat/orient.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Feature.js */ "./build/wg/format/Feature.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/EsriJSON
 */




















/**
 * @typedef {import("arcgis-rest-api").Feature} EsriJSONFeature
 * @typedef {import("arcgis-rest-api").FeatureSet} EsriJSONFeatureSet
 * @typedef {import("arcgis-rest-api").Geometry} EsriJSONGeometry
 * @typedef {import("arcgis-rest-api").Point} EsriJSONPoint
 * @typedef {import("arcgis-rest-api").Polyline} EsriJSONPolyline
 * @typedef {import("arcgis-rest-api").Polygon} EsriJSONPolygon
 * @typedef {import("arcgis-rest-api").Multipoint} EsriJSONMultipoint
 * @typedef {import("arcgis-rest-api").HasZM} EsriJSONHasZM
 * @typedef {import("arcgis-rest-api").Position} EsriJSONPosition
 * @typedef {import("arcgis-rest-api").SpatialReferenceWkid} EsriJSONSpatialReferenceWkid
 */

/**
 * @typedef {Object} EsriJSONMultiPolygon
 * @property {Array<Array<Array<Array<number>>>>} rings Rings for the MultiPolygon.
 * @property {boolean} [hasM] If the polygon coordinates have an M value.
 * @property {boolean} [hasZ] If the polygon coordinates have a Z value.
 * @property {EsriJSONSpatialReferenceWkid} [spatialReference] The coordinate reference system.
 */

/**
 * @const
 * @type {Object<import("../geom/GeometryType.js").default, function(EsriJSONGeometry): import("../geom/Geometry.js").default>}
 */

var GEOMETRY_READERS = {};
GEOMETRY_READERS[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT] = readPointGeometry;
GEOMETRY_READERS[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING] = readLineStringGeometry;
GEOMETRY_READERS[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON] = readPolygonGeometry;
GEOMETRY_READERS[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT] = readMultiPointGeometry;
GEOMETRY_READERS[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING] = readMultiLineStringGeometry;
GEOMETRY_READERS[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON] = readMultiPolygonGeometry;
/**
 * @const
 * @type {Object<string, function(import("../geom/Geometry.js").default, import("./Feature.js").WriteOptions=): (EsriJSONGeometry)>}
 */

var GEOMETRY_WRITERS = {};
GEOMETRY_WRITERS[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT] = writePointGeometry;
GEOMETRY_WRITERS[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING] = writeLineStringGeometry;
GEOMETRY_WRITERS[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON] = writePolygonGeometry;
GEOMETRY_WRITERS[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT] = writeMultiPointGeometry;
GEOMETRY_WRITERS[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING] = writeMultiLineStringGeometry;
GEOMETRY_WRITERS[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON] = writeMultiPolygonGeometry;
/**
 * @typedef {Object} Options
 * @property {string} [geometryName] Geometry name to use when creating features.
 */

/**
 * @classdesc
 * Feature format for reading and writing data in the EsriJSON format.
 *
 * @api
 */

var EsriJSON =
/** @class */
function (_super) {
  __extends(EsriJSON, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function EsriJSON(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this) || this;
    /**
     * Name of the geometry attribute for features.
     * @type {string|undefined}
     * @private
     */

    _this.geometryName_ = options.geometryName;
    return _this;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @param {string} [opt_idField] Name of the field where to get the id from.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */


  EsriJSON.prototype.readFeatureFromObject = function (object, opt_options, opt_idField) {
    var esriJSONFeature =
    /** @type {EsriJSONFeature} */
    object;
    var geometry = readGeometry(esriJSONFeature.geometry, opt_options);
    var feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_2__["default"]();

    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    }

    feature.setGeometry(geometry);

    if (esriJSONFeature.attributes) {
      feature.setProperties(esriJSONFeature.attributes, true);
      var id = esriJSONFeature.attributes[opt_idField];

      if (id !== undefined) {
        feature.setId(
        /** @type {number} */
        id);
      }
    }

    return feature;
  };
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */


  EsriJSON.prototype.readFeaturesFromObject = function (object, opt_options) {
    var options = opt_options ? opt_options : {};

    if (object['features']) {
      var esriJSONFeatureSet =
      /** @type {EsriJSONFeatureSet} */
      object;
      /** @type {Array<import("../Feature.js").default>} */

      var features = [];
      var esriJSONFeatures = esriJSONFeatureSet.features;

      for (var i = 0, ii = esriJSONFeatures.length; i < ii; ++i) {
        features.push(this.readFeatureFromObject(esriJSONFeatures[i], options, object.objectIdFieldName));
      }

      return features;
    } else {
      return [this.readFeatureFromObject(object, options)];
    }
  };
  /**
   * @param {EsriJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */


  EsriJSON.prototype.readGeometryFromObject = function (object, opt_options) {
    return readGeometry(object, opt_options);
  };
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */


  EsriJSON.prototype.readProjectionFromObject = function (object) {
    if (object['spatialReference'] && object['spatialReference']['wkid'] !== undefined) {
      var spatialReference =
      /** @type {EsriJSONSpatialReferenceWkid} */
      object['spatialReference'];
      var crs = spatialReference.wkid;
      return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:' + crs);
    } else {
      return null;
    }
  };
  /**
   * Encode a geometry as a EsriJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {EsriJSONGeometry} Object.
   * @api
   */


  EsriJSON.prototype.writeGeometryObject = function (geometry, opt_options) {
    return writeGeometry(geometry, this.adaptOptions(opt_options));
  };
  /**
   * Encode a feature as a esriJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {Object} Object.
   * @api
   */


  EsriJSON.prototype.writeFeatureObject = function (feature, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var object = {};

    if (!feature.hasProperties()) {
      object['attributes'] = {};
      return object;
    }

    var properties = feature.getProperties();
    var geometry = feature.getGeometry();

    if (geometry) {
      object['geometry'] = writeGeometry(geometry, opt_options);
      var projection = opt_options && (opt_options.dataProjection || opt_options.featureProjection);

      if (projection) {
        object['geometry']['spatialReference'] =
        /** @type {EsriJSONSpatialReferenceWkid} */
        {
          wkid: Number((0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection).getCode().split(':').pop())
        };
      }

      delete properties[feature.getGeometryName()];
    }

    if (!(0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.isEmpty)(properties)) {
      object['attributes'] = properties;
    } else {
      object['attributes'] = {};
    }

    return object;
  };
  /**
   * Encode an array of features as a EsriJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {EsriJSONFeatureSet} EsriJSON Object.
   * @api
   */


  EsriJSON.prototype.writeFeaturesObject = function (features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var objects = [];

    for (var i = 0, ii = features.length; i < ii; ++i) {
      objects.push(this.writeFeatureObject(features[i], opt_options));
    }

    return {
      'features': objects
    };
  };

  return EsriJSON;
}(_JSONFeature_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @param {EsriJSONGeometry} object Object.
 * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */


function readGeometry(object, opt_options) {
  var _a, _b;

  if (!object) {
    return null;
  }
  /** @type {import("../geom/GeometryType.js").default} */


  var type;

  if (typeof object['x'] === 'number' && typeof object['y'] === 'number') {
    type = _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT;
  } else if (object['points']) {
    type = _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT;
  } else if (object['paths']) {
    var esriJSONPolyline =
    /** @type {EsriJSONPolyline} */
    object;

    if (esriJSONPolyline.paths.length === 1) {
      type = _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING;
    } else {
      type = _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING;
    }
  } else if (object['rings']) {
    var esriJSONPolygon =
    /** @type {EsriJSONPolygon} */
    object;
    var layout = getGeometryLayout(esriJSONPolygon);
    var rings = convertRings(esriJSONPolygon.rings, layout);

    if (rings.length === 1) {
      type = _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON;
      object = (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.assign)({}, object, (_a = {}, _a['rings'] = rings[0], _a));
    } else {
      type = _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON;
      object = (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.assign)({}, object, (_b = {}, _b['rings'] = rings, _b));
    }
  }

  var geometryReader = GEOMETRY_READERS[type];
  return (0,_Feature_js__WEBPACK_IMPORTED_MODULE_5__.transformGeometryWithOptions)(geometryReader(object), false, opt_options);
}
/**
 * Determines inner and outer rings.
 * Checks if any polygons in this array contain any other polygons in this
 * array. It is used for checking for holes.
 * Logic inspired by: https://github.com/Esri/terraformer-arcgis-parser
 * @param {Array<!Array<!Array<number>>>} rings Rings.
 * @param {import("../geom/GeometryLayout.js").default} layout Geometry layout.
 * @return {Array<!Array<!Array<!Array<number>>>>} Transformed rings.
 */


function convertRings(rings, layout) {
  var flatRing = [];
  var outerRings = [];
  var holes = [];
  var i, ii;

  for (i = 0, ii = rings.length; i < ii; ++i) {
    flatRing.length = 0;
    (0,_geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__.deflateCoordinates)(flatRing, 0, rings[i], layout.length); // is this ring an outer ring? is it clockwise?

    var clockwise = (0,_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_7__.linearRingIsClockwise)(flatRing, 0, flatRing.length, layout.length);

    if (clockwise) {
      outerRings.push([rings[i]]);
    } else {
      holes.push(rings[i]);
    }
  }

  while (holes.length) {
    var hole = holes.shift();
    var matched = false; // loop over all outer rings and see if they contain our hole.

    for (i = outerRings.length - 1; i >= 0; i--) {
      var outerRing = outerRings[i][0];
      var containsHole = (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.containsExtent)(new _geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_9__["default"](outerRing).getExtent(), new _geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_9__["default"](hole).getExtent());

      if (containsHole) {
        // the hole is contained push it into our polygon
        outerRings[i].push(hole);
        matched = true;
        break;
      }
    }

    if (!matched) {
      // no outer rings contain this hole turn it into and outer
      // ring (reverse it)
      outerRings.push([hole.reverse()]);
    }
  }

  return outerRings;
}
/**
 * @param {EsriJSONPoint} object Object.
 * @return {import("../geom/Geometry.js").default} Point.
 */


function readPointGeometry(object) {
  var point;

  if (object.m !== undefined && object.z !== undefined) {
    point = new _geom_Point_js__WEBPACK_IMPORTED_MODULE_10__["default"]([object.x, object.y, object.z, object.m], _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XYZM);
  } else if (object.z !== undefined) {
    point = new _geom_Point_js__WEBPACK_IMPORTED_MODULE_10__["default"]([object.x, object.y, object.z], _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XYZ);
  } else if (object.m !== undefined) {
    point = new _geom_Point_js__WEBPACK_IMPORTED_MODULE_10__["default"]([object.x, object.y, object.m], _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XYM);
  } else {
    point = new _geom_Point_js__WEBPACK_IMPORTED_MODULE_10__["default"]([object.x, object.y]);
  }

  return point;
}
/**
 * @param {EsriJSONPolyline} object Object.
 * @return {import("../geom/Geometry.js").default} LineString.
 */


function readLineStringGeometry(object) {
  var layout = getGeometryLayout(object);
  return new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_12__["default"](object.paths[0], layout);
}
/**
 * @param {EsriJSONPolyline} object Object.
 * @return {import("../geom/Geometry.js").default} MultiLineString.
 */


function readMultiLineStringGeometry(object) {
  var layout = getGeometryLayout(object);
  return new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_13__["default"](object.paths, layout);
}
/**
 * @param {EsriJSONHasZM} object Object.
 * @return {import("../geom/GeometryLayout.js").default} The geometry layout to use.
 */


function getGeometryLayout(object) {
  var layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XY;

  if (object.hasZ === true && object.hasM === true) {
    layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XYZM;
  } else if (object.hasZ === true) {
    layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XYZ;
  } else if (object.hasM === true) {
    layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XYM;
  }

  return layout;
}
/**
 * @param {EsriJSONMultipoint} object Object.
 * @return {import("../geom/Geometry.js").default} MultiPoint.
 */


function readMultiPointGeometry(object) {
  var layout = getGeometryLayout(object);
  return new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_14__["default"](object.points, layout);
}
/**
 * @param {EsriJSONMultiPolygon} object Object.
 * @return {import("../geom/Geometry.js").default} MultiPolygon.
 */


function readMultiPolygonGeometry(object) {
  var layout = getGeometryLayout(object);
  return new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_15__["default"](object.rings, layout);
}
/**
 * @param {EsriJSONPolygon} object Object.
 * @return {import("../geom/Geometry.js").default} Polygon.
 */


function readPolygonGeometry(object) {
  var layout = getGeometryLayout(object);
  return new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_16__["default"](object.rings, layout);
}
/**
 * @param {import("../geom/Point.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {EsriJSONPoint} EsriJSON geometry.
 */


function writePointGeometry(geometry, opt_options) {
  var coordinates = geometry.getCoordinates();
  /** @type {EsriJSONPoint} */

  var esriJSON;
  var layout = geometry.getLayout();

  if (layout === _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XYZ) {
    esriJSON = {
      x: coordinates[0],
      y: coordinates[1],
      z: coordinates[2]
    };
  } else if (layout === _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XYM) {
    esriJSON = {
      x: coordinates[0],
      y: coordinates[1],
      m: coordinates[2]
    };
  } else if (layout === _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XYZM) {
    esriJSON = {
      x: coordinates[0],
      y: coordinates[1],
      z: coordinates[2],
      m: coordinates[3]
    };
  } else if (layout === _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XY) {
    esriJSON = {
      x: coordinates[0],
      y: coordinates[1]
    };
  } else {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_17__.assert)(false, 34); // Invalid geometry layout
  }

  return esriJSON;
}
/**
 * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @return {Object} Object with boolean hasZ and hasM keys.
 */


function getHasZM(geometry) {
  var layout = geometry.getLayout();
  return {
    hasZ: layout === _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XYZ || layout === _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XYZM,
    hasM: layout === _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XYM || layout === _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XYZM
  };
}
/**
 * @param {import("../geom/LineString.js").default} lineString Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {EsriJSONPolyline} EsriJSON geometry.
 */


function writeLineStringGeometry(lineString, opt_options) {
  var hasZM = getHasZM(lineString);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    paths: [
    /** @type {Array<EsriJSONPosition>} */
    lineString.getCoordinates()]
  };
}
/**
 * @param {import("../geom/Polygon.js").default} polygon Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {EsriJSONPolygon} EsriJSON geometry.
 */


function writePolygonGeometry(polygon, opt_options) {
  // Esri geometries use the left-hand rule
  var hasZM = getHasZM(polygon);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    rings:
    /** @type {Array<Array<EsriJSONPosition>>} */
    polygon.getCoordinates(false)
  };
}
/**
 * @param {import("../geom/MultiLineString.js").default} multiLineString Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {EsriJSONPolyline} EsriJSON geometry.
 */


function writeMultiLineStringGeometry(multiLineString, opt_options) {
  var hasZM = getHasZM(multiLineString);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    paths:
    /** @type {Array<Array<EsriJSONPosition>>} */
    multiLineString.getCoordinates()
  };
}
/**
 * @param {import("../geom/MultiPoint.js").default} multiPoint Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {EsriJSONMultipoint} EsriJSON geometry.
 */


function writeMultiPointGeometry(multiPoint, opt_options) {
  var hasZM = getHasZM(multiPoint);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    points:
    /** @type {Array<EsriJSONPosition>} */
    multiPoint.getCoordinates()
  };
}
/**
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {EsriJSONPolygon} EsriJSON geometry.
 */


function writeMultiPolygonGeometry(geometry, opt_options) {
  var hasZM = getHasZM(geometry);
  var coordinates = geometry.getCoordinates(false);
  var output = [];

  for (var i = 0; i < coordinates.length; i++) {
    for (var x = coordinates[i].length - 1; x >= 0; x--) {
      output.push(coordinates[i][x]);
    }
  }

  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    rings:
    /** @type {Array<Array<EsriJSONPosition>>} */
    output
  };
}
/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {EsriJSONGeometry} EsriJSON geometry.
 */


function writeGeometry(geometry, opt_options) {
  var geometryWriter = GEOMETRY_WRITERS[geometry.getType()];
  return geometryWriter((0,_Feature_js__WEBPACK_IMPORTED_MODULE_5__.transformGeometryWithOptions)(geometry, true, opt_options), opt_options);
}

/* harmony default export */ __webpack_exports__["default"] = (EsriJSON);

/***/ }),

/***/ "./build/wg/format/Feature.js":
/*!************************************!*\
  !*** ./build/wg/format/Feature.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transformGeometryWithOptions": function() { return /* binding */ transformGeometryWithOptions; },
/* harmony export */   "transformExtentWithOptions": function() { return /* binding */ transformExtentWithOptions; }
/* harmony export */ });
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../proj/Units.js */ "./build/wg/proj/Units.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/**
 * @module wg/format/Feature
 */




/**
 * @typedef {Object} ReadOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are reading.
 * If not provided, the projection will be derived from the data (where possible) or
 * the `dataProjection` of the format is assigned (where set). If the projection
 * can not be derived from the data and if no `dataProjection` is set for a format,
 * the features will not be reprojected.
 * @property {import("../extent.js").Extent} [extent] Tile extent in map units of the tile being read.
 * This is only required when reading data with tile pixels as geometry units. When configured,
 * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be
 * provided.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * created by the format reader. If not provided, features will be returned in the
 * `dataProjection`.
 */

/**
 * @typedef {Object} WriteOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are writing.
 * If not provided, the `dataProjection` of the format is assigned (where set).
 * If no `dataProjection` is set for a format, the features will be returned
 * in the `featureProjection`.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * that will be serialized by the format writer. If not provided, geometries are assumed
 * to be in the `dataProjection` if that is set; in other words, they are not transformed.
 * @property {boolean} [rightHanded] When writing geometries, follow the right-hand
 * rule for linear ring orientation.  This means that polygons will have counter-clockwise
 * exterior rings and clockwise interior rings.  By default, coordinates are serialized
 * as they are provided at construction.  If `true`, the right-hand rule will
 * be applied.  If `false`, the left-hand rule will be applied (clockwise for
 * exterior and counter-clockwise for interior rings).  Note that not all
 * formats support this.  The GeoJSON format does use this property when writing
 * geometries.
 * @property {number} [decimals] Maximum number of decimal places for coordinates.
 * Coordinates are stored internally as floats, but floating-point arithmetic can create
 * coordinates with a large number of decimal places, not generally wanted on output.
 * Set a number here to round coordinates. Can also be used to ensure that
 * coordinates read in can be written back out with the same number of decimals.
 * Default is no rounding.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for feature formats.
 * {@link module:wg/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode
 * {@link module:wg/Feature~Feature} objects from a variety of commonly used geospatial
 * file formats.  See the documentation for each format for more details.
 *
 * @abstract
 * @api
 */

var FeatureFormat =
/** @class */
function () {
  function FeatureFormat() {
    /**
     * @protected
     * @type {import("../proj/Projection.js").default|undefined}
     */
    this.dataProjection = undefined;
    /**
     * @protected
     * @type {import("../proj/Projection.js").default|undefined}
     */

    this.defaultFeatureProjection = undefined;
    /**
     * A list media types supported by the format in descending order of preference.
     * @type {Array<string>}
     */

    this.supportedMediaTypes = null;
  }
  /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [opt_options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */


  FeatureFormat.prototype.getReadOptions = function (source, opt_options) {
    var options;

    if (opt_options) {
      var dataProjection = opt_options.dataProjection ? (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(opt_options.dataProjection) : this.readProjection(source);

      if (opt_options.extent && dataProjection && dataProjection.getUnits() === _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__["default"].TILE_PIXELS) {
        dataProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(dataProjection);
        dataProjection.setWorldExtent(opt_options.extent);
      }

      options = {
        dataProjection: dataProjection,
        featureProjection: opt_options.featureProjection
      };
    }

    return this.adaptOptions(options);
  };
  /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */


  FeatureFormat.prototype.adaptOptions = function (options) {
    return (0,_obj_js__WEBPACK_IMPORTED_MODULE_2__.assign)({
      dataProjection: this.dataProjection,
      featureProjection: this.defaultFeatureProjection
    }, options);
  };
  /**
   * @abstract
   * @return {import("./FormatType.js").default} Format.
   */


  FeatureFormat.prototype.getType = function () {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.abstract)();
  };
  /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [opt_options] Read options.
   * @return {import("../Feature.js").FeatureLike} Feature.
   */


  FeatureFormat.prototype.readFeature = function (source, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.abstract)();
  };
  /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [opt_options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   */


  FeatureFormat.prototype.readFeatures = function (source, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.abstract)();
  };
  /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [opt_options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */


  FeatureFormat.prototype.readGeometry = function (source, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.abstract)();
  };
  /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */


  FeatureFormat.prototype.readProjection = function (source) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.abstract)();
  };
  /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {WriteOptions} [opt_options] Write options.
   * @return {string|ArrayBuffer} Result.
   */


  FeatureFormat.prototype.writeFeature = function (feature, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.abstract)();
  };
  /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {WriteOptions} [opt_options] Write options.
   * @return {string|ArrayBuffer} Result.
   */


  FeatureFormat.prototype.writeFeatures = function (features, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.abstract)();
  };
  /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [opt_options] Write options.
   * @return {string|ArrayBuffer} Result.
   */


  FeatureFormat.prototype.writeGeometry = function (geometry, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.abstract)();
  };

  return FeatureFormat;
}();

/* harmony default export */ __webpack_exports__["default"] = (FeatureFormat);
/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {boolean} write Set to true for writing, false for reading.
 * @param {WriteOptions|ReadOptions} [opt_options] Options.
 * @return {import("../geom/Geometry.js").default} Transformed geometry.
 */

function transformGeometryWithOptions(geometry, write, opt_options) {
  var featureProjection = opt_options ? (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(opt_options.featureProjection) : null;
  var dataProjection = opt_options ? (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(opt_options.dataProjection) : null;
  var transformed;

  if (featureProjection && dataProjection && !(0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(featureProjection, dataProjection)) {
    transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
  } else {
    transformed = geometry;
  }

  if (write && opt_options &&
  /** @type {WriteOptions} */
  opt_options.decimals !== undefined) {
    var power_1 = Math.pow(10,
    /** @type {WriteOptions} */
    opt_options.decimals); // if decimals option on write, round each coordinate appropriately

    /**
     * @param {Array<number>} coordinates Coordinates.
     * @return {Array<number>} Transformed coordinates.
     */

    var transform = function transform(coordinates) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = Math.round(coordinates[i] * power_1) / power_1;
      }

      return coordinates;
    };

    if (transformed === geometry) {
      transformed = geometry.clone();
    }

    transformed.applyTransform(transform);
  }

  return transformed;
}
/**
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {ReadOptions} [opt_options] Read options.
 * @return {import("../extent.js").Extent} Transformed extent.
 */

function transformExtentWithOptions(extent, opt_options) {
  var featureProjection = opt_options ? (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(opt_options.featureProjection) : null;
  var dataProjection = opt_options ? (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(opt_options.dataProjection) : null;

  if (featureProjection && dataProjection && !(0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(featureProjection, dataProjection)) {
    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.transformExtent)(extent, dataProjection, featureProjection);
  } else {
    return extent;
  }
}

/***/ }),

/***/ "./build/wg/format/FormatType.js":
/*!***************************************!*\
  !*** ./build/wg/format/FormatType.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/format/FormatType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  ARRAY_BUFFER: 'arraybuffer',
  JSON: 'json',
  TEXT: 'text',
  XML: 'xml'
});

/***/ }),

/***/ "./build/wg/format/GML.js":
/*!********************************!*\
  !*** ./build/wg/format/GML.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GML3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GML3.js */ "./build/wg/format/GML3.js");
/**
 * @module wg/format/GML
 */

/**
 * Feature format for reading and writing data in the GML format
 * version 3.1.1.
 * Currently only supports GML 3.1.1 Simple Features profile.
 *
 * @class
 * @param {import("./GMLBase.js").Options} [opt_options]
 *     Optional configuration object.
 * @api
 */

var GML = _GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"];
/**
 * Encode an array of features in GML 3.1.1 Simple Features.
 *
 * @function
 * @param {Array<import("../Feature.js").default>} features Features.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Options.
 * @return {string} Result.
 * @api
 */

GML.prototype.writeFeatures;
/**
 * Encode an array of features in the GML 3.1.1 format as an XML node.
 *
 * @function
 * @param {Array<import("../Feature.js").default>} features Features.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Options.
 * @return {Node} Node.
 * @api
 */

GML.prototype.writeFeaturesNode;
/* harmony default export */ __webpack_exports__["default"] = (GML);

/***/ }),

/***/ "./build/wg/format/GML2.js":
/*!*********************************!*\
  !*** ./build/wg/format/GML2.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GMLBase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GMLBase.js */ "./build/wg/format/GMLBase.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../xml.js */ "./build/wg/xml.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Feature.js */ "./build/wg/format/Feature.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./xsd.js */ "./build/wg/format/xsd.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/GML2
 */









/**
 * @const
 * @type {string}
 */

var schemaLocation = _GMLBase_js__WEBPACK_IMPORTED_MODULE_1__.GMLNS + ' http://schemas.opengis.net/gml/2.1.2/feature.xsd';
/**
 * @const
 * @type {Object<string, string>}
 */

var MULTIGEOMETRY_TO_MEMBER_NODENAME = {
  'MultiLineString': 'lineStringMember',
  'MultiCurve': 'curveMember',
  'MultiPolygon': 'polygonMember',
  'MultiSurface': 'surfaceMember'
};
/**
 * @classdesc
 * Feature format for reading and writing data in the GML format,
 * version 2.1.2.
 *
 * @api
 */

var GML2 =
/** @class */
function (_super) {
  __extends(GML2, _super);
  /**
   * @param {import("./GMLBase.js").Options} [opt_options] Optional configuration object.
   */


  function GML2(opt_options) {
    var _this = this;

    var options =
    /** @type {import("./GMLBase.js").Options} */
    opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    _this.FEATURE_COLLECTION_PARSERS[_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__.GMLNS]['featureMember'] = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(_this.readFeaturesInternal);
    /**
     * @type {string}
     */

    _this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;
    return _this;
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */


  GML2.prototype.readFlatCoordinates = function (node, objectStack) {
    var s = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.getAllTextContent)(node, false).replace(/^\s*|\s*$/g, '');
    var context =
    /** @type {import("../xml.js").NodeStackItem} */
    objectStack[0];
    var containerSrs = context['srsName'];
    var axisOrientation = 'enu';

    if (containerSrs) {
      var proj = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(containerSrs);

      if (proj) {
        axisOrientation = proj.getAxisOrientation();
      }
    }

    var coordsGroups = s.trim().split(/\s+/);
    var flatCoordinates = [];

    for (var i = 0, ii = coordsGroups.length; i < ii; i++) {
      var coords = coordsGroups[i].split(/,+/);
      var x = parseFloat(coords[0]);
      var y = parseFloat(coords[1]);
      var z = coords.length === 3 ? parseFloat(coords[2]) : 0;

      if (axisOrientation.substr(0, 2) === 'en') {
        flatCoordinates.push(x, y, z);
      } else {
        flatCoordinates.push(y, x, z);
      }
    }

    return flatCoordinates;
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */


  GML2.prototype.readBox = function (node, objectStack) {
    /** @type {Array<number>} */
    var flatCoordinates = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([null], this.BOX_PARSERS_, node, objectStack, this);
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.createOrUpdate)(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[1][3], flatCoordinates[1][4]);
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */


  GML2.prototype.innerBoundaryIsParser = function (node, objectStack) {
    /** @type {Array<number>|undefined} */
    var flatLinearRing = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)(undefined, this.RING_PARSERS, node, objectStack, this);

    if (flatLinearRing) {
      var flatLinearRings =
      /** @type {Array<Array<number>>} */
      objectStack[objectStack.length - 1];
      flatLinearRings.push(flatLinearRing);
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */


  GML2.prototype.outerBoundaryIsParser = function (node, objectStack) {
    /** @type {Array<number>|undefined} */
    var flatLinearRing = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)(undefined, this.RING_PARSERS, node, objectStack, this);

    if (flatLinearRing) {
      var flatLinearRings =
      /** @type {Array<Array<number>>} */
      objectStack[objectStack.length - 1];
      flatLinearRings[0] = flatLinearRing;
    }
  };
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [opt_nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */


  GML2.prototype.GEOMETRY_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {
    var context = objectStack[objectStack.length - 1];
    var multiSurface = context['multiSurface'];
    var surface = context['surface'];
    var multiCurve = context['multiCurve'];
    var nodeName;

    if (!Array.isArray(value)) {
      nodeName =
      /** @type {import("../geom/Geometry.js").default} */
      value.getType();

      if (nodeName === 'MultiPolygon' && multiSurface === true) {
        nodeName = 'MultiSurface';
      } else if (nodeName === 'Polygon' && surface === true) {
        nodeName = 'Surface';
      } else if (nodeName === 'MultiLineString' && multiCurve === true) {
        nodeName = 'MultiCurve';
      }
    } else {
      nodeName = 'Envelope';
    }

    return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)('http://www.opengis.net/gml', nodeName);
  };
  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */


  GML2.prototype.writeFeatureElement = function (node, feature, objectStack) {
    var fid = feature.getId();

    if (fid) {
      node.setAttribute('fid',
      /** @type {string} */
      fid);
    }

    var context =
    /** @type {Object} */
    objectStack[objectStack.length - 1];
    var featureNS = context['featureNS'];
    var geometryName = feature.getGeometryName();

    if (!context.serializers) {
      context.serializers = {};
      context.serializers[featureNS] = {};
    }

    var keys = [];
    var values = [];

    if (feature.hasProperties()) {
      var properties = feature.getProperties();

      for (var key in properties) {
        var value = properties[key];

        if (value !== null) {
          keys.push(key);
          values.push(value);

          if (key == geometryName || typeof
          /** @type {?} */
          value.getSimplifiedGeometry === 'function') {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(this.writeGeometryElement, this);
            }
          } else {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_4__.writeStringTextNode);
            }
          }
        }
      }
    }

    var item = (0,_obj_js__WEBPACK_IMPORTED_MODULE_5__.assign)({}, context);
    item.node = node;
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(
    /** @type {import("../xml.js").NodeStackItem} */
    item, context.serializers, (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSimpleNodeFactory)(undefined, featureNS), values, objectStack, keys);
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML2.prototype.writeCurveOrLineString = function (node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context['srsName'];

    if (node.nodeName !== 'LineStringSegment' && srsName) {
      node.setAttribute('srsName', srsName);
    }

    if (node.nodeName === 'LineString' || node.nodeName === 'LineStringSegment') {
      var coordinates = this.createCoordinatesNode_(node.namespaceURI);
      node.appendChild(coordinates);
      this.writeCoordinates_(coordinates, geometry, objectStack);
    } else if (node.nodeName === 'Curve') {
      var segments = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(node.namespaceURI, 'segments');
      node.appendChild(segments);
      this.writeCurveSegments_(segments, geometry, objectStack);
    }
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML2.prototype.writeLineStringOrCurveMember = function (node, line, objectStack) {
    var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);

    if (child) {
      node.appendChild(child);
      this.writeCurveOrLineString(child, line, objectStack);
    }
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiLineString.js").default} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML2.prototype.writeMultiCurveOrLineString = function (node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context['hasZ'];
    var srsName = context['srsName'];
    var curve = context['curve'];

    if (srsName) {
      node.setAttribute('srsName', srsName);
    }

    var lines = geometry.getLineStrings();
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)({
      node: node,
      hasZ: hasZ,
      srsName: srsName,
      curve: curve
    }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, undefined, this);
  };
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML2.prototype.writeGeometryElement = function (node, geometry, objectStack) {
    var context =
    /** @type {import("./Feature.js").WriteOptions} */
    objectStack[objectStack.length - 1];
    var item = (0,_obj_js__WEBPACK_IMPORTED_MODULE_5__.assign)({}, context);
    item['node'] = node;
    var value;

    if (Array.isArray(geometry)) {
      value = (0,_Feature_js__WEBPACK_IMPORTED_MODULE_6__.transformExtentWithOptions)(
      /** @type {import("../extent.js").Extent} */
      geometry, context);
    } else {
      value = (0,_Feature_js__WEBPACK_IMPORTED_MODULE_6__.transformGeometryWithOptions)(
      /** @type {import("../geom/Geometry.js").default} */
      geometry, true, context);
    }

    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(
    /** @type {import("../xml.js").NodeStackItem} */
    item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, undefined, this);
  };
  /**
   * @param {string} namespaceURI XML namespace.
   * @return {Element} coordinates node.
   * @private
   */


  GML2.prototype.createCoordinatesNode_ = function (namespaceURI) {
    var coordinates = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(namespaceURI, 'coordinates');
    coordinates.setAttribute('decimal', '.');
    coordinates.setAttribute('cs', ',');
    coordinates.setAttribute('ts', ' ');
    return coordinates;
  };
  /**
   * @param {Node} node Node.
   * @param {import("../geom/LineString.js").default|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */


  GML2.prototype.writeCoordinates_ = function (node, value, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context['hasZ'];
    var srsName = context['srsName']; // only 2d for simple features profile

    var points = value.getCoordinates();
    var len = points.length;
    var parts = new Array(len);

    for (var i = 0; i < len; ++i) {
      var point = points[i];
      parts[i] = this.getCoords_(point, srsName, hasZ);
    }

    (0,_xsd_js__WEBPACK_IMPORTED_MODULE_4__.writeStringTextNode)(node, parts.join(' '));
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */


  GML2.prototype.writeCurveSegments_ = function (node, line, objectStack) {
    var child = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(node.namespaceURI, 'LineStringSegment');
    node.appendChild(child);
    this.writeCurveOrLineString(child, line, objectStack);
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML2.prototype.writeSurfaceOrPolygon = function (node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context['hasZ'];
    var srsName = context['srsName'];

    if (node.nodeName !== 'PolygonPatch' && srsName) {
      node.setAttribute('srsName', srsName);
    }

    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {
      var rings = geometry.getLinearRings();
      (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)({
        node: node,
        hasZ: hasZ,
        srsName: srsName
      }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, undefined, this);
    } else if (node.nodeName === 'Surface') {
      var patches = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(node.namespaceURI, 'patches');
      node.appendChild(patches);
      this.writeSurfacePatches_(patches, geometry, objectStack);
    }
  };
  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [opt_nodeName] Node name.
   * @return {Node} Node.
   * @private
   */


  GML2.prototype.RING_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {
    var context = objectStack[objectStack.length - 1];
    var parentNode = context.node;
    var exteriorWritten = context['exteriorWritten'];

    if (exteriorWritten === undefined) {
      context['exteriorWritten'] = true;
    }

    return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(parentNode.namespaceURI, exteriorWritten !== undefined ? 'innerBoundaryIs' : 'outerBoundaryIs');
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */


  GML2.prototype.writeSurfacePatches_ = function (node, polygon, objectStack) {
    var child = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(node.namespaceURI, 'PolygonPatch');
    node.appendChild(child);
    this.writeSurfaceOrPolygon(child, polygon, objectStack);
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML2.prototype.writeRing = function (node, ring, objectStack) {
    var linearRing = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(node.namespaceURI, 'LinearRing');
    node.appendChild(linearRing);
    this.writeLinearRing(linearRing, ring, objectStack);
  };
  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [opt_srsName] Optional srsName
   * @param {boolean} [opt_hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */


  GML2.prototype.getCoords_ = function (point, opt_srsName, opt_hasZ) {
    var axisOrientation = 'enu';

    if (opt_srsName) {
      axisOrientation = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(opt_srsName).getAxisOrientation();
    }

    var coords = axisOrientation.substr(0, 2) === 'en' ? point[0] + ',' + point[1] : point[1] + ',' + point[0];

    if (opt_hasZ) {
      // For newly created points, Z can be undefined.
      var z = point[2] || 0;
      coords += ',' + z;
    }

    return coords;
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML2.prototype.writePoint = function (node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context['hasZ'];
    var srsName = context['srsName'];

    if (srsName) {
      node.setAttribute('srsName', srsName);
    }

    var coordinates = this.createCoordinatesNode_(node.namespaceURI);
    node.appendChild(coordinates);
    var point = geometry.getCoordinates();
    var coord = this.getCoords_(point, srsName, hasZ);
    (0,_xsd_js__WEBPACK_IMPORTED_MODULE_4__.writeStringTextNode)(coordinates, coord);
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML2.prototype.writeMultiPoint = function (node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context['hasZ'];
    var srsName = context['srsName'];

    if (srsName) {
      node.setAttribute('srsName', srsName);
    }

    var points = geometry.getPoints();
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)({
      node: node,
      hasZ: hasZ,
      srsName: srsName
    }, this.POINTMEMBER_SERIALIZERS, (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSimpleNodeFactory)('pointMember'), points, objectStack, undefined, this);
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML2.prototype.writePointMember = function (node, point, objectStack) {
    var child = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(node.namespaceURI, 'Point');
    node.appendChild(child);
    this.writePoint(child, point, objectStack);
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML2.prototype.writeLinearRing = function (node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context['srsName'];

    if (srsName) {
      node.setAttribute('srsName', srsName);
    }

    var coordinates = this.createCoordinatesNode_(node.namespaceURI);
    node.appendChild(coordinates);
    this.writeCoordinates_(coordinates, geometry, objectStack);
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML2.prototype.writeMultiSurfaceOrPolygon = function (node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context['hasZ'];
    var srsName = context['srsName'];
    var surface = context['surface'];

    if (srsName) {
      node.setAttribute('srsName', srsName);
    }

    var polygons = geometry.getPolygons();
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)({
      node: node,
      hasZ: hasZ,
      srsName: srsName,
      surface: surface
    }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, undefined, this);
  };
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML2.prototype.writeSurfaceOrPolygonMember = function (node, polygon, objectStack) {
    var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);

    if (child) {
      node.appendChild(child);
      this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
  };
  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */


  GML2.prototype.writeEnvelope = function (node, extent, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context['srsName'];

    if (srsName) {
      node.setAttribute('srsName', srsName);
    }

    var keys = ['lowerCorner', 'upperCorner'];
    var values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(
    /** @type {import("../xml.js").NodeStackItem} */
    {
      node: node
    }, this.ENVELOPE_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_2__.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, keys, this);
  };
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [opt_nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */


  GML2.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {
    var parentNode = objectStack[objectStack.length - 1].node;
    return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)('http://www.opengis.net/gml', MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);
  };

  return GML2;
}(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */


GML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  'http://www.opengis.net/gml': {
    'coordinates': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(GML2.prototype.readFlatCoordinates)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  'http://www.opengis.net/gml': {
    'innerBoundaryIs': GML2.prototype.innerBoundaryIsParser,
    'outerBoundaryIs': GML2.prototype.outerBoundaryIsParser
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML2.prototype.BOX_PARSERS_ = {
  'http://www.opengis.net/gml': {
    'coordinates': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(GML2.prototype.readFlatCoordinates)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML2.prototype.GEOMETRY_PARSERS = {
  'http://www.opengis.net/gml': {
    'Point': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readPoint),
    'MultiPoint': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readMultiPoint),
    'LineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readLineString),
    'MultiLineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readMultiLineString),
    'LinearRing': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readLinearRing),
    'Polygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readPolygon),
    'MultiPolygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readMultiPolygon),
    'Box': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(GML2.prototype.readBox)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML2.prototype.GEOMETRY_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'Curve': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeCurveOrLineString),
    'MultiCurve': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeMultiCurveOrLineString),
    'Point': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writePoint),
    'MultiPoint': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeMultiPoint),
    'LineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeCurveOrLineString),
    'MultiLineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeMultiCurveOrLineString),
    'LinearRing': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeLinearRing),
    'Polygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeSurfaceOrPolygon),
    'MultiPolygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeMultiSurfaceOrPolygon),
    'Surface': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeSurfaceOrPolygon),
    'MultiSurface': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeMultiSurfaceOrPolygon),
    'Envelope': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeEnvelope)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'lineStringMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeLineStringOrCurveMember),
    'curveMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeLineStringOrCurveMember)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML2.prototype.RING_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'outerBoundaryIs': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeRing),
    'innerBoundaryIs': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeRing)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML2.prototype.POINTMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'pointMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writePointMember)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'surfaceMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeSurfaceOrPolygonMember),
    'polygonMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML2.prototype.writeSurfaceOrPolygonMember)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML2.prototype.ENVELOPE_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'lowerCorner': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_4__.writeStringTextNode),
    'upperCorner': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_4__.writeStringTextNode)
  }
};
/* harmony default export */ __webpack_exports__["default"] = (GML2);

/***/ }),

/***/ "./build/wg/format/GML3.js":
/*!*********************************!*\
  !*** ./build/wg/format/GML3.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GML2_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./GML2.js */ "./build/wg/format/GML2.js");
/* harmony import */ var _GMLBase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GMLBase.js */ "./build/wg/format/GMLBase.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./build/wg/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./build/wg/geom/MultiPolygon.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../xml.js */ "./build/wg/xml.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./xsd.js */ "./build/wg/format/xsd.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Feature.js */ "./build/wg/format/Feature.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/GML3
 */
















/**
 * @const
 * @type {string}
 * @private
 */

var schemaLocation = _GMLBase_js__WEBPACK_IMPORTED_MODULE_1__.GMLNS + ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' + '1.0.0/gmlsf.xsd';
/**
 * @const
 * @type {Object<string, string>}
 */

var MULTIGEOMETRY_TO_MEMBER_NODENAME = {
  'MultiLineString': 'lineStringMember',
  'MultiCurve': 'curveMember',
  'MultiPolygon': 'polygonMember',
  'MultiSurface': 'surfaceMember'
};
/**
 * @classdesc
 * Feature format for reading and writing data in the GML format
 * version 3.1.1.
 * Currently only supports GML 3.1.1 Simple Features profile.
 *
 * @api
 */

var GML3 =
/** @class */
function (_super) {
  __extends(GML3, _super);
  /**
   * @param {import("./GMLBase.js").Options} [opt_options] Optional configuration object.
   */


  function GML3(opt_options) {
    var _this = this;

    var options =
    /** @type {import("./GMLBase.js").Options} */
    opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    /**
     * @private
     * @type {boolean}
     */

    _this.surface_ = options.surface !== undefined ? options.surface : false;
    /**
     * @private
     * @type {boolean}
     */

    _this.curve_ = options.curve !== undefined ? options.curve : false;
    /**
     * @private
     * @type {boolean}
     */

    _this.multiCurve_ = options.multiCurve !== undefined ? options.multiCurve : true;
    /**
     * @private
     * @type {boolean}
     */

    _this.multiSurface_ = options.multiSurface !== undefined ? options.multiSurface : true;
    /**
     * @type {string}
     */

    _this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;
    /**
     * @private
     * @type {boolean}
     */

    _this.hasZ = options.hasZ !== undefined ? options.hasZ : false;
    return _this;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */


  GML3.prototype.readMultiCurve = function (node, objectStack) {
    /** @type {Array<LineString>} */
    var lineStrings = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([], this.MULTICURVE_PARSERS, node, objectStack, this);

    if (lineStrings) {
      var multiLineString = new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__["default"](lineStrings);
      return multiLineString;
    } else {
      return undefined;
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */


  GML3.prototype.readMultiSurface = function (node, objectStack) {
    /** @type {Array<Polygon>} */
    var polygons = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([], this.MULTISURFACE_PARSERS, node, objectStack, this);

    if (polygons) {
      return new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_4__["default"](polygons);
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */


  GML3.prototype.curveMemberParser = function (node, objectStack) {
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.parseNode)(this.CURVEMEMBER_PARSERS, node, objectStack, this);
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */


  GML3.prototype.surfaceMemberParser = function (node, objectStack) {
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.parseNode)(this.SURFACEMEMBER_PARSERS, node, objectStack, this);
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */


  GML3.prototype.readPatch = function (node, objectStack) {
    return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([null], this.PATCHES_PARSERS, node, objectStack, this);
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */


  GML3.prototype.readSegment = function (node, objectStack) {
    return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([null], this.SEGMENTS_PARSERS, node, objectStack, this);
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */


  GML3.prototype.readPolygonPatch = function (node, objectStack) {
    return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */


  GML3.prototype.readLineStringSegment = function (node, objectStack) {
    return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */


  GML3.prototype.interiorParser = function (node, objectStack) {
    /** @type {Array<number>|undefined} */
    var flatLinearRing = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)(undefined, this.RING_PARSERS, node, objectStack, this);

    if (flatLinearRing) {
      var flatLinearRings =
      /** @type {Array<Array<number>>} */
      objectStack[objectStack.length - 1];
      flatLinearRings.push(flatLinearRing);
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */


  GML3.prototype.exteriorParser = function (node, objectStack) {
    /** @type {Array<number>|undefined} */
    var flatLinearRing = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)(undefined, this.RING_PARSERS, node, objectStack, this);

    if (flatLinearRing) {
      var flatLinearRings =
      /** @type {Array<Array<number>>} */
      objectStack[objectStack.length - 1];
      flatLinearRings[0] = flatLinearRing;
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */


  GML3.prototype.readSurface = function (node, objectStack) {
    /** @type {Array<Array<number>>} */
    var flatLinearRings = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([null], this.SURFACE_PARSERS, node, objectStack, this);

    if (flatLinearRings && flatLinearRings[0]) {
      var flatCoordinates = flatLinearRings[0];
      var ends = [flatCoordinates.length];
      var i = void 0,
          ii = void 0;

      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
        (0,_array_js__WEBPACK_IMPORTED_MODULE_5__.extend)(flatCoordinates, flatLinearRings[i]);
        ends.push(flatCoordinates.length);
      }

      return new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_6__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_7__["default"].XYZ, ends);
    } else {
      return undefined;
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */


  GML3.prototype.readCurve = function (node, objectStack) {
    /** @type {Array<number>} */
    var flatCoordinates = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([null], this.CURVE_PARSERS, node, objectStack, this);

    if (flatCoordinates) {
      var lineString = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_8__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_7__["default"].XYZ);
      return lineString;
    } else {
      return undefined;
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */


  GML3.prototype.readEnvelope = function (node, objectStack) {
    /** @type {Array<number>} */
    var flatCoordinates = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([null], this.ENVELOPE_PARSERS, node, objectStack, this);
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_9__.createOrUpdate)(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[2][0], flatCoordinates[2][1]);
  };
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */


  GML3.prototype.readFlatPos = function (node, objectStack) {
    var s = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.getAllTextContent)(node, false);
    var re = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/;
    /** @type {Array<number>} */

    var flatCoordinates = [];
    var m;

    while (m = re.exec(s)) {
      flatCoordinates.push(parseFloat(m[1]));
      s = s.substr(m[0].length);
    }

    if (s !== '') {
      return undefined;
    }

    var context = objectStack[0];
    var containerSrs = context['srsName'];
    var axisOrientation = 'enu';

    if (containerSrs) {
      var proj = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(containerSrs);
      axisOrientation = proj.getAxisOrientation();
    }

    if (axisOrientation === 'neu') {
      var i = void 0,
          ii = void 0;

      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {
        var y = flatCoordinates[i];
        var x = flatCoordinates[i + 1];
        flatCoordinates[i] = x;
        flatCoordinates[i + 1] = y;
      }
    }

    var len = flatCoordinates.length;

    if (len == 2) {
      flatCoordinates.push(0);
    }

    if (len === 0) {
      return undefined;
    }

    return flatCoordinates;
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */


  GML3.prototype.readFlatPosList = function (node, objectStack) {
    var s = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.getAllTextContent)(node, false).replace(/^\s*|\s*$/g, '');
    var context = objectStack[0];
    var containerSrs = context['srsName'];
    var contextDimension = context['srsDimension'];
    var axisOrientation = 'enu';

    if (containerSrs) {
      var proj = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(containerSrs);
      axisOrientation = proj.getAxisOrientation();
    }

    var coords = s.split(/\s+/); // The "dimension" attribute is from the GML 3.0.1 spec.

    var dim = 2;

    if (node.getAttribute('srsDimension')) {
      dim = (0,_xsd_js__WEBPACK_IMPORTED_MODULE_10__.readNonNegativeIntegerString)(node.getAttribute('srsDimension'));
    } else if (node.getAttribute('dimension')) {
      dim = (0,_xsd_js__WEBPACK_IMPORTED_MODULE_10__.readNonNegativeIntegerString)(node.getAttribute('dimension'));
    } else if (
    /** @type {Element} */
    node.parentNode.getAttribute('srsDimension')) {
      dim = (0,_xsd_js__WEBPACK_IMPORTED_MODULE_10__.readNonNegativeIntegerString)(
      /** @type {Element} */
      node.parentNode.getAttribute('srsDimension'));
    } else if (contextDimension) {
      dim = (0,_xsd_js__WEBPACK_IMPORTED_MODULE_10__.readNonNegativeIntegerString)(contextDimension);
    }

    var x, y, z;
    var flatCoordinates = [];

    for (var i = 0, ii = coords.length; i < ii; i += dim) {
      x = parseFloat(coords[i]);
      y = parseFloat(coords[i + 1]);
      z = dim === 3 ? parseFloat(coords[i + 2]) : 0;

      if (axisOrientation.substr(0, 2) === 'en') {
        flatCoordinates.push(x, y, z);
      } else {
        flatCoordinates.push(y, x, z);
      }
    }

    return flatCoordinates;
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} value Point geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */


  GML3.prototype.writePos_ = function (node, value, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context['hasZ'];
    var srsDimension = hasZ ? '3' : '2';
    node.setAttribute('srsDimension', srsDimension);
    var srsName = context['srsName'];
    var axisOrientation = 'enu';

    if (srsName) {
      axisOrientation = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(srsName).getAxisOrientation();
    }

    var point = value.getCoordinates();
    var coords; // only 2d for simple features profile

    if (axisOrientation.substr(0, 2) === 'en') {
      coords = point[0] + ' ' + point[1];
    } else {
      coords = point[1] + ' ' + point[0];
    }

    if (hasZ) {
      // For newly created points, Z can be undefined.
      var z = point[2] || 0;
      coords += ' ' + z;
    }

    (0,_xsd_js__WEBPACK_IMPORTED_MODULE_10__.writeStringTextNode)(node, coords);
  };
  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [opt_srsName] Optional srsName
   * @param {boolean} [opt_hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */


  GML3.prototype.getCoords_ = function (point, opt_srsName, opt_hasZ) {
    var axisOrientation = 'enu';

    if (opt_srsName) {
      axisOrientation = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(opt_srsName).getAxisOrientation();
    }

    var coords = axisOrientation.substr(0, 2) === 'en' ? point[0] + ' ' + point[1] : point[1] + ' ' + point[0];

    if (opt_hasZ) {
      // For newly created points, Z can be undefined.
      var z = point[2] || 0;
      coords += ' ' + z;
    }

    return coords;
  };
  /**
   * @param {Element} node Node.
   * @param {LineString|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */


  GML3.prototype.writePosList_ = function (node, value, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context['hasZ'];
    var srsDimension = hasZ ? '3' : '2';
    node.setAttribute('srsDimension', srsDimension);
    var srsName = context['srsName']; // only 2d for simple features profile

    var points = value.getCoordinates();
    var len = points.length;
    var parts = new Array(len);
    var point;

    for (var i = 0; i < len; ++i) {
      point = points[i];
      parts[i] = this.getCoords_(point, srsName, hasZ);
    }

    (0,_xsd_js__WEBPACK_IMPORTED_MODULE_10__.writeStringTextNode)(node, parts.join(' '));
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML3.prototype.writePoint = function (node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context['srsName'];

    if (srsName) {
      node.setAttribute('srsName', srsName);
    }

    var pos = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(node.namespaceURI, 'pos');
    node.appendChild(pos);
    this.writePos_(pos, geometry, objectStack);
  };
  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */


  GML3.prototype.writeEnvelope = function (node, extent, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context['srsName'];

    if (srsName) {
      node.setAttribute('srsName', srsName);
    }

    var keys = ['lowerCorner', 'upperCorner'];
    var values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(
    /** @type {import("../xml.js").NodeStackItem} */
    {
      node: node
    }, this.ENVELOPE_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_2__.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, keys, this);
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML3.prototype.writeLinearRing = function (node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context['srsName'];

    if (srsName) {
      node.setAttribute('srsName', srsName);
    }

    var posList = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(node.namespaceURI, 'posList');
    node.appendChild(posList);
    this.writePosList_(posList, geometry, objectStack);
  };
  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [opt_nodeName] Node name.
   * @return {Node} Node.
   * @private
   */


  GML3.prototype.RING_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {
    var context = objectStack[objectStack.length - 1];
    var parentNode = context.node;
    var exteriorWritten = context['exteriorWritten'];

    if (exteriorWritten === undefined) {
      context['exteriorWritten'] = true;
    }

    return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(parentNode.namespaceURI, exteriorWritten !== undefined ? 'interior' : 'exterior');
  };
  /**
   * @param {Element} node Node.
   * @param {Polygon} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML3.prototype.writeSurfaceOrPolygon = function (node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context['hasZ'];
    var srsName = context['srsName'];

    if (node.nodeName !== 'PolygonPatch' && srsName) {
      node.setAttribute('srsName', srsName);
    }

    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {
      var rings = geometry.getLinearRings();
      (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)({
        node: node,
        hasZ: hasZ,
        srsName: srsName
      }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, undefined, this);
    } else if (node.nodeName === 'Surface') {
      var patches = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(node.namespaceURI, 'patches');
      node.appendChild(patches);
      this.writeSurfacePatches_(patches, geometry, objectStack);
    }
  };
  /**
   * @param {Element} node Node.
   * @param {LineString} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML3.prototype.writeCurveOrLineString = function (node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context['srsName'];

    if (node.nodeName !== 'LineStringSegment' && srsName) {
      node.setAttribute('srsName', srsName);
    }

    if (node.nodeName === 'LineString' || node.nodeName === 'LineStringSegment') {
      var posList = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(node.namespaceURI, 'posList');
      node.appendChild(posList);
      this.writePosList_(posList, geometry, objectStack);
    } else if (node.nodeName === 'Curve') {
      var segments = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(node.namespaceURI, 'segments');
      node.appendChild(segments);
      this.writeCurveSegments_(segments, geometry, objectStack);
    }
  };
  /**
   * @param {Element} node Node.
   * @param {MultiPolygon} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML3.prototype.writeMultiSurfaceOrPolygon = function (node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context['hasZ'];
    var srsName = context['srsName'];
    var surface = context['surface'];

    if (srsName) {
      node.setAttribute('srsName', srsName);
    }

    var polygons = geometry.getPolygons();
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)({
      node: node,
      hasZ: hasZ,
      srsName: srsName,
      surface: surface
    }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, undefined, this);
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML3.prototype.writeMultiPoint = function (node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context['srsName'];
    var hasZ = context['hasZ'];

    if (srsName) {
      node.setAttribute('srsName', srsName);
    }

    var points = geometry.getPoints();
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)({
      node: node,
      hasZ: hasZ,
      srsName: srsName
    }, this.POINTMEMBER_SERIALIZERS, (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSimpleNodeFactory)('pointMember'), points, objectStack, undefined, this);
  };
  /**
   * @param {Element} node Node.
   * @param {MultiLineString} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML3.prototype.writeMultiCurveOrLineString = function (node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context['hasZ'];
    var srsName = context['srsName'];
    var curve = context['curve'];

    if (srsName) {
      node.setAttribute('srsName', srsName);
    }

    var lines = geometry.getLineStrings();
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)({
      node: node,
      hasZ: hasZ,
      srsName: srsName,
      curve: curve
    }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, undefined, this);
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML3.prototype.writeRing = function (node, ring, objectStack) {
    var linearRing = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(node.namespaceURI, 'LinearRing');
    node.appendChild(linearRing);
    this.writeLinearRing(linearRing, ring, objectStack);
  };
  /**
   * @param {Node} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML3.prototype.writeSurfaceOrPolygonMember = function (node, polygon, objectStack) {
    var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);

    if (child) {
      node.appendChild(child);
      this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
  };
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML3.prototype.writePointMember = function (node, point, objectStack) {
    var child = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(node.namespaceURI, 'Point');
    node.appendChild(child);
    this.writePoint(child, point, objectStack);
  };
  /**
   * @param {Node} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML3.prototype.writeLineStringOrCurveMember = function (node, line, objectStack) {
    var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);

    if (child) {
      node.appendChild(child);
      this.writeCurveOrLineString(child, line, objectStack);
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */


  GML3.prototype.writeSurfacePatches_ = function (node, polygon, objectStack) {
    var child = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(node.namespaceURI, 'PolygonPatch');
    node.appendChild(child);
    this.writeSurfaceOrPolygon(child, polygon, objectStack);
  };
  /**
   * @param {Element} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */


  GML3.prototype.writeCurveSegments_ = function (node, line, objectStack) {
    var child = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(node.namespaceURI, 'LineStringSegment');
    node.appendChild(child);
    this.writeCurveOrLineString(child, line, objectStack);
  };
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */


  GML3.prototype.writeGeometryElement = function (node, geometry, objectStack) {
    var context =
    /** @type {import("./Feature.js").WriteOptions} */
    objectStack[objectStack.length - 1];
    var item = (0,_obj_js__WEBPACK_IMPORTED_MODULE_11__.assign)({}, context);
    item['node'] = node;
    var value;

    if (Array.isArray(geometry)) {
      value = (0,_Feature_js__WEBPACK_IMPORTED_MODULE_12__.transformExtentWithOptions)(
      /** @type {import("../extent.js").Extent} */
      geometry, context);
    } else {
      value = (0,_Feature_js__WEBPACK_IMPORTED_MODULE_12__.transformGeometryWithOptions)(
      /** @type {import("../geom/Geometry.js").default} */
      geometry, true, context);
    }

    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(
    /** @type {import("../xml.js").NodeStackItem} */
    item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, undefined, this);
  };
  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */


  GML3.prototype.writeFeatureElement = function (node, feature, objectStack) {
    var fid = feature.getId();

    if (fid) {
      node.setAttribute('fid',
      /** @type {string} */
      fid);
    }

    var context =
    /** @type {Object} */
    objectStack[objectStack.length - 1];
    var featureNS = context['featureNS'];
    var geometryName = feature.getGeometryName();

    if (!context.serializers) {
      context.serializers = {};
      context.serializers[featureNS] = {};
    }

    var keys = [];
    var values = [];

    if (feature.hasProperties()) {
      var properties = feature.getProperties();

      for (var key in properties) {
        var value = properties[key];

        if (value !== null) {
          keys.push(key);
          values.push(value);

          if (key == geometryName || typeof
          /** @type {?} */
          value.getSimplifiedGeometry === 'function') {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(this.writeGeometryElement, this);
            }
          } else {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_10__.writeStringTextNode);
            }
          }
        }
      }
    }

    var item = (0,_obj_js__WEBPACK_IMPORTED_MODULE_11__.assign)({}, context);
    item.node = node;
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(
    /** @type {import("../xml.js").NodeStackItem} */
    item, context.serializers, (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSimpleNodeFactory)(undefined, featureNS), values, objectStack, keys);
  };
  /**
   * @param {Node} node Node.
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */


  GML3.prototype.writeFeatureMembers_ = function (node, features, objectStack) {
    var context =
    /** @type {Object} */
    objectStack[objectStack.length - 1];
    var featureType = context['featureType'];
    var featureNS = context['featureNS'];
    /** @type {Object<string, Object<string, import("../xml.js").Serializer>>} */

    var serializers = {};
    serializers[featureNS] = {};
    serializers[featureNS][featureType] = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(this.writeFeatureElement, this);
    var item = (0,_obj_js__WEBPACK_IMPORTED_MODULE_11__.assign)({}, context);
    item.node = node;
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(
    /** @type {import("../xml.js").NodeStackItem} */
    item, serializers, (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSimpleNodeFactory)(featureType, featureNS), features, objectStack);
  };
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [opt_nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */


  GML3.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {
    var parentNode = objectStack[objectStack.length - 1].node;
    return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(this.namespace, MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);
  };
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [opt_nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */


  GML3.prototype.GEOMETRY_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {
    var context = objectStack[objectStack.length - 1];
    var multiSurface = context['multiSurface'];
    var surface = context['surface'];
    var curve = context['curve'];
    var multiCurve = context['multiCurve'];
    var nodeName;

    if (!Array.isArray(value)) {
      nodeName =
      /** @type {import("../geom/Geometry.js").default} */
      value.getType();

      if (nodeName === 'MultiPolygon' && multiSurface === true) {
        nodeName = 'MultiSurface';
      } else if (nodeName === 'Polygon' && surface === true) {
        nodeName = 'Surface';
      } else if (nodeName === 'LineString' && curve === true) {
        nodeName = 'Curve';
      } else if (nodeName === 'MultiLineString' && multiCurve === true) {
        nodeName = 'MultiCurve';
      }
    } else {
      nodeName = 'Envelope';
    }

    return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(this.namespace, nodeName);
  };
  /**
   * Encode a geometry in GML 3.1.1 Simple Features.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Options.
   * @return {Node} Node.
   * @api
   */


  GML3.prototype.writeGeometryNode = function (geometry, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var geom = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(this.namespace, 'geom');
    var context = {
      node: geom,
      hasZ: this.hasZ,
      srsName: this.srsName,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_
    };

    if (opt_options) {
      (0,_obj_js__WEBPACK_IMPORTED_MODULE_11__.assign)(context, opt_options);
    }

    this.writeGeometryElement(geom, geometry, [context]);
    return geom;
  };
  /**
   * Encode an array of features in the GML 3.1.1 format as an XML node.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Options.
   * @return {Element} Node.
   * @api
   */


  GML3.prototype.writeFeaturesNode = function (features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var node = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(this.namespace, 'featureMembers');
    node.setAttributeNS(_xml_js__WEBPACK_IMPORTED_MODULE_2__.XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation);
    var context = {
      srsName: this.srsName,
      hasZ: this.hasZ,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_,
      featureNS: this.featureNS,
      featureType: this.featureType
    };

    if (opt_options) {
      (0,_obj_js__WEBPACK_IMPORTED_MODULE_11__.assign)(context, opt_options);
    }

    this.writeFeatureMembers_(node, features, [context]);
    return node;
  };

  return GML3;
}(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */


GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  'http://www.opengis.net/gml': {
    'pos': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(GML3.prototype.readFlatPos),
    'posList': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(GML3.prototype.readFlatPosList),
    'coordinates': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(_GML2_js__WEBPACK_IMPORTED_MODULE_13__["default"].prototype.readFlatCoordinates)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  'http://www.opengis.net/gml': {
    'interior': GML3.prototype.interiorParser,
    'exterior': GML3.prototype.exteriorParser
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML3.prototype.GEOMETRY_PARSERS = {
  'http://www.opengis.net/gml': {
    'Point': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readPoint),
    'MultiPoint': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readMultiPoint),
    'LineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readLineString),
    'MultiLineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readMultiLineString),
    'LinearRing': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readLinearRing),
    'Polygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readPolygon),
    'MultiPolygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readMultiPolygon),
    'Surface': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(GML3.prototype.readSurface),
    'MultiSurface': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(GML3.prototype.readMultiSurface),
    'Curve': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(GML3.prototype.readCurve),
    'MultiCurve': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(GML3.prototype.readMultiCurve),
    'Envelope': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(GML3.prototype.readEnvelope)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML3.prototype.MULTICURVE_PARSERS = {
  'http://www.opengis.net/gml': {
    'curveMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(GML3.prototype.curveMemberParser),
    'curveMembers': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(GML3.prototype.curveMemberParser)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML3.prototype.MULTISURFACE_PARSERS = {
  'http://www.opengis.net/gml': {
    'surfaceMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(GML3.prototype.surfaceMemberParser),
    'surfaceMembers': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(GML3.prototype.surfaceMemberParser)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML3.prototype.CURVEMEMBER_PARSERS = {
  'http://www.opengis.net/gml': {
    'LineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readLineString),
    'Curve': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(GML3.prototype.readCurve)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML3.prototype.SURFACEMEMBER_PARSERS = {
  'http://www.opengis.net/gml': {
    'Polygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readPolygon),
    'Surface': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(GML3.prototype.readSurface)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML3.prototype.SURFACE_PARSERS = {
  'http://www.opengis.net/gml': {
    'patches': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(GML3.prototype.readPatch)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML3.prototype.CURVE_PARSERS = {
  'http://www.opengis.net/gml': {
    'segments': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(GML3.prototype.readSegment)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML3.prototype.ENVELOPE_PARSERS = {
  'http://www.opengis.net/gml': {
    'lowerCorner': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(GML3.prototype.readFlatPosList),
    'upperCorner': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(GML3.prototype.readFlatPosList)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML3.prototype.PATCHES_PARSERS = {
  'http://www.opengis.net/gml': {
    'PolygonPatch': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(GML3.prototype.readPolygonPatch)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML3.prototype.SEGMENTS_PARSERS = {
  'http://www.opengis.net/gml': {
    'LineStringSegment': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(GML3.prototype.readLineStringSegment)
  }
};
/**
 * Encode an array of features in GML 3.1.1 Simple Features.
 *
 * @function
 * @param {Array<import("../Feature.js").default>} features Features.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Options.
 * @return {string} Result.
 * @api
 */

GML3.prototype.writeFeatures;
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML3.prototype.RING_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'exterior': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeRing),
    'interior': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeRing)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML3.prototype.ENVELOPE_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'lowerCorner': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_10__.writeStringTextNode),
    'upperCorner': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_10__.writeStringTextNode)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'surfaceMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeSurfaceOrPolygonMember),
    'polygonMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeSurfaceOrPolygonMember)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML3.prototype.POINTMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'pointMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writePointMember)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'lineStringMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeLineStringOrCurveMember),
    'curveMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeLineStringOrCurveMember)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML3.prototype.GEOMETRY_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'Curve': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeCurveOrLineString),
    'MultiCurve': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeMultiCurveOrLineString),
    'Point': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writePoint),
    'MultiPoint': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeMultiPoint),
    'LineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeCurveOrLineString),
    'MultiLineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeMultiCurveOrLineString),
    'LinearRing': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeLinearRing),
    'Polygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeSurfaceOrPolygon),
    'MultiPolygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeMultiSurfaceOrPolygon),
    'Surface': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeSurfaceOrPolygon),
    'MultiSurface': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeMultiSurfaceOrPolygon),
    'Envelope': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(GML3.prototype.writeEnvelope)
  }
};
/* harmony default export */ __webpack_exports__["default"] = (GML3);

/***/ }),

/***/ "./build/wg/format/GML32.js":
/*!**********************************!*\
  !*** ./build/wg/format/GML32.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GML2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GML2.js */ "./build/wg/format/GML2.js");
/* harmony import */ var _GML3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GML3.js */ "./build/wg/format/GML3.js");
/* harmony import */ var _GMLBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GMLBase.js */ "./build/wg/format/GMLBase.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../xml.js */ "./build/wg/xml.js");
/* harmony import */ var _format_xsd_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../format/xsd.js */ "./build/wg/format/xsd.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/GML32
 */







/**
 * @classdesc Feature format for reading and writing data in the GML format
 *            version 3.2.1.
 * @api
 */

var GML32 =
/** @class */
function (_super) {
  __extends(GML32, _super);
  /**
   * @param {import("./GMLBase.js").Options} [opt_options] Optional configuration object.
   */


  function GML32(opt_options) {
    var _this = this;

    var options =
    /** @type {import("./GMLBase.js").Options} */
    opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    /**
     * @type {string}
     */

    _this.schemaLocation = options.schemaLocation ? options.schemaLocation : _this.namespace + ' http://schemas.opengis.net/gml/3.2.1/gml.xsd';
    return _this;
  }

  return GML32;
}(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

GML32.prototype.namespace = 'http://www.opengis.net/gml/3.2';
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'pos': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readFlatPos),
    'posList': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readFlatPosList),
    'coordinates': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GML2_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readFlatCoordinates)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'interior': _GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.interiorParser,
    'exterior': _GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.exteriorParser
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.GEOMETRY_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'Point': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readPoint),
    'MultiPoint': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readMultiPoint),
    'LineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readLineString),
    'MultiLineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readMultiLineString),
    'LinearRing': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readLinearRing),
    'Polygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readPolygon),
    'MultiPolygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readMultiPolygon),
    'Surface': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(GML32.prototype.readSurface),
    'MultiSurface': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readMultiSurface),
    'Curve': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(GML32.prototype.readCurve),
    'MultiCurve': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readMultiCurve),
    'Envelope': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(GML32.prototype.readEnvelope)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.MULTICURVE_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'curveMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.curveMemberParser),
    'curveMembers': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.curveMemberParser)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.MULTISURFACE_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'surfaceMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.surfaceMemberParser),
    'surfaceMembers': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.surfaceMemberParser)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.CURVEMEMBER_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'LineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readLineString),
    'Curve': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readCurve)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.SURFACEMEMBER_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'Polygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readPolygon),
    'Surface': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readSurface)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.SURFACE_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'patches': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readPatch)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.CURVE_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'segments': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readSegment)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.ENVELOPE_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'lowerCorner': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readFlatPosList),
    'upperCorner': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readFlatPosList)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.PATCHES_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'PolygonPatch': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readPolygonPatch)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.SEGMENTS_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'LineStringSegment': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readLineStringSegment)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.MULTIPOINT_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'pointMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.pointMemberParser),
    'pointMembers': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.pointMemberParser)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.MULTILINESTRING_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'lineStringMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.lineStringMemberParser),
    'lineStringMembers': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.lineStringMemberParser)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.MULTIPOLYGON_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'polygonMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.polygonMemberParser),
    'polygonMembers': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.polygonMemberParser)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.POINTMEMBER_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'Point': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readFlatCoordinatesFromNode)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.LINESTRINGMEMBER_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'LineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readLineString)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.POLYGONMEMBER_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'Polygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readPolygon)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GML32.prototype.RING_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'LinearRing': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readFlatLinearRing)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML32.prototype.RING_SERIALIZERS = {
  'http://www.opengis.net/gml/3.2': {
    'exterior': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeRing),
    'interior': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeRing)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML32.prototype.ENVELOPE_SERIALIZERS = {
  'http://www.opengis.net/gml/3.2': {
    'lowerCorner': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_format_xsd_js__WEBPACK_IMPORTED_MODULE_4__.writeStringTextNode),
    'upperCorner': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_format_xsd_js__WEBPACK_IMPORTED_MODULE_4__.writeStringTextNode)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML32.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml/3.2': {
    'surfaceMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeSurfaceOrPolygonMember),
    'polygonMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeSurfaceOrPolygonMember)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML32.prototype.POINTMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml/3.2': {
    'pointMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writePointMember)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML32.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml/3.2': {
    'lineStringMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeLineStringOrCurveMember),
    'curveMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeLineStringOrCurveMember)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

GML32.prototype.GEOMETRY_SERIALIZERS = {
  'http://www.opengis.net/gml/3.2': {
    'Curve': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeCurveOrLineString),
    'MultiCurve': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeMultiCurveOrLineString),
    'Point': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(GML32.prototype.writePoint),
    'MultiPoint': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeMultiPoint),
    'LineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeCurveOrLineString),
    'MultiLineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeMultiCurveOrLineString),
    'LinearRing': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeLinearRing),
    'Polygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeSurfaceOrPolygon),
    'MultiPolygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeMultiSurfaceOrPolygon),
    'Surface': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeSurfaceOrPolygon),
    'MultiSurface': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeMultiSurfaceOrPolygon),
    'Envelope': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeEnvelope)
  }
};
/* harmony default export */ __webpack_exports__["default"] = (GML32);

/***/ }),

/***/ "./build/wg/format/GMLBase.js":
/*!************************************!*\
  !*** ./build/wg/format/GMLBase.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GMLNS": function() { return /* binding */ GMLNS; }
/* harmony export */ });
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/LinearRing.js */ "./build/wg/geom/LinearRing.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./build/wg/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./build/wg/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./build/wg/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _XMLFeature_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./XMLFeature.js */ "./build/wg/format/XMLFeature.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../xml.js */ "./build/wg/xml.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Feature.js */ "./build/wg/format/Feature.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/GMLBase
 */
// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part
// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect
// envelopes/extents, only geometries!

















/**
 * @const
 * @type {string}
 */

var GMLNS = 'http://www.opengis.net/gml';
/**
 * A regular expression that matches if a string only contains whitespace
 * characters. It will e.g. match `''`, `' '`, `'\n'` etc. The non-breaking
 * space (0xa0) is explicitly included as IE doesn't include it in its
 * definition of `\s`.
 *
 * Information from `goog.string.isEmptyOrWhitespace`: https://github.com/google/closure-library/blob/e877b1e/closure/goog/string/string.js#L156-L160
 *
 * @const
 * @type {RegExp}
 */

var ONLY_WHITESPACE_RE = /^[\s\xa0]*$/;
/**
 * @typedef {Object} Options
 * @property {Object<string, string>|string} [featureNS] Feature
 * namespace. If not defined will be derived from GML. If multiple
 * feature types have been configured which come from different feature
 * namespaces, this will be an object with the keys being the prefixes used
 * in the entries of featureType array. The values of the object will be the
 * feature namespaces themselves. So for instance there might be a featureType
 * item `topp:states` in the `featureType` array and then there will be a key
 * `topp` in the featureNS object with value `http://www.openplans.org/topp`.
 * @property {Array<string>|string} [featureType] Feature type(s) to parse.
 * If multiple feature types need to be configured
 * which come from different feature namespaces, `featureNS` will be an object
 * with the keys being the prefixes used in the entries of featureType array.
 * The values of the object will be the feature namespaces themselves.
 * So for instance there might be a featureType item `topp:states` and then
 * there will be a key named `topp` in the featureNS object with value
 * `http://www.openplans.org/topp`.
 * @property {string} srsName srsName to use when writing geometries.
 * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon
 * elements. This also affects the elements in multi-part geometries.
 * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString
 * elements. This also affects the elements in multi-part geometries.
 * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.
 * Since the latter is deprecated in GML 3.
 * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of
 * gml:MultiPolygon. Since the latter is deprecated in GML 3.
 * @property {string} [schemaLocation] Optional schemaLocation to use when
 * writing out the GML, this will override the default provided.
 * @property {boolean} [hasZ=false] If coordinates have a Z value.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Feature base format for reading and writing data in the GML format.
 * This class cannot be instantiated, it contains only base content that
 * is shared with versioned format classes GML2 and GML3.
 *
 * @abstract
 * @api
 */

var GMLBase =
/** @class */
function (_super) {
  __extends(GMLBase, _super);
  /**
   * @param {Options} [opt_options] Optional configuration object.
   */


  function GMLBase(opt_options) {
    var _this = _super.call(this) || this;

    var options =
    /** @type {Options} */
    opt_options ? opt_options : {};
    /**
     * @protected
     * @type {Array<string>|string|undefined}
     */

    _this.featureType = options.featureType;
    /**
     * @protected
     * @type {Object<string, string>|string|undefined}
     */

    _this.featureNS = options.featureNS;
    /**
     * @protected
     * @type {string}
     */

    _this.srsName = options.srsName;
    /**
     * @protected
     * @type {string}
     */

    _this.schemaLocation = '';
    /**
     * @type {Object<string, Object<string, Object>>}
     */

    _this.FEATURE_COLLECTION_PARSERS = {};
    _this.FEATURE_COLLECTION_PARSERS[_this.namespace] = {
      'featureMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_this.readFeaturesInternal),
      'featureMembers': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(_this.readFeaturesInternal)
    };
    _this.supportedMediaTypes = ['application/gml+xml'];
    return _this;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<Feature> | undefined} Features.
   */


  GMLBase.prototype.readFeaturesInternal = function (node, objectStack) {
    var localName = node.localName;
    var features = null;

    if (localName == 'FeatureCollection') {
      features = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)([], this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);
    } else if (localName == 'featureMembers' || localName == 'featureMember' || localName == 'member') {
      var context = objectStack[0];
      var featureType = context['featureType'];
      var featureNS = context['featureNS'];
      var prefix = 'p';
      var defaultPrefix = 'p0';

      if (!featureType && node.childNodes) {
        featureType = [], featureNS = {};

        for (var i = 0, ii = node.childNodes.length; i < ii; ++i) {
          var child =
          /** @type {Element} */
          node.childNodes[i];

          if (child.nodeType === 1) {
            var ft = child.nodeName.split(':').pop();

            if (featureType.indexOf(ft) === -1) {
              var key = '';
              var count = 0;
              var uri = child.namespaceURI;

              for (var candidate in featureNS) {
                if (featureNS[candidate] === uri) {
                  key = candidate;
                  break;
                }

                ++count;
              }

              if (!key) {
                key = prefix + count;
                featureNS[key] = uri;
              }

              featureType.push(key + ':' + ft);
            }
          }
        }

        if (localName != 'featureMember') {
          // recheck featureType for each featureMember
          context['featureType'] = featureType;
          context['featureNS'] = featureNS;
        }
      }

      if (typeof featureNS === 'string') {
        var ns = featureNS;
        featureNS = {};
        featureNS[defaultPrefix] = ns;
      }
      /** @type {Object<string, Object<string, import("../xml.js").Parser>>} */


      var parsersNS = {};
      var featureTypes = Array.isArray(featureType) ? featureType : [featureType];

      for (var p in featureNS) {
        /** @type {Object<string, import("../xml.js").Parser>} */
        var parsers = {};

        for (var i = 0, ii = featureTypes.length; i < ii; ++i) {
          var featurePrefix = featureTypes[i].indexOf(':') === -1 ? defaultPrefix : featureTypes[i].split(':')[0];

          if (featurePrefix === p) {
            parsers[featureTypes[i].split(':').pop()] = localName == 'featureMembers' ? (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(this.readFeatureElement, this) : (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(this.readFeatureElement, this);
          }
        }

        parsersNS[featureNS[p]] = parsers;
      }

      if (localName == 'featureMember' || localName == 'member') {
        features = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)(undefined, parsersNS, node, objectStack);
      } else {
        features = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)([], parsersNS, node, objectStack);
      }
    }

    if (features === null) {
      features = [];
    }

    return features;
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent|undefined} Geometry.
   */


  GMLBase.prototype.readGeometryElement = function (node, objectStack) {
    var context =
    /** @type {Object} */
    objectStack[0];
    context['srsName'] = node.firstElementChild.getAttribute('srsName');
    context['srsDimension'] = node.firstElementChild.getAttribute('srsDimension');
    var geometry = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)(null, this.GEOMETRY_PARSERS, node, objectStack, this);

    if (geometry) {
      if (Array.isArray(geometry)) {
        return (0,_Feature_js__WEBPACK_IMPORTED_MODULE_2__.transformExtentWithOptions)(
        /** @type {import("../extent.js").Extent} */
        geometry, context);
      } else {
        return (0,_Feature_js__WEBPACK_IMPORTED_MODULE_2__.transformGeometryWithOptions)(
        /** @type {import("../geom/Geometry.js").default} */
        geometry, false, context);
      }
    } else {
      return undefined;
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @param {boolean} asFeature whether result should be wrapped as a feature.
   * @return {Feature|Object} Feature
   */


  GMLBase.prototype.readFeatureElementInternal = function (node, objectStack, asFeature) {
    var geometryName;
    var values = {};

    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
      var value = void 0;
      var localName = n.localName; // first, check if it is simple attribute

      if (n.childNodes.length === 0 || n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4)) {
        value = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.getAllTextContent)(n, false);

        if (ONLY_WHITESPACE_RE.test(value)) {
          value = undefined;
        }
      } else {
        if (asFeature) {
          //if feature, try it as a geometry
          value = this.readGeometryElement(n, objectStack);
        }

        if (!value) {
          //if not a geometry or not a feature, treat it as a complex attribute
          value = this.readFeatureElementInternal(n, objectStack, false);
        } else if (localName !== 'boundedBy') {
          // boundedBy is an extent and must not be considered as a geometry
          geometryName = localName;
        }
      }

      if (values[localName]) {
        if (!(values[localName] instanceof Array)) {
          values[localName] = [values[localName]];
        }

        values[localName].push(value);
      } else {
        values[localName] = value;
      }

      var len = n.attributes.length;

      if (len > 0) {
        values[localName] = {
          _content_: values[localName]
        };

        for (var i = 0; i < len; i++) {
          var attName = n.attributes[i].name;
          values[localName][attName] = n.attributes[i].value;
        }
      }
    }

    if (!asFeature) {
      return values;
    } else {
      var feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_3__["default"](values);

      if (geometryName) {
        feature.setGeometryName(geometryName);
      }

      var fid = node.getAttribute('fid') || (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.getAttributeNS)(node, this.namespace, 'id');

      if (fid) {
        feature.setId(fid);
      }

      return feature;
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Feature} Feature.
   */


  GMLBase.prototype.readFeatureElement = function (node, objectStack) {
    return this.readFeatureElementInternal(node, objectStack, true);
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Point|undefined} Point.
   */


  GMLBase.prototype.readPoint = function (node, objectStack) {
    var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);

    if (flatCoordinates) {
      return new _geom_Point_js__WEBPACK_IMPORTED_MODULE_4__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XYZ);
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPoint|undefined} MultiPoint.
   */


  GMLBase.prototype.readMultiPoint = function (node, objectStack) {
    /** @type {Array<Array<number>>} */
    var coordinates = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)([], this.MULTIPOINT_PARSERS, node, objectStack, this);

    if (coordinates) {
      return new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_6__["default"](coordinates);
    } else {
      return undefined;
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */


  GMLBase.prototype.readMultiLineString = function (node, objectStack) {
    /** @type {Array<LineString>} */
    var lineStrings = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)([], this.MULTILINESTRING_PARSERS, node, objectStack, this);

    if (lineStrings) {
      return new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_7__["default"](lineStrings);
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */


  GMLBase.prototype.readMultiPolygon = function (node, objectStack) {
    /** @type {Array<Polygon>} */
    var polygons = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)([], this.MULTIPOLYGON_PARSERS, node, objectStack, this);

    if (polygons) {
      return new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_8__["default"](polygons);
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */


  GMLBase.prototype.pointMemberParser = function (node, objectStack) {
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.parseNode)(this.POINTMEMBER_PARSERS, node, objectStack, this);
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */


  GMLBase.prototype.lineStringMemberParser = function (node, objectStack) {
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.parseNode)(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */


  GMLBase.prototype.polygonMemberParser = function (node, objectStack) {
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.parseNode)(this.POLYGONMEMBER_PARSERS, node, objectStack, this);
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */


  GMLBase.prototype.readLineString = function (node, objectStack) {
    var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);

    if (flatCoordinates) {
      var lineString = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_9__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XYZ);
      return lineString;
    } else {
      return undefined;
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} LinearRing flat coordinates.
   */


  GMLBase.prototype.readFlatLinearRing = function (node, objectStack) {
    var ring = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);

    if (ring) {
      return ring;
    } else {
      return undefined;
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LinearRing|undefined} LinearRing.
   */


  GMLBase.prototype.readLinearRing = function (node, objectStack) {
    var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);

    if (flatCoordinates) {
      return new _geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_10__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XYZ);
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */


  GMLBase.prototype.readPolygon = function (node, objectStack) {
    /** @type {Array<Array<number>>} */
    var flatLinearRings = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);

    if (flatLinearRings && flatLinearRings[0]) {
      var flatCoordinates = flatLinearRings[0];
      var ends = [flatCoordinates.length];
      var i = void 0,
          ii = void 0;

      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
        (0,_array_js__WEBPACK_IMPORTED_MODULE_11__.extend)(flatCoordinates, flatLinearRings[i]);
        ends.push(flatCoordinates.length);
      }

      return new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_12__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XYZ, ends);
    } else {
      return undefined;
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>} Flat coordinates.
   */


  GMLBase.prototype.readFlatCoordinatesFromNode = function (node, objectStack) {
    return (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
  };
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent} Geometry.
   */
  //@ts-ignore


  GMLBase.prototype.readGeometryFromNode = function (node, opt_options) {
    var geometry = this.readGeometryElement(node, [this.getReadOptions(node, opt_options ? opt_options : {})]);
    return geometry ? geometry : null;
  };
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */


  GMLBase.prototype.readFeaturesFromNode = function (node, opt_options) {
    var options = {
      featureType: this.featureType,
      featureNS: this.featureNS
    };

    if (opt_options) {
      (0,_obj_js__WEBPACK_IMPORTED_MODULE_13__.assign)(options, this.getReadOptions(node, opt_options));
    }

    var features = this.readFeaturesInternal(node, [options]);
    return features || [];
  };
  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */


  GMLBase.prototype.readProjectionFromNode = function (node) {
    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.srsName ? this.srsName : node.firstElementChild.getAttribute('srsName'));
  };

  return GMLBase;
}(_XMLFeature_js__WEBPACK_IMPORTED_MODULE_14__["default"]);

GMLBase.prototype.namespace = GMLNS;
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  'http://www.opengis.net/gml': {}
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  'http://www.opengis.net/gml': {}
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GMLBase.prototype.GEOMETRY_PARSERS = {
  'http://www.opengis.net/gml': {}
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GMLBase.prototype.MULTIPOINT_PARSERS = {
  'http://www.opengis.net/gml': {
    'pointMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(GMLBase.prototype.pointMemberParser),
    'pointMembers': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(GMLBase.prototype.pointMemberParser)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GMLBase.prototype.MULTILINESTRING_PARSERS = {
  'http://www.opengis.net/gml': {
    'lineStringMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(GMLBase.prototype.lineStringMemberParser),
    'lineStringMembers': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(GMLBase.prototype.lineStringMemberParser)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GMLBase.prototype.MULTIPOLYGON_PARSERS = {
  'http://www.opengis.net/gml': {
    'polygonMember': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(GMLBase.prototype.polygonMemberParser),
    'polygonMembers': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(GMLBase.prototype.polygonMemberParser)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GMLBase.prototype.POINTMEMBER_PARSERS = {
  'http://www.opengis.net/gml': {
    'Point': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(GMLBase.prototype.readFlatCoordinatesFromNode)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GMLBase.prototype.LINESTRINGMEMBER_PARSERS = {
  'http://www.opengis.net/gml': {
    'LineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(GMLBase.prototype.readLineString)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GMLBase.prototype.POLYGONMEMBER_PARSERS = {
  'http://www.opengis.net/gml': {
    'Polygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(GMLBase.prototype.readPolygon)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

GMLBase.prototype.RING_PARSERS = {
  'http://www.opengis.net/gml': {
    'LinearRing': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeReplacer)(GMLBase.prototype.readFlatLinearRing)
  }
};
/* harmony default export */ __webpack_exports__["default"] = (GMLBase);

/***/ }),

/***/ "./build/wg/format/GPX.js":
/*!********************************!*\
  !*** ./build/wg/format/GPX.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./build/wg/geom/MultiLineString.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _XMLFeature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./XMLFeature.js */ "./build/wg/format/XMLFeature.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../xml.js */ "./build/wg/xml.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./xsd.js */ "./build/wg/format/xsd.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Feature.js */ "./build/wg/format/Feature.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/GPX
 */














/**
 * @const
 * @type {Array<null|string>}
 */

var NAMESPACE_URIS = [null, 'http://www.topografix.com/GPX/1/0', 'http://www.topografix.com/GPX/1/1'];
/**
 * @const
 * @type {string}
 */

var SCHEMA_LOCATION = 'http://www.topografix.com/GPX/1/1 ' + 'http://www.topografix.com/GPX/1/1/gpx.xsd';
/**
 * @const
 * @type {Object<string, function(Node, Array<*>): (Feature|undefined)>}
 */

var FEATURE_READER = {
  'rte': readRte,
  'trk': readTrk,
  'wpt': readWpt
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var GPX_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'rte': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(readRte),
  'trk': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(readTrk),
  'wpt': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(readWpt)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var LINK_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'text': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString, 'linkText'),
  'type': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString, 'linkType')
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore

var GPX_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'rte': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeRte),
  'trk': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeTrk),
  'wpt': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeWpt)
});
/**
 * @typedef {Object} Options
 * @property {function(Feature, Node):void} [readExtensions] Callback function
 * to process `extensions` nodes. To prevent memory leaks, this callback function must
 * not store any references to the node. Note that the `extensions`
 * node is not allowed in GPX 1.0. Moreover, only `extensions`
 * nodes from `wpt`, `rte` and `trk` can be processed, as those are
 * directly mapped to a feature.
 */

/**
 * @typedef {Object} LayoutOptions
 * @property {boolean} [hasZ] HasZ.
 * @property {boolean} [hasM] HasM.
 */

/**
 * @classdesc
 * Feature format for reading and writing data in the GPX format.
 *
 * Note that {@link module:wg/format/GPX~GPX#readFeature} only reads the first
 * feature of the source.
 *
 * When reading, routes (`<rte>`) are converted into LineString geometries, and
 * tracks (`<trk>`) into MultiLineString. Any properties on route and track
 * waypoints are ignored.
 *
 * When writing, LineString geometries are output as routes (`<rte>`), and
 * MultiLineString as tracks (`<trk>`).
 *
 * @api
 */

var GPX =
/** @class */
function (_super) {
  __extends(GPX, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function GPX(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @type {import("../proj/Projection.js").default}
     */

    _this.dataProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:4326');
    /**
     * @type {function(Feature, Node): void|undefined}
     * @private
     */

    _this.readExtensions_ = options.readExtensions;
    return _this;
  }
  /**
   * @param {Array<Feature>} features List of features.
   * @private
   */


  GPX.prototype.handleReadExtensions_ = function (features) {
    if (!features) {
      features = [];
    }

    for (var i = 0, ii = features.length; i < ii; ++i) {
      var feature = features[i];

      if (this.readExtensions_) {
        var extensionsNode = feature.get('extensionsNode_') || null;
        this.readExtensions_(feature, extensionsNode);
      }

      feature.set('extensionsNode_', undefined);
    }
  };
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @return {import("../Feature.js").default} Feature.
   */


  GPX.prototype.readFeatureFromNode = function (node, opt_options) {
    if (!(0,_array_js__WEBPACK_IMPORTED_MODULE_3__.includes)(NAMESPACE_URIS, node.namespaceURI)) {
      return null;
    }

    var featureReader = FEATURE_READER[node.localName];

    if (!featureReader) {
      return null;
    }

    var feature = featureReader(node, [this.getReadOptions(node, opt_options)]);

    if (!feature) {
      return null;
    }

    this.handleReadExtensions_([feature]);
    return feature;
  };
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */


  GPX.prototype.readFeaturesFromNode = function (node, opt_options) {
    if (!(0,_array_js__WEBPACK_IMPORTED_MODULE_3__.includes)(NAMESPACE_URIS, node.namespaceURI)) {
      return [];
    }

    if (node.localName == 'gpx') {
      /** @type {Array<Feature>} */
      var features = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)([], GPX_PARSERS, node, [this.getReadOptions(node, opt_options)]);

      if (features) {
        this.handleReadExtensions_(features);
        return features;
      } else {
        return [];
      }
    }

    return [];
  };
  /**
   * Encode an array of features in the GPX format as an XML node.
   * LineString geometries are output as routes (`<rte>`), and MultiLineString
   * as tracks (`<trk>`).
   *
   * @param {Array<Feature>} features Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Options.
   * @return {Node} Node.
   * @api
   */


  GPX.prototype.writeFeaturesNode = function (features, opt_options) {
    opt_options = this.adaptOptions(opt_options); //FIXME Serialize metadata

    var gpx = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)('http://www.topografix.com/GPX/1/1', 'gpx');
    var xmlnsUri = 'http://www.w3.org/2000/xmlns/';
    gpx.setAttributeNS(xmlnsUri, 'xmlns:xsi', _xml_js__WEBPACK_IMPORTED_MODULE_1__.XML_SCHEMA_INSTANCE_URI);
    gpx.setAttributeNS(_xml_js__WEBPACK_IMPORTED_MODULE_1__.XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', SCHEMA_LOCATION);
    gpx.setAttribute('version', '1.1');
    gpx.setAttribute('creator', 'OpenLayers');
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushSerializeAndPop)(
    /** @type {import("../xml.js").NodeStackItem} */
    {
      node: gpx
    }, GPX_SERIALIZERS, GPX_NODE_FACTORY, features, [opt_options]);
    return gpx;
  };

  return GPX;
}(_XMLFeature_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var RTE_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'name': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'cmt': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'desc': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'src': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'link': parseLink,
  'number': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readPositiveInteger),
  'extensions': parseExtensions,
  'type': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'rtept': parseRtePt
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var RTEPT_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'ele': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimal),
  'time': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDateTime)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var TRK_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'name': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'cmt': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'desc': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'src': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'link': parseLink,
  'number': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readPositiveInteger),
  'type': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'extensions': parseExtensions,
  'trkseg': parseTrkSeg
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var TRKSEG_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'trkpt': parseTrkPt
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var TRKPT_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'ele': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimal),
  'time': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDateTime)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var WPT_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'ele': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimal),
  'time': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDateTime),
  'magvar': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimal),
  'geoidheight': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimal),
  'name': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'cmt': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'desc': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'src': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'link': parseLink,
  'sym': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'type': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'fix': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'sat': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readPositiveInteger),
  'hdop': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimal),
  'vdop': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimal),
  'pdop': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimal),
  'ageofdgpsdata': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimal),
  'dgpsid': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readPositiveInteger),
  'extensions': parseExtensions
});
/**
 * @const
 * @type {Array<string>}
 */

var LINK_SEQUENCE = ['text', 'type'];
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore

var LINK_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'text': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'type': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode)
});
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore

var RTE_SEQUENCE = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, ['name', 'cmt', 'desc', 'src', 'link', 'number', 'type', 'rtept']);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore

var RTE_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'name': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'cmt': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'desc': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'src': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'link': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeLink),
  'number': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeNonNegativeIntegerTextNode),
  'type': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'rtept': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArraySerializer)((0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeWptType))
});
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore

var RTEPT_TYPE_SEQUENCE = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, ['ele', 'time']);
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore

var TRK_SEQUENCE = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, ['name', 'cmt', 'desc', 'src', 'link', 'number', 'type', 'trkseg']);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore

var TRK_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'name': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'cmt': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'desc': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'src': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'link': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeLink),
  'number': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeNonNegativeIntegerTextNode),
  'type': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'trkseg': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArraySerializer)((0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeTrkSeg))
});
/**
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */

var TRKSEG_NODE_FACTORY = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleNodeFactory)('trkpt');
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore

var TRKSEG_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'trkpt': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeWptType)
});
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore

var WPT_TYPE_SEQUENCE = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, ['ele', 'time', 'magvar', 'geoidheight', 'name', 'cmt', 'desc', 'src', 'link', 'sym', 'type', 'fix', 'sat', 'hdop', 'vdop', 'pdop', 'ageofdgpsdata', 'dgpsid']);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore

var WPT_TYPE_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'ele': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeDecimalTextNode),
  'time': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeDateTimeTextNode),
  'magvar': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeDecimalTextNode),
  'geoidheight': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeDecimalTextNode),
  'name': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'cmt': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'desc': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'src': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'link': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeLink),
  'sym': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'type': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'fix': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeStringTextNode),
  'sat': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeNonNegativeIntegerTextNode),
  'hdop': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeDecimalTextNode),
  'vdop': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeDecimalTextNode),
  'pdop': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeDecimalTextNode),
  'ageofdgpsdata': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeDecimalTextNode),
  'dgpsid': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.writeNonNegativeIntegerTextNode)
});
/**
 * @const
 * @type {Object<string, string>}
 */

var GEOMETRY_TYPE_TO_NODENAME = {
  'Point': 'wpt',
  'LineString': 'rte',
  'MultiLineString': 'trk'
};
/**
 * @param {*} value Value.
 * @param {Array<*>} objectStack Object stack.
 * @param {string} [opt_nodeName] Node name.
 * @return {Node|undefined} Node.
 */

function GPX_NODE_FACTORY(value, objectStack, opt_nodeName) {
  var geometry =
  /** @type {Feature} */
  value.getGeometry();

  if (geometry) {
    var nodeName = GEOMETRY_TYPE_TO_NODENAME[geometry.getType()];

    if (nodeName) {
      var parentNode = objectStack[objectStack.length - 1].node;
      return (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(parentNode.namespaceURI, nodeName);
    }
  }
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {LayoutOptions} layoutOptions Layout options.
 * @param {Element} node Node.
 * @param {!Object} values Values.
 * @return {Array<number>} Flat coordinates.
 */


function appendCoordinate(flatCoordinates, layoutOptions, node, values) {
  flatCoordinates.push(parseFloat(node.getAttribute('lon')), parseFloat(node.getAttribute('lat')));

  if ('ele' in values) {
    flatCoordinates.push(
    /** @type {number} */
    values['ele']);
    delete values['ele'];
    layoutOptions.hasZ = true;
  } else {
    flatCoordinates.push(0);
  }

  if ('time' in values) {
    flatCoordinates.push(
    /** @type {number} */
    values['time']);
    delete values['time'];
    layoutOptions.hasM = true;
  } else {
    flatCoordinates.push(0);
  }

  return flatCoordinates;
}
/**
 * Choose GeometryLayout based on flags in layoutOptions and adjust flatCoordinates
 * and ends arrays by shrinking them accordingly (removing unused zero entries).
 *
 * @param {LayoutOptions} layoutOptions Layout options.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {Array<number>} [ends] Ends.
 * @return {import("../geom/GeometryLayout.js").default} Layout.
 */


function applyLayoutOptions(layoutOptions, flatCoordinates, ends) {
  var layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XY;
  var stride = 2;

  if (layoutOptions.hasZ && layoutOptions.hasM) {
    layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XYZM;
    stride = 4;
  } else if (layoutOptions.hasZ) {
    layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XYZ;
    stride = 3;
  } else if (layoutOptions.hasM) {
    layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XYM;
    stride = 3;
  }

  if (stride !== 4) {
    for (var i = 0, ii = flatCoordinates.length / 4; i < ii; i++) {
      flatCoordinates[i * stride] = flatCoordinates[i * 4];
      flatCoordinates[i * stride + 1] = flatCoordinates[i * 4 + 1];

      if (layoutOptions.hasZ) {
        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 2];
      }

      if (layoutOptions.hasM) {
        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 3];
      }
    }

    flatCoordinates.length = flatCoordinates.length / 4 * stride;

    if (ends) {
      for (var i = 0, ii = ends.length; i < ii; i++) {
        ends[i] = ends[i] / 4 * stride;
      }
    }
  }

  return layout;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */


function parseLink(node, objectStack) {
  var values =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var href = node.getAttribute('href');

  if (href !== null) {
    values['link'] = href;
  }

  (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.parseNode)(LINK_PARSERS, node, objectStack);
}
/**
 * @param {Node} node Node.
 * @param {Array<*>} objectStack Object stack.
 */


function parseExtensions(node, objectStack) {
  var values =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  values['extensionsNode_'] = node;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */


function parseRtePt(node, objectStack) {
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)({}, RTEPT_PARSERS, node, objectStack);

  if (values) {
    var rteValues =
    /** @type {!Object} */
    objectStack[objectStack.length - 1];
    var flatCoordinates =
    /** @type {Array<number>} */
    rteValues['flatCoordinates'];
    var layoutOptions =
    /** @type {LayoutOptions} */
    rteValues['layoutOptions'];
    appendCoordinate(flatCoordinates, layoutOptions, node, values);
  }
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */


function parseTrkPt(node, objectStack) {
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)({}, TRKPT_PARSERS, node, objectStack);

  if (values) {
    var trkValues =
    /** @type {!Object} */
    objectStack[objectStack.length - 1];
    var flatCoordinates =
    /** @type {Array<number>} */
    trkValues['flatCoordinates'];
    var layoutOptions =
    /** @type {LayoutOptions} */
    trkValues['layoutOptions'];
    appendCoordinate(flatCoordinates, layoutOptions, node, values);
  }
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */


function parseTrkSeg(node, objectStack) {
  var values =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.parseNode)(TRKSEG_PARSERS, node, objectStack);
  var flatCoordinates =
  /** @type {Array<number>} */
  values['flatCoordinates'];
  var ends =
  /** @type {Array<number>} */
  values['ends'];
  ends.push(flatCoordinates.length);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Feature|undefined} Track.
 */


function readRte(node, objectStack) {
  var options =
  /** @type {import("./Feature.js").ReadOptions} */
  objectStack[0];
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)({
    'flatCoordinates': [],
    'layoutOptions': {}
  }, RTE_PARSERS, node, objectStack);

  if (!values) {
    return undefined;
  }

  var flatCoordinates =
  /** @type {Array<number>} */
  values['flatCoordinates'];
  delete values['flatCoordinates'];
  var layoutOptions =
  /** @type {LayoutOptions} */
  values['layoutOptions'];
  delete values['layoutOptions'];
  var layout = applyLayoutOptions(layoutOptions, flatCoordinates);
  var geometry = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__["default"](flatCoordinates, layout);
  (0,_Feature_js__WEBPACK_IMPORTED_MODULE_7__.transformGeometryWithOptions)(geometry, false, options);
  var feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_8__["default"](geometry);
  feature.setProperties(values, true);
  return feature;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Feature|undefined} Track.
 */


function readTrk(node, objectStack) {
  var options =
  /** @type {import("./Feature.js").ReadOptions} */
  objectStack[0];
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)({
    'flatCoordinates': [],
    'ends': [],
    'layoutOptions': {}
  }, TRK_PARSERS, node, objectStack);

  if (!values) {
    return undefined;
  }

  var flatCoordinates =
  /** @type {Array<number>} */
  values['flatCoordinates'];
  delete values['flatCoordinates'];
  var ends =
  /** @type {Array<number>} */
  values['ends'];
  delete values['ends'];
  var layoutOptions =
  /** @type {LayoutOptions} */
  values['layoutOptions'];
  delete values['layoutOptions'];
  var layout = applyLayoutOptions(layoutOptions, flatCoordinates, ends);
  var geometry = new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_9__["default"](flatCoordinates, layout, ends);
  (0,_Feature_js__WEBPACK_IMPORTED_MODULE_7__.transformGeometryWithOptions)(geometry, false, options);
  var feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_8__["default"](geometry);
  feature.setProperties(values, true);
  return feature;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Feature|undefined} Waypoint.
 */


function readWpt(node, objectStack) {
  var options =
  /** @type {import("./Feature.js").ReadOptions} */
  objectStack[0];
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)({}, WPT_PARSERS, node, objectStack);

  if (!values) {
    return undefined;
  }

  var layoutOptions =
  /** @type {LayoutOptions} */
  {};
  var coordinates = appendCoordinate([], layoutOptions, node, values);
  var layout = applyLayoutOptions(layoutOptions, coordinates);
  var geometry = new _geom_Point_js__WEBPACK_IMPORTED_MODULE_10__["default"](coordinates, layout);
  (0,_Feature_js__WEBPACK_IMPORTED_MODULE_7__.transformGeometryWithOptions)(geometry, false, options);
  var feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_8__["default"](geometry);
  feature.setProperties(values, true);
  return feature;
}
/**
 * @param {Element} node Node.
 * @param {string} value Value for the link's `href` attribute.
 * @param {Array<*>} objectStack Node stack.
 */


function writeLink(node, value, objectStack) {
  node.setAttribute('href', value);
  var context = objectStack[objectStack.length - 1];
  var properties = context['properties'];
  var link = [properties['linkText'], properties['linkType']];
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushSerializeAndPop)(
  /** @type {import("../xml.js").NodeStackItem} */
  {
    node: node
  }, LINK_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_1__.OBJECT_PROPERTY_NODE_FACTORY, link, objectStack, LINK_SEQUENCE);
}
/**
 * @param {Element} node Node.
 * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Array<*>} objectStack Object stack.
 */


function writeWptType(node, coordinate, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var parentNode = context.node;
  var namespaceURI = parentNode.namespaceURI;
  var properties = context['properties']; //FIXME Projection handling

  node.setAttributeNS(null, 'lat', String(coordinate[1]));
  node.setAttributeNS(null, 'lon', String(coordinate[0]));
  var geometryLayout = context['geometryLayout'];

  switch (geometryLayout) {
    case _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XYZM:
      if (coordinate[3] !== 0) {
        properties['time'] = coordinate[3];
      }

    // fall through

    case _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XYZ:
      if (coordinate[2] !== 0) {
        properties['ele'] = coordinate[2];
      }

      break;

    case _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XYM:
      if (coordinate[2] !== 0) {
        properties['time'] = coordinate[2];
      }

      break;

    default: // pass

  }

  var orderedKeys = node.nodeName == 'rtept' ? RTEPT_TYPE_SEQUENCE[namespaceURI] : WPT_TYPE_SEQUENCE[namespaceURI];
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeSequence)(properties, orderedKeys);
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushSerializeAndPop)(
  /** @type {import("../xml.js").NodeStackItem} */
  {
    node: node,
    'properties': properties
  }, WPT_TYPE_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_1__.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @param {Node} node Node.
 * @param {Feature} feature Feature.
 * @param {Array<*>} objectStack Object stack.
 */


function writeRte(node, feature, objectStack) {
  var options =
  /** @type {import("./Feature.js").WriteOptions} */
  objectStack[0];
  var properties = feature.getProperties();
  var context = {
    node: node
  };
  context['properties'] = properties;
  var geometry = feature.getGeometry();

  if (geometry.getType() == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].LINE_STRING) {
    var lineString =
    /** @type {LineString} */
    (0,_Feature_js__WEBPACK_IMPORTED_MODULE_7__.transformGeometryWithOptions)(geometry, true, options);
    context['geometryLayout'] = lineString.getLayout();
    properties['rtept'] = lineString.getCoordinates();
  }

  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = RTE_SEQUENCE[parentNode.namespaceURI];
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeSequence)(properties, orderedKeys);
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushSerializeAndPop)(context, RTE_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_1__.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @param {Element} node Node.
 * @param {Feature} feature Feature.
 * @param {Array<*>} objectStack Object stack.
 */


function writeTrk(node, feature, objectStack) {
  var options =
  /** @type {import("./Feature.js").WriteOptions} */
  objectStack[0];
  var properties = feature.getProperties();
  /** @type {import("../xml.js").NodeStackItem} */

  var context = {
    node: node
  };
  context['properties'] = properties;
  var geometry = feature.getGeometry();

  if (geometry.getType() == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].MULTI_LINE_STRING) {
    var multiLineString =
    /** @type {MultiLineString} */
    (0,_Feature_js__WEBPACK_IMPORTED_MODULE_7__.transformGeometryWithOptions)(geometry, true, options);
    properties['trkseg'] = multiLineString.getLineStrings();
  }

  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = TRK_SEQUENCE[parentNode.namespaceURI];
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeSequence)(properties, orderedKeys);
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushSerializeAndPop)(context, TRK_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_1__.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @param {Element} node Node.
 * @param {LineString} lineString LineString.
 * @param {Array<*>} objectStack Object stack.
 */


function writeTrkSeg(node, lineString, objectStack) {
  /** @type {import("../xml.js").NodeStackItem} */
  var context = {
    node: node
  };
  context['geometryLayout'] = lineString.getLayout();
  context['properties'] = {};
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushSerializeAndPop)(context, TRKSEG_SERIALIZERS, TRKSEG_NODE_FACTORY, lineString.getCoordinates(), objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Feature} feature Feature.
 * @param {Array<*>} objectStack Object stack.
 */


function writeWpt(node, feature, objectStack) {
  var options =
  /** @type {import("./Feature.js").WriteOptions} */
  objectStack[0];
  var context = objectStack[objectStack.length - 1];
  context['properties'] = feature.getProperties();
  var geometry = feature.getGeometry();

  if (geometry.getType() == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].POINT) {
    var point =
    /** @type {Point} */
    (0,_Feature_js__WEBPACK_IMPORTED_MODULE_7__.transformGeometryWithOptions)(geometry, true, options);
    context['geometryLayout'] = point.getLayout();
    writeWptType(node, point.getCoordinates(), objectStack);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (GPX);

/***/ }),

/***/ "./build/wg/format/GeoJSON.js":
/*!************************************!*\
  !*** ./build/wg/format/GeoJSON.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/GeometryCollection.js */ "./build/wg/geom/GeometryCollection.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _JSONFeature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./JSONFeature.js */ "./build/wg/format/JSONFeature.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./build/wg/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./build/wg/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./build/wg/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Feature.js */ "./build/wg/format/Feature.js");
/**
 * @module wg/format/GeoJSON
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();















/**
 * @typedef {import("geojson").GeoJSON} GeoJSONObject
 * @typedef {import("geojson").Feature} GeoJSONFeature
 * @typedef {import("geojson").FeatureCollection} GeoJSONFeatureCollection
 * @typedef {import("geojson").Geometry} GeoJSONGeometry
 * @typedef {import("geojson").Point} GeoJSONPoint
 * @typedef {import("geojson").LineString} GeoJSONLineString
 * @typedef {import("geojson").Polygon} GeoJSONPolygon
 * @typedef {import("geojson").MultiPoint} GeoJSONMultiPoint
 * @typedef {import("geojson").MultiLineString} GeoJSONMultiLineString
 * @typedef {import("geojson").MultiPolygon} GeoJSONMultiPolygon
 * @typedef {import("geojson").GeometryCollection} GeoJSONGeometryCollection
 */

/**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection for features read or
 * written by the format.  Options passed to read or write methods will take precedence.
 * @property {string} [geometryName] Geometry name to use when creating features.
 * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include
 * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader
 * will look for that field to set the geometry name. If both this field is set to `true`
 * and a `geometryName` is provided, the `geometryName` will take precedence.
 */

/**
 * @classdesc
 * Feature format for reading and writing data in the GeoJSON format.
 *
 * @api
 */

var GeoJSON =
/** @class */
function (_super) {
  __extends(GeoJSON, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function GeoJSON(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this) || this;
    /**
     * @type {import("../proj/Projection.js").default}
     */

    _this.dataProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.dataProjection ? options.dataProjection : 'EPSG:4326');

    if (options.featureProjection) {
      /**
       * @type {import("../proj/Projection.js").default}
       */
      _this.defaultFeatureProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.featureProjection);
    }
    /**
     * Name of the geometry attribute for features.
     * @type {string|undefined}
     * @private
     */


    _this.geometryName_ = options.geometryName;
    /**
     * Look for the geometry name in the feature GeoJSON
     * @type {boolean|undefined}
     * @private
     */

    _this.extractGeometryName_ = options.extractGeometryName;
    _this.supportedMediaTypes = ['application/geo+json', 'application/vnd.geo+json'];
    return _this;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */


  GeoJSON.prototype.readFeatureFromObject = function (object, opt_options) {
    /**
     * @type {GeoJSONFeature}
     */
    var geoJSONFeature = null;

    if (object['type'] === 'Feature') {
      geoJSONFeature =
      /** @type {GeoJSONFeature} */
      object;
    } else {
      geoJSONFeature = {
        'type': 'Feature',
        'geometry':
        /** @type {GeoJSONGeometry} */
        object,
        'properties': null
      };
    }

    var geometry = readGeometry(geoJSONFeature['geometry'], opt_options);
    var feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"]();

    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    } else if (this.extractGeometryName_ && 'geometry_name' in geoJSONFeature !== undefined) {
      feature.setGeometryName(geoJSONFeature['geometry_name']);
    }

    feature.setGeometry(geometry);

    if ('id' in geoJSONFeature) {
      feature.setId(geoJSONFeature['id']);
    }

    if (geoJSONFeature['properties']) {
      feature.setProperties(geoJSONFeature['properties'], true);
    }

    return feature;
  };
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */


  GeoJSON.prototype.readFeaturesFromObject = function (object, opt_options) {
    var geoJSONObject =
    /** @type {GeoJSONObject} */
    object;
    /** @type {Array<import("../Feature.js").default>} */

    var features = null;

    if (geoJSONObject['type'] === 'FeatureCollection') {
      var geoJSONFeatureCollection =
      /** @type {GeoJSONFeatureCollection} */
      object;
      features = [];
      var geoJSONFeatures = geoJSONFeatureCollection['features'];

      for (var i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
        features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));
      }
    } else {
      features = [this.readFeatureFromObject(object, opt_options)];
    }

    return features;
  };
  /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */


  GeoJSON.prototype.readGeometryFromObject = function (object, opt_options) {
    return readGeometry(object, opt_options);
  };
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */


  GeoJSON.prototype.readProjectionFromObject = function (object) {
    var crs = object['crs'];
    var projection;

    if (crs) {
      if (crs['type'] == 'name') {
        projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(crs['properties']['name']);
      } else if (crs['type'] === 'EPSG') {
        projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:' + crs['properties']['code']);
      } else {
        (0,_asserts_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 36); // Unknown SRS type
      }
    } else {
      projection = this.dataProjection;
    }

    return (
      /** @type {import("../proj/Projection.js").default} */
      projection
    );
  };
  /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   */


  GeoJSON.prototype.writeFeatureObject = function (feature, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    /** @type {GeoJSONFeature} */

    var object = {
      'type': 'Feature',
      geometry: null,
      properties: null
    };
    var id = feature.getId();

    if (id !== undefined) {
      object.id = id;
    }

    if (!feature.hasProperties()) {
      return object;
    }

    var properties = feature.getProperties();
    var geometry = feature.getGeometry();

    if (geometry) {
      object.geometry = writeGeometry(geometry, opt_options);
      delete properties[feature.getGeometryName()];
    }

    if (!(0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.isEmpty)(properties)) {
      object.properties = properties;
    }

    return object;
  };
  /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   */


  GeoJSON.prototype.writeFeaturesObject = function (features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var objects = [];

    for (var i = 0, ii = features.length; i < ii; ++i) {
      objects.push(this.writeFeatureObject(features[i], opt_options));
    }

    return {
      type: 'FeatureCollection',
      features: objects
    };
  };
  /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   */


  GeoJSON.prototype.writeGeometryObject = function (geometry, opt_options) {
    return writeGeometry(geometry, this.adaptOptions(opt_options));
  };

  return GeoJSON;
}(_JSONFeature_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */


function readGeometry(object, opt_options) {
  if (!object) {
    return null;
  }
  /**
   * @type {import("../geom/Geometry.js").default}
   */


  var geometry;

  switch (object['type']) {
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINT:
      {
        geometry = readPointGeometry(
        /** @type {GeoJSONPoint} */
        object);
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].LINE_STRING:
      {
        geometry = readLineStringGeometry(
        /** @type {GeoJSONLineString} */
        object);
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON:
      {
        geometry = readPolygonGeometry(
        /** @type {GeoJSONPolygon} */
        object);
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POINT:
      {
        geometry = readMultiPointGeometry(
        /** @type {GeoJSONMultiPoint} */
        object);
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_LINE_STRING:
      {
        geometry = readMultiLineStringGeometry(
        /** @type {GeoJSONMultiLineString} */
        object);
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POLYGON:
      {
        geometry = readMultiPolygonGeometry(
        /** @type {GeoJSONMultiPolygon} */
        object);
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].GEOMETRY_COLLECTION:
      {
        geometry = readGeometryCollectionGeometry(
        /** @type {GeoJSONGeometryCollection} */
        object);
        break;
      }

    default:
      {
        throw new Error('Unsupported GeoJSON type: ' + object.type);
      }
  }

  return (0,_Feature_js__WEBPACK_IMPORTED_MODULE_6__.transformGeometryWithOptions)(geometry, false, opt_options);
}
/**
 * @param {GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
 * @return {GeometryCollection} Geometry collection.
 */


function readGeometryCollectionGeometry(object, opt_options) {
  var geometries = object['geometries'].map(
  /**
   * @param {GeoJSONGeometry} geometry Geometry.
   * @return {import("../geom/Geometry.js").default} geometry Geometry.
   */
  function (geometry) {
    return readGeometry(geometry, opt_options);
  });
  return new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_7__["default"](geometries);
}
/**
 * @param {GeoJSONPoint} object Object.
 * @return {Point} Point.
 */


function readPointGeometry(object) {
  return new _geom_Point_js__WEBPACK_IMPORTED_MODULE_8__["default"](object['coordinates']);
}
/**
 * @param {GeoJSONLineString} object Object.
 * @return {LineString} LineString.
 */


function readLineStringGeometry(object) {
  return new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_9__["default"](object['coordinates']);
}
/**
 * @param {GeoJSONMultiLineString} object Object.
 * @return {MultiLineString} MultiLineString.
 */


function readMultiLineStringGeometry(object) {
  return new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_10__["default"](object['coordinates']);
}
/**
 * @param {GeoJSONMultiPoint} object Object.
 * @return {MultiPoint} MultiPoint.
 */


function readMultiPointGeometry(object) {
  return new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_11__["default"](object['coordinates']);
}
/**
 * @param {GeoJSONMultiPolygon} object Object.
 * @return {MultiPolygon} MultiPolygon.
 */


function readMultiPolygonGeometry(object) {
  return new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_12__["default"](object['coordinates']);
}
/**
 * @param {GeoJSONPolygon} object Object.
 * @return {Polygon} Polygon.
 */


function readPolygonGeometry(object) {
  return new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_13__["default"](object['coordinates']);
}
/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


function writeGeometry(geometry, opt_options) {
  geometry = (0,_Feature_js__WEBPACK_IMPORTED_MODULE_6__.transformGeometryWithOptions)(geometry, true, opt_options);
  var type = geometry.getType();
  /** @type {GeoJSONGeometry} */

  var geoJSON;

  switch (type) {
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINT:
      {
        geoJSON = writePointGeometry(
        /** @type {Point} */
        geometry, opt_options);
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].LINE_STRING:
      {
        geoJSON = writeLineStringGeometry(
        /** @type {LineString} */
        geometry, opt_options);
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON:
      {
        geoJSON = writePolygonGeometry(
        /** @type {Polygon} */
        geometry, opt_options);
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POINT:
      {
        geoJSON = writeMultiPointGeometry(
        /** @type {MultiPoint} */
        geometry, opt_options);
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_LINE_STRING:
      {
        geoJSON = writeMultiLineStringGeometry(
        /** @type {MultiLineString} */
        geometry, opt_options);
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POLYGON:
      {
        geoJSON = writeMultiPolygonGeometry(
        /** @type {MultiPolygon} */
        geometry, opt_options);
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].GEOMETRY_COLLECTION:
      {
        geoJSON = writeGeometryCollectionGeometry(
        /** @type {GeometryCollection} */
        geometry, opt_options);
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CIRCLE:
      {
        geoJSON = {
          type: 'GeometryCollection',
          geometries: []
        };
        break;
      }

    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }

  return geoJSON;
}
/**
 * @param {GeometryCollection} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
 */


function writeGeometryCollectionGeometry(geometry, opt_options) {
  var geometries = geometry.getGeometriesArray().map(function (geometry) {
    var options = (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.assign)({}, opt_options);
    delete options.featureProjection;
    return writeGeometry(geometry, options);
  });
  return {
    type: 'GeometryCollection',
    geometries: geometries
  };
}
/**
 * @param {LineString} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


function writeLineStringGeometry(geometry, opt_options) {
  return {
    type: 'LineString',
    coordinates: geometry.getCoordinates()
  };
}
/**
 * @param {MultiLineString} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


function writeMultiLineStringGeometry(geometry, opt_options) {
  return {
    type: 'MultiLineString',
    coordinates: geometry.getCoordinates()
  };
}
/**
 * @param {MultiPoint} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


function writeMultiPointGeometry(geometry, opt_options) {
  return {
    type: 'MultiPoint',
    coordinates: geometry.getCoordinates()
  };
}
/**
 * @param {MultiPolygon} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


function writeMultiPolygonGeometry(geometry, opt_options) {
  var right;

  if (opt_options) {
    right = opt_options.rightHanded;
  }

  return {
    type: 'MultiPolygon',
    coordinates: geometry.getCoordinates(right)
  };
}
/**
 * @param {Point} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


function writePointGeometry(geometry, opt_options) {
  return {
    type: 'Point',
    coordinates: geometry.getCoordinates()
  };
}
/**
 * @param {Polygon} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


function writePolygonGeometry(geometry, opt_options) {
  var right;

  if (opt_options) {
    right = opt_options.rightHanded;
  }

  return {
    type: 'Polygon',
    coordinates: geometry.getCoordinates(right)
  };
}

/* harmony default export */ __webpack_exports__["default"] = (GeoJSON);

/***/ }),

/***/ "./build/wg/format/IGC.js":
/*!********************************!*\
  !*** ./build/wg/format/IGC.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _TextFeature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TextFeature.js */ "./build/wg/format/TextFeature.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Feature.js */ "./build/wg/format/Feature.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/IGC
 */








/**
 * IGC altitude/z. One of 'barometric', 'gps', 'none'.
 * @enum {string}
 */

var IGCZ = {
  BAROMETRIC: 'barometric',
  GPS: 'gps',
  NONE: 'none'
};
/**
 * @const
 * @type {RegExp}
 */

var B_RECORD_RE = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/;
/**
 * @const
 * @type {RegExp}
 */

var H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;
/**
 * @const
 * @type {RegExp}
 */

var HFDTE_RECORD_RE = /^HFDTE(\d{2})(\d{2})(\d{2})/;
/**
 * A regular expression matching the newline characters `\r\n`, `\r` and `\n`.
 *
 * @const
 * @type {RegExp}
 */

var NEWLINE_RE = /\r\n|\r|\n/;
/**
 * @typedef {Object} Options
 * @property {IGCZ|string} [altitudeMode='none'] Altitude mode. Possible
 * values are `'barometric'`, `'gps'`, and `'none'`.
 */

/**
 * @classdesc
 * Feature format for `*.igc` flight recording files.
 *
 * As IGC sources contain a single feature,
 * {@link module:wg/format/IGC~IGC#readFeatures} will return the feature in an
 * array
 *
 * @api
 */

var IGC =
/** @class */
function (_super) {
  __extends(IGC, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function IGC(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @type {import("../proj/Projection.js").default}
     */

    _this.dataProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:4326');
    /**
     * @private
     * @type {IGCZ}
     */

    _this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : IGCZ.NONE;
    return _this;
  }
  /**
   * @protected
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @return {import("../Feature.js").default} Feature.
   */


  IGC.prototype.readFeatureFromText = function (text, opt_options) {
    var altitudeMode = this.altitudeMode_;
    var lines = text.split(NEWLINE_RE);
    /** @type {Object<string, string>} */

    var properties = {};
    var flatCoordinates = [];
    var year = 2000;
    var month = 0;
    var day = 1;
    var lastDateTime = -1;
    var i, ii;

    for (i = 0, ii = lines.length; i < ii; ++i) {
      var line = lines[i];
      var m = void 0;

      if (line.charAt(0) == 'B') {
        m = B_RECORD_RE.exec(line);

        if (m) {
          var hour = parseInt(m[1], 10);
          var minute = parseInt(m[2], 10);
          var second = parseInt(m[3], 10);
          var y = parseInt(m[4], 10) + parseInt(m[5], 10) / 60000;

          if (m[6] == 'S') {
            y = -y;
          }

          var x = parseInt(m[7], 10) + parseInt(m[8], 10) / 60000;

          if (m[9] == 'W') {
            x = -x;
          }

          flatCoordinates.push(x, y);

          if (altitudeMode != IGCZ.NONE) {
            var z = void 0;

            if (altitudeMode == IGCZ.GPS) {
              z = parseInt(m[11], 10);
            } else if (altitudeMode == IGCZ.BAROMETRIC) {
              z = parseInt(m[12], 10);
            } else {
              z = 0;
            }

            flatCoordinates.push(z);
          }

          var dateTime = Date.UTC(year, month, day, hour, minute, second); // Detect UTC midnight wrap around.

          if (dateTime < lastDateTime) {
            dateTime = Date.UTC(year, month, day + 1, hour, minute, second);
          }

          flatCoordinates.push(dateTime / 1000);
          lastDateTime = dateTime;
        }
      } else if (line.charAt(0) == 'H') {
        m = HFDTE_RECORD_RE.exec(line);

        if (m) {
          day = parseInt(m[1], 10);
          month = parseInt(m[2], 10) - 1;
          year = 2000 + parseInt(m[3], 10);
        } else {
          m = H_RECORD_RE.exec(line);

          if (m) {
            properties[m[1]] = m[2].trim();
          }
        }
      }
    }

    if (flatCoordinates.length === 0) {
      return null;
    }

    var layout = altitudeMode == IGCZ.NONE ? _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__["default"].XYM : _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__["default"].XYZM;
    var lineString = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_2__["default"](flatCoordinates, layout);
    var feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_3__["default"]((0,_Feature_js__WEBPACK_IMPORTED_MODULE_4__.transformGeometryWithOptions)(lineString, false, opt_options));
    feature.setProperties(properties, true);
    return feature;
  };
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */


  IGC.prototype.readFeaturesFromText = function (text, opt_options) {
    var feature = this.readFeatureFromText(text, opt_options);

    if (feature) {
      return [feature];
    } else {
      return [];
    }
  };

  return IGC;
}(_TextFeature_js__WEBPACK_IMPORTED_MODULE_5__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (IGC);

/***/ }),

/***/ "./build/wg/format/IIIFInfo.js":
/*!*************************************!*\
  !*** ./build/wg/format/IIIFInfo.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Versions": function() { return /* binding */ Versions; }
/* harmony export */ });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/**
 * @module wg/format/IIIFInfo
 */
var __spreadArray = undefined && undefined.__spreadArray || function (to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};



/**
 * @typedef {Object} PreferredOptions
 * @property {string} [format] Preferred image format. Will be used if the image information
 * indicates support for that format.
 * @property {string} [quality] IIIF image qualitiy.  Will be used if the image information
 * indicates support for that quality.
 */

/**
 * @typedef {Object} SupportedFeatures
 * @property {Array<string>} [supports] Supported IIIF image size and region
 * calculation features.
 * @property {Array<string>} [formats] Supported image formats.
 * @property {Array<string>} [qualities] Supported IIIF image qualities.
 */

/**
 * @typedef {Object} TileInfo
 * @property {Array<number>} scaleFactors Supported resolution scaling factors.
 * @property {number} width Tile width in pixels.
 * @property {number} [height] Tile height in pixels. Same as tile width if height is
 * not given.
 */

/**
 * @typedef {Object} IiifProfile
 * @property {Array<string>} [formats] Supported image formats for the image service.
 * @property {Array<string>} [qualities] Supported IIIF image qualities.
 * @property {Array<string>} [supports] Supported features.
 * @property {number} [maxArea] Maximum area (pixels) available for this image service.
 * @property {number} [maxHeight] Maximum height.
 * @property {number} [maxWidth] Maximum width.
 */

/**
 * @typedef {Object<string,string|number|Array<number|string|IiifProfile|Object<string, number>|TileInfo>>}
 *    ImageInformationResponse
 */

/**
 * Enum representing the major IIIF Image API versions
 * @enum {string}
 */

var Versions = {
  VERSION1: 'version1',
  VERSION2: 'version2',
  VERSION3: 'version3'
};
/**
 * Supported image formats, qualities and supported region / size calculation features
 * for different image API versions and compliance levels
 * @const
 * @type {Object<string, Object<string, SupportedFeatures>>}
 */

var IIIF_PROFILE_VALUES = {};
IIIF_PROFILE_VALUES[Versions.VERSION1] = {
  'level0': {
    supports: [],
    formats: [],
    qualities: ['native']
  },
  'level1': {
    supports: ['regionByPx', 'sizeByW', 'sizeByH', 'sizeByPct'],
    formats: ['jpg'],
    qualities: ['native']
  },
  'level2': {
    supports: ['regionByPx', 'regionByPct', 'sizeByW', 'sizeByH', 'sizeByPct', 'sizeByConfinedWh', 'sizeByWh'],
    formats: ['jpg', 'png'],
    qualities: ['native', 'color', 'grey', 'bitonal']
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION2] = {
  'level0': {
    supports: [],
    formats: ['jpg'],
    qualities: ['default']
  },
  'level1': {
    supports: ['regionByPx', 'sizeByW', 'sizeByH', 'sizeByPct'],
    formats: ['jpg'],
    qualities: ['default']
  },
  'level2': {
    supports: ['regionByPx', 'regionByPct', 'sizeByW', 'sizeByH', 'sizeByPct', 'sizeByConfinedWh', 'sizeByDistortedWh', 'sizeByWh'],
    formats: ['jpg', 'png'],
    qualities: ['default', 'bitonal']
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION3] = {
  'level0': {
    supports: [],
    formats: ['jpg'],
    qualities: ['default']
  },
  'level1': {
    supports: ['regionByPx', 'regionSquare', 'sizeByW', 'sizeByH', 'sizeByWh'],
    formats: ['jpg'],
    qualities: ['default']
  },
  'level2': {
    supports: ['regionByPx', 'regionSquare', 'regionByPct', 'sizeByW', 'sizeByH', 'sizeByPct', 'sizeByConfinedWh', 'sizeByWh'],
    formats: ['jpg', 'png'],
    qualities: ['default']
  }
};
IIIF_PROFILE_VALUES['none'] = {
  'none': {
    supports: [],
    formats: [],
    qualities: []
  }
};
var COMPLIANCE_VERSION1 = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/;
var COMPLIANCE_VERSION2 = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/;
var COMPLIANCE_VERSION3 = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;

function generateVersion1Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(); // Version 1.0 and 1.1 do not require a profile.

  if (levelProfile === undefined) {
    levelProfile = IIIF_PROFILE_VALUES[Versions.VERSION1]['level0'];
  }

  return {
    url: iiifInfo.imageInfo['@id'] === undefined ? undefined : iiifInfo.imageInfo['@id'].replace(/\/?(?:info\.json)?$/g, ''),
    supports: levelProfile.supports,
    formats: __spreadArray(__spreadArray([], levelProfile.formats, true), [iiifInfo.imageInfo.formats === undefined ? [] : iiifInfo.imageInfo.formats], false),
    qualities: __spreadArray(__spreadArray([], levelProfile.qualities, true), [iiifInfo.imageInfo.qualities === undefined ? [] : iiifInfo.imageInfo.qualities], false),
    resolutions: iiifInfo.imageInfo.scale_factors,
    tileSize: iiifInfo.imageInfo.tile_width !== undefined ? iiifInfo.imageInfo.tile_height !== undefined ? [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_height] : [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_width] : iiifInfo.imageInfo.tile_height != undefined ? [iiifInfo.imageInfo.tile_height, iiifInfo.imageInfo.tile_height] : undefined
  };
}

function generateVersion2Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(),
      additionalProfile = Array.isArray(iiifInfo.imageInfo.profile) && iiifInfo.imageInfo.profile.length > 1,
      profileSupports = additionalProfile && iiifInfo.imageInfo.profile[1].supports ? iiifInfo.imageInfo.profile[1].supports : [],
      profileFormats = additionalProfile && iiifInfo.imageInfo.profile[1].formats ? iiifInfo.imageInfo.profile[1].formats : [],
      profileQualities = additionalProfile && iiifInfo.imageInfo.profile[1].qualities ? iiifInfo.imageInfo.profile[1].qualities : [];
  return {
    url: iiifInfo.imageInfo['@id'].replace(/\/?(?:info\.json)?$/g, ''),
    sizes: iiifInfo.imageInfo.sizes === undefined ? undefined : iiifInfo.imageInfo.sizes.map(function (size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === undefined ? undefined : [iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.width;
    })[0], iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.height === undefined ? tile.width : tile.height;
    })[0]],
    resolutions: iiifInfo.imageInfo.tiles === undefined ? undefined : iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.scaleFactors;
    })[0],
    supports: __spreadArray(__spreadArray([], levelProfile.supports, true), profileSupports, true),
    formats: __spreadArray(__spreadArray([], levelProfile.formats, true), profileFormats, true),
    qualities: __spreadArray(__spreadArray([], levelProfile.qualities, true), profileQualities, true)
  };
}

function generateVersion3Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(),
      formats = iiifInfo.imageInfo.extraFormats === undefined ? levelProfile.formats : __spreadArray(__spreadArray([], levelProfile.formats, true), iiifInfo.imageInfo.extraFormats, true),
      preferredFormat = iiifInfo.imageInfo.preferredFormats !== undefined && Array.isArray(iiifInfo.imageInfo.preferredFormats) && iiifInfo.imageInfo.preferredFormats.length > 0 ? iiifInfo.imageInfo.preferredFormats.filter(function (format) {
    return (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.includes)(['jpg', 'png', 'gif'], format);
  }).reduce(function (acc, format) {
    return acc === undefined && (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.includes)(formats, format) ? format : acc;
  }, undefined) : undefined;
  return {
    url: iiifInfo.imageInfo['id'],
    sizes: iiifInfo.imageInfo.sizes === undefined ? undefined : iiifInfo.imageInfo.sizes.map(function (size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === undefined ? undefined : [iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.width;
    })[0], iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.height;
    })[0]],
    resolutions: iiifInfo.imageInfo.tiles === undefined ? undefined : iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.scaleFactors;
    })[0],
    supports: iiifInfo.imageInfo.extraFeatures === undefined ? levelProfile.supports : __spreadArray(__spreadArray([], levelProfile.supports, true), iiifInfo.imageInfo.extraFeatures, true),
    formats: formats,
    qualities: iiifInfo.imageInfo.extraQualities === undefined ? levelProfile.qualities : __spreadArray(__spreadArray([], levelProfile.qualities, true), iiifInfo.imageInfo.extraQualities, true),
    preferredFormat: preferredFormat
  };
}

var versionFunctions = {};
versionFunctions[Versions.VERSION1] = generateVersion1Options;
versionFunctions[Versions.VERSION2] = generateVersion2Options;
versionFunctions[Versions.VERSION3] = generateVersion3Options;
/**
 * @classdesc
 * Format for transforming IIIF Image API image information responses into
 * IIIF tile source ready options
 *
 * @api
 */

var IIIFInfo =
/** @class */
function () {
  /**
   * @param {string|ImageInformationResponse} imageInfo
   * Deserialized image information JSON response object or JSON response as string
   */
  function IIIFInfo(imageInfo) {
    this.setImageInfo(imageInfo);
  }
  /**
   * @param {string|ImageInformationResponse} imageInfo
   * Deserialized image information JSON response object or JSON response as string
   * @api
   */


  IIIFInfo.prototype.setImageInfo = function (imageInfo) {
    if (typeof imageInfo == 'string') {
      this.imageInfo = JSON.parse(imageInfo);
    } else {
      this.imageInfo = imageInfo;
    }
  };
  /**
   * @return {Versions} Major IIIF version.
   * @api
   */


  IIIFInfo.prototype.getImageApiVersion = function () {
    if (this.imageInfo === undefined) {
      return;
    }

    var context = this.imageInfo['@context'] || 'wg-no-context';

    if (typeof context == 'string') {
      context = [context];
    }

    for (var i = 0; i < context.length; i++) {
      switch (context[i]) {
        case 'http://library.stanford.edu/iiif/image-api/1.1/context.json':
        case 'http://iiif.io/api/image/1/context.json':
          return Versions.VERSION1;

        case 'http://iiif.io/api/image/2/context.json':
          return Versions.VERSION2;

        case 'http://iiif.io/api/image/3/context.json':
          return Versions.VERSION3;

        case 'wg-no-context':
          // Image API 1.0 has no '@context'
          if (this.getComplianceLevelEntryFromProfile(Versions.VERSION1) && this.imageInfo.identifier) {
            return Versions.VERSION1;
          }

          break;

        default:
      }
    }

    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, 61);
  };
  /**
   * @param {Versions} version Optional IIIF image API version
   * @return {string} Compliance level as it appears in the IIIF image information
   * response.
   */


  IIIFInfo.prototype.getComplianceLevelEntryFromProfile = function (version) {
    if (this.imageInfo === undefined || this.imageInfo.profile === undefined) {
      return;
    }

    if (version === undefined) {
      version = this.getImageApiVersion();
    }

    switch (version) {
      case Versions.VERSION1:
        if (COMPLIANCE_VERSION1.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }

        break;

      case Versions.VERSION3:
        if (COMPLIANCE_VERSION3.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }

        break;

      case Versions.VERSION2:
        if (typeof this.imageInfo.profile === 'string' && COMPLIANCE_VERSION2.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }

        if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && typeof this.imageInfo.profile[0] === 'string' && COMPLIANCE_VERSION2.test(this.imageInfo.profile[0])) {
          return this.imageInfo.profile[0];
        }

        break;

      default:
    }
  };
  /**
   * @param {Versions} version Optional IIIF image API version
   * @return {string} Compliance level, on of 'level0', 'level1' or 'level2' or undefined
   */


  IIIFInfo.prototype.getComplianceLevelFromProfile = function (version) {
    var complianceLevel = this.getComplianceLevelEntryFromProfile(version);

    if (complianceLevel === undefined) {
      return undefined;
    }

    var level = complianceLevel.match(/level[0-2](?:\.json)?$/g);
    return Array.isArray(level) ? level[0].replace('.json', '') : undefined;
  };
  /**
   * @return {SupportedFeatures} Image formats, qualities and region / size calculation
   * methods that are supported by the IIIF service.
   */


  IIIFInfo.prototype.getComplianceLevelSupportedFeatures = function () {
    if (this.imageInfo === undefined) {
      return;
    }

    var version = this.getImageApiVersion();
    var level = this.getComplianceLevelFromProfile(version);

    if (level === undefined) {
      return IIIF_PROFILE_VALUES['none']['none'];
    }

    return IIIF_PROFILE_VALUES[version][level];
  };
  /**
   * @param {PreferredOptions} [opt_preferredOptions] Optional options for preferred format and quality.
   * @return {import("../source/IIIF.js").Options} IIIF tile source ready constructor options.
   * @api
   */


  IIIFInfo.prototype.getTileSourceOptions = function (opt_preferredOptions) {
    var options = opt_preferredOptions || {},
        version = this.getImageApiVersion();

    if (version === undefined) {
      return;
    }

    var imageOptions = version === undefined ? undefined : versionFunctions[version](this);

    if (imageOptions === undefined) {
      return;
    }

    return {
      url: imageOptions.url,
      version: version,
      size: [this.imageInfo.width, this.imageInfo.height],
      sizes: imageOptions.sizes,
      format: options.format !== undefined && (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.includes)(imageOptions.formats, options.format) ? options.format : imageOptions.preferredFormat !== undefined ? imageOptions.preferredFormat : 'jpg',
      supports: imageOptions.supports,
      quality: options.quality && (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.includes)(imageOptions.qualities, options.quality) ? options.quality : (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.includes)(imageOptions.qualities, 'native') ? 'native' : 'default',
      resolutions: Array.isArray(imageOptions.resolutions) ? imageOptions.resolutions.sort(function (a, b) {
        return b - a;
      }) : undefined,
      tileSize: imageOptions.tileSize
    };
  };

  return IIIFInfo;
}();

/* harmony default export */ __webpack_exports__["default"] = (IIIFInfo);

/***/ }),

/***/ "./build/wg/format/JSONFeature.js":
/*!****************************************!*\
  !*** ./build/wg/format/JSONFeature.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Feature.js */ "./build/wg/format/Feature.js");
/* harmony import */ var _FormatType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FormatType.js */ "./build/wg/format/FormatType.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/JSONFeature
 */





/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 *
 * @abstract
 */

var JSONFeature =
/** @class */
function (_super) {
  __extends(JSONFeature, _super);

  function JSONFeature() {
    return _super.call(this) || this;
  }
  /**
   * @return {import("./FormatType.js").default} Format.
   */


  JSONFeature.prototype.getType = function () {
    return _FormatType_js__WEBPACK_IMPORTED_MODULE_0__["default"].JSON;
  };
  /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */


  JSONFeature.prototype.readFeature = function (source, opt_options) {
    return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */


  JSONFeature.prototype.readFeatures = function (source, opt_options) {
    return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */


  JSONFeature.prototype.readFeatureFromObject = function (object, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */


  JSONFeature.prototype.readFeaturesFromObject = function (object, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */


  JSONFeature.prototype.readGeometry = function (source, opt_options) {
    return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */


  JSONFeature.prototype.readGeometryFromObject = function (object, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */


  JSONFeature.prototype.readProjection = function (source) {
    return this.readProjectionFromObject(getObject(source));
  };
  /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */


  JSONFeature.prototype.readProjectionFromObject = function (object) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {string} Encoded feature.
   * @api
   */


  JSONFeature.prototype.writeFeature = function (feature, opt_options) {
    return JSON.stringify(this.writeFeatureObject(feature, opt_options));
  };
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {Object} Object.
   */


  JSONFeature.prototype.writeFeatureObject = function (feature, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {string} Encoded features.
   * @api
   */


  JSONFeature.prototype.writeFeatures = function (features, opt_options) {
    return JSON.stringify(this.writeFeaturesObject(features, opt_options));
  };
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {Object} Object.
   */


  JSONFeature.prototype.writeFeaturesObject = function (features, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {string} Encoded geometry.
   * @api
   */


  JSONFeature.prototype.writeGeometry = function (geometry, opt_options) {
    return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
  };
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {Object} Object.
   */


  JSONFeature.prototype.writeGeometryObject = function (geometry, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };

  return JSONFeature;
}(_Feature_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @param {Document|Element|Object|string} source Source.
 * @return {Object} Object.
 */


function getObject(source) {
  if (typeof source === 'string') {
    var object = JSON.parse(source);
    return object ?
    /** @type {Object} */
    object : null;
  } else if (source !== null) {
    return source;
  } else {
    return null;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (JSONFeature);

/***/ }),

/***/ "./build/wg/format/KML.js":
/*!********************************!*\
  !*** ./build/wg/format/KML.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDefaultFillStyle": function() { return /* binding */ getDefaultFillStyle; },
/* harmony export */   "getDefaultImageStyle": function() { return /* binding */ getDefaultImageStyle; },
/* harmony export */   "getDefaultStrokeStyle": function() { return /* binding */ getDefaultStrokeStyle; },
/* harmony export */   "getDefaultTextStyle": function() { return /* binding */ getDefaultTextStyle; },
/* harmony export */   "getDefaultStyle": function() { return /* binding */ getDefaultStyle; },
/* harmony export */   "getDefaultStyleArray": function() { return /* binding */ getDefaultStyleArray; },
/* harmony export */   "readFlatCoordinates": function() { return /* binding */ readFlatCoordinates; }
/* harmony export */ });
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _style_Fill_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style/Fill.js */ "./build/wg/style/Fill.js");
/* harmony import */ var _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geom/GeometryCollection.js */ "./build/wg/geom/GeometryCollection.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _style_Icon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../style/Icon.js */ "./build/wg/style/Icon.js");
/* harmony import */ var _style_IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../style/IconAnchorUnits.js */ "./build/wg/style/IconAnchorUnits.js");
/* harmony import */ var _style_IconOrigin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../style/IconOrigin.js */ "./build/wg/style/IconOrigin.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../ImageState.js */ "./build/wg/ImageState.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./build/wg/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./build/wg/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./build/wg/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _style_Stroke_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../style/Stroke.js */ "./build/wg/style/Stroke.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../style/Style.js */ "./build/wg/style/Style.js");
/* harmony import */ var _style_Text_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../style/Text.js */ "./build/wg/style/Text.js");
/* harmony import */ var _XMLFeature_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./XMLFeature.js */ "./build/wg/format/XMLFeature.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../xml.js */ "./build/wg/xml.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../color.js */ "./build/wg/color.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./xsd.js */ "./build/wg/format/xsd.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Feature.js */ "./build/wg/format/Feature.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/KML
 */





























/**
 * @typedef {Object} Vec2
 * @property {number} x X coordinate.
 * @property {import("../style/IconAnchorUnits").default} xunits Units of x.
 * @property {number} y Y coordinate.
 * @property {import("../style/IconAnchorUnits").default} yunits Units of Y.
 * @property {import("../style/IconOrigin.js").default} [origin] Origin.
 */

/**
 * @typedef {Object} GxTrackObject
 * @property {Array<Array<number>>} coordinates Coordinates.
 * @property {Array<number>} whens Whens.
 */

/**
 * @const
 * @type {Array<string>}
 */

var GX_NAMESPACE_URIS = ['http://www.google.com/kml/ext/2.2'];
/**
 * @const
 * @type {Array<null|string>}
 */

var NAMESPACE_URIS = [null, 'http://earth.google.com/kml/2.0', 'http://earth.google.com/kml/2.1', 'http://earth.google.com/kml/2.2', 'http://www.opengis.net/kml/2.2'];
/**
 * @const
 * @type {string}
 */

var SCHEMA_LOCATION = 'http://www.opengis.net/kml/2.2 ' + 'https://developers.google.com/kml/schema/kml22gx.xsd';
/**
 * @type {Object<string, import("../style/IconAnchorUnits").default>}
 */

var ICON_ANCHOR_UNITS_MAP = {
  'fraction': _style_IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_1__["default"].FRACTION,
  'pixels': _style_IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_1__["default"].PIXELS,
  'insetPixels': _style_IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_1__["default"].PIXELS
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var PLACEMARK_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'ExtendedData': extendedDataParser,
  'Region': regionParser,
  'MultiGeometry': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readMultiGeometry, 'geometry'),
  'LineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readLineString, 'geometry'),
  'LinearRing': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readLinearRing, 'geometry'),
  'Point': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readPoint, 'geometry'),
  'Polygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readPolygon, 'geometry'),
  'Style': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readStyle),
  'StyleMap': placemarkStyleMapParser,
  'address': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'description': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'name': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'open': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readBoolean),
  'phoneNumber': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'styleUrl': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readStyleURL),
  'visibility': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readBoolean)
}, (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(GX_NAMESPACE_URIS, {
  'MultiTrack': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readGxMultiTrack, 'geometry'),
  'Track': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readGxTrack, 'geometry')
}));
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var NETWORK_LINK_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'ExtendedData': extendedDataParser,
  'Region': regionParser,
  'Link': linkParser,
  'address': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'description': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'name': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'open': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readBoolean),
  'phoneNumber': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'visibility': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readBoolean)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var LINK_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'href': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readURI)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var REGION_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'LatLonAltBox': latLonAltBoxParser,
  'Lod': lodParser
});
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore

var KML_SEQUENCE = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, ['Document', 'Placemark']);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore

var KML_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'Document': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeDocument),
  'Placemark': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writePlacemark)
});
/**
 * @type {import("../color.js").Color}
 */

var DEFAULT_COLOR;
/**
 * @type {Fill|null}
 */

var DEFAULT_FILL_STYLE = null;
/**
 * Get the default fill style (or null if not yet set).
 * @return {Fill|null} The default fill style.
 */

function getDefaultFillStyle() {
  return DEFAULT_FILL_STYLE;
}
/**
 * @type {import("../size.js").Size}
 */

var DEFAULT_IMAGE_STYLE_ANCHOR;
/**
 * @type {import("../style/IconAnchorUnits").default}
 */

var DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
/**
 * @type {import("../style/IconAnchorUnits").default}
 */

var DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
/**
 * @type {import("../size.js").Size}
 */

var DEFAULT_IMAGE_STYLE_SIZE;
/**
 * @type {string}
 */

var DEFAULT_IMAGE_STYLE_SRC;
/**
 * @type {import("../style/Image.js").default|null}
 */

var DEFAULT_IMAGE_STYLE = null;
/**
 * Get the default image style (or null if not yet set).
 * @return {import("../style/Image.js").default|null} The default image style.
 */

function getDefaultImageStyle() {
  return DEFAULT_IMAGE_STYLE;
}
/**
 * @type {string}
 */

var DEFAULT_NO_IMAGE_STYLE;
/**
 * @type {Stroke|null}
 */

var DEFAULT_STROKE_STYLE = null;
/**
 * Get the default stroke style (or null if not yet set).
 * @return {Stroke|null} The default stroke style.
 */

function getDefaultStrokeStyle() {
  return DEFAULT_STROKE_STYLE;
}
/**
 * @type {Stroke}
 */

var DEFAULT_TEXT_STROKE_STYLE;
/**
 * @type {Text|null}
 */

var DEFAULT_TEXT_STYLE = null;
/**
 * Get the default text style (or null if not yet set).
 * @return {Text|null} The default text style.
 */

function getDefaultTextStyle() {
  return DEFAULT_TEXT_STYLE;
}
/**
 * @type {Style|null}
 */

var DEFAULT_STYLE = null;
/**
 * Get the default style (or null if not yet set).
 * @return {Style|null} The default style.
 */

function getDefaultStyle() {
  return DEFAULT_STYLE;
}
/**
 * @type {Array<Style>|null}
 */

var DEFAULT_STYLE_ARRAY = null;
/**
 * Get the default style array (or null if not yet set).
 * @return {Array<Style>|null} The default style.
 */

function getDefaultStyleArray() {
  return DEFAULT_STYLE_ARRAY;
}
/**
 * Function that returns the scale needed to normalize an icon image to 32 pixels.
 * @param {import("../size.js").Size} size Image size.
 * @return {number} Scale.
 */

function scaleForSize(size) {
  return 32 / Math.min(size[0], size[1]);
}

function createStyleDefaults() {
  DEFAULT_COLOR = [255, 255, 255, 1];
  DEFAULT_FILL_STYLE = new _style_Fill_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
    color: DEFAULT_COLOR
  });
  DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];
  DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = _style_IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_1__["default"].PIXELS;
  DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = _style_IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_1__["default"].PIXELS;
  DEFAULT_IMAGE_STYLE_SIZE = [64, 64];
  DEFAULT_IMAGE_STYLE_SRC = 'https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png';
  DEFAULT_IMAGE_STYLE = new _style_Icon_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
    anchor: DEFAULT_IMAGE_STYLE_ANCHOR,
    anchorOrigin: _style_IconOrigin_js__WEBPACK_IMPORTED_MODULE_6__["default"].BOTTOM_LEFT,
    anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,
    anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,
    crossOrigin: 'anonymous',
    rotation: 0,
    scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),
    size: DEFAULT_IMAGE_STYLE_SIZE,
    src: DEFAULT_IMAGE_STYLE_SRC
  });
  DEFAULT_NO_IMAGE_STYLE = 'NO_IMAGE';
  DEFAULT_STROKE_STYLE = new _style_Stroke_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
    color: DEFAULT_COLOR,
    width: 1
  });
  DEFAULT_TEXT_STROKE_STYLE = new _style_Stroke_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
    color: [51, 51, 51, 1],
    width: 2
  });
  DEFAULT_TEXT_STYLE = new _style_Text_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
    font: 'bold 16px Helvetica',
    fill: DEFAULT_FILL_STYLE,
    stroke: DEFAULT_TEXT_STROKE_STYLE,
    scale: 0.8
  });
  DEFAULT_STYLE = new _style_Style_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
    fill: DEFAULT_FILL_STYLE,
    image: DEFAULT_IMAGE_STYLE,
    text: DEFAULT_TEXT_STYLE,
    stroke: DEFAULT_STROKE_STYLE,
    zIndex: 0
  });
  DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];
}
/**
 * @type {HTMLTextAreaElement}
 */


var TEXTAREA;
/**
 * A function that takes a url `{string}` and returns a url `{string}`.
 * Might be used to change an icon path or to substitute a
 * data url obtained from a KMZ array buffer.
 *
 * @typedef {function(string):string} IconUrlFunction
 * @api
 */

/**
 * Function that returns a url unchanged.
 * @param {string} href Input url.
 * @return {string} Output url.
 */

function defaultIconUrlFunction(href) {
  return href;
}
/**
 * @typedef {Object} Options
 * @property {boolean} [extractStyles=true] Extract styles from the KML.
 * @property {boolean} [showPointNames=true] Show names as labels for placemarks which contain points.
 * @property {Array<Style>} [defaultStyle] Default style. The
 * default default style is the same as Google Earth.
 * @property {boolean} [writeStyles=true] Write styles into KML.
 * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * @property {IconUrlFunction} [iconUrlFunction] Function that takes a url string and returns a url string.
 * Might be used to change an icon path or to substitute a data url obtained from a KMZ array buffer.
 */

/**
 * @classdesc
 * Feature format for reading and writing data in the KML format.
 *
 * {@link module:wg/format/KML~KML#readFeature} will read the first feature from
 * a KML source.
 *
 * MultiGeometries are converted into GeometryCollections if they are a mix of
 * geometry types, and into MultiPoint/MultiLineString/MultiPolygon if they are
 * all of the same type.
 *
 * Note that the KML format uses the URL() constructor. Older browsers such as IE
 * which do not support this will need a URL polyfill to be loaded before use.
 *
 * @api
 */


var KML =
/** @class */
function (_super) {
  __extends(KML, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function KML(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};

    if (!DEFAULT_STYLE_ARRAY) {
      createStyleDefaults();
    }
    /**
     * @type {import("../proj/Projection.js").default}
     */


    _this.dataProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:4326');
    /**
     * @private
     * @type {Array<Style>}
     */

    _this.defaultStyle_ = options.defaultStyle ? options.defaultStyle : DEFAULT_STYLE_ARRAY;
    /**
     * @private
     * @type {boolean}
     */

    _this.extractStyles_ = options.extractStyles !== undefined ? options.extractStyles : true;
    /**
     * @type {boolean}
     */

    _this.writeStyles_ = options.writeStyles !== undefined ? options.writeStyles : true;
    /**
     * @private
     * @type {!Object<string, (Array<Style>|string)>}
     */

    _this.sharedStyles_ = {};
    /**
     * @private
     * @type {boolean}
     */

    _this.showPointNames_ = options.showPointNames !== undefined ? options.showPointNames : true;
    /**
     * @type {null|string}
     */

    _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';
    /**
     * @type {IconUrlFunction}
     */

    _this.iconUrlFunction_ = options.iconUrlFunction ? options.iconUrlFunction : defaultIconUrlFunction;
    _this.supportedMediaTypes = ['application/vnd.google-earth.kml+xml'];
    return _this;
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   * @return {Array<Feature>|undefined} Features.
   */


  KML.prototype.readDocumentOrFolder_ = function (node, objectStack) {
    // FIXME use scope somehow
    var parsersNS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
      'Document': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayExtender)(this.readDocumentOrFolder_, this),
      'Folder': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayExtender)(this.readDocumentOrFolder_, this),
      'Placemark': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(this.readPlacemark_, this),
      'Style': this.readSharedStyle_.bind(this),
      'StyleMap': this.readSharedStyleMap_.bind(this)
    });
    /** @type {Array<Feature>} */
    // @ts-ignore

    var features = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([], parsersNS, node, objectStack, this);

    if (features) {
      return features;
    } else {
      return undefined;
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   * @return {Feature|undefined} Feature.
   */


  KML.prototype.readPlacemark_ = function (node, objectStack) {
    var object = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)({
      'geometry': null
    }, PLACEMARK_PARSERS, node, objectStack, this);

    if (!object) {
      return undefined;
    }

    var feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_10__["default"]();
    var id = node.getAttribute('id');

    if (id !== null) {
      feature.setId(id);
    }

    var options =
    /** @type {import("./Feature.js").ReadOptions} */
    objectStack[0];
    var geometry = object['geometry'];

    if (geometry) {
      (0,_Feature_js__WEBPACK_IMPORTED_MODULE_11__.transformGeometryWithOptions)(geometry, false, options);
    }

    feature.setGeometry(geometry);
    delete object['geometry'];

    if (this.extractStyles_) {
      var style = object['Style'];
      var styleUrl = object['styleUrl'];
      var styleFunction = createFeatureStyleFunction(style, styleUrl, this.defaultStyle_, this.sharedStyles_, this.showPointNames_);
      feature.setStyle(styleFunction);
    }

    delete object['Style']; // we do not remove the styleUrl property from the object, so it
    // gets stored on feature when setProperties is called

    feature.setProperties(object, true);
    return feature;
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   */


  KML.prototype.readSharedStyle_ = function (node, objectStack) {
    var id = node.getAttribute('id');

    if (id !== null) {
      var style = readStyle.call(this, node, objectStack);

      if (style) {
        var styleUri = void 0;
        var baseURI = node.baseURI;

        if (!baseURI || baseURI == 'about:blank') {
          baseURI = window.location.href;
        }

        if (baseURI) {
          var url = new URL('#' + id, baseURI);
          styleUri = url.href;
        } else {
          styleUri = '#' + id;
        }

        this.sharedStyles_[styleUri] = style;
      }
    }
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   */


  KML.prototype.readSharedStyleMap_ = function (node, objectStack) {
    var id = node.getAttribute('id');

    if (id === null) {
      return;
    }

    var styleMapValue = readStyleMapValue.call(this, node, objectStack);

    if (!styleMapValue) {
      return;
    }

    var styleUri;
    var baseURI = node.baseURI;

    if (!baseURI || baseURI == 'about:blank') {
      baseURI = window.location.href;
    }

    if (baseURI) {
      var url = new URL('#' + id, baseURI);
      styleUri = url.href;
    } else {
      styleUri = '#' + id;
    }

    this.sharedStyles_[styleUri] = styleMapValue;
  };
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @return {import("../Feature.js").default} Feature.
   */


  KML.prototype.readFeatureFromNode = function (node, opt_options) {
    if (!(0,_array_js__WEBPACK_IMPORTED_MODULE_12__.includes)(NAMESPACE_URIS, node.namespaceURI)) {
      return null;
    }

    var feature = this.readPlacemark_(node, [this.getReadOptions(node, opt_options)]);

    if (feature) {
      return feature;
    } else {
      return null;
    }
  };
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */


  KML.prototype.readFeaturesFromNode = function (node, opt_options) {
    if (!(0,_array_js__WEBPACK_IMPORTED_MODULE_12__.includes)(NAMESPACE_URIS, node.namespaceURI)) {
      return [];
    }

    var features;
    var localName = node.localName;

    if (localName == 'Document' || localName == 'Folder') {
      features = this.readDocumentOrFolder_(node, [this.getReadOptions(node, opt_options)]);

      if (features) {
        return features;
      } else {
        return [];
      }
    } else if (localName == 'Placemark') {
      var feature = this.readPlacemark_(node, [this.getReadOptions(node, opt_options)]);

      if (feature) {
        return [feature];
      } else {
        return [];
      }
    } else if (localName == 'kml') {
      features = [];

      for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
        var fs = this.readFeaturesFromNode(n, opt_options);

        if (fs) {
          (0,_array_js__WEBPACK_IMPORTED_MODULE_12__.extend)(features, fs);
        }
      }

      return features;
    } else {
      return [];
    }
  };
  /**
   * Read the name of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {string|undefined} Name.
   * @api
   */


  KML.prototype.readName = function (source) {
    if (!source) {
      return undefined;
    } else if (typeof source === 'string') {
      var doc = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.parse)(source);
      return this.readNameFromDocument(doc);
    } else if ((0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.isDocument)(source)) {
      return this.readNameFromDocument(
      /** @type {Document} */
      source);
    } else {
      return this.readNameFromNode(
      /** @type {Element} */
      source);
    }
  };
  /**
   * @param {Document} doc Document.
   * @return {string|undefined} Name.
   */


  KML.prototype.readNameFromDocument = function (doc) {
    for (var n =
    /** @type {Node} */
    doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        var name_1 = this.readNameFromNode(
        /** @type {Element} */
        n);

        if (name_1) {
          return name_1;
        }
      }
    }

    return undefined;
  };
  /**
   * @param {Element} node Node.
   * @return {string|undefined} Name.
   */


  KML.prototype.readNameFromNode = function (node) {
    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
      if ((0,_array_js__WEBPACK_IMPORTED_MODULE_12__.includes)(NAMESPACE_URIS, n.namespaceURI) && n.localName == 'name') {
        return (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString)(n);
      }
    }

    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
      var localName = n.localName;

      if ((0,_array_js__WEBPACK_IMPORTED_MODULE_12__.includes)(NAMESPACE_URIS, n.namespaceURI) && (localName == 'Document' || localName == 'Folder' || localName == 'Placemark' || localName == 'kml')) {
        var name_2 = this.readNameFromNode(n);

        if (name_2) {
          return name_2;
        }
      }
    }

    return undefined;
  };
  /**
   * Read the network links of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<Object>} Network links.
   * @api
   */


  KML.prototype.readNetworkLinks = function (source) {
    var networkLinks = [];

    if (typeof source === 'string') {
      var doc = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.parse)(source);
      (0,_array_js__WEBPACK_IMPORTED_MODULE_12__.extend)(networkLinks, this.readNetworkLinksFromDocument(doc));
    } else if ((0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.isDocument)(source)) {
      (0,_array_js__WEBPACK_IMPORTED_MODULE_12__.extend)(networkLinks, this.readNetworkLinksFromDocument(
      /** @type {Document} */
      source));
    } else {
      (0,_array_js__WEBPACK_IMPORTED_MODULE_12__.extend)(networkLinks, this.readNetworkLinksFromNode(
      /** @type {Element} */
      source));
    }

    return networkLinks;
  };
  /**
   * @param {Document} doc Document.
   * @return {Array<Object>} Network links.
   */


  KML.prototype.readNetworkLinksFromDocument = function (doc) {
    var networkLinks = [];

    for (var n =
    /** @type {Node} */
    doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        (0,_array_js__WEBPACK_IMPORTED_MODULE_12__.extend)(networkLinks, this.readNetworkLinksFromNode(
        /** @type {Element} */
        n));
      }
    }

    return networkLinks;
  };
  /**
   * @param {Element} node Node.
   * @return {Array<Object>} Network links.
   */


  KML.prototype.readNetworkLinksFromNode = function (node) {
    var networkLinks = [];

    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
      if ((0,_array_js__WEBPACK_IMPORTED_MODULE_12__.includes)(NAMESPACE_URIS, n.namespaceURI) && n.localName == 'NetworkLink') {
        var obj = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)({}, NETWORK_LINK_PARSERS, n, []);
        networkLinks.push(obj);
      }
    }

    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
      var localName = n.localName;

      if ((0,_array_js__WEBPACK_IMPORTED_MODULE_12__.includes)(NAMESPACE_URIS, n.namespaceURI) && (localName == 'Document' || localName == 'Folder' || localName == 'kml')) {
        (0,_array_js__WEBPACK_IMPORTED_MODULE_12__.extend)(networkLinks, this.readNetworkLinksFromNode(n));
      }
    }

    return networkLinks;
  };
  /**
   * Read the regions of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<Object>} Regions.
   * @api
   */


  KML.prototype.readRegion = function (source) {
    var regions = [];

    if (typeof source === 'string') {
      var doc = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.parse)(source);
      (0,_array_js__WEBPACK_IMPORTED_MODULE_12__.extend)(regions, this.readRegionFromDocument(doc));
    } else if ((0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.isDocument)(source)) {
      (0,_array_js__WEBPACK_IMPORTED_MODULE_12__.extend)(regions, this.readRegionFromDocument(
      /** @type {Document} */
      source));
    } else {
      (0,_array_js__WEBPACK_IMPORTED_MODULE_12__.extend)(regions, this.readRegionFromNode(
      /** @type {Element} */
      source));
    }

    return regions;
  };
  /**
   * @param {Document} doc Document.
   * @return {Array<Object>} Region.
   */


  KML.prototype.readRegionFromDocument = function (doc) {
    var regions = [];

    for (var n =
    /** @type {Node} */
    doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        (0,_array_js__WEBPACK_IMPORTED_MODULE_12__.extend)(regions, this.readRegionFromNode(
        /** @type {Element} */
        n));
      }
    }

    return regions;
  };
  /**
   * @param {Element} node Node.
   * @return {Array<Object>} Region.
   * @api
   */


  KML.prototype.readRegionFromNode = function (node) {
    var regions = [];

    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
      if ((0,_array_js__WEBPACK_IMPORTED_MODULE_12__.includes)(NAMESPACE_URIS, n.namespaceURI) && n.localName == 'Region') {
        var obj = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)({}, REGION_PARSERS, n, []);
        regions.push(obj);
      }
    }

    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
      var localName = n.localName;

      if ((0,_array_js__WEBPACK_IMPORTED_MODULE_12__.includes)(NAMESPACE_URIS, n.namespaceURI) && (localName == 'Document' || localName == 'Folder' || localName == 'kml')) {
        (0,_array_js__WEBPACK_IMPORTED_MODULE_12__.extend)(regions, this.readRegionFromNode(n));
      }
    }

    return regions;
  };
  /**
   * Encode an array of features in the KML format as an XML node. GeometryCollections,
   * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.
   *
   * @param {Array<Feature>} features Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Options.
   * @return {Node} Node.
   * @api
   */


  KML.prototype.writeFeaturesNode = function (features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var kml = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(NAMESPACE_URIS[4], 'kml');
    var xmlnsUri = 'http://www.w3.org/2000/xmlns/';
    kml.setAttributeNS(xmlnsUri, 'xmlns:gx', GX_NAMESPACE_URIS[0]);
    kml.setAttributeNS(xmlnsUri, 'xmlns:xsi', _xml_js__WEBPACK_IMPORTED_MODULE_2__.XML_SCHEMA_INSTANCE_URI);
    kml.setAttributeNS(_xml_js__WEBPACK_IMPORTED_MODULE_2__.XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', SCHEMA_LOCATION);
    var
    /** @type {import("../xml.js").NodeStackItem} */
    context = {
      node: kml
    };
    /** @type {!Object<string, (Array<Feature>|Feature|undefined)>} */

    var properties = {};

    if (features.length > 1) {
      properties['Document'] = features;
    } else if (features.length == 1) {
      properties['Placemark'] = features[0];
    }

    var orderedKeys = KML_SEQUENCE[kml.namespaceURI];
    var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSequence)(properties, orderedKeys);
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, KML_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_2__.OBJECT_PROPERTY_NODE_FACTORY, values, [opt_options], orderedKeys, this);
    return kml;
  };

  return KML;
}(_XMLFeature_js__WEBPACK_IMPORTED_MODULE_13__["default"]);
/**
 * @param {Style|undefined} foundStyle Style.
 * @param {string} name Name.
 * @return {Style} style Style.
 */


function createNameStyleFunction(foundStyle, name) {
  var textOffset = [0, 0];
  var textAlign = 'start';
  var imageStyle = foundStyle.getImage();

  if (imageStyle) {
    var imageSize = imageStyle.getSize();

    if (imageSize && imageSize.length == 2) {
      var imageScale = imageStyle.getScaleArray();
      var anchor = imageStyle.getAnchor(); // Offset the label to be centered to the right of the icon,
      // if there is one.

      textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);
      textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);
      textAlign = 'left';
    }
  }

  var textStyle = foundStyle.getText();

  if (textStyle) {
    // clone the text style, customizing it with name, alignments and offset.
    // Note that kml does not support many text options that OpenLayers does (rotation, textBaseline).
    textStyle = textStyle.clone();
    textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());
    textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());
    textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());
    textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);
  } else {
    textStyle = DEFAULT_TEXT_STYLE.clone();
  }

  textStyle.setText(name);
  textStyle.setOffsetX(textOffset[0]);
  textStyle.setOffsetY(textOffset[1]);
  textStyle.setTextAlign(textAlign);
  var nameStyle = new _style_Style_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
    image: imageStyle,
    text: textStyle
  });
  return nameStyle;
}
/**
 * @param {Array<Style>|undefined} style Style.
 * @param {string} styleUrl Style URL.
 * @param {Array<Style>} defaultStyle Default style.
 * @param {!Object<string, (Array<Style>|string)>} sharedStyles Shared styles.
 * @param {boolean|undefined} showPointNames true to show names for point placemarks.
 * @return {import("../style/Style.js").StyleFunction} Feature style function.
 */


function createFeatureStyleFunction(style, styleUrl, defaultStyle, sharedStyles, showPointNames) {
  return (
    /**
     * @param {Feature} feature feature.
     * @param {number} resolution Resolution.
     * @return {Array<Style>|Style} Style.
     */
    function (feature, resolution) {
      var drawName = showPointNames;
      var name = '';
      var multiGeometryPoints = [];

      if (drawName) {
        var geometry = feature.getGeometry();

        if (geometry) {
          if (geometry instanceof _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_14__["default"]) {
            multiGeometryPoints = geometry.getGeometriesArrayRecursive().filter(function (geometry) {
              var type = geometry.getType();
              return type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POINT || type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POINT;
            });
            drawName = multiGeometryPoints.length > 0;
          } else {
            var type = geometry.getType();
            drawName = type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POINT || type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POINT;
          }
        }
      }

      if (drawName) {
        name =
        /** @type {string} */
        feature.get('name');
        drawName = drawName && !!name; // convert any html character codes

        if (drawName && name.search(/&[^&]+;/) > -1) {
          if (!TEXTAREA) {
            TEXTAREA = document.createElement('textarea');
          }

          TEXTAREA.innerHTML = name;
          name = TEXTAREA.value;
        }
      }

      var featureStyle = defaultStyle;

      if (style) {
        featureStyle = style;
      } else if (styleUrl) {
        featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);
      }

      if (drawName) {
        var nameStyle = createNameStyleFunction(featureStyle[0], name);

        if (multiGeometryPoints.length > 0) {
          // in multigeometries restrict the name style to points and create a
          // style without image or text for geometries requiring fill or stroke
          // including any polygon specific style if there is one
          nameStyle.setGeometry(new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_14__["default"](multiGeometryPoints));
          var baseStyle = new _style_Style_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
            geometry: featureStyle[0].getGeometry(),
            image: null,
            fill: featureStyle[0].getFill(),
            stroke: featureStyle[0].getStroke(),
            text: null
          });
          return [nameStyle, baseStyle].concat(featureStyle.slice(1));
        }

        return nameStyle;
      }

      return featureStyle;
    }
  );
}
/**
 * @param {Array<Style>|string|undefined} styleValue Style value.
 * @param {Array<Style>} defaultStyle Default style.
 * @param {!Object<string, (Array<Style>|string)>} sharedStyles
 * Shared styles.
 * @return {Array<Style>} Style.
 */


function findStyle(styleValue, defaultStyle, sharedStyles) {
  if (Array.isArray(styleValue)) {
    return styleValue;
  } else if (typeof styleValue === 'string') {
    return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);
  } else {
    return defaultStyle;
  }
}
/**
 * @param {Node} node Node.
 * @return {import("../color.js").Color|undefined} Color.
 */


function readColor(node) {
  var s = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.getAllTextContent)(node, false); // The KML specification states that colors should not include a leading `#`
  // but we tolerate them.

  var m = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(s);

  if (m) {
    var hexColor = m[1];
    return [parseInt(hexColor.substr(6, 2), 16), parseInt(hexColor.substr(4, 2), 16), parseInt(hexColor.substr(2, 2), 16), parseInt(hexColor.substr(0, 2), 16) / 255];
  } else {
    return undefined;
  }
}
/**
 * @param {Node} node Node.
 * @return {Array<number>|undefined} Flat coordinates.
 */


function readFlatCoordinates(node) {
  var s = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.getAllTextContent)(node, false);
  var flatCoordinates = []; // The KML specification states that coordinate tuples should not include
  // spaces, but we tolerate them.

  s = s.replace(/\s*,\s*/g, ',');
  var re = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
  var m;

  while (m = re.exec(s)) {
    var x = parseFloat(m[1]);
    var y = parseFloat(m[2]);
    var z = m[3] ? parseFloat(m[3]) : 0;
    flatCoordinates.push(x, y, z);
    s = s.substr(m[0].length);
  }

  if (s !== '') {
    return undefined;
  }

  return flatCoordinates;
}
/**
 * @param {Node} node Node.
 * @return {string} URI.
 */

function readURI(node) {
  var s = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.getAllTextContent)(node, false).trim();
  var baseURI = node.baseURI;

  if (!baseURI || baseURI == 'about:blank') {
    baseURI = window.location.href;
  }

  if (baseURI) {
    var url = new URL(s, baseURI);
    return url.href;
  } else {
    return s;
  }
}
/**
 * @param {Node} node Node.
 * @return {string} URI.
 */


function readStyleURL(node) {
  // KML files in the wild occasionally forget the leading
  // `#` on styleUrlsdefined in the same document.
  var s = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.getAllTextContent)(node, false).trim().replace(/^(?!.*#)/, '#');
  var baseURI = node.baseURI;

  if (!baseURI || baseURI == 'about:blank') {
    baseURI = window.location.href;
  }

  if (baseURI) {
    var url = new URL(s, baseURI);
    return url.href;
  } else {
    return s;
  }
}
/**
 * @param {Element} node Node.
 * @return {Vec2} Vec2.
 */


function readVec2(node) {
  var xunits = node.getAttribute('xunits');
  var yunits = node.getAttribute('yunits');
  var origin;

  if (xunits !== 'insetPixels') {
    if (yunits !== 'insetPixels') {
      origin = _style_IconOrigin_js__WEBPACK_IMPORTED_MODULE_6__["default"].BOTTOM_LEFT;
    } else {
      origin = _style_IconOrigin_js__WEBPACK_IMPORTED_MODULE_6__["default"].TOP_LEFT;
    }
  } else {
    if (yunits !== 'insetPixels') {
      origin = _style_IconOrigin_js__WEBPACK_IMPORTED_MODULE_6__["default"].BOTTOM_RIGHT;
    } else {
      origin = _style_IconOrigin_js__WEBPACK_IMPORTED_MODULE_6__["default"].TOP_RIGHT;
    }
  }

  return {
    x: parseFloat(node.getAttribute('x')),
    xunits: ICON_ANCHOR_UNITS_MAP[xunits],
    y: parseFloat(node.getAttribute('y')),
    yunits: ICON_ANCHOR_UNITS_MAP[yunits],
    origin: origin
  };
}
/**
 * @param {Node} node Node.
 * @return {number|undefined} Scale.
 */


function readScale(node) {
  return (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal)(node);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var STYLE_MAP_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'Pair': pairDataParser
});
/**
 * @this {KML}
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<Style>|string|undefined} StyleMap.
 */

function readStyleMapValue(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)(undefined, STYLE_MAP_PARSERS, node, objectStack, this);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var ICON_STYLE_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'Icon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readIcon),
  'color': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readColor),
  'heading': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal),
  'hotSpot': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readVec2),
  'scale': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readScale)
});
/**
 * @this {KML}
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */

function iconStyleParser(node, objectStack) {
  // FIXME refreshMode
  // FIXME refreshInterval
  // FIXME viewRefreshTime
  // FIXME viewBoundScale
  // FIXME viewFormat
  // FIXME httpQuery
  var object = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)({}, ICON_STYLE_PARSERS, node, objectStack);

  if (!object) {
    return;
  }

  var styleObject =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var IconObject = 'Icon' in object ? object['Icon'] : {};
  var drawIcon = !('Icon' in object) || Object.keys(IconObject).length > 0;
  var src;
  var href =
  /** @type {string|undefined} */
  IconObject['href'];

  if (href) {
    src = href;
  } else if (drawIcon) {
    src = DEFAULT_IMAGE_STYLE_SRC;
  }

  var anchor, anchorXUnits, anchorYUnits;
  var anchorOrigin = _style_IconOrigin_js__WEBPACK_IMPORTED_MODULE_6__["default"].BOTTOM_LEFT;
  var hotSpot =
  /** @type {Vec2|undefined} */
  object['hotSpot'];

  if (hotSpot) {
    anchor = [hotSpot.x, hotSpot.y];
    anchorXUnits = hotSpot.xunits;
    anchorYUnits = hotSpot.yunits;
    anchorOrigin = hotSpot.origin;
  } else if (/^http:\/\/maps\.(?:google|gstatic)\.com\//.test(src)) {
    // Google hotspots from https://kml4earth.appspot.com/icons.html#notes
    if (/pushpin/.test(src)) {
      anchor = DEFAULT_IMAGE_STYLE_ANCHOR;
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    } else if (/arrow-reverse/.test(src)) {
      anchor = [54, 42];
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    } else if (/paddle/.test(src)) {
      anchor = [32, 1];
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    }
  }

  var offset;
  var x =
  /** @type {number|undefined} */
  IconObject['x'];
  var y =
  /** @type {number|undefined} */
  IconObject['y'];

  if (x !== undefined && y !== undefined) {
    offset = [x, y];
  }

  var size;
  var w =
  /** @type {number|undefined} */
  IconObject['w'];
  var h =
  /** @type {number|undefined} */
  IconObject['h'];

  if (w !== undefined && h !== undefined) {
    size = [w, h];
  }

  var rotation;
  var heading =
  /** @type {number} */
  object['heading'];

  if (heading !== undefined) {
    rotation = (0,_math_js__WEBPACK_IMPORTED_MODULE_16__.toRadians)(heading);
  }

  var scale =
  /** @type {number|undefined} */
  object['scale'];
  var color =
  /** @type {Array<number>|undefined} */
  object['color'];

  if (drawIcon) {
    if (src == DEFAULT_IMAGE_STYLE_SRC) {
      size = DEFAULT_IMAGE_STYLE_SIZE;
    }

    var imageStyle_1 = new _style_Icon_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
      anchor: anchor,
      anchorOrigin: anchorOrigin,
      anchorXUnits: anchorXUnits,
      anchorYUnits: anchorYUnits,
      crossOrigin: this.crossOrigin_,
      offset: offset,
      offsetOrigin: _style_IconOrigin_js__WEBPACK_IMPORTED_MODULE_6__["default"].BOTTOM_LEFT,
      rotation: rotation,
      scale: scale,
      size: size,
      src: this.iconUrlFunction_(src),
      color: color
    });
    var imageScale_1 = imageStyle_1.getScaleArray()[0];
    var imageSize = imageStyle_1.getSize();

    if (imageSize === null) {
      var imageState = imageStyle_1.getImageState();

      if (imageState === _ImageState_js__WEBPACK_IMPORTED_MODULE_17__["default"].IDLE || imageState === _ImageState_js__WEBPACK_IMPORTED_MODULE_17__["default"].LOADING) {
        var listener_1 = function listener_1() {
          var imageState = imageStyle_1.getImageState();

          if (!(imageState === _ImageState_js__WEBPACK_IMPORTED_MODULE_17__["default"].IDLE || imageState === _ImageState_js__WEBPACK_IMPORTED_MODULE_17__["default"].LOADING)) {
            var imageSize_1 = imageStyle_1.getSize();

            if (imageSize_1 && imageSize_1.length == 2) {
              var resizeScale = scaleForSize(imageSize_1);
              imageStyle_1.setScale(imageScale_1 * resizeScale);
            }

            imageStyle_1.unlistenImageChange(listener_1);
          }
        };

        imageStyle_1.listenImageChange(listener_1);

        if (imageState === _ImageState_js__WEBPACK_IMPORTED_MODULE_17__["default"].IDLE) {
          imageStyle_1.load();
        }
      }
    } else if (imageSize.length == 2) {
      var resizeScale = scaleForSize(imageSize);
      imageStyle_1.setScale(imageScale_1 * resizeScale);
    }

    styleObject['imageStyle'] = imageStyle_1;
  } else {
    // handle the case when we explicitly want to draw no icon.
    styleObject['imageStyle'] = DEFAULT_NO_IMAGE_STYLE;
  }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var LABEL_STYLE_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'color': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readColor),
  'scale': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readScale)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */

function labelStyleParser(node, objectStack) {
  // FIXME colorMode
  var object = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)({}, LABEL_STYLE_PARSERS, node, objectStack);

  if (!object) {
    return;
  }

  var styleObject = objectStack[objectStack.length - 1];
  var textStyle = new _style_Text_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
    fill: new _style_Fill_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
      color:
      /** @type {import("../color.js").Color} */
      'color' in object ? object['color'] : DEFAULT_COLOR
    }),
    scale:
    /** @type {number|undefined} */
    object['scale']
  });
  styleObject['textStyle'] = textStyle;
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var LINE_STYLE_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'color': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readColor),
  'width': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */

function lineStyleParser(node, objectStack) {
  // FIXME colorMode
  // FIXME gx:outerColor
  // FIXME gx:outerWidth
  // FIXME gx:physicalWidth
  // FIXME gx:labelVisibility
  var object = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)({}, LINE_STYLE_PARSERS, node, objectStack);

  if (!object) {
    return;
  }

  var styleObject = objectStack[objectStack.length - 1];
  var strokeStyle = new _style_Stroke_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
    color:
    /** @type {import("../color.js").Color} */
    'color' in object ? object['color'] : DEFAULT_COLOR,
    width:
    /** @type {number} */
    'width' in object ? object['width'] : 1
  });
  styleObject['strokeStyle'] = strokeStyle;
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var POLY_STYLE_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'color': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readColor),
  'fill': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readBoolean),
  'outline': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readBoolean)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */

function polyStyleParser(node, objectStack) {
  // FIXME colorMode
  var object = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)({}, POLY_STYLE_PARSERS, node, objectStack);

  if (!object) {
    return;
  }

  var styleObject = objectStack[objectStack.length - 1];
  var fillStyle = new _style_Fill_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
    color:
    /** @type {import("../color.js").Color} */
    'color' in object ? object['color'] : DEFAULT_COLOR
  });
  styleObject['fillStyle'] = fillStyle;
  var fill =
  /** @type {boolean|undefined} */
  object['fill'];

  if (fill !== undefined) {
    styleObject['fill'] = fill;
  }

  var outline =
  /** @type {boolean|undefined} */
  object['outline'];

  if (outline !== undefined) {
    styleObject['outline'] = outline;
  }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var FLAT_LINEAR_RING_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'coordinates': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(readFlatCoordinates)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<number>} LinearRing flat coordinates.
 */

function readFlatLinearRing(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)(null, FLAT_LINEAR_RING_PARSERS, node, objectStack);
}
/**
 * @param {Node} node Node.
 * @param {Array<*>} objectStack Object stack.
 */


function gxCoordParser(node, objectStack) {
  var gxTrackObject =
  /** @type {GxTrackObject} */
  objectStack[objectStack.length - 1];
  var coordinates = gxTrackObject.coordinates;
  var s = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.getAllTextContent)(node, false);
  var re = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i;
  var m = re.exec(s);

  if (m) {
    var x = parseFloat(m[1]);
    var y = parseFloat(m[2]);
    var z = parseFloat(m[3]);
    coordinates.push([x, y, z]);
  } else {
    coordinates.push([]);
  }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var GX_MULTITRACK_GEOMETRY_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(GX_NAMESPACE_URIS, {
  'Track': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(readGxTrack)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {MultiLineString|undefined} MultiLineString.
 */

function readGxMultiTrack(node, objectStack) {
  var lineStrings = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([], GX_MULTITRACK_GEOMETRY_PARSERS, node, objectStack);

  if (!lineStrings) {
    return undefined;
  }

  return new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_18__["default"](lineStrings);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var GX_TRACK_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'when': whenParser
}, (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(GX_NAMESPACE_URIS, {
  'coord': gxCoordParser
}));
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {LineString|undefined} LineString.
 */

function readGxTrack(node, objectStack) {
  var gxTrackObject = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)(
  /** @type {GxTrackObject} */
  {
    coordinates: [],
    whens: []
  }, GX_TRACK_PARSERS, node, objectStack);

  if (!gxTrackObject) {
    return undefined;
  }

  var flatCoordinates = [];
  var coordinates = gxTrackObject.coordinates;
  var whens = gxTrackObject.whens;

  for (var i = 0, ii = Math.min(coordinates.length, whens.length); i < ii; ++i) {
    if (coordinates[i].length == 3) {
      flatCoordinates.push(coordinates[i][0], coordinates[i][1], coordinates[i][2], whens[i]);
    }
  }

  return new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_19__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_20__["default"].XYZM);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var ICON_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'href': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readURI)
}, (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(GX_NAMESPACE_URIS, {
  'x': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal),
  'y': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal),
  'w': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal),
  'h': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal)
}));
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object} Icon object.
 */

function readIcon(node, objectStack) {
  var iconObject = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)({}, ICON_PARSERS, node, objectStack);

  if (iconObject) {
    return iconObject;
  } else {
    return null;
  }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var GEOMETRY_FLAT_COORDINATES_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'coordinates': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(readFlatCoordinates)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<number>} Flat coordinates.
 */

function readFlatCoordinatesFromNode(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)(null, GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var EXTRUDE_AND_ALTITUDE_MODE_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'extrude': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readBoolean),
  'tessellate': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readBoolean),
  'altitudeMode': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {LineString|undefined} LineString.
 */

function readLineString(node, objectStack) {
  var properties = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
  var flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);

  if (flatCoordinates) {
    var lineString = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_19__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_20__["default"].XYZ);
    lineString.setProperties(properties, true);
    return lineString;
  } else {
    return undefined;
  }
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Polygon|undefined} Polygon.
 */


function readLinearRing(node, objectStack) {
  var properties = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
  var flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);

  if (flatCoordinates) {
    var polygon = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_21__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_20__["default"].XYZ, [flatCoordinates.length]);
    polygon.setProperties(properties, true);
    return polygon;
  } else {
    return undefined;
  }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var MULTI_GEOMETRY_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'LineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(readLineString),
  'LinearRing': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(readLinearRing),
  'MultiGeometry': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(readMultiGeometry),
  'Point': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(readPoint),
  'Polygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(readPolygon)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */

function readMultiGeometry(node, objectStack) {
  var geometries = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([], MULTI_GEOMETRY_PARSERS, node, objectStack);

  if (!geometries) {
    return null;
  }

  if (geometries.length === 0) {
    return new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_14__["default"](geometries);
  }

  var multiGeometry;
  var homogeneous = true;
  var type = geometries[0].getType();
  var geometry;

  for (var i = 1, ii = geometries.length; i < ii; ++i) {
    geometry = geometries[i];

    if (geometry.getType() != type) {
      homogeneous = false;
      break;
    }
  }

  if (homogeneous) {
    var layout = void 0;
    var flatCoordinates = void 0;

    if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POINT) {
      var point = geometries[0];
      layout = point.getLayout();
      flatCoordinates = point.getFlatCoordinates();

      for (var i = 1, ii = geometries.length; i < ii; ++i) {
        geometry = geometries[i];
        (0,_array_js__WEBPACK_IMPORTED_MODULE_12__.extend)(flatCoordinates, geometry.getFlatCoordinates());
      }

      multiGeometry = new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_22__["default"](flatCoordinates, layout);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].LINE_STRING) {
      multiGeometry = new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_18__["default"](geometries);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POLYGON) {
      multiGeometry = new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_23__["default"](geometries);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].GEOMETRY_COLLECTION) {
      multiGeometry = new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_14__["default"](geometries);
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_24__.assert)(false, 37); // Unknown geometry type found
    }
  } else {
    multiGeometry = new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_14__["default"](geometries);
  }

  return (
    /** @type {import("../geom/Geometry.js").default} */
    multiGeometry
  );
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Point|undefined} Point.
 */


function readPoint(node, objectStack) {
  var properties = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
  var flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);

  if (flatCoordinates) {
    var point = new _geom_Point_js__WEBPACK_IMPORTED_MODULE_25__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_20__["default"].XYZ);
    point.setProperties(properties, true);
    return point;
  } else {
    return undefined;
  }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var FLAT_LINEAR_RINGS_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'innerBoundaryIs': innerBoundaryIsParser,
  'outerBoundaryIs': outerBoundaryIsParser
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Polygon|undefined} Polygon.
 */

function readPolygon(node, objectStack) {
  var properties = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)(
  /** @type {Object<string,*>} */
  {}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
  var flatLinearRings = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([null], FLAT_LINEAR_RINGS_PARSERS, node, objectStack);

  if (flatLinearRings && flatLinearRings[0]) {
    var flatCoordinates = flatLinearRings[0];
    var ends = [flatCoordinates.length];

    for (var i = 1, ii = flatLinearRings.length; i < ii; ++i) {
      (0,_array_js__WEBPACK_IMPORTED_MODULE_12__.extend)(flatCoordinates, flatLinearRings[i]);
      ends.push(flatCoordinates.length);
    }

    var polygon = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_21__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_20__["default"].XYZ, ends);
    polygon.setProperties(properties, true);
    return polygon;
  } else {
    return undefined;
  }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var STYLE_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'IconStyle': iconStyleParser,
  'LabelStyle': labelStyleParser,
  'LineStyle': lineStyleParser,
  'PolyStyle': polyStyleParser
});
/**
 * @this {KML}
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<Style>} Style.
 */

function readStyle(node, objectStack) {
  var styleObject = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)({}, STYLE_PARSERS, node, objectStack, this);

  if (!styleObject) {
    return null;
  }

  var fillStyle =
  /** @type {Fill} */
  'fillStyle' in styleObject ? styleObject['fillStyle'] : DEFAULT_FILL_STYLE;
  var fill =
  /** @type {boolean|undefined} */
  styleObject['fill'];

  if (fill !== undefined && !fill) {
    fillStyle = null;
  }

  var imageStyle;

  if ('imageStyle' in styleObject) {
    if (styleObject['imageStyle'] != DEFAULT_NO_IMAGE_STYLE) {
      imageStyle = styleObject['imageStyle'];
    }
  } else {
    imageStyle = DEFAULT_IMAGE_STYLE;
  }

  var textStyle =
  /** @type {Text} */
  'textStyle' in styleObject ? styleObject['textStyle'] : DEFAULT_TEXT_STYLE;
  var strokeStyle =
  /** @type {Stroke} */
  'strokeStyle' in styleObject ? styleObject['strokeStyle'] : DEFAULT_STROKE_STYLE;
  var outline =
  /** @type {boolean|undefined} */
  styleObject['outline'];

  if (outline !== undefined && !outline) {
    // if the polystyle specifies no outline two styles are needed,
    // one for non-polygon geometries where linestrings require a stroke
    // and one for polygons where there should be no stroke
    return [new _style_Style_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
      geometry: function geometry(feature) {
        var geometry = feature.getGeometry();
        var type = geometry.getType();

        if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].GEOMETRY_COLLECTION) {
          var collection =
          /** @type {import("../geom/GeometryCollection").default} */
          geometry;
          return new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_14__["default"](collection.getGeometriesArrayRecursive().filter(function (geometry) {
            var type = geometry.getType();
            return type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POLYGON && type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POLYGON;
          }));
        } else if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POLYGON && type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POLYGON) {
          return geometry;
        }
      },
      fill: fillStyle,
      image: imageStyle,
      stroke: strokeStyle,
      text: textStyle,
      zIndex: undefined // FIXME

    }), new _style_Style_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
      geometry: function geometry(feature) {
        var geometry = feature.getGeometry();
        var type = geometry.getType();

        if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].GEOMETRY_COLLECTION) {
          var collection =
          /** @type {import("../geom/GeometryCollection").default} */
          geometry;
          return new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_14__["default"](collection.getGeometriesArrayRecursive().filter(function (geometry) {
            var type = geometry.getType();
            return type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POLYGON || type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POLYGON;
          }));
        } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POLYGON || type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POLYGON) {
          return geometry;
        }
      },
      fill: fillStyle,
      stroke: null,
      zIndex: undefined // FIXME

    })];
  }

  return [new _style_Style_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
    fill: fillStyle,
    image: imageStyle,
    stroke: strokeStyle,
    text: textStyle,
    zIndex: undefined // FIXME

  })];
}
/**
 * Reads an array of geometries and creates arrays for common geometry
 * properties. Then sets them to the multi geometry.
 * @param {MultiPoint|MultiLineString|MultiPolygon} multiGeometry A multi-geometry.
 * @param {Array<import("../geom/Geometry.js").default>} geometries List of geometries.
 */


function setCommonGeometryProperties(multiGeometry, geometries) {
  var ii = geometries.length;
  var extrudes = new Array(geometries.length);
  var tessellates = new Array(geometries.length);
  var altitudeModes = new Array(geometries.length);
  var hasExtrude, hasTessellate, hasAltitudeMode;
  hasExtrude = false;
  hasTessellate = false;
  hasAltitudeMode = false;

  for (var i = 0; i < ii; ++i) {
    var geometry = geometries[i];
    extrudes[i] = geometry.get('extrude');
    tessellates[i] = geometry.get('tessellate');
    altitudeModes[i] = geometry.get('altitudeMode');
    hasExtrude = hasExtrude || extrudes[i] !== undefined;
    hasTessellate = hasTessellate || tessellates[i] !== undefined;
    hasAltitudeMode = hasAltitudeMode || altitudeModes[i];
  }

  if (hasExtrude) {
    multiGeometry.set('extrude', extrudes);
  }

  if (hasTessellate) {
    multiGeometry.set('tessellate', tessellates);
  }

  if (hasAltitudeMode) {
    multiGeometry.set('altitudeMode', altitudeModes);
  }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var DATA_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'displayName': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'value': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */

function dataParser(node, objectStack) {
  var name = node.getAttribute('name');
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.parseNode)(DATA_PARSERS, node, objectStack);
  var featureObject =
  /** @type {Object} */
  objectStack[objectStack.length - 1];

  if (name && featureObject.displayName) {
    featureObject[name] = {
      value: featureObject.value,
      displayName: featureObject.displayName,
      toString: function toString() {
        return featureObject.value;
      }
    };
  } else if (name !== null) {
    featureObject[name] = featureObject.value;
  } else if (featureObject.displayName !== null) {
    featureObject[featureObject.displayName] = featureObject.value;
  }

  delete featureObject['value'];
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var EXTENDED_DATA_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'Data': dataParser,
  'SchemaData': schemaDataParser
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */

function extendedDataParser(node, objectStack) {
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.parseNode)(EXTENDED_DATA_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */


function regionParser(node, objectStack) {
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.parseNode)(REGION_PARSERS, node, objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var PAIR_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'Style': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readStyle),
  'key': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'styleUrl': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(readStyleURL)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */

function pairDataParser(node, objectStack) {
  var pairObject = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)({}, PAIR_PARSERS, node, objectStack, this);

  if (!pairObject) {
    return;
  }

  var key =
  /** @type {string|undefined} */
  pairObject['key'];

  if (key && key == 'normal') {
    var styleUrl =
    /** @type {string|undefined} */
    pairObject['styleUrl'];

    if (styleUrl) {
      objectStack[objectStack.length - 1] = styleUrl;
    }

    var style =
    /** @type {Style} */
    pairObject['Style'];

    if (style) {
      objectStack[objectStack.length - 1] = style;
    }
  }
}
/**
 * @this {KML}
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */


function placemarkStyleMapParser(node, objectStack) {
  var styleMapValue = readStyleMapValue.call(this, node, objectStack);

  if (!styleMapValue) {
    return;
  }

  var placemarkObject = objectStack[objectStack.length - 1];

  if (Array.isArray(styleMapValue)) {
    placemarkObject['Style'] = styleMapValue;
  } else if (typeof styleMapValue === 'string') {
    placemarkObject['styleUrl'] = styleMapValue;
  } else {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_24__.assert)(false, 38); // `styleMapValue` has an unknown type
  }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var SCHEMA_DATA_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'SimpleData': simpleDataParser
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */

function schemaDataParser(node, objectStack) {
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.parseNode)(SCHEMA_DATA_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */


function simpleDataParser(node, objectStack) {
  var name = node.getAttribute('name');

  if (name !== null) {
    var data = (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString)(node);
    var featureObject =
    /** @type {Object} */
    objectStack[objectStack.length - 1];
    featureObject[name] = data;
  }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var LAT_LON_ALT_BOX_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'altitudeMode': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'minAltitude': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal),
  'maxAltitude': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal),
  'north': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal),
  'south': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal),
  'east': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal),
  'west': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */

function latLonAltBoxParser(node, objectStack) {
  var object = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)({}, LAT_LON_ALT_BOX_PARSERS, node, objectStack);

  if (!object) {
    return;
  }

  var regionObject =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var extent = [parseFloat(object['west']), parseFloat(object['south']), parseFloat(object['east']), parseFloat(object['north'])];
  regionObject['extent'] = extent;
  regionObject['altitudeMode'] = object['altitudeMode'];
  regionObject['minAltitude'] = parseFloat(object['minAltitude']);
  regionObject['maxAltitude'] = parseFloat(object['maxAltitude']);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var LOD_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'minLodPixels': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal),
  'maxLodPixels': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal),
  'minFadeExtent': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal),
  'maxFadeExtent': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */

function lodParser(node, objectStack) {
  var object = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)({}, LOD_PARSERS, node, objectStack);

  if (!object) {
    return;
  }

  var lodObject =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  lodObject['minLodPixels'] = parseFloat(object['minLodPixels']);
  lodObject['maxLodPixels'] = parseFloat(object['maxLodPixels']);
  lodObject['minFadeExtent'] = parseFloat(object['minFadeExtent']);
  lodObject['maxFadeExtent'] = parseFloat(object['maxFadeExtent']);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var INNER_BOUNDARY_IS_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth
  // allows multiple, so we parse multiple here too.
  'LinearRing': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(readFlatLinearRing)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */

function innerBoundaryIsParser(node, objectStack) {
  var innerBoundaryFlatLinearRings = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)(
  /** @type {Array<Array<number>>} */
  [], INNER_BOUNDARY_IS_PARSERS, node, objectStack);

  if (innerBoundaryFlatLinearRings.length > 0) {
    var flatLinearRings =
    /** @type {Array<Array<number>>} */
    objectStack[objectStack.length - 1];
    flatLinearRings.push.apply(flatLinearRings, innerBoundaryFlatLinearRings);
  }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var OUTER_BOUNDARY_IS_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'LinearRing': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeReplacer)(readFlatLinearRing)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */

function outerBoundaryIsParser(node, objectStack) {
  /** @type {Array<number>|undefined} */
  var flatLinearRing = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)(undefined, OUTER_BOUNDARY_IS_PARSERS, node, objectStack);

  if (flatLinearRing) {
    var flatLinearRings =
    /** @type {Array<Array<number>>} */
    objectStack[objectStack.length - 1];
    flatLinearRings[0] = flatLinearRing;
  }
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */


function linkParser(node, objectStack) {
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.parseNode)(LINK_PARSERS, node, objectStack);
}
/**
 * @param {Node} node Node.
 * @param {Array<*>} objectStack Object stack.
 */


function whenParser(node, objectStack) {
  var gxTrackObject =
  /** @type {GxTrackObject} */
  objectStack[objectStack.length - 1];
  var whens = gxTrackObject.whens;
  var s = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.getAllTextContent)(node, false);
  var when = Date.parse(s);
  whens.push(isNaN(when) ? 0 : when);
}
/**
 * @param {Node} node Node to append a TextNode with the color to.
 * @param {import("../color.js").Color|string} color Color.
 */


function writeColorTextNode(node, color) {
  var rgba = (0,_color_js__WEBPACK_IMPORTED_MODULE_26__.asArray)(color);
  var opacity = rgba.length == 4 ? rgba[3] : 1;
  /** @type {Array<string|number>} */

  var abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];

  for (var i = 0; i < 4; ++i) {
    var hex = Math.floor(
    /** @type {number} */
    abgr[i]).toString(16);
    abgr[i] = hex.length == 1 ? '0' + hex : hex;
  }

  (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode)(node, abgr.join(''));
}
/**
 * @param {Node} node Node to append a TextNode with the coordinates to.
 * @param {Array<number>} coordinates Coordinates.
 * @param {Array<*>} objectStack Object stack.
 */


function writeCoordinatesTextNode(node, coordinates, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var layout = context['layout'];
  var stride = context['stride'];
  var dimension;

  if (layout == _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_20__["default"].XY || layout == _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_20__["default"].XYM) {
    dimension = 2;
  } else if (layout == _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_20__["default"].XYZ || layout == _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_20__["default"].XYZM) {
    dimension = 3;
  } else {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_24__.assert)(false, 34); // Invalid geometry layout
  }

  var ii = coordinates.length;
  var text = '';

  if (ii > 0) {
    text += coordinates[0];

    for (var d = 1; d < dimension; ++d) {
      text += ',' + coordinates[d];
    }

    for (var i = stride; i < ii; i += stride) {
      text += ' ' + coordinates[i];

      for (var d = 1; d < dimension; ++d) {
        text += ',' + coordinates[i + d];
      }
    }
  }

  (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode)(node, text);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore


var EXTENDEDDATA_NODE_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'Data': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeDataNode),
  'value': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeDataNodeValue),
  'displayName': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeDataNodeName)
});
/**
 * @param {Element} node Node.
 * @param {{name: *, value: *}} pair Name value pair.
 * @param {Array<*>} objectStack Object stack.
 */

function writeDataNode(node, pair, objectStack) {
  node.setAttribute('name', pair.name);
  var
  /** @type {import("../xml.js").NodeStackItem} */
  context = {
    node: node
  };
  var value = pair.value;

  if (_typeof(value) == 'object') {
    if (value !== null && value.displayName) {
      (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, EXTENDEDDATA_NODE_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_2__.OBJECT_PROPERTY_NODE_FACTORY, [value.displayName], objectStack, ['displayName']);
    }

    if (value !== null && value.value) {
      (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, EXTENDEDDATA_NODE_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_2__.OBJECT_PROPERTY_NODE_FACTORY, [value.value], objectStack, ['value']);
    }
  } else {
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, EXTENDEDDATA_NODE_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_2__.OBJECT_PROPERTY_NODE_FACTORY, [value], objectStack, ['value']);
  }
}
/**
 * @param {Node} node Node to append a TextNode with the name to.
 * @param {string} name DisplayName.
 */


function writeDataNodeName(node, name) {
  (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeCDATASection)(node, name);
}
/**
 * @param {Node} node Node to append a CDATA Section with the value to.
 * @param {string} value Value.
 */


function writeDataNodeValue(node, value) {
  (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode)(node, value);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore


var DOCUMENT_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'Placemark': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writePlacemark)
});
/**
 * @const
 * @param {*} value Value.
 * @param {Array<*>} objectStack Object stack.
 * @param {string} [opt_nodeName] Node name.
 * @return {Node|undefined} Node.
 */

var DOCUMENT_NODE_FACTORY = function DOCUMENT_NODE_FACTORY(value, objectStack, opt_nodeName) {
  var parentNode = objectStack[objectStack.length - 1].node;
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(parentNode.namespaceURI, 'Placemark');
};
/**
 * @param {Element} node Node.
 * @param {Array<Feature>} features Features.
 * @param {Array<*>} objectStack Object stack.
 * @this {KML}
 */


function writeDocument(node, features, objectStack) {
  var
  /** @type {import("../xml.js").NodeStackItem} */
  context = {
    node: node
  };
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, DOCUMENT_SERIALIZERS, DOCUMENT_NODE_FACTORY, features, objectStack, undefined, this);
}
/**
 * A factory for creating Data nodes.
 * @const
 * @type {function(*, Array<*>): (Node|undefined)}
 */


var DATA_NODE_FACTORY = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSimpleNodeFactory)('Data');
/**
 * @param {Element} node Node.
 * @param {{names: Array<string>, values: (Array<*>)}} namesAndValues Names and values.
 * @param {Array<*>} objectStack Object stack.
 */

function writeExtendedData(node, namesAndValues, objectStack) {
  var
  /** @type {import("../xml.js").NodeStackItem} */
  context = {
    node: node
  };
  var names = namesAndValues.names;
  var values = namesAndValues.values;
  var length = names.length;

  for (var i = 0; i < length; i++) {
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, EXTENDEDDATA_NODE_SERIALIZERS, DATA_NODE_FACTORY, [{
      name: names[i],
      value: values[i]
    }], objectStack);
  }
}
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore


var ICON_SEQUENCE = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, ['href'], (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(GX_NAMESPACE_URIS, ['x', 'y', 'w', 'h']));
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore

var ICON_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'href': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode)
}, (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(GX_NAMESPACE_URIS, {
  'x': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeDecimalTextNode),
  'y': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeDecimalTextNode),
  'w': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeDecimalTextNode),
  'h': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeDecimalTextNode)
}));
/**
 * @const
 * @param {*} value Value.
 * @param {Array<*>} objectStack Object stack.
 * @param {string} [opt_nodeName] Node name.
 * @return {Node|undefined} Node.
 */

var GX_NODE_FACTORY = function GX_NODE_FACTORY(value, objectStack, opt_nodeName) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(GX_NAMESPACE_URIS[0], 'gx:' + opt_nodeName);
};
/**
 * @param {Element} node Node.
 * @param {Object} icon Icon object.
 * @param {Array<*>} objectStack Object stack.
 */


function writeIcon(node, icon, objectStack) {
  var
  /** @type {import("../xml.js").NodeStackItem} */
  context = {
    node: node
  };
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSequence)(icon, orderedKeys);
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, ICON_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_2__.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
  orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];
  values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSequence)(icon, orderedKeys);
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, ICON_SERIALIZERS, GX_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore


var ICON_STYLE_SEQUENCE = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, ['scale', 'heading', 'Icon', 'color', 'hotSpot']);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore

var ICON_STYLE_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'Icon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeIcon),
  'color': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeColorTextNode),
  'heading': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeDecimalTextNode),
  'hotSpot': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeVec2),
  'scale': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeScaleTextNode)
});
/**
 * @param {Element} node Node.
 * @param {import("../style/Icon.js").default} style Icon style.
 * @param {Array<*>} objectStack Object stack.
 */

function writeIconStyle(node, style, objectStack) {
  var
  /** @type {import("../xml.js").NodeStackItem} */
  context = {
    node: node
  };
  var
  /** @type {Object<string, any>} */
  properties = {};
  var src = style.getSrc();
  var size = style.getSize();
  var iconImageSize = style.getImageSize();
  var iconProperties = {
    'href': src
  };

  if (size) {
    iconProperties['w'] = size[0];
    iconProperties['h'] = size[1];
    var anchor = style.getAnchor(); // top-left

    var origin_1 = style.getOrigin(); // top-left

    if (origin_1 && iconImageSize && origin_1[0] !== 0 && origin_1[1] !== size[1]) {
      iconProperties['x'] = origin_1[0];
      iconProperties['y'] = iconImageSize[1] - (origin_1[1] + size[1]);
    }

    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {
      var
      /** @type {Vec2} */
      hotSpot = {
        x: anchor[0],
        xunits: _style_IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_1__["default"].PIXELS,
        y: size[1] - anchor[1],
        yunits: _style_IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_1__["default"].PIXELS
      };
      properties['hotSpot'] = hotSpot;
    }
  }

  properties['Icon'] = iconProperties;
  var scale = style.getScaleArray()[0];
  var imageSize = size;

  if (imageSize === null) {
    imageSize = DEFAULT_IMAGE_STYLE_SIZE;
  }

  if (imageSize.length == 2) {
    var resizeScale = scaleForSize(imageSize);
    scale = scale / resizeScale;
  }

  if (scale !== 1) {
    properties['scale'] = scale;
  }

  var rotation = style.getRotation();

  if (rotation !== 0) {
    properties['heading'] = rotation; // 0-360
  }

  var color = style.getColor();

  if (color) {
    properties['color'] = color;
  }

  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSequence)(properties, orderedKeys);
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, ICON_STYLE_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_2__.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore


var LABEL_STYLE_SEQUENCE = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, ['color', 'scale']);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore

var LABEL_STYLE_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'color': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeColorTextNode),
  'scale': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeScaleTextNode)
});
/**
 * @param {Element} node Node.
 * @param {Text} style style.
 * @param {Array<*>} objectStack Object stack.
 */

function writeLabelStyle(node, style, objectStack) {
  var
  /** @type {import("../xml.js").NodeStackItem} */
  context = {
    node: node
  };
  var properties = {};
  var fill = style.getFill();

  if (fill) {
    properties['color'] = fill.getColor();
  }

  var scale = style.getScale();

  if (scale && scale !== 1) {
    properties['scale'] = scale;
  }

  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSequence)(properties, orderedKeys);
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, LABEL_STYLE_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_2__.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore


var LINE_STYLE_SEQUENCE = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, ['color', 'width']);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore

var LINE_STYLE_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'color': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeColorTextNode),
  'width': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeDecimalTextNode)
});
/**
 * @param {Element} node Node.
 * @param {Stroke} style style.
 * @param {Array<*>} objectStack Object stack.
 */

function writeLineStyle(node, style, objectStack) {
  var
  /** @type {import("../xml.js").NodeStackItem} */
  context = {
    node: node
  };
  var properties = {
    'color': style.getColor(),
    'width': Number(style.getWidth()) || 1
  };
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSequence)(properties, orderedKeys);
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, LINE_STYLE_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_2__.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @const
 * @type {Object<string, string>}
 */


var GEOMETRY_TYPE_TO_NODENAME = {
  'Point': 'Point',
  'LineString': 'LineString',
  'LinearRing': 'LinearRing',
  'Polygon': 'Polygon',
  'MultiPoint': 'MultiGeometry',
  'MultiLineString': 'MultiGeometry',
  'MultiPolygon': 'MultiGeometry',
  'GeometryCollection': 'MultiGeometry'
};
/**
 * @const
 * @param {*} value Value.
 * @param {Array<*>} objectStack Object stack.
 * @param {string} [opt_nodeName] Node name.
 * @return {Node|undefined} Node.
 */

var GEOMETRY_NODE_FACTORY = function GEOMETRY_NODE_FACTORY(value, objectStack, opt_nodeName) {
  if (value) {
    var parentNode = objectStack[objectStack.length - 1].node;
    return (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.createElementNS)(parentNode.namespaceURI, GEOMETRY_TYPE_TO_NODENAME[
    /** @type {import("../geom/Geometry.js").default} */
    value.getType()]);
  }
};
/**
 * A factory for creating Point nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */


var POINT_NODE_FACTORY = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSimpleNodeFactory)('Point');
/**
 * A factory for creating LineString nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */

var LINE_STRING_NODE_FACTORY = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSimpleNodeFactory)('LineString');
/**
 * A factory for creating LinearRing nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */

var LINEAR_RING_NODE_FACTORY = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSimpleNodeFactory)('LinearRing');
/**
 * A factory for creating Polygon nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */

var POLYGON_NODE_FACTORY = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSimpleNodeFactory)('Polygon');
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore

var MULTI_GEOMETRY_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'LineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writePrimitiveGeometry),
  'Point': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writePrimitiveGeometry),
  'Polygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writePolygon),
  'GeometryCollection': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeMultiGeometry)
});
/**
 * @param {Element} node Node.
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {Array<*>} objectStack Object stack.
 */

function writeMultiGeometry(node, geometry, objectStack) {
  /** @type {import("../xml.js").NodeStackItem} */
  var context = {
    node: node
  };
  var type = geometry.getType();
  /** @type {Array<import("../geom/Geometry.js").default>} */

  var geometries = [];
  /** @type {function(*, Array<*>, string=): (Node|undefined)} */

  var factory;

  if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].GEOMETRY_COLLECTION) {
    /** @type {GeometryCollection} */
    geometry.getGeometriesArrayRecursive().forEach(function (geometry) {
      var type = geometry.getType();

      if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POINT) {
        geometries = geometries.concat(
        /** @type {MultiPoint} */
        geometry.getPoints());
      } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_LINE_STRING) {
        geometries = geometries.concat(
        /** @type {MultiLineString} */
        geometry.getLineStrings());
      } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POLYGON) {
        geometries = geometries.concat(
        /** @type {MultiPolygon} */
        geometry.getPolygons());
      } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POINT || type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].LINE_STRING || type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POLYGON) {
        geometries.push(geometry);
      } else {
        (0,_asserts_js__WEBPACK_IMPORTED_MODULE_24__.assert)(false, 39); // Unknown geometry type
      }
    });
    factory = GEOMETRY_NODE_FACTORY;
  } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POINT) {
    geometries =
    /** @type {MultiPoint} */
    geometry.getPoints();
    factory = POINT_NODE_FACTORY;
  } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_LINE_STRING) {
    geometries =
    /** @type {MultiLineString} */
    geometry.getLineStrings();
    factory = LINE_STRING_NODE_FACTORY;
  } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POLYGON) {
    geometries =
    /** @type {MultiPolygon} */
    geometry.getPolygons();
    factory = POLYGON_NODE_FACTORY;
  } else {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_24__.assert)(false, 39); // Unknown geometry type
  }

  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, MULTI_GEOMETRY_SERIALIZERS, factory, geometries, objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore


var BOUNDARY_IS_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'LinearRing': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writePrimitiveGeometry)
});
/**
 * @param {Element} node Node.
 * @param {import("../geom/LinearRing.js").default} linearRing Linear ring.
 * @param {Array<*>} objectStack Object stack.
 */

function writeBoundaryIs(node, linearRing, objectStack) {
  var
  /** @type {import("../xml.js").NodeStackItem} */
  context = {
    node: node
  };
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, BOUNDARY_IS_SERIALIZERS, LINEAR_RING_NODE_FACTORY, [linearRing], objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore


var PLACEMARK_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'ExtendedData': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeExtendedData),
  'MultiGeometry': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeMultiGeometry),
  'LineString': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writePrimitiveGeometry),
  'LinearRing': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writePrimitiveGeometry),
  'Point': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writePrimitiveGeometry),
  'Polygon': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writePolygon),
  'Style': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeStyle),
  'address': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode),
  'description': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode),
  'name': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode),
  'open': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeBooleanTextNode),
  'phoneNumber': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode),
  'styleUrl': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode),
  'visibility': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeBooleanTextNode)
});
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore

var PLACEMARK_SEQUENCE = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, ['name', 'open', 'visibility', 'address', 'phoneNumber', 'description', 'styleUrl', 'Style']);
/**
 * A factory for creating ExtendedData nodes.
 * @const
 * @type {function(*, Array<*>): (Node|undefined)}
 */

var EXTENDEDDATA_NODE_FACTORY = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSimpleNodeFactory)('ExtendedData');
/**
 * FIXME currently we do serialize arbitrary/custom feature properties
 * (ExtendedData).
 * @param {Element} node Node.
 * @param {Feature} feature Feature.
 * @param {Array<*>} objectStack Object stack.
 * @this {KML}
 */

function writePlacemark(node, feature, objectStack) {
  var
  /** @type {import("../xml.js").NodeStackItem} */
  context = {
    node: node
  }; // set id

  if (feature.getId()) {
    node.setAttribute('id',
    /** @type {string} */
    feature.getId());
  } // serialize properties (properties unknown to KML are not serialized)


  var properties = feature.getProperties(); // don't export these to ExtendedData

  var filter = {
    'address': 1,
    'description': 1,
    'name': 1,
    'open': 1,
    'phoneNumber': 1,
    'styleUrl': 1,
    'visibility': 1
  };
  filter[feature.getGeometryName()] = 1;
  var keys = Object.keys(properties || {}).sort().filter(function (v) {
    return !filter[v];
  });
  var styleFunction = feature.getStyleFunction();

  if (styleFunction) {
    // FIXME the styles returned by the style function are supposed to be
    // resolution-independent here
    var styles = styleFunction(feature, 0);

    if (styles) {
      var styleArray = Array.isArray(styles) ? styles : [styles];
      var pointStyles = styleArray;

      if (feature.getGeometry()) {
        pointStyles = styleArray.filter(function (style) {
          var geometry = style.getGeometryFunction()(feature);

          if (geometry) {
            var type = geometry.getType();

            if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].GEOMETRY_COLLECTION) {
              return (
                /** @type {GeometryCollection} */
                geometry.getGeometriesArrayRecursive().filter(function (geometry) {
                  var type = geometry.getType();
                  return type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POINT || type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POINT;
                }).length
              );
            }

            return type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POINT || type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POINT;
          }
        });
      }

      if (this.writeStyles_) {
        var lineStyles = styleArray;
        var polyStyles = styleArray;

        if (feature.getGeometry()) {
          lineStyles = styleArray.filter(function (style) {
            var geometry = style.getGeometryFunction()(feature);

            if (geometry) {
              var type = geometry.getType();

              if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].GEOMETRY_COLLECTION) {
                return (
                  /** @type {GeometryCollection} */
                  geometry.getGeometriesArrayRecursive().filter(function (geometry) {
                    var type = geometry.getType();
                    return type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].LINE_STRING || type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_LINE_STRING;
                  }).length
                );
              }

              return type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].LINE_STRING || type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_LINE_STRING;
            }
          });
          polyStyles = styleArray.filter(function (style) {
            var geometry = style.getGeometryFunction()(feature);

            if (geometry) {
              var type = geometry.getType();

              if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].GEOMETRY_COLLECTION) {
                return (
                  /** @type {GeometryCollection} */
                  geometry.getGeometriesArrayRecursive().filter(function (geometry) {
                    var type = geometry.getType();
                    return type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POLYGON || type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POLYGON;
                  }).length
                );
              }

              return type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POLYGON || type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POLYGON;
            }
          });
        }

        properties['Style'] = {
          pointStyles: pointStyles,
          lineStyles: lineStyles,
          polyStyles: polyStyles
        };
      }

      if (pointStyles.length && properties['name'] === undefined) {
        var textStyle = pointStyles[0].getText();

        if (textStyle) {
          properties['name'] = textStyle.getText();
        }
      }
    }
  }

  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSequence)(properties, orderedKeys);
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, PLACEMARK_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_2__.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);

  if (keys.length > 0) {
    var sequence = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSequence)(properties, keys);
    var namesAndValues = {
      names: keys,
      values: sequence
    };
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, PLACEMARK_SERIALIZERS, EXTENDEDDATA_NODE_FACTORY, [namesAndValues], objectStack);
  } // serialize geometry


  var options =
  /** @type {import("./Feature.js").WriteOptions} */
  objectStack[0];
  var geometry = feature.getGeometry();

  if (geometry) {
    geometry = (0,_Feature_js__WEBPACK_IMPORTED_MODULE_11__.transformGeometryWithOptions)(geometry, true, options);
  }

  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, PLACEMARK_SERIALIZERS, GEOMETRY_NODE_FACTORY, [geometry], objectStack);
}
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore


var PRIMITIVE_GEOMETRY_SEQUENCE = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, ['extrude', 'tessellate', 'altitudeMode', 'coordinates']);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore

var PRIMITIVE_GEOMETRY_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'extrude': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeBooleanTextNode),
  'tessellate': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeBooleanTextNode),
  'altitudeMode': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode),
  'coordinates': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeCoordinatesTextNode)
});
/**
 * @param {Element} node Node.
 * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @param {Array<*>} objectStack Object stack.
 */

function writePrimitiveGeometry(node, geometry, objectStack) {
  var flatCoordinates = geometry.getFlatCoordinates();
  var
  /** @type {import("../xml.js").NodeStackItem} */
  context = {
    node: node
  };
  context['layout'] = geometry.getLayout();
  context['stride'] = geometry.getStride(); // serialize properties (properties unknown to KML are not serialized)

  var properties = geometry.getProperties();
  properties.coordinates = flatCoordinates;
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSequence)(properties, orderedKeys);
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, PRIMITIVE_GEOMETRY_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_2__.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore


var POLY_STYLE_SEQUENCE = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, ['color', 'fill', 'outline']);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore

var POLYGON_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'outerBoundaryIs': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeBoundaryIs),
  'innerBoundaryIs': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeBoundaryIs)
});
/**
 * A factory for creating innerBoundaryIs nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */

var INNER_BOUNDARY_NODE_FACTORY = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSimpleNodeFactory)('innerBoundaryIs');
/**
 * A factory for creating outerBoundaryIs nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */

var OUTER_BOUNDARY_NODE_FACTORY = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSimpleNodeFactory)('outerBoundaryIs');
/**
 * @param {Element} node Node.
 * @param {Polygon} polygon Polygon.
 * @param {Array<*>} objectStack Object stack.
 */

function writePolygon(node, polygon, objectStack) {
  var linearRings = polygon.getLinearRings();
  var outerRing = linearRings.shift();
  var
  /** @type {import("../xml.js").NodeStackItem} */
  context = {
    node: node
  }; // inner rings

  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, POLYGON_SERIALIZERS, INNER_BOUNDARY_NODE_FACTORY, linearRings, objectStack); // outer ring

  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, POLYGON_SERIALIZERS, OUTER_BOUNDARY_NODE_FACTORY, [outerRing], objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore


var POLY_STYLE_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'color': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeColorTextNode),
  'fill': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeBooleanTextNode),
  'outline': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeBooleanTextNode)
});
/**
 * @param {Element} node Node.
 * @param {Style} style Style.
 * @param {Array<*>} objectStack Object stack.
 */

function writePolyStyle(node, style, objectStack) {
  var
  /** @type {import("../xml.js").NodeStackItem} */
  context = {
    node: node
  };
  var fill = style.getFill();
  var stroke = style.getStroke();
  var properties = {
    'color': fill ? fill.getColor() : undefined,
    'fill': fill ? undefined : false,
    'outline': stroke ? undefined : false
  };
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSequence)(properties, orderedKeys);
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, POLY_STYLE_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_2__.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @param {Node} node Node to append a TextNode with the scale to.
 * @param {number|undefined} scale Scale.
 */


function writeScaleTextNode(node, scale) {
  // the Math is to remove any excess decimals created by float arithmetic
  (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeDecimalTextNode)(node, Math.round(scale * 1e6) / 1e6);
}
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore


var STYLE_SEQUENCE = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, ['IconStyle', 'LabelStyle', 'LineStyle', 'PolyStyle']);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore

var STYLE_SERIALIZERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)(NAMESPACE_URIS, {
  'IconStyle': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeIconStyle),
  'LabelStyle': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeLabelStyle),
  'LineStyle': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writeLineStyle),
  'PolyStyle': (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeChildAppender)(writePolyStyle)
});
/**
 * @param {Element} node Node.
 * @param {Object<string, Array<Style>>} styles Styles.
 * @param {Array<*>} objectStack Object stack.
 */

function writeStyle(node, styles, objectStack) {
  var
  /** @type {import("../xml.js").NodeStackItem} */
  context = {
    node: node
  };
  var properties = {};

  if (styles.pointStyles.length) {
    var textStyle = styles.pointStyles[0].getText();

    if (textStyle) {
      properties['LabelStyle'] = textStyle;
    }

    var imageStyle = styles.pointStyles[0].getImage();

    if (imageStyle && typeof
    /** @type {?} */
    imageStyle.getSrc === 'function') {
      properties['IconStyle'] = imageStyle;
    }
  }

  if (styles.lineStyles.length) {
    var strokeStyle = styles.lineStyles[0].getStroke();

    if (strokeStyle) {
      properties['LineStyle'] = strokeStyle;
    }
  }

  if (styles.polyStyles.length) {
    var strokeStyle = styles.polyStyles[0].getStroke();

    if (strokeStyle && !properties['LineStyle']) {
      properties['LineStyle'] = strokeStyle;
    }

    properties['PolyStyle'] = styles.polyStyles[0];
  }

  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeSequence)(properties, orderedKeys);
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushSerializeAndPop)(context, STYLE_SERIALIZERS, _xml_js__WEBPACK_IMPORTED_MODULE_2__.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @param {Element} node Node to append a TextNode with the Vec2 to.
 * @param {Vec2} vec2 Vec2.
 */


function writeVec2(node, vec2) {
  node.setAttribute('x', String(vec2.x));
  node.setAttribute('y', String(vec2.y));
  node.setAttribute('xunits', vec2.xunits);
  node.setAttribute('yunits', vec2.yunits);
}

/* harmony default export */ __webpack_exports__["default"] = (KML);

/***/ }),

/***/ "./build/wg/format/MVT.js":
/*!********************************!*\
  !*** ./build/wg/format/MVT.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Feature.js */ "./build/wg/format/Feature.js");
/* harmony import */ var _FormatType_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./FormatType.js */ "./build/wg/format/FormatType.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./build/wg/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./build/wg/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./build/wg/geom/MultiPolygon.js");
/* harmony import */ var pbf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pbf */ "./node_modules/pbf/index.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _proj_Projection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj/Projection.js */ "./build/wg/proj/Projection.js");
/* harmony import */ var _render_Feature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../render/Feature.js */ "./build/wg/render/Feature.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../proj/Units.js */ "./build/wg/proj/Units.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/flat/orient.js */ "./build/wg/geom/flat/orient.js");
/**
 * @module wg/format/MVT
 */
//FIXME Implement projection handling
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();


















/**
 * @typedef {Object} Options
 * @property {import("../Feature.js").FeatureClass} [featureClass] Class for features returned by
 * {@link module:wg/format/MVT~MVT#readFeatures}. Set to {@link module:wg/Feature~Feature} to get full editing and geometry
 * support at the cost of decreased rendering performance. The default is
 * {@link module:wg/render/Feature~RenderFeature}, which is optimized for rendering and hit detection.
 * @property {string} [geometryName='geometry'] Geometry name to use when creating features.
 * @property {string} [layerName='layer'] Name of the feature attribute that holds the layer name.
 * @property {Array<string>} [layers] Layers to read features from. If not provided, features will be read from all
 * @property {string} [idProperty] Optional property that will be assigned as the feature id and removed from the properties.
 * layers.
 */

/**
 * @classdesc
 * Feature format for reading data in the Mapbox MVT format.
 *
 * @param {Options} [opt_options] Options.
 * @api
 */

var MVT =
/** @class */
function (_super) {
  __extends(MVT, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function MVT(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @type {Projection}
     */

    _this.dataProjection = new _proj_Projection_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
      code: '',
      units: _proj_Units_js__WEBPACK_IMPORTED_MODULE_3__["default"].TILE_PIXELS
    });
    /**
     * @private
     * @type {import("../Feature.js").FeatureClass}
     */

    _this.featureClass_ = options.featureClass ? options.featureClass : _render_Feature_js__WEBPACK_IMPORTED_MODULE_4__["default"];
    /**
     * @private
     * @type {string|undefined}
     */

    _this.geometryName_ = options.geometryName;
    /**
     * @private
     * @type {string}
     */

    _this.layerName_ = options.layerName ? options.layerName : 'layer';
    /**
     * @private
     * @type {Array<string>|null}
     */

    _this.layers_ = options.layers ? options.layers : null;
    /**
     * @private
     * @type {string}
     */

    _this.idProperty_ = options.idProperty;
    _this.supportedMediaTypes = ['application/vnd.mapbox-vector-tile', 'application/x-protobuf'];
    return _this;
  }
  /**
   * Read the raw geometry from the pbf offset stored in a raw feature's geometry
   * property.
   * @param {PBF} pbf PBF.
   * @param {Object} feature Raw feature.
   * @param {Array<number>} flatCoordinates Array to store flat coordinates in.
   * @param {Array<number>} ends Array to store ends in.
   * @private
   */


  MVT.prototype.readRawGeometry_ = function (pbf, feature, flatCoordinates, ends) {
    pbf.pos = feature.geometry;
    var end = pbf.readVarint() + pbf.pos;
    var cmd = 1;
    var length = 0;
    var x = 0;
    var y = 0;
    var coordsLen = 0;
    var currentEnd = 0;

    while (pbf.pos < end) {
      if (!length) {
        var cmdLen = pbf.readVarint();
        cmd = cmdLen & 0x7;
        length = cmdLen >> 3;
      }

      length--;

      if (cmd === 1 || cmd === 2) {
        x += pbf.readSVarint();
        y += pbf.readSVarint();

        if (cmd === 1) {
          // moveTo
          if (coordsLen > currentEnd) {
            ends.push(coordsLen);
            currentEnd = coordsLen;
          }
        }

        flatCoordinates.push(x, y);
        coordsLen += 2;
      } else if (cmd === 7) {
        if (coordsLen > currentEnd) {
          // close polygon
          flatCoordinates.push(flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);
          coordsLen += 2;
        }
      } else {
        (0,_asserts_js__WEBPACK_IMPORTED_MODULE_5__.assert)(false, 59); // Invalid command found in the PBF
      }
    }

    if (coordsLen > currentEnd) {
      ends.push(coordsLen);
      currentEnd = coordsLen;
    }
  };
  /**
   * @private
   * @param {PBF} pbf PBF
   * @param {Object} rawFeature Raw Mapbox feature.
   * @param {import("./Feature.js").ReadOptions} options Read options.
   * @return {import("../Feature.js").FeatureLike|null} Feature.
   */


  MVT.prototype.createFeature_ = function (pbf, rawFeature, options) {
    var type = rawFeature.type;

    if (type === 0) {
      return null;
    }

    var feature;
    var values = rawFeature.properties;
    var id;

    if (!this.idProperty_) {
      id = rawFeature.id;
    } else {
      id = values[this.idProperty_];
      delete values[this.idProperty_];
    }

    values[this.layerName_] = rawFeature.layer.name;
    var flatCoordinates =
    /** @type {Array<number>} */
    [];
    var ends =
    /** @type {Array<number>} */
    [];
    this.readRawGeometry_(pbf, rawFeature, flatCoordinates, ends);
    var geometryType = getGeometryType(type, ends.length);

    if (this.featureClass_ === _render_Feature_js__WEBPACK_IMPORTED_MODULE_4__["default"]) {
      feature = new this.featureClass_(geometryType, flatCoordinates, ends, values, id);
      feature.transform(options.dataProjection);
    } else {
      var geom = void 0;

      if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POLYGON) {
        var endss = (0,_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_7__.inflateEnds)(flatCoordinates, ends);
        geom = endss.length > 1 ? new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_8__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XY, endss) : new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_10__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XY, ends);
      } else {
        geom = geometryType === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINT ? new _geom_Point_js__WEBPACK_IMPORTED_MODULE_11__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XY) : geometryType === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].LINE_STRING ? new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_12__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XY) : geometryType === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POLYGON ? new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_10__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XY, ends) : geometryType === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].MULTI_POINT ? new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_13__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XY) : geometryType === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].MULTI_LINE_STRING ? new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_14__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XY, ends) : null;
      }

      var ctor =
      /** @type {typeof import("../Feature.js").default} */
      this.featureClass_;
      feature = new ctor();

      if (this.geometryName_) {
        feature.setGeometryName(this.geometryName_);
      }

      var geometry = (0,_Feature_js__WEBPACK_IMPORTED_MODULE_15__.transformGeometryWithOptions)(geom, false, options);
      feature.setGeometry(geometry);

      if (id !== undefined) {
        feature.setId(id);
      }

      feature.setProperties(values, true);
    }

    return feature;
  };
  /**
   * @return {import("./FormatType.js").default} Format.
   */


  MVT.prototype.getType = function () {
    return _FormatType_js__WEBPACK_IMPORTED_MODULE_16__["default"].ARRAY_BUFFER;
  };
  /**
   * Read all features.
   *
   * @param {ArrayBuffer} source Source.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */


  MVT.prototype.readFeatures = function (source, opt_options) {
    var layers = this.layers_;
    var options =
    /** @type {import("./Feature.js").ReadOptions} */
    this.adaptOptions(opt_options);
    var dataProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_1__.get)(options.dataProjection);
    dataProjection.setWorldExtent(options.extent);
    options.dataProjection = dataProjection;
    var pbf = new pbf__WEBPACK_IMPORTED_MODULE_0__(
    /** @type {ArrayBuffer} */
    source);
    var pbfLayers = pbf.readFields(layersPBFReader, {});
    var features = [];

    for (var name_1 in pbfLayers) {
      if (layers && layers.indexOf(name_1) == -1) {
        continue;
      }

      var pbfLayer = pbfLayers[name_1];
      var extent = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;
      dataProjection.setExtent(extent);

      for (var i = 0, ii = pbfLayer.length; i < ii; ++i) {
        var rawFeature = readRawFeature(pbf, pbfLayer, i);
        var feature = this.createFeature_(pbf, rawFeature, options);

        if (feature !== null) {
          features.push(feature);
        }
      }
    }

    return features;
  };
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */


  MVT.prototype.readProjection = function (source) {
    return this.dataProjection;
  };
  /**
   * Sets the layers that features will be read from.
   * @param {Array<string>} layers Layers.
   * @api
   */


  MVT.prototype.setLayers = function (layers) {
    this.layers_ = layers;
  };

  return MVT;
}(_Feature_js__WEBPACK_IMPORTED_MODULE_15__["default"]);
/**
 * Reader callback for parsing layers.
 * @param {number} tag The tag.
 * @param {Object} layers The layers object.
 * @param {PBF} pbf The PBF.
 */


function layersPBFReader(tag, layers, pbf) {
  if (tag === 3) {
    var layer = {
      keys: [],
      values: [],
      features: []
    };
    var end = pbf.readVarint() + pbf.pos;
    pbf.readFields(layerPBFReader, layer, end);
    layer.length = layer.features.length;

    if (layer.length) {
      layers[layer.name] = layer;
    }
  }
}
/**
 * Reader callback for parsing layer.
 * @param {number} tag The tag.
 * @param {Object} layer The layer object.
 * @param {PBF} pbf The PBF.
 */


function layerPBFReader(tag, layer, pbf) {
  if (tag === 15) {
    layer.version = pbf.readVarint();
  } else if (tag === 1) {
    layer.name = pbf.readString();
  } else if (tag === 5) {
    layer.extent = pbf.readVarint();
  } else if (tag === 2) {
    layer.features.push(pbf.pos);
  } else if (tag === 3) {
    layer.keys.push(pbf.readString());
  } else if (tag === 4) {
    var value = null;
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
      tag = pbf.readVarint() >> 3;
      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }

    layer.values.push(value);
  }
}
/**
 * Reader callback for parsing feature.
 * @param {number} tag The tag.
 * @param {Object} feature The feature object.
 * @param {PBF} pbf The PBF.
 */


function featurePBFReader(tag, feature, pbf) {
  if (tag == 1) {
    feature.id = pbf.readVarint();
  } else if (tag == 2) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
      var key = feature.layer.keys[pbf.readVarint()];
      var value = feature.layer.values[pbf.readVarint()];
      feature.properties[key] = value;
    }
  } else if (tag == 3) {
    feature.type = pbf.readVarint();
  } else if (tag == 4) {
    feature.geometry = pbf.pos;
  }
}
/**
 * Read a raw feature from the pbf offset stored at index `i` in the raw layer.
 * @param {PBF} pbf PBF.
 * @param {Object} layer Raw layer.
 * @param {number} i Index of the feature in the raw layer's `features` array.
 * @return {Object} Raw feature.
 */


function readRawFeature(pbf, layer, i) {
  pbf.pos = layer.features[i];
  var end = pbf.readVarint() + pbf.pos;
  var feature = {
    layer: layer,
    type: 0,
    properties: {}
  };
  pbf.readFields(featurePBFReader, feature, end);
  return feature;
}
/**
 * @param {number} type The raw feature's geometry type
 * @param {number} numEnds Number of ends of the flat coordinates of the
 * geometry.
 * @return {import("../geom/GeometryType.js").default} The geometry type.
 */


function getGeometryType(type, numEnds) {
  /** @type {import("../geom/GeometryType.js").default} */
  var geometryType;

  if (type === 1) {
    geometryType = numEnds === 1 ? _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINT : _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].MULTI_POINT;
  } else if (type === 2) {
    geometryType = numEnds === 1 ? _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].LINE_STRING : _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].MULTI_LINE_STRING;
  } else if (type === 3) {
    geometryType = _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POLYGON; // MultiPolygon not relevant for rendering - winding order determines
    // outer rings of polygons.
  }

  return geometryType;
}

/* harmony default export */ __webpack_exports__["default"] = (MVT);

/***/ }),

/***/ "./build/wg/format/OSMXML.js":
/*!***********************************!*\
  !*** ./build/wg/format/OSMXML.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _XMLFeature_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./XMLFeature.js */ "./build/wg/format/XMLFeature.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../xml.js */ "./build/wg/xml.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Feature.js */ "./build/wg/format/Feature.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/OSMXML
 */
// FIXME add typedef for stack state objects













/**
 * @const
 * @type {Array<null>}
 */

var NAMESPACE_URIS = [null];
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var WAY_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'nd': readNd,
  'tag': readTag
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'node': readNode,
  'way': readWay
});
/**
 * @classdesc
 * Feature format for reading data in the
 * [OSMXML format](https://wiki.openstreetmap.org/wiki/OSM_XML).
 *
 * @api
 */

var OSMXML =
/** @class */
function (_super) {
  __extends(OSMXML, _super);

  function OSMXML() {
    var _this = _super.call(this) || this;
    /**
     * @type {import("../proj/Projection.js").default}
     */


    _this.dataProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:4326');
    return _this;
  }
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */


  OSMXML.prototype.readFeaturesFromNode = function (node, opt_options) {
    var options = this.getReadOptions(node, opt_options);

    if (node.localName == 'osm') {
      var state = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)({
        nodes: {},
        ways: [],
        features: []
      }, PARSERS, node, [options]); // parse nodes in ways

      for (var j = 0; j < state.ways.length; j++) {
        var values =
        /** @type {Object} */
        state.ways[j];
        /** @type {Array<number>} */

        var flatCoordinates = [];

        for (var i = 0, ii = values.ndrefs.length; i < ii; i++) {
          var point = state.nodes[values.ndrefs[i]];
          (0,_array_js__WEBPACK_IMPORTED_MODULE_2__.extend)(flatCoordinates, point);
        }

        var geometry = void 0;

        if (values.ndrefs[0] == values.ndrefs[values.ndrefs.length - 1]) {
          // closed way
          geometry = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_3__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_4__["default"].XY, [flatCoordinates.length]);
        } else {
          geometry = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_5__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_4__["default"].XY);
        }

        (0,_Feature_js__WEBPACK_IMPORTED_MODULE_6__.transformGeometryWithOptions)(geometry, false, options);
        var feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_7__["default"](geometry);

        if (values.id !== undefined) {
          feature.setId(values.id);
        }

        feature.setProperties(values.tags, true);
        state.features.push(feature);
      }

      if (state.features) {
        return state.features;
      }
    }

    return [];
  };

  return OSMXML;
}(_XMLFeature_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var NODE_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeStructureNS)(NAMESPACE_URIS, {
  'tag': readTag
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */

function readNode(node, objectStack) {
  var options =
  /** @type {import("./Feature.js").ReadOptions} */
  objectStack[0];
  var state =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var id = node.getAttribute('id');
  /** @type {import("../coordinate.js").Coordinate} */

  var coordinates = [parseFloat(node.getAttribute('lon')), parseFloat(node.getAttribute('lat'))];
  state.nodes[id] = coordinates;
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)({
    tags: {}
  }, NODE_PARSERS, node, objectStack);

  if (!(0,_obj_js__WEBPACK_IMPORTED_MODULE_9__.isEmpty)(values.tags)) {
    var geometry = new _geom_Point_js__WEBPACK_IMPORTED_MODULE_10__["default"](coordinates);
    (0,_Feature_js__WEBPACK_IMPORTED_MODULE_6__.transformGeometryWithOptions)(geometry, false, options);
    var feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_7__["default"](geometry);

    if (id !== undefined) {
      feature.setId(id);
    }

    feature.setProperties(values.tags, true);
    state.features.push(feature);
  }
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */


function readWay(node, objectStack) {
  var id = node.getAttribute('id');
  var values = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)({
    id: id,
    ndrefs: [],
    tags: {}
  }, WAY_PARSERS, node, objectStack);
  var state =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  state.ways.push(values);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */


function readNd(node, objectStack) {
  var values =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  values.ndrefs.push(node.getAttribute('ref'));
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */


function readTag(node, objectStack) {
  var values =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  values.tags[node.getAttribute('k')] = node.getAttribute('v');
}

/* harmony default export */ __webpack_exports__["default"] = (OSMXML);

/***/ }),

/***/ "./build/wg/format/OWS.js":
/*!********************************!*\
  !*** ./build/wg/format/OWS.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _XML_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XML.js */ "./build/wg/format/XML.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../xml.js */ "./build/wg/xml.js");
/* harmony import */ var _xlink_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./xlink.js */ "./build/wg/format/xlink.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./xsd.js */ "./build/wg/format/xsd.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/OWS
 */






/**
 * @const
 * @type {Array<null|string>}
 */

var NAMESPACE_URIS = [null, 'http://www.opengis.net/ows/1.1'];
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'ServiceIdentification': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readServiceIdentification),
  'ServiceProvider': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readServiceProvider),
  'OperationsMetadata': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readOperationsMetadata)
});

var OWS =
/** @class */
function (_super) {
  __extends(OWS, _super);

  function OWS() {
    return _super.call(this) || this;
  }
  /**
   * @param {Element} node Node.
   * @return {Object} Object
   */


  OWS.prototype.readFromNode = function (node) {
    var owsObject = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, PARSERS, node, []);
    return owsObject ? owsObject : null;
  };

  return OWS;
}(_XML_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var ADDRESS_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'DeliveryPoint': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'City': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'AdministrativeArea': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'PostalCode': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'Country': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'ElectronicMailAddress': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var ALLOWED_VALUES_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Value': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readValue)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var CONSTRAINT_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'AllowedValues': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readAllowedValues)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var CONTACT_INFO_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Phone': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readPhone),
  'Address': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readAddress)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var DCP_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'HTTP': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readHttp)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var HTTP_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Get': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readGet),
  'Post': undefined // TODO

});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var OPERATION_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'DCP': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readDcp)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var OPERATIONS_METADATA_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Operation': readOperation
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var PHONE_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Voice': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'Facsimile': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var REQUEST_METHOD_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Constraint': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readConstraint)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var SERVICE_CONTACT_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'IndividualName': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'PositionName': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'ContactInfo': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readContactInfo)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var SERVICE_IDENTIFICATION_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Abstract': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'AccessConstraints': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'Fees': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'Title': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'ServiceTypeVersion': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'ServiceType': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var SERVICE_PROVIDER_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'ProviderName': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'ProviderSite': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xlink_js__WEBPACK_IMPORTED_MODULE_3__.readHref),
  'ServiceContact': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readServiceContact)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The address.
 */

function readAddress(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, ADDRESS_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The values.
 */


function readAllowedValues(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, ALLOWED_VALUES_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The constraint.
 */


function readConstraint(node, objectStack) {
  var name = node.getAttribute('name');

  if (!name) {
    return undefined;
  }

  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({
    'name': name
  }, CONSTRAINT_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The contact info.
 */


function readContactInfo(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, CONTACT_INFO_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The DCP.
 */


function readDcp(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, DCP_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The GET object.
 */


function readGet(node, objectStack) {
  var href = (0,_xlink_js__WEBPACK_IMPORTED_MODULE_3__.readHref)(node);

  if (!href) {
    return undefined;
  }

  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({
    'href': href
  }, REQUEST_METHOD_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The HTTP object.
 */


function readHttp(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, HTTP_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The operation.
 */


function readOperation(node, objectStack) {
  var name = node.getAttribute('name');
  var value = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, OPERATION_PARSERS, node, objectStack);

  if (!value) {
    return undefined;
  }

  var object =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  object[name] = value;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The operations metadata.
 */


function readOperationsMetadata(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, OPERATIONS_METADATA_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The phone.
 */


function readPhone(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, PHONE_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The service identification.
 */


function readServiceIdentification(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, SERVICE_IDENTIFICATION_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The service contact.
 */


function readServiceContact(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, SERVICE_CONTACT_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The service provider.
 */


function readServiceProvider(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, SERVICE_PROVIDER_PARSERS, node, objectStack);
}
/**
 * @param {Node} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {string|undefined} The value.
 */


function readValue(node, objectStack) {
  return (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString)(node);
}

/* harmony default export */ __webpack_exports__["default"] = (OWS);

/***/ }),

/***/ "./build/wg/format/Polyline.js":
/*!*************************************!*\
  !*** ./build/wg/format/Polyline.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "encodeDeltas": function() { return /* binding */ encodeDeltas; },
/* harmony export */   "decodeDeltas": function() { return /* binding */ decodeDeltas; },
/* harmony export */   "encodeFloats": function() { return /* binding */ encodeFloats; },
/* harmony export */   "decodeFloats": function() { return /* binding */ decodeFloats; },
/* harmony export */   "encodeSignedIntegers": function() { return /* binding */ encodeSignedIntegers; },
/* harmony export */   "decodeSignedIntegers": function() { return /* binding */ decodeSignedIntegers; },
/* harmony export */   "encodeUnsignedIntegers": function() { return /* binding */ encodeUnsignedIntegers; },
/* harmony export */   "decodeUnsignedIntegers": function() { return /* binding */ decodeUnsignedIntegers; },
/* harmony export */   "encodeUnsignedInteger": function() { return /* binding */ encodeUnsignedInteger; }
/* harmony export */ });
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _TextFeature_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TextFeature.js */ "./build/wg/format/TextFeature.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _geom_flat_flip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/flat/flip.js */ "./build/wg/geom/flat/flip.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/SimpleGeometry.js */ "./build/wg/geom/SimpleGeometry.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/flat/inflate.js */ "./build/wg/geom/flat/inflate.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Feature.js */ "./build/wg/format/Feature.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/Polyline
 */












/**
 * @typedef {Object} Options
 * @property {number} [factor=1e5] The factor by which the coordinates values will be scaled.
 * @property {GeometryLayout} [geometryLayout='XY'] Layout of the
 * feature geometries created by the format reader.
 */

/**
 * @classdesc
 * Feature format for reading and writing data in the Encoded
 * Polyline Algorithm Format.
 *
 * When reading features, the coordinates are assumed to be in two dimensions
 * and in [latitude, longitude] order.
 *
 * As Polyline sources contain a single feature,
 * {@link module:wg/format/Polyline~Polyline#readFeatures} will return the
 * feature in an array.
 *
 * @api
 */

var Polyline =
/** @class */
function (_super) {
  __extends(Polyline, _super);
  /**
   * @param {Options} [opt_options] Optional configuration object.
   */


  function Polyline(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @type {import("../proj/Projection.js").default}
     */

    _this.dataProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:4326');
    /**
     * @private
     * @type {number}
     */

    _this.factor_ = options.factor ? options.factor : 1e5;
    /**
     * @private
     * @type {import("../geom/GeometryLayout").default}
     */

    _this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__["default"].XY;
    return _this;
  }
  /**
   * @protected
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @return {import("../Feature.js").default} Feature.
   */


  Polyline.prototype.readFeatureFromText = function (text, opt_options) {
    var geometry = this.readGeometryFromText(text, opt_options);
    return new _Feature_js__WEBPACK_IMPORTED_MODULE_2__["default"](geometry);
  };
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */


  Polyline.prototype.readFeaturesFromText = function (text, opt_options) {
    var feature = this.readFeatureFromText(text, opt_options);
    return [feature];
  };
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */


  Polyline.prototype.readGeometryFromText = function (text, opt_options) {
    var stride = (0,_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_3__.getStrideForLayout)(this.geometryLayout_);
    var flatCoordinates = decodeDeltas(text, stride, this.factor_);
    (0,_geom_flat_flip_js__WEBPACK_IMPORTED_MODULE_4__.flipXY)(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
    var coordinates = (0,_geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_5__.inflateCoordinates)(flatCoordinates, 0, flatCoordinates.length, stride);
    var lineString = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__["default"](coordinates, this.geometryLayout_);
    return (0,_Feature_js__WEBPACK_IMPORTED_MODULE_7__.transformGeometryWithOptions)(lineString, false, this.adaptOptions(opt_options));
  };
  /**
   * @param {import("../Feature.js").default<LineString>} feature Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @protected
   * @return {string} Text.
   */


  Polyline.prototype.writeFeatureText = function (feature, opt_options) {
    var geometry = feature.getGeometry();

    if (geometry) {
      return this.writeGeometryText(geometry, opt_options);
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_8__.assert)(false, 40); // Expected `feature` to have a geometry

      return '';
    }
  };
  /**
   * @param {Array<import("../Feature.js").default<LineString>>} features Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @protected
   * @return {string} Text.
   */


  Polyline.prototype.writeFeaturesText = function (features, opt_options) {
    return this.writeFeatureText(features[0], opt_options);
  };
  /**
   * @param {LineString} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @protected
   * @return {string} Text.
   */


  Polyline.prototype.writeGeometryText = function (geometry, opt_options) {
    geometry =
    /** @type {LineString} */
    (0,_Feature_js__WEBPACK_IMPORTED_MODULE_7__.transformGeometryWithOptions)(geometry, true, this.adaptOptions(opt_options));
    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    (0,_geom_flat_flip_js__WEBPACK_IMPORTED_MODULE_4__.flipXY)(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
    return encodeDeltas(flatCoordinates, stride, this.factor_);
  };

  return Polyline;
}(_TextFeature_js__WEBPACK_IMPORTED_MODULE_9__["default"]);
/**
 * Encode a list of n-dimensional points and return an encoded string
 *
 * Attention: This function will modify the passed array!
 *
 * @param {Array<number>} numbers A list of n-dimensional points.
 * @param {number} stride The number of dimension of the points in the list.
 * @param {number} [opt_factor] The factor by which the numbers will be
 *     multiplied. The remaining decimal places will get rounded away.
 *     Default is `1e5`.
 * @return {string} The encoded string.
 * @api
 */


function encodeDeltas(numbers, stride, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;
  var d;
  var lastNumbers = new Array(stride);

  for (d = 0; d < stride; ++d) {
    lastNumbers[d] = 0;
  }

  for (var i = 0, ii = numbers.length; i < ii;) {
    for (d = 0; d < stride; ++d, ++i) {
      var num = numbers[i];
      var delta = num - lastNumbers[d];
      lastNumbers[d] = num;
      numbers[i] = delta;
    }
  }

  return encodeFloats(numbers, factor);
}
/**
 * Decode a list of n-dimensional points from an encoded string
 *
 * @param {string} encoded An encoded string.
 * @param {number} stride The number of dimension of the points in the
 *     encoded string.
 * @param {number} [opt_factor] The factor by which the resulting numbers will
 *     be divided. Default is `1e5`.
 * @return {Array<number>} A list of n-dimensional points.
 * @api
 */

function decodeDeltas(encoded, stride, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;
  var d;
  /** @type {Array<number>} */

  var lastNumbers = new Array(stride);

  for (d = 0; d < stride; ++d) {
    lastNumbers[d] = 0;
  }

  var numbers = decodeFloats(encoded, factor);

  for (var i = 0, ii = numbers.length; i < ii;) {
    for (d = 0; d < stride; ++d, ++i) {
      lastNumbers[d] += numbers[i];
      numbers[i] = lastNumbers[d];
    }
  }

  return numbers;
}
/**
 * Encode a list of floating point numbers and return an encoded string
 *
 * Attention: This function will modify the passed array!
 *
 * @param {Array<number>} numbers A list of floating point numbers.
 * @param {number} [opt_factor] The factor by which the numbers will be
 *     multiplied. The remaining decimal places will get rounded away.
 *     Default is `1e5`.
 * @return {string} The encoded string.
 * @api
 */

function encodeFloats(numbers, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;

  for (var i = 0, ii = numbers.length; i < ii; ++i) {
    numbers[i] = Math.round(numbers[i] * factor);
  }

  return encodeSignedIntegers(numbers);
}
/**
 * Decode a list of floating point numbers from an encoded string
 *
 * @param {string} encoded An encoded string.
 * @param {number} [opt_factor] The factor by which the result will be divided.
 *     Default is `1e5`.
 * @return {Array<number>} A list of floating point numbers.
 * @api
 */

function decodeFloats(encoded, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;
  var numbers = decodeSignedIntegers(encoded);

  for (var i = 0, ii = numbers.length; i < ii; ++i) {
    numbers[i] /= factor;
  }

  return numbers;
}
/**
 * Encode a list of signed integers and return an encoded string
 *
 * Attention: This function will modify the passed array!
 *
 * @param {Array<number>} numbers A list of signed integers.
 * @return {string} The encoded string.
 */

function encodeSignedIntegers(numbers) {
  for (var i = 0, ii = numbers.length; i < ii; ++i) {
    var num = numbers[i];
    numbers[i] = num < 0 ? ~(num << 1) : num << 1;
  }

  return encodeUnsignedIntegers(numbers);
}
/**
 * Decode a list of signed integers from an encoded string
 *
 * @param {string} encoded An encoded string.
 * @return {Array<number>} A list of signed integers.
 */

function decodeSignedIntegers(encoded) {
  var numbers = decodeUnsignedIntegers(encoded);

  for (var i = 0, ii = numbers.length; i < ii; ++i) {
    var num = numbers[i];
    numbers[i] = num & 1 ? ~(num >> 1) : num >> 1;
  }

  return numbers;
}
/**
 * Encode a list of unsigned integers and return an encoded string
 *
 * @param {Array<number>} numbers A list of unsigned integers.
 * @return {string} The encoded string.
 */

function encodeUnsignedIntegers(numbers) {
  var encoded = '';

  for (var i = 0, ii = numbers.length; i < ii; ++i) {
    encoded += encodeUnsignedInteger(numbers[i]);
  }

  return encoded;
}
/**
 * Decode a list of unsigned integers from an encoded string
 *
 * @param {string} encoded An encoded string.
 * @return {Array<number>} A list of unsigned integers.
 */

function decodeUnsignedIntegers(encoded) {
  var numbers = [];
  var current = 0;
  var shift = 0;

  for (var i = 0, ii = encoded.length; i < ii; ++i) {
    var b = encoded.charCodeAt(i) - 63;
    current |= (b & 0x1f) << shift;

    if (b < 0x20) {
      numbers.push(current);
      current = 0;
      shift = 0;
    } else {
      shift += 5;
    }
  }

  return numbers;
}
/**
 * Encode one single unsigned integer and return an encoded string
 *
 * @param {number} num Unsigned integer that should be encoded.
 * @return {string} The encoded string.
 */

function encodeUnsignedInteger(num) {
  var value,
      encoded = '';

  while (num >= 0x20) {
    value = (0x20 | num & 0x1f) + 63;
    encoded += String.fromCharCode(value);
    num >>= 5;
  }

  value = num + 63;
  encoded += String.fromCharCode(value);
  return encoded;
}
/* harmony default export */ __webpack_exports__["default"] = (Polyline);

/***/ }),

/***/ "./build/wg/format/TextFeature.js":
/*!****************************************!*\
  !*** ./build/wg/format/TextFeature.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _format_Feature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../format/Feature.js */ "./build/wg/format/Feature.js");
/* harmony import */ var _format_FormatType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../format/FormatType.js */ "./build/wg/format/FormatType.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/TextFeature
 */





/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for text feature formats.
 *
 * @abstract
 */

var TextFeature =
/** @class */
function (_super) {
  __extends(TextFeature, _super);

  function TextFeature() {
    return _super.call(this) || this;
  }
  /**
   * @return {import("./FormatType.js").default} Format.
   */


  TextFeature.prototype.getType = function () {
    return _format_FormatType_js__WEBPACK_IMPORTED_MODULE_0__["default"].TEXT;
  };
  /**
   * Read the feature from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */


  TextFeature.prototype.readFeature = function (source, opt_options) {
    return this.readFeatureFromText(getText(source), this.adaptOptions(opt_options));
  };
  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */


  TextFeature.prototype.readFeatureFromText = function (text, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Read the features from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */


  TextFeature.prototype.readFeatures = function (source, opt_options) {
    return this.readFeaturesFromText(getText(source), this.adaptOptions(opt_options));
  };
  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */


  TextFeature.prototype.readFeaturesFromText = function (text, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Read the geometry from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */


  TextFeature.prototype.readGeometry = function (source, opt_options) {
    return this.readGeometryFromText(getText(source), this.adaptOptions(opt_options));
  };
  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */


  TextFeature.prototype.readGeometryFromText = function (text, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   * @api
   */


  TextFeature.prototype.readProjection = function (source) {
    return this.readProjectionFromText(getText(source));
  };
  /**
   * @param {string} text Text.
   * @protected
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */


  TextFeature.prototype.readProjectionFromText = function (text) {
    return this.dataProjection;
  };
  /**
   * Encode a feature as a string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {string} Encoded feature.
   * @api
   */


  TextFeature.prototype.writeFeature = function (feature, opt_options) {
    return this.writeFeatureText(feature, this.adaptOptions(opt_options));
  };
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @protected
   * @return {string} Text.
   */


  TextFeature.prototype.writeFeatureText = function (feature, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {string} Encoded features.
   * @api
   */


  TextFeature.prototype.writeFeatures = function (features, opt_options) {
    return this.writeFeaturesText(features, this.adaptOptions(opt_options));
  };
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @protected
   * @return {string} Text.
   */


  TextFeature.prototype.writeFeaturesText = function (features, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Write a single geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {string} Geometry.
   * @api
   */


  TextFeature.prototype.writeGeometry = function (geometry, opt_options) {
    return this.writeGeometryText(geometry, this.adaptOptions(opt_options));
  };
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @protected
   * @return {string} Text.
   */


  TextFeature.prototype.writeGeometryText = function (geometry, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };

  return TextFeature;
}(_format_Feature_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @param {Document|Element|Object|string} source Source.
 * @return {string} Text.
 */


function getText(source) {
  if (typeof source === 'string') {
    return source;
  } else {
    return '';
  }
}

/* harmony default export */ __webpack_exports__["default"] = (TextFeature);

/***/ }),

/***/ "./build/wg/format/TopoJSON.js":
/*!*************************************!*\
  !*** ./build/wg/format/TopoJSON.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _JSONFeature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./JSONFeature.js */ "./build/wg/format/JSONFeature.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./build/wg/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./build/wg/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./build/wg/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Feature.js */ "./build/wg/format/Feature.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/TopoJSON
 */












/**
 * @typedef {import("topojson-specification").Topology} TopoJSONTopology
 * @typedef {import("topojson-specification").GeometryCollection} TopoJSONGeometryCollection
 * @typedef {import("topojson-specification").GeometryObject} TopoJSONGeometry
 * @typedef {import("topojson-specification").Point} TopoJSONPoint
 * @typedef {import("topojson-specification").MultiPoint} TopoJSONMultiPoint
 * @typedef {import("topojson-specification").LineString} TopoJSONLineString
 * @typedef {import("topojson-specification").MultiLineString} TopoJSONMultiLineString
 * @typedef {import("topojson-specification").Polygon} TopoJSONPolygon
 * @typedef {import("topojson-specification").MultiPolygon} TopoJSONMultiPolygon
 */

/**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
 * @property {string} [layerName] Set the name of the TopoJSON topology
 * `objects`'s children as feature property with the specified name. This means
 * that when set to `'layer'`, a topology like
 * ```
 * {
 *   "type": "Topology",
 *   "objects": {
 *     "example": {
 *       "type": "GeometryCollection",
 *       "geometries": []
 *     }
 *   }
 * }
 * ```
 * will result in features that have a property `'layer'` set to `'example'`.
 * When not set, no property will be added to features.
 * @property {Array<string>} [layers] Names of the TopoJSON topology's
 * `objects`'s children to read features from.  If not provided, features will
 * be read from all children.
 */

/**
 * @classdesc
 * Feature format for reading data in the TopoJSON format.
 *
 * @api
 */

var TopoJSON =
/** @class */
function (_super) {
  __extends(TopoJSON, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function TopoJSON(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @private
     * @type {string|undefined}
     */

    _this.layerName_ = options.layerName;
    /**
     * @private
     * @type {?Array<string>}
     */

    _this.layers_ = options.layers ? options.layers : null;
    /**
     * @type {import("../proj/Projection.js").default}
     */

    _this.dataProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.dataProjection ? options.dataProjection : 'EPSG:4326');
    return _this;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */


  TopoJSON.prototype.readFeaturesFromObject = function (object, opt_options) {
    if (object.type == 'Topology') {
      var topoJSONTopology =
      /** @type {TopoJSONTopology} */
      object;
      var transform = void 0,
          scale = null,
          translate = null;

      if (topoJSONTopology['transform']) {
        transform = topoJSONTopology['transform'];
        scale = transform['scale'];
        translate = transform['translate'];
      }

      var arcs = topoJSONTopology['arcs'];

      if (transform) {
        transformArcs(arcs, scale, translate);
      }
      /** @type {Array<Feature>} */


      var features = [];
      var topoJSONFeatures = topoJSONTopology['objects'];
      var property = this.layerName_;
      var feature = void 0;

      for (var objectName in topoJSONFeatures) {
        if (this.layers_ && this.layers_.indexOf(objectName) == -1) {
          continue;
        }

        if (topoJSONFeatures[objectName].type === 'GeometryCollection') {
          feature =
          /** @type {TopoJSONGeometryCollection} */
          topoJSONFeatures[objectName];
          features.push.apply(features, readFeaturesFromGeometryCollection(feature, arcs, scale, translate, property, objectName, opt_options));
        } else {
          feature =
          /** @type {TopoJSONGeometry} */
          topoJSONFeatures[objectName];
          features.push(readFeatureFromGeometry(feature, arcs, scale, translate, property, objectName, opt_options));
        }
      }

      return features;
    } else {
      return [];
    }
  };
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */


  TopoJSON.prototype.readProjectionFromObject = function (object) {
    return this.dataProjection;
  };

  return TopoJSON;
}(_JSONFeature_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @const
 * @type {Object<string, function(TopoJSONGeometry, Array, ...Array=): import("../geom/Geometry.js").default>}
 */


var GEOMETRY_READERS = {
  'Point': readPointGeometry,
  'LineString': readLineStringGeometry,
  'Polygon': readPolygonGeometry,
  'MultiPoint': readMultiPointGeometry,
  'MultiLineString': readMultiLineStringGeometry,
  'MultiPolygon': readMultiPolygonGeometry
};
/**
 * Concatenate arcs into a coordinate array.
 * @param {Array<number>} indices Indices of arcs to concatenate.  Negative
 *     values indicate arcs need to be reversed.
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs (already
 *     transformed).
 * @return {Array<import("../coordinate.js").Coordinate>} Coordinates array.
 */

function concatenateArcs(indices, arcs) {
  /** @type {Array<import("../coordinate.js").Coordinate>} */
  var coordinates = [];
  var index;

  for (var i = 0, ii = indices.length; i < ii; ++i) {
    index = indices[i];

    if (i > 0) {
      // splicing together arcs, discard last point
      coordinates.pop();
    }

    if (index >= 0) {
      // forward arc
      var arc = arcs[index];

      for (var j = 0, jj = arc.length; j < jj; ++j) {
        coordinates.push(arc[j].slice(0));
      }
    } else {
      // reverse arc
      var arc = arcs[~index];

      for (var j = arc.length - 1; j >= 0; --j) {
        coordinates.push(arc[j].slice(0));
      }
    }
  }

  return coordinates;
}
/**
 * Create a point from a TopoJSON geometry object.
 *
 * @param {TopoJSONPoint} object TopoJSON object.
 * @param {Array<number>} scale Scale for each dimension.
 * @param {Array<number>} translate Translation for each dimension.
 * @return {Point} Geometry.
 */


function readPointGeometry(object, scale, translate) {
  var coordinates = object['coordinates'];

  if (scale && translate) {
    transformVertex(coordinates, scale, translate);
  }

  return new _geom_Point_js__WEBPACK_IMPORTED_MODULE_2__["default"](coordinates);
}
/**
 * Create a multi-point from a TopoJSON geometry object.
 *
 * @param {TopoJSONMultiPoint} object TopoJSON object.
 * @param {Array<number>} scale Scale for each dimension.
 * @param {Array<number>} translate Translation for each dimension.
 * @return {MultiPoint} Geometry.
 */


function readMultiPointGeometry(object, scale, translate) {
  var coordinates = object['coordinates'];

  if (scale && translate) {
    for (var i = 0, ii = coordinates.length; i < ii; ++i) {
      transformVertex(coordinates[i], scale, translate);
    }
  }

  return new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_3__["default"](coordinates);
}
/**
 * Create a linestring from a TopoJSON geometry object.
 *
 * @param {TopoJSONLineString} object TopoJSON object.
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
 * @return {LineString} Geometry.
 */


function readLineStringGeometry(object, arcs) {
  var coordinates = concatenateArcs(object['arcs'], arcs);
  return new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_4__["default"](coordinates);
}
/**
 * Create a multi-linestring from a TopoJSON geometry object.
 *
 * @param {TopoJSONMultiLineString} object TopoJSON object.
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
 * @return {MultiLineString} Geometry.
 */


function readMultiLineStringGeometry(object, arcs) {
  var coordinates = [];

  for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {
    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);
  }

  return new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_5__["default"](coordinates);
}
/**
 * Create a polygon from a TopoJSON geometry object.
 *
 * @param {TopoJSONPolygon} object TopoJSON object.
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
 * @return {Polygon} Geometry.
 */


function readPolygonGeometry(object, arcs) {
  var coordinates = [];

  for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {
    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);
  }

  return new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_6__["default"](coordinates);
}
/**
 * Create a multi-polygon from a TopoJSON geometry object.
 *
 * @param {TopoJSONMultiPolygon} object TopoJSON object.
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
 * @return {MultiPolygon} Geometry.
 */


function readMultiPolygonGeometry(object, arcs) {
  var coordinates = [];

  for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {
    // for each polygon
    var polyArray = object['arcs'][i];
    var ringCoords = [];

    for (var j = 0, jj = polyArray.length; j < jj; ++j) {
      // for each ring
      ringCoords[j] = concatenateArcs(polyArray[j], arcs);
    }

    coordinates[i] = ringCoords;
  }

  return new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_7__["default"](coordinates);
}
/**
 * Create features from a TopoJSON GeometryCollection object.
 *
 * @param {TopoJSONGeometryCollection} collection TopoJSON Geometry
 *     object.
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
 * @param {Array<number>} scale Scale for each dimension.
 * @param {Array<number>} translate Translation for each dimension.
 * @param {string|undefined} property Property to set the `GeometryCollection`'s parent
 *     object to.
 * @param {string} name Name of the `Topology`'s child object.
 * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
 * @return {Array<Feature>} Array of features.
 */


function readFeaturesFromGeometryCollection(collection, arcs, scale, translate, property, name, opt_options) {
  var geometries = collection['geometries'];
  var features = [];

  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    features[i] = readFeatureFromGeometry(geometries[i], arcs, scale, translate, property, name, opt_options);
  }

  return features;
}
/**
 * Create a feature from a TopoJSON geometry object.
 *
 * @param {TopoJSONGeometry} object TopoJSON geometry object.
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
 * @param {Array<number>} scale Scale for each dimension.
 * @param {Array<number>} translate Translation for each dimension.
 * @param {string|undefined} property Property to set the `GeometryCollection`'s parent
 *     object to.
 * @param {string} name Name of the `Topology`'s child object.
 * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
 * @return {Feature} Feature.
 */


function readFeatureFromGeometry(object, arcs, scale, translate, property, name, opt_options) {
  var geometry = null;
  var type = object.type;

  if (type) {
    var geometryReader = GEOMETRY_READERS[type];

    if (type === 'Point' || type === 'MultiPoint') {
      geometry = geometryReader(object, scale, translate);
    } else {
      geometry = geometryReader(object, arcs);
    }

    geometry = (0,_Feature_js__WEBPACK_IMPORTED_MODULE_8__.transformGeometryWithOptions)(geometry, false, opt_options);
  }

  var feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
    geometry: geometry
  });

  if (object.id !== undefined) {
    feature.setId(object.id);
  }

  var properties = object.properties;

  if (property) {
    if (!properties) {
      properties = {};
    }

    properties[property] = name;
  }

  if (properties) {
    feature.setProperties(properties, true);
  }

  return feature;
}
/**
 * Apply a linear transform to array of arcs.  The provided array of arcs is
 * modified in place.
 *
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
 * @param {Array<number>} scale Scale for each dimension.
 * @param {Array<number>} translate Translation for each dimension.
 */


function transformArcs(arcs, scale, translate) {
  for (var i = 0, ii = arcs.length; i < ii; ++i) {
    transformArc(arcs[i], scale, translate);
  }
}
/**
 * Apply a linear transform to an arc.  The provided arc is modified in place.
 *
 * @param {Array<import("../coordinate.js").Coordinate>} arc Arc.
 * @param {Array<number>} scale Scale for each dimension.
 * @param {Array<number>} translate Translation for each dimension.
 */


function transformArc(arc, scale, translate) {
  var x = 0;
  var y = 0;

  for (var i = 0, ii = arc.length; i < ii; ++i) {
    var vertex = arc[i];
    x += vertex[0];
    y += vertex[1];
    vertex[0] = x;
    vertex[1] = y;
    transformVertex(vertex, scale, translate);
  }
}
/**
 * Apply a linear transform to a vertex.  The provided vertex is modified in
 * place.
 *
 * @param {import("../coordinate.js").Coordinate} vertex Vertex.
 * @param {Array<number>} scale Scale for each dimension.
 * @param {Array<number>} translate Translation for each dimension.
 */


function transformVertex(vertex, scale, translate) {
  vertex[0] = vertex[0] * scale[0] + translate[0];
  vertex[1] = vertex[1] * scale[1] + translate[1];
}

/* harmony default export */ __webpack_exports__["default"] = (TopoJSON);

/***/ }),

/***/ "./build/wg/format/WFS.js":
/*!********************************!*\
  !*** ./build/wg/format/WFS.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "writeFilter": function() { return /* binding */ writeFilter; }
/* harmony export */ });
/* harmony import */ var _GML2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GML2.js */ "./build/wg/format/GML2.js");
/* harmony import */ var _GML3_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GML3.js */ "./build/wg/format/GML3.js");
/* harmony import */ var _GML32_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GML32.js */ "./build/wg/format/GML32.js");
/* harmony import */ var _GMLBase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GMLBase.js */ "./build/wg/format/GMLBase.js");
/* harmony import */ var _XMLFeature_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./XMLFeature.js */ "./build/wg/format/XMLFeature.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../xml.js */ "./build/wg/xml.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./filter.js */ "./build/wg/format/filter.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./xsd.js */ "./build/wg/format/xsd.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/WFS
 */













/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

var FEATURE_COLLECTION_PARSERS = {
  'http://www.opengis.net/gml': {
    'boundedBy': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readGeometryElement, 'bounds')
  },
  'http://www.opengis.net/wfs/2.0': {
    'member': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readFeaturesInternal)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

var TRANSACTION_SUMMARY_PARSERS = {
  'http://www.opengis.net/wfs': {
    'totalInserted': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readPositiveInteger),
    'totalUpdated': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readPositiveInteger),
    'totalDeleted': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readPositiveInteger)
  },
  'http://www.opengis.net/wfs/2.0': {
    'totalInserted': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readPositiveInteger),
    'totalUpdated': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readPositiveInteger),
    'totalDeleted': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readPositiveInteger)
  }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */

var TRANSACTION_RESPONSE_PARSERS = {
  'http://www.opengis.net/wfs': {
    'TransactionSummary': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(readTransactionSummary, 'transactionSummary'),
    'InsertResults': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(readInsertResults, 'insertIds')
  },
  'http://www.opengis.net/wfs/2.0': {
    'TransactionSummary': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(readTransactionSummary, 'transactionSummary'),
    'InsertResults': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeObjectPropertySetter)(readInsertResults, 'insertIds')
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

var QUERY_SERIALIZERS = {
  'http://www.opengis.net/wfs': {
    'PropertyName': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode)
  },
  'http://www.opengis.net/wfs/2.0': {
    'PropertyName': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode)
  }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */

var TRANSACTION_SERIALIZERS = {
  'http://www.opengis.net/wfs': {
    'Insert': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeFeature),
    'Update': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeUpdate),
    'Delete': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeDelete),
    'Property': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeProperty),
    'Native': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeNative)
  },
  'http://www.opengis.net/wfs/2.0': {
    'Insert': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeFeature),
    'Update': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeUpdate),
    'Delete': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeDelete),
    'Property': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeProperty),
    'Native': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeNative)
  }
};
/**
 * @typedef {Object} Options
 * @property {Object<string, string>|string} [featureNS] The namespace URI used for features.
 * @property {Array<string>|string} [featureType] The feature type to parse. Only used for read operations.
 * @property {GMLBase} [gmlFormat] The GML format to use to parse the response.
 * Default is `ol/format/GML2` for WFS 1.0.0, `ol/format/GML3` for WFS 1.1.0 and `ol/format/GML32` for WFS 2.0.0.
 * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.
 * @property {string} [version='1.1.0'] WFS version to use. Can be either `1.0.0`, `1.1.0` or `2.0.0`.
 */

/**
 * @typedef {Object} WriteGetFeatureOptions
 * @property {string} featureNS The namespace URI used for features.
 * @property {string} featurePrefix The prefix for the feature namespace.
 * @property {Array<string|FeatureType>} featureTypes The feature type names or FeatureType objects to
 * define a unique bbox filter per feature type name (in this case, options `bbox` and `geometryName` are
 * ignored.).
 * @property {string} [srsName] SRS name. No srsName attribute will be set on
 * geometries when this is not provided.
 * @property {string} [handle] Handle.
 * @property {string} [outputFormat] Output format.
 * @property {number} [maxFeatures] Maximum number of features to fetch.
 * @property {string} [geometryName] Geometry name to use in a BBOX filter.
 * @property {Array<string>} [propertyNames] Optional list of property names to serialize.
 * @property {string} [viewParams] viewParams GeoServer vendor parameter.
 * @property {number} [startIndex] Start index to use for WFS paging. This is a
 * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.
 * @property {number} [count] Number of features to retrieve when paging. This is a
 * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some
 * Web Feature Services have repurposed `maxfeatures` instead.
 * @property {import("../extent.js").Extent} [bbox] Extent to use for the BBOX filter. The `geometryName`
 * option must be set.
 * @property {import("./filter/Filter.js").default} [filter] Filter condition. See
 * {@link module:wg/format/filter} for more information.
 * @property {string} [resultType] Indicates what response should be returned,
 * e.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.
 */

/**
 * @typedef {Object} FeatureType
 * @property {!string} name The feature type name.
 * @property {!import("../extent.js").Extent} bbox Extent to use for the BBOX filter.
 * @property {!string} geometryName Geometry name to use in the BBOX filter.
 */

/**
 * @typedef {Object} WriteTransactionOptions
 * @property {string} featureNS The namespace URI used for features.
 * @property {string} featurePrefix The prefix for the feature namespace.
 * @property {string} featureType The feature type name.
 * @property {string} [srsName] SRS name. No srsName attribute will be set on
 * geometries when this is not provided.
 * @property {string} [handle] Handle.
 * @property {boolean} [hasZ] Must be set to true if the transaction is for
 * a 3D layer. This will allow the Z coordinate to be included in the transaction.
 * @property {Array<Object>} nativeElements Native elements. Currently not supported.
 * @property {import("./GMLBase.js").Options} [gmlOptions] GML options for the WFS transaction writer.
 * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0`, `1.1.0` or `2.0.0`.
 */

/**
 * Number of features; bounds/extent.
 * @typedef {Object} FeatureCollectionMetadata
 * @property {number} numberOfFeatures NumberOfFeatures.
 * @property {import("../extent.js").Extent} bounds Bounds.
 */

/**
 * Total deleted; total inserted; total updated; array of insert ids.
 * @typedef {Object} TransactionResponse
 * @property {number} totalDeleted TotalDeleted.
 * @property {number} totalInserted TotalInserted.
 * @property {number} totalUpdated TotalUpdated.
 * @property {Array<string>} insertIds InsertIds.
 */

/**
 * @type {string}
 */

var FEATURE_PREFIX = 'feature';
/**
 * @type {string}
 */

var XMLNS = 'http://www.w3.org/2000/xmlns/';
/**
 * @type {Object<string, string>}
 */

var OGCNS = {
  '2.0.0': 'http://www.opengis.net/ogc/1.1',
  '1.1.0': 'http://www.opengis.net/ogc',
  '1.0.0': 'http://www.opengis.net/ogc'
};
/**
 * @type {Object<string, string>}
 */

var WFSNS = {
  '2.0.0': 'http://www.opengis.net/wfs/2.0',
  '1.1.0': 'http://www.opengis.net/wfs',
  '1.0.0': 'http://www.opengis.net/wfs'
};
/**
 * @type {Object<string, string>}
 */

var FESNS = {
  '2.0.0': 'http://www.opengis.net/fes/2.0',
  '1.1.0': 'http://www.opengis.net/fes',
  '1.0.0': 'http://www.opengis.net/fes'
};
/**
 * @type {Object<string, string>}
 */

var SCHEMA_LOCATIONS = {
  '2.0.0': 'http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd',
  '1.1.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',
  '1.0.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd'
};
/**
 * @type {Object<string, object>}
 */

var GML_FORMATS = {
  '2.0.0': _GML32_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  '1.1.0': _GML3_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  '1.0.0': _GML2_js__WEBPACK_IMPORTED_MODULE_6__["default"]
};
/**
 * @const
 * @type {string}
 */

var DEFAULT_VERSION = '1.1.0';
/**
 * @classdesc
 * Feature format for reading and writing data in the WFS format.
 * By default, supports WFS version 1.1.0. You can pass a GML format
 * as option to override the default.
 * Also see {@link module:wg/format/GMLBase~GMLBase} which is used by this format.
 *
 * @api
 */

var WFS =
/** @class */
function (_super) {
  __extends(WFS, _super);
  /**
   * @param {Options} [opt_options] Optional configuration object.
   */


  function WFS(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @private
     * @type {string}
     */

    _this.version_ = options.version ? options.version : DEFAULT_VERSION;
    /**
     * @private
     * @type {Array<string>|string|undefined}
     */

    _this.featureType_ = options.featureType;
    /**
     * @private
     * @type {Object<string, string>|string|undefined}
     */

    _this.featureNS_ = options.featureNS;
    /**
     * @private
     * @type {GMLBase}
     */

    _this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new GML_FORMATS[_this.version_]();
    /**
     * @private
     * @type {string}
     */

    _this.schemaLocation_ = options.schemaLocation ? options.schemaLocation : SCHEMA_LOCATIONS[_this.version_];
    return _this;
  }
  /**
   * @return {Array<string>|string|undefined} featureType
   */


  WFS.prototype.getFeatureType = function () {
    return this.featureType_;
  };
  /**
   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.
   */


  WFS.prototype.setFeatureType = function (featureType) {
    this.featureType_ = featureType;
  };
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */


  WFS.prototype.readFeaturesFromNode = function (node, opt_options) {
    /** @type {import("../xml.js").NodeStackItem} */
    var context = {
      node: node
    };
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.assign)(context, {
      'featureType': this.featureType_,
      'featureNS': this.featureNS_
    });
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.assign)(context, this.getReadOptions(node, opt_options ? opt_options : {}));
    var objectStack = [context];
    var featuresNS;

    if (this.version_ === '2.0.0') {
      featuresNS = FEATURE_COLLECTION_PARSERS;
    } else {
      featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
    }

    var features = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)([], featuresNS, node, objectStack, this.gmlFormat_);

    if (!features) {
      features = [];
    }

    return features;
  };
  /**
   * Read transaction response of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {TransactionResponse|undefined} Transaction response.
   * @api
   */


  WFS.prototype.readTransactionResponse = function (source) {
    if (!source) {
      return undefined;
    } else if (typeof source === 'string') {
      var doc = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.parse)(source);
      return this.readTransactionResponseFromDocument(doc);
    } else if ((0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.isDocument)(source)) {
      return this.readTransactionResponseFromDocument(
      /** @type {Document} */
      source);
    } else {
      return this.readTransactionResponseFromNode(
      /** @type {Element} */
      source);
    }
  };
  /**
   * Read feature collection metadata of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   * @api
   */


  WFS.prototype.readFeatureCollectionMetadata = function (source) {
    if (!source) {
      return undefined;
    } else if (typeof source === 'string') {
      var doc = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.parse)(source);
      return this.readFeatureCollectionMetadataFromDocument(doc);
    } else if ((0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.isDocument)(source)) {
      return this.readFeatureCollectionMetadataFromDocument(
      /** @type {Document} */
      source);
    } else {
      return this.readFeatureCollectionMetadataFromNode(
      /** @type {Element} */
      source);
    }
  };
  /**
   * @param {Document} doc Document.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */


  WFS.prototype.readFeatureCollectionMetadataFromDocument = function (doc) {
    for (var n =
    /** @type {Node} */
    doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readFeatureCollectionMetadataFromNode(
        /** @type {Element} */
        n);
      }
    }

    return undefined;
  };
  /**
   * @param {Element} node Node.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */


  WFS.prototype.readFeatureCollectionMetadataFromNode = function (node) {
    var result = {};
    var value = (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readNonNegativeIntegerString)(node.getAttribute('numberOfFeatures'));
    result['numberOfFeatures'] = value;
    return (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)(
    /** @type {FeatureCollectionMetadata} */
    result, FEATURE_COLLECTION_PARSERS, node, [], this.gmlFormat_);
  };
  /**
   * @param {Document} doc Document.
   * @return {TransactionResponse|undefined} Transaction response.
   */


  WFS.prototype.readTransactionResponseFromDocument = function (doc) {
    for (var n =
    /** @type {Node} */
    doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readTransactionResponseFromNode(
        /** @type {Element} */
        n);
      }
    }

    return undefined;
  };
  /**
   * @param {Element} node Node.
   * @return {TransactionResponse|undefined} Transaction response.
   */


  WFS.prototype.readTransactionResponseFromNode = function (node) {
    return (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)(
    /** @type {TransactionResponse} */
    {}, TRANSACTION_RESPONSE_PARSERS, node, []);
  };
  /**
   * Encode format as WFS `GetFeature` and return the Node.
   *
   * @param {WriteGetFeatureOptions} options Options.
   * @return {Node} Result.
   * @api
   */


  WFS.prototype.writeGetFeature = function (options) {
    var _this = this;

    var node = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(WFSNS[this.version_], 'GetFeature');
    node.setAttribute('service', 'WFS');
    node.setAttribute('version', this.version_);

    if (options.handle) {
      node.setAttribute('handle', options.handle);
    }

    if (options.outputFormat) {
      node.setAttribute('outputFormat', options.outputFormat);
    }

    if (options.maxFeatures !== undefined) {
      node.setAttribute('maxFeatures', String(options.maxFeatures));
    }

    if (options.resultType) {
      node.setAttribute('resultType', options.resultType);
    }

    if (options.startIndex !== undefined) {
      node.setAttribute('startIndex', String(options.startIndex));
    }

    if (options.count !== undefined) {
      node.setAttribute('count', String(options.count));
    }

    if (options.viewParams !== undefined) {
      node.setAttribute('viewParams', options.viewParams);
    }

    node.setAttributeNS(_xml_js__WEBPACK_IMPORTED_MODULE_1__.XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation_);
    /** @type {import("../xml.js").NodeStackItem} */

    var context = {
      node: node
    };
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.assign)(context, {
      'version': this.version_,
      'srsName': options.srsName,
      'featureNS': options.featureNS ? options.featureNS : this.featureNS_,
      'featurePrefix': options.featurePrefix,
      'propertyNames': options.propertyNames ? options.propertyNames : []
    });
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_8__.assert)(Array.isArray(options.featureTypes), 11); // `options.featureTypes` must be an Array

    if (typeof options.featureTypes[0] === 'string') {
      var filter = options.filter;

      if (options.bbox) {
        (0,_asserts_js__WEBPACK_IMPORTED_MODULE_8__.assert)(options.geometryName, 12); // `options.geometryName` must also be provided when `options.bbox` is set

        filter = this.combineBboxAndFilter(options.geometryName, options.bbox, options.srsName, filter);
      }

      (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.assign)(context, {
        'geometryName': options.geometryName,
        'filter': filter
      });
      writeGetFeature(node,
      /** @type {!Array<string>} */
      options.featureTypes, [context]);
    } else {
      // Write one query node per element in featuresType.
      options.featureTypes.forEach(function (
      /** @type {FeatureType} */
      featureType) {
        var completeFilter = _this.combineBboxAndFilter(featureType.geometryName, featureType.bbox, options.srsName, options.filter);

        (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.assign)(context, {
          'geometryName': featureType.geometryName,
          'filter': completeFilter
        });
        writeGetFeature(node, [featureType.name], [context]);
      });
    }

    return node;
  };
  /**
   * Create a bbox filter and combine it with another optional filter.
   *
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../extent.js").Extent} extent Extent.
   * @param {string} [opt_srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   * @param {import("./filter/Filter.js").default} [opt_filter] Filter condition.
   * @return {import("./filter/Filter.js").default} The filter.
   */


  WFS.prototype.combineBboxAndFilter = function (geometryName, extent, opt_srsName, opt_filter) {
    var bboxFilter = (0,_filter_js__WEBPACK_IMPORTED_MODULE_9__.bbox)(geometryName, extent, opt_srsName);

    if (opt_filter) {
      // if bbox and filter are both set, combine the two into a single filter
      return (0,_filter_js__WEBPACK_IMPORTED_MODULE_9__.and)(opt_filter, bboxFilter);
    }

    return bboxFilter;
  };
  /**
   * Encode format as WFS `Transaction` and return the Node.
   *
   * @param {Array<import("../Feature.js").default>} inserts The features to insert.
   * @param {Array<import("../Feature.js").default>} updates The features to update.
   * @param {Array<import("../Feature.js").default>} deletes The features to delete.
   * @param {WriteTransactionOptions} options Write options.
   * @return {Node} Result.
   * @api
   */


  WFS.prototype.writeTransaction = function (inserts, updates, deletes, options) {
    var objectStack = [];
    var version = options.version ? options.version : this.version_;
    var node = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(WFSNS[version], 'Transaction');
    node.setAttribute('service', 'WFS');
    node.setAttribute('version', version);
    var baseObj;
    /** @type {import("../xml.js").NodeStackItem} */

    if (options) {
      baseObj = options.gmlOptions ? options.gmlOptions : {};

      if (options.handle) {
        node.setAttribute('handle', options.handle);
      }
    }

    node.setAttributeNS(_xml_js__WEBPACK_IMPORTED_MODULE_1__.XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', SCHEMA_LOCATIONS[version]);
    var request = createTransactionRequest(node, baseObj, version, options);

    if (inserts) {
      serializeTransactionRequest('Insert', inserts, objectStack, request);
    }

    if (updates) {
      serializeTransactionRequest('Update', updates, objectStack, request);
    }

    if (deletes) {
      serializeTransactionRequest('Delete', deletes, objectStack, request);
    }

    if (options.nativeElements) {
      serializeTransactionRequest('Native', options.nativeElements, objectStack, request);
    }

    return node;
  };
  /**
   * @param {Document} doc Document.
   * @return {import("../proj/Projection.js").default} Projection.
   */


  WFS.prototype.readProjectionFromDocument = function (doc) {
    for (var n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readProjectionFromNode(
        /** @type {Element} */
        n);
      }
    }

    return null;
  };
  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */


  WFS.prototype.readProjectionFromNode = function (node) {
    if (node.firstElementChild && node.firstElementChild.firstElementChild) {
      node = node.firstElementChild.firstElementChild;

      for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
        if (!(n.childNodes.length === 0 || n.childNodes.length === 1 && n.firstChild.nodeType === 3)) {
          var objectStack = [{}];
          this.gmlFormat_.readGeometryElement(n, objectStack);
          return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(objectStack.pop().srsName);
        }
      }
    }

    return null;
  };

  return WFS;
}(_XMLFeature_js__WEBPACK_IMPORTED_MODULE_10__["default"]);
/**
 * @param {Element} node Node.
 * @param {*} baseObj Base object.
 * @param {string} version Version.
 * @param {WriteTransactionOptions} options Options.
 * @return {Object} Request object.
 */


function createTransactionRequest(node, baseObj, version, options) {
  var featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;
  var gmlVersion;

  if (version === '1.0.0') {
    gmlVersion = 2;
  } else if (version === '1.1.0') {
    gmlVersion = 3;
  } else if (version === '2.0.0') {
    gmlVersion = 3.2;
  }

  var obj = (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.assign)({
    node: node
  }, {
    version: version,
    'featureNS': options.featureNS,
    'featureType': options.featureType,
    'featurePrefix': featurePrefix,
    'gmlVersion': gmlVersion,
    'hasZ': options.hasZ,
    'srsName': options.srsName
  }, baseObj);
  return obj;
}
/**
 * @param {string} type Request type.
 * @param {Array<import("../Feature.js").default>} features Features.
 * @param {Array<*>} objectStack Object stack.
 * @param {Element} request Transaction Request.
 */


function serializeTransactionRequest(type, features, objectStack, request) {
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushSerializeAndPop)(request, TRANSACTION_SERIALIZERS, (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleNodeFactory)(type), features, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Transaction Summary.
 */


function readTransactionSummary(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */


var OGC_FID_PARSERS = {
  'http://www.opengis.net/ogc': {
    'FeatureId': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(function (node, objectStack) {
      return node.getAttribute('fid');
    })
  },
  'http://www.opengis.net/ogc/1.1': {
    'FeatureId': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayPusher)(function (node, objectStack) {
      return node.getAttribute('fid');
    })
  }
};
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */

function fidParser(node, objectStack) {
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.parseNode)(OGC_FID_PARSERS, node, objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */


var INSERT_RESULTS_PARSERS = {
  'http://www.opengis.net/wfs': {
    'Feature': fidParser
  },
  'http://www.opengis.net/wfs/2.0': {
    'Feature': fidParser
  }
};
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<string>|undefined} Insert results.
 */

function readInsertResults(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushParseAndPop)([], INSERT_RESULTS_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {Array<*>} objectStack Node stack.
 */


function writeFeature(node, feature, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var featureType = context['featureType'];
  var featureNS = context['featureNS'];
  var gmlVersion = context['gmlVersion'];
  var child = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(featureNS, featureType);
  node.appendChild(child);

  if (gmlVersion === 2) {
    _GML2_js__WEBPACK_IMPORTED_MODULE_6__["default"].prototype.writeFeatureElement(child, feature, objectStack);
  } else if (gmlVersion === 3) {
    _GML3_js__WEBPACK_IMPORTED_MODULE_5__["default"].prototype.writeFeatureElement(child, feature, objectStack);
  } else {
    _GML32_js__WEBPACK_IMPORTED_MODULE_4__["default"].prototype.writeFeatureElement(child, feature, objectStack);
  }
}
/**
 * @param {Node} node Node.
 * @param {number|string} fid Feature identifier.
 * @param {Array<*>} objectStack Node stack.
 */


function writeOgcFidFilter(node, fid, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var version = context['version'];
  var ns = OGCNS[version];
  var filter = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(ns, 'Filter');
  var child = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(ns, 'FeatureId');
  filter.appendChild(child);
  child.setAttribute('fid',
  /** @type {string} */
  fid);
  node.appendChild(filter);
}
/**
 * @param {string|undefined} featurePrefix The prefix of the feature.
 * @param {string} featureType The type of the feature.
 * @return {string} The value of the typeName property.
 */


function getTypeName(featurePrefix, featureType) {
  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;
  var prefix = featurePrefix + ':'; // The featureType already contains the prefix.

  if (featureType.indexOf(prefix) === 0) {
    return featureType;
  } else {
    return prefix + featureType;
  }
}
/**
 * @param {Element} node Node.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {Array<*>} objectStack Node stack.
 */


function writeDelete(node, feature, objectStack) {
  var context = objectStack[objectStack.length - 1];
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_8__.assert)(feature.getId() !== undefined, 26); // Features must have an id set

  var featureType = context['featureType'];
  var featurePrefix = context['featurePrefix'];
  var featureNS = context['featureNS'];
  var typeName = getTypeName(featurePrefix, featureType);
  node.setAttribute('typeName', typeName);
  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);
  var fid = feature.getId();

  if (fid !== undefined) {
    writeOgcFidFilter(node, fid, objectStack);
  }
}
/**
 * @param {Element} node Node.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {Array<*>} objectStack Node stack.
 */


function writeUpdate(node, feature, objectStack) {
  var context = objectStack[objectStack.length - 1];
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_8__.assert)(feature.getId() !== undefined, 27); // Features must have an id set

  var version = context['version'];
  var featureType = context['featureType'];
  var featurePrefix = context['featurePrefix'];
  var featureNS = context['featureNS'];
  var typeName = getTypeName(featurePrefix, featureType);
  var geometryName = feature.getGeometryName();
  node.setAttribute('typeName', typeName);
  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);
  var fid = feature.getId();

  if (fid !== undefined) {
    var keys = feature.getKeys();
    var values = [];

    for (var i = 0, ii = keys.length; i < ii; i++) {
      var value = feature.get(keys[i]);

      if (value !== undefined) {
        var name_1 = keys[i];

        if (value && typeof
        /** @type {?} */
        value.getSimplifiedGeometry === 'function') {
          name_1 = geometryName;
        }

        values.push({
          name: name_1,
          value: value
        });
      }
    }

    (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushSerializeAndPop)(
    /** @type {import("../xml.js").NodeStackItem} */
    {
      version: version,
      'gmlVersion': context['gmlVersion'],
      node: node,
      'hasZ': context['hasZ'],
      'srsName': context['srsName']
    }, TRANSACTION_SERIALIZERS, (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleNodeFactory)('Property'), values, objectStack);
    writeOgcFidFilter(node, fid, objectStack);
  }
}
/**
 * @param {Node} node Node.
 * @param {Object} pair Property name and value.
 * @param {Array<*>} objectStack Node stack.
 */


function writeProperty(node, pair, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var version = context['version'];
  var ns = WFSNS[version];
  var name = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(ns, 'Name');
  var gmlVersion = context['gmlVersion'];
  node.appendChild(name);
  (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode)(name, pair.name);

  if (pair.value !== undefined && pair.value !== null) {
    var value = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(ns, 'Value');
    node.appendChild(value);

    if (pair.value && typeof
    /** @type {?} */
    pair.value.getSimplifiedGeometry === 'function') {
      if (gmlVersion === 2) {
        _GML2_js__WEBPACK_IMPORTED_MODULE_6__["default"].prototype.writeGeometryElement(value, pair.value, objectStack);
      } else if (gmlVersion === 3) {
        _GML3_js__WEBPACK_IMPORTED_MODULE_5__["default"].prototype.writeGeometryElement(value, pair.value, objectStack);
      } else {
        _GML32_js__WEBPACK_IMPORTED_MODULE_4__["default"].prototype.writeGeometryElement(value, pair.value, objectStack);
      }
    } else {
      (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode)(value, pair.value);
    }
  }
}
/**
 * @param {Element} node Node.
 * @param {{vendorId: string, safeToIgnore: boolean, value: string}} nativeElement The native element.
 * @param {Array<*>} objectStack Node stack.
 */


function writeNative(node, nativeElement, objectStack) {
  if (nativeElement.vendorId) {
    node.setAttribute('vendorId', nativeElement.vendorId);
  }

  if (nativeElement.safeToIgnore !== undefined) {
    node.setAttribute('safeToIgnore', String(nativeElement.safeToIgnore));
  }

  if (nativeElement.value !== undefined) {
    (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode)(node, nativeElement.value);
  }
}
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */


var GETFEATURE_SERIALIZERS = {
  'http://www.opengis.net/wfs': {
    'Query': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeQuery)
  },
  'http://www.opengis.net/wfs/2.0': {
    'Query': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeQuery)
  },
  'http://www.opengis.net/ogc': {
    'During': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeDuringFilter),
    'And': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeLogicalFilter),
    'Or': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeLogicalFilter),
    'Not': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeNotFilter),
    'BBOX': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeBboxFilter),
    'Contains': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeSpatialFilter),
    'Intersects': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeSpatialFilter),
    'Within': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeSpatialFilter),
    'DWithin': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeDWithinFilter),
    'PropertyIsEqualTo': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeComparisonFilter),
    'PropertyIsNotEqualTo': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeComparisonFilter),
    'PropertyIsLessThan': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeComparisonFilter),
    'PropertyIsLessThanOrEqualTo': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeComparisonFilter),
    'PropertyIsGreaterThan': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeComparisonFilter),
    'PropertyIsGreaterThanOrEqualTo': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeComparisonFilter),
    'PropertyIsNull': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeIsNullFilter),
    'PropertyIsBetween': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeIsBetweenFilter),
    'PropertyIsLike': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeIsLikeFilter)
  },
  'http://www.opengis.net/fes/2.0': {
    'During': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeDuringFilter),
    'And': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeLogicalFilter),
    'Or': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeLogicalFilter),
    'Not': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeNotFilter),
    'BBOX': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeBboxFilter),
    'Contains': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeSpatialFilter),
    'Disjoint': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeSpatialFilter),
    'Intersects': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeSpatialFilter),
    'ResourceId': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeResourceIdFilter),
    'Within': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeSpatialFilter),
    'DWithin': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeDWithinFilter),
    'PropertyIsEqualTo': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeComparisonFilter),
    'PropertyIsNotEqualTo': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeComparisonFilter),
    'PropertyIsLessThan': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeComparisonFilter),
    'PropertyIsLessThanOrEqualTo': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeComparisonFilter),
    'PropertyIsGreaterThan': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeComparisonFilter),
    'PropertyIsGreaterThanOrEqualTo': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeComparisonFilter),
    'PropertyIsNull': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeIsNullFilter),
    'PropertyIsBetween': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeIsBetweenFilter),
    'PropertyIsLike': (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeChildAppender)(writeIsLikeFilter)
  }
};
/**
 * @param {Element} node Node.
 * @param {string} featureType Feature type.
 * @param {Array<*>} objectStack Node stack.
 */

function writeQuery(node, featureType, objectStack) {
  var context =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var version = context['version'];
  var featurePrefix = context['featurePrefix'];
  var featureNS = context['featureNS'];
  var propertyNames = context['propertyNames'];
  var srsName = context['srsName'];
  var typeName; // If feature prefix is not defined, we must not use the default prefix.

  if (featurePrefix) {
    typeName = getTypeName(featurePrefix, featureType);
  } else {
    typeName = featureType;
  }

  var typeNameAttr;

  if (version === '2.0.0') {
    typeNameAttr = 'typeNames';
  } else {
    typeNameAttr = 'typeName';
  }

  node.setAttribute(typeNameAttr, typeName);

  if (srsName) {
    node.setAttribute('srsName', srsName);
  }

  if (featureNS) {
    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);
  }

  var item =
  /** @type {import("../xml.js").NodeStackItem} */
  (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.assign)({}, context);
  item.node = node;
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushSerializeAndPop)(item, QUERY_SERIALIZERS, (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleNodeFactory)('PropertyName'), propertyNames, objectStack);
  var filter = context['filter'];

  if (filter) {
    var child = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(getFilterNS(version), 'Filter');
    node.appendChild(child);
    writeFilterCondition(child, filter, objectStack);
  }
}
/**
 * @param {Element} node Node.
 * @param {import("./filter/Filter.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */


function writeFilterCondition(node, filter, objectStack) {
  var context =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  /** @type {import("../xml.js").NodeStackItem} */

  var item = {
    node: node
  };
  (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.assign)(item, {
    context: context
  });
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushSerializeAndPop)(item, GETFEATURE_SERIALIZERS, (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleNodeFactory)(filter.getTagName()), [filter], objectStack);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/Bbox.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */


function writeBboxFilter(node, filter, objectStack) {
  var parent =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var context = parent['context'];
  var version = context['version'];
  parent['srsName'] = filter.srsName;
  var format = GML_FORMATS[version];
  writePropertyName(version, node, filter.geometryName);
  format.prototype.writeGeometryElement(node, filter.extent, objectStack);
}
/**
 * @param {Element} node Element.
 * @param {import("./filter/ResourceId.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */


function writeResourceIdFilter(node, filter, objectStack) {
  node.setAttribute('rid',
  /** @type {string} */
  filter.rid);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/Spatial.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */


function writeSpatialFilter(node, filter, objectStack) {
  var parent =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var context = parent['context'];
  var version = context['version'];
  parent['srsName'] = filter.srsName;
  var format = GML_FORMATS[version];
  writePropertyName(version, node, filter.geometryName);
  format.prototype.writeGeometryElement(node, filter.geometry, objectStack);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/DWithin.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */


function writeDWithinFilter(node, filter, objectStack) {
  var parent =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var context = parent['context'];
  var version = context['version'];
  writeSpatialFilter(node, filter, objectStack);
  var distance = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(getFilterNS(version), 'Distance');
  (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode)(distance, filter.distance.toString());

  if (version === '2.0.0') {
    distance.setAttribute('uom', filter.unit);
  } else {
    distance.setAttribute('units', filter.unit);
  }

  node.appendChild(distance);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/During.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */


function writeDuringFilter(node, filter, objectStack) {
  var parent =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var context = parent['context'];
  var version = context['version'];
  writeExpression(FESNS[version], 'ValueReference', node, filter.propertyName);
  var timePeriod = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__.GMLNS, 'TimePeriod');
  node.appendChild(timePeriod);
  var begin = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__.GMLNS, 'begin');
  timePeriod.appendChild(begin);
  writeTimeInstant(begin, filter.begin);
  var end = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__.GMLNS, 'end');
  timePeriod.appendChild(end);
  writeTimeInstant(end, filter.end);
}
/**
 * @param {Element} node Node.
 * @param {import("./filter/LogicalNary.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */


function writeLogicalFilter(node, filter, objectStack) {
  var parent =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var context = parent['context'];
  /** @type {import("../xml.js").NodeStackItem} */

  var item = {
    node: node
  };
  (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.assign)(item, {
    context: context
  });
  var conditions = filter.conditions;

  for (var i = 0, ii = conditions.length; i < ii; ++i) {
    var condition = conditions[i];
    (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushSerializeAndPop)(item, GETFEATURE_SERIALIZERS, (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleNodeFactory)(condition.getTagName()), [condition], objectStack);
  }
}
/**
 * @param {Element} node Node.
 * @param {import("./filter/Not.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */


function writeNotFilter(node, filter, objectStack) {
  var parent =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var context = parent['context'];
  /** @type {import("../xml.js").NodeStackItem} */

  var item = {
    node: node
  };
  (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.assign)(item, {
    context: context
  });
  var condition = filter.condition;
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushSerializeAndPop)(item, GETFEATURE_SERIALIZERS, (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleNodeFactory)(condition.getTagName()), [condition], objectStack);
}
/**
 * @param {Element} node Node.
 * @param {import("./filter/ComparisonBinary.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */


function writeComparisonFilter(node, filter, objectStack) {
  var parent =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var context = parent['context'];
  var version = context['version'];

  if (filter.matchCase !== undefined) {
    node.setAttribute('matchCase', filter.matchCase.toString());
  }

  writePropertyName(version, node, filter.propertyName);
  writeLiteral(version, node, '' + filter.expression);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/IsNull.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */


function writeIsNullFilter(node, filter, objectStack) {
  var parent =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var context = parent['context'];
  var version = context['version'];
  writePropertyName(version, node, filter.propertyName);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/IsBetween.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */


function writeIsBetweenFilter(node, filter, objectStack) {
  var parent =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var context = parent['context'];
  var version = context['version'];
  var ns = getFilterNS(version);
  writePropertyName(version, node, filter.propertyName);
  var lowerBoundary = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(ns, 'LowerBoundary');
  node.appendChild(lowerBoundary);
  writeLiteral(version, lowerBoundary, '' + filter.lowerBoundary);
  var upperBoundary = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(ns, 'UpperBoundary');
  node.appendChild(upperBoundary);
  writeLiteral(version, upperBoundary, '' + filter.upperBoundary);
}
/**
 * @param {Element} node Node.
 * @param {import("./filter/IsLike.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */


function writeIsLikeFilter(node, filter, objectStack) {
  var parent =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var context = parent['context'];
  var version = context['version'];
  node.setAttribute('wildCard', filter.wildCard);
  node.setAttribute('singleChar', filter.singleChar);
  node.setAttribute('escapeChar', filter.escapeChar);

  if (filter.matchCase !== undefined) {
    node.setAttribute('matchCase', filter.matchCase.toString());
  }

  writePropertyName(version, node, filter.propertyName);
  writeLiteral(version, node, '' + filter.pattern);
}
/**
 * @param {string} ns Namespace.
 * @param {string} tagName Tag name.
 * @param {Node} node Node.
 * @param {string} value Value.
 */


function writeExpression(ns, tagName, node, value) {
  var property = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(ns, tagName);
  (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode)(property, value);
  node.appendChild(property);
}
/**
 * @param {string} version Version.
 * @param {Node} node Node.
 * @param {string} value PropertyName value.
 */


function writeLiteral(version, node, value) {
  writeExpression(getFilterNS(version), 'Literal', node, value);
}
/**
 * @param {string} version Version.
 * @param {Node} node Node.
 * @param {string} value PropertyName value.
 */


function writePropertyName(version, node, value) {
  if (version === '2.0.0') {
    writeExpression(FESNS[version], 'ValueReference', node, value);
  } else {
    writeExpression(OGCNS[version], 'PropertyName', node, value);
  }
}
/**
 * @param {Node} node Node.
 * @param {string} time PropertyName value.
 */


function writeTimeInstant(node, time) {
  var timeInstant = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__.GMLNS, 'TimeInstant');
  node.appendChild(timeInstant);
  var timePosition = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__.GMLNS, 'timePosition');
  timeInstant.appendChild(timePosition);
  (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.writeStringTextNode)(timePosition, time);
}
/**
 * Encode filter as WFS `Filter` and return the Node.
 *
 * @param {import("./filter/Filter.js").default} filter Filter.
 * @param {string} opt_version WFS version. If not provided defaults to '1.1.0'
 * @return {Node} Result.
 * @api
 */


function writeFilter(filter, opt_version) {
  var version = opt_version || '1.1.0';
  var child = (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.createElementNS)(getFilterNS(version), 'Filter');
  var context = {
    node: child
  };
  (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.assign)(context, {
    'version': version,
    'filter': filter
  });
  writeFilterCondition(child, filter, [context]);
  return child;
}
/**
 * @param {Element} node Node.
 * @param {Array<string>} featureTypes Feature types.
 * @param {Array<*>} objectStack Node stack.
 */

function writeGetFeature(node, featureTypes, objectStack) {
  var context =
  /** @type {Object} */
  objectStack[objectStack.length - 1];
  var item =
  /** @type {import("../xml.js").NodeStackItem} */
  (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.assign)({}, context);
  item.node = node;
  (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.pushSerializeAndPop)(item, GETFEATURE_SERIALIZERS, (0,_xml_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleNodeFactory)('Query'), featureTypes, objectStack);
}

function getFilterNS(version) {
  var ns;

  if (version === '2.0.0') {
    ns = FESNS[version];
  } else {
    ns = OGCNS[version];
  }

  return ns;
}

/* harmony default export */ __webpack_exports__["default"] = (WFS);

/***/ }),

/***/ "./build/wg/format/WKB.js":
/*!********************************!*\
  !*** ./build/wg/format/WKB.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Feature.js */ "./build/wg/format/Feature.js");
/* harmony import */ var _FormatType_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./FormatType.js */ "./build/wg/format/FormatType.js");
/* harmony import */ var _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/GeometryCollection.js */ "./build/wg/geom/GeometryCollection.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./build/wg/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./build/wg/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./build/wg/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/SimpleGeometry.js */ "./build/wg/geom/SimpleGeometry.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/WKB
 */
















 // WKB spec: https://www.ogc.org/standards/sfa
// EWKB spec: https://raw.githubusercontent.com/postgis/postgis/2.1.0/doc/ZMSgeoms.txt

/**
 * @const
 * @enum {number}
 */

var WKBGeometryType = {
  POINT: 1,
  LINE_STRING: 2,
  POLYGON: 3,
  MULTI_POINT: 4,
  MULTI_LINE_STRING: 5,
  MULTI_POLYGON: 6,
  GEOMETRY_COLLECTION: 7,

  /*
  CIRCULAR_STRING: 8,
  COMPOUND_CURVE: 9,
  CURVE_POLYGON: 10,
      MULTI_CURVE: 11,
  MULTI_SURFACE: 12,
  CURVE: 13,
  SURFACE: 14,
  */
  POLYHEDRAL_SURFACE: 15,
  TIN: 16,
  TRIANGLE: 17
};

var WkbReader =
/** @class */
function () {
  /**
   * @param {DataView} view source to read
   */
  function WkbReader(view) {
    this.view_ = view;
    this.pos_ = 0;
    this.initialized_ = false;
    this.isLittleEndian_ = false;
    this.hasZ_ = false;
    this.hasM_ = false;
    /** @type {number|null} */

    this.srid_ = null;
    this.layout_ = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__["default"].XY;
  }
  /**
   * @return {number} value
   */


  WkbReader.prototype.readUint8 = function () {
    return this.view_.getUint8(this.pos_++);
  };
  /**
   * @param {boolean} [isLittleEndian] Whether read value as little endian
   * @return {number} value
   */


  WkbReader.prototype.readUint32 = function (isLittleEndian) {
    return this.view_.getUint32((this.pos_ += 4) - 4, isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_);
  };
  /**
   * @param {boolean} [isLittleEndian] Whether read value as little endian
   * @return {number} value
   */


  WkbReader.prototype.readDouble = function (isLittleEndian) {
    return this.view_.getFloat64((this.pos_ += 8) - 8, isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_);
  };
  /**
   * @return {import('../coordinate.js').Coordinate} coords for Point
   */


  WkbReader.prototype.readPoint = function () {
    /** @type import('../coordinate.js').Coordinate */
    var coords = [];
    coords.push(this.readDouble());
    coords.push(this.readDouble());

    if (this.hasZ_) {
      coords.push(this.readDouble());
    }

    if (this.hasM_) {
      coords.push(this.readDouble());
    }

    return coords;
  };
  /**
   * @return {Array<import('../coordinate.js').Coordinate>} coords for LineString / LinearRing
   */


  WkbReader.prototype.readLineString = function () {
    var numPoints = this.readUint32();
    /** @type Array<import('../coordinate.js').Coordinate> */

    var coords = [];

    for (var i = 0; i < numPoints; i++) {
      coords.push(this.readPoint());
    }

    return coords;
  };
  /**
   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for Polygon like
   */


  WkbReader.prototype.readPolygon = function () {
    var numRings = this.readUint32();
    /** @type Array<Array<import('../coordinate.js').Coordinate>> */

    var rings = [];

    for (var i = 0; i < numRings; i++) {
      rings.push(this.readLineString()); // as a LinearRing
    }

    return rings;
  };
  /**
   * @param {number} [expectedTypeId] Expected WKB Type ID
   * @return {number} WKB Type ID
   */


  WkbReader.prototype.readWkbHeader = function (expectedTypeId) {
    var byteOrder = this.readUint8();
    var isLittleEndian = byteOrder > 0;
    var wkbType = this.readUint32(isLittleEndian);
    var wkbTypeThousandth = Math.floor((wkbType & 0x0fffffff) / 1000);
    var hasZ = Boolean(wkbType & 0x80000000) || wkbTypeThousandth === 1 || wkbTypeThousandth === 3;
    var hasM = Boolean(wkbType & 0x40000000) || wkbTypeThousandth === 2 || wkbTypeThousandth === 3;
    var hasSRID = Boolean(wkbType & 0x20000000);
    var typeId = (wkbType & 0x0fffffff) % 1000; // Assume 1000 is an upper limit for type ID

    var layout = ['XY', hasZ ? 'Z' : '', hasM ? 'M' : ''].join('');
    var srid = hasSRID ? this.readUint32(isLittleEndian) : null;

    if (expectedTypeId !== undefined && expectedTypeId !== typeId) {
      throw new Error('Unexpected WKB geometry type ' + typeId);
    }

    if (this.initialized_) {
      // sanity checks
      if (this.isLittleEndian_ !== isLittleEndian) {
        throw new Error('Inconsistent endian');
      }

      if (this.layout_ !== layout) {
        throw new Error('Inconsistent geometry layout');
      }

      if (srid && this.srid_ !== srid) {
        throw new Error('Inconsistent coordinate system (SRID)');
      }
    } else {
      this.isLittleEndian_ = isLittleEndian;
      this.hasZ_ = hasZ;
      this.hasM_ = hasM;
      this.layout_ = layout;
      this.srid_ = srid;
      this.initialized_ = true;
    }

    return typeId;
  };
  /**
   * @param {number} typeId WKB Type ID
   * @return {any} values read
   */


  WkbReader.prototype.readWkbPayload = function (typeId) {
    switch (typeId) {
      case WKBGeometryType.POINT:
        return this.readPoint();

      case WKBGeometryType.LINE_STRING:
        return this.readLineString();

      case WKBGeometryType.POLYGON:
      case WKBGeometryType.TRIANGLE:
        return this.readPolygon();

      case WKBGeometryType.MULTI_POINT:
        return this.readMultiPoint();

      case WKBGeometryType.MULTI_LINE_STRING:
        return this.readMultiLineString();

      case WKBGeometryType.MULTI_POLYGON:
      case WKBGeometryType.POLYHEDRAL_SURFACE:
      case WKBGeometryType.TIN:
        return this.readMultiPolygon();

      case WKBGeometryType.GEOMETRY_COLLECTION:
        return this.readGeometryCollection();

      default:
        throw new Error('Unsupported WKB geometry type ' + typeId + ' is found');
    }
  };
  /**
   * @param {number} expectedTypeId Expected WKB Type ID
   * @return {any} values read
   */


  WkbReader.prototype.readWkbBlock = function (expectedTypeId) {
    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));
  };
  /**
   * @param {Function} reader reader function for each item
   * @param {number} [expectedTypeId] Expected WKB Type ID
   * @return {any} values read
   */


  WkbReader.prototype.readWkbCollection = function (reader, expectedTypeId) {
    var num = this.readUint32();
    var items = [];

    for (var i = 0; i < num; i++) {
      var result = reader.call(this, expectedTypeId);

      if (result) {
        items.push(result);
      }
    }

    return items;
  };
  /**
   * @return {Array<import('../coordinate.js').Coordinate>} coords for MultiPoint
   */


  WkbReader.prototype.readMultiPoint = function () {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);
  };
  /**
   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for MultiLineString like
   */


  WkbReader.prototype.readMultiLineString = function () {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.LINE_STRING);
  };
  /**
   * @return {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords for MultiPolygon like
   */


  WkbReader.prototype.readMultiPolygon = function () {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);
  };
  /**
   * @return {Array<import('../geom/Geometry.js').default>} array of geometries
   */


  WkbReader.prototype.readGeometryCollection = function () {
    return this.readWkbCollection(this.readGeometry);
  };
  /**
   * @return {import('../geom/Geometry.js').default} geometry
   */


  WkbReader.prototype.readGeometry = function () {
    var typeId = this.readWkbHeader();
    var result = this.readWkbPayload(typeId);

    switch (typeId) {
      case WKBGeometryType.POINT:
        return new _geom_Point_js__WEBPACK_IMPORTED_MODULE_2__["default"](
        /** @type {import('../coordinate.js').Coordinate} */
        result, this.layout_);

      case WKBGeometryType.LINE_STRING:
        return new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_3__["default"](
        /** @type {Array<import('../coordinate.js').Coordinate>} */
        result, this.layout_);

      case WKBGeometryType.POLYGON:
      case WKBGeometryType.TRIANGLE:
        return new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_4__["default"](
        /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */
        result, this.layout_);

      case WKBGeometryType.MULTI_POINT:
        return new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_5__["default"](
        /** @type {Array<import('../coordinate.js').Coordinate>} */
        result, this.layout_);

      case WKBGeometryType.MULTI_LINE_STRING:
        return new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_6__["default"](
        /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */
        result, this.layout_);

      case WKBGeometryType.MULTI_POLYGON:
      case WKBGeometryType.POLYHEDRAL_SURFACE:
      case WKBGeometryType.TIN:
        return new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_7__["default"](
        /** @type {Array<Array<Array<import('../coordinate.js').Coordinate>>>} */
        result, this.layout_);

      case WKBGeometryType.GEOMETRY_COLLECTION:
        return new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_8__["default"](
        /** @type {Array<import('../geom/Geometry.js').default>} */
        result);

      default:
        return null;
    }
  };
  /**
   * @return {number|null} SRID in the EWKB. `null` if not defined.
   */


  WkbReader.prototype.getSrid = function () {
    return this.srid_;
  };

  return WkbReader;
}();

var WkbWriter =
/** @class */
function () {
  /**
   * @type {object}
   * @property {string} [layout] geometryLayout
   * @property {boolean} [littleEndian=true] littleEndian
   * @property {boolean} [ewkb=true] Whether writes in EWKB format
   * @property {object} [nodata] NoData value for each axes
   * @param {object} opts options
   */
  function WkbWriter(opts) {
    opts = opts || {};
    /** @type {string} */

    this.layout_ = opts.layout;
    this.isLittleEndian_ = opts.littleEndian !== false;
    this.isEWKB_ = opts.ewkb !== false;
    /** @type {Array<Array<number>>} */

    this.writeQueue_ = [];
    /**
     * @type {object}
     * @property {number} X NoData value for X
     * @property {number} Y NoData value for Y
     * @property {number} Z NoData value for Z
     * @property {number} M NoData value for M
     */

    this.nodata_ = (0,_obj_js__WEBPACK_IMPORTED_MODULE_9__.assign)({
      X: 0,
      Y: 0,
      Z: 0,
      M: 0
    }, opts.nodata);
  }
  /**
   * @param {number} value value
   */


  WkbWriter.prototype.writeUint8 = function (value) {
    this.writeQueue_.push([1, value]);
  };
  /**
   * @param {number} value value
   */


  WkbWriter.prototype.writeUint32 = function (value) {
    this.writeQueue_.push([4, value]);
  };
  /**
   * @param {number} value value
   */


  WkbWriter.prototype.writeDouble = function (value) {
    this.writeQueue_.push([8, value]);
  };
  /**
   * @param {import('../coordinate.js').Coordinate} coords coords
   * @param {import("../geom/GeometryLayout").default} layout layout
   */


  WkbWriter.prototype.writePoint = function (coords, layout) {
    /**
     * @type {object}
     * @property {number} X NoData value for X
     * @property {number} Y NoData value for Y
     * @property {number} [Z] NoData value for Z
     * @property {number} [M] NoData value for M
     */
    var coordsObj = _obj_js__WEBPACK_IMPORTED_MODULE_9__.assign.apply(null, layout.split('').map(function (axis, idx) {
      var _a;

      return _a = {}, _a[axis] = coords[idx], _a;
    }));

    for (var _i = 0, _a = this.layout_; _i < _a.length; _i++) {
      var axis = _a[_i];
      this.writeDouble(axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]);
    }
  };
  /**
   * @param {Array<import('../coordinate.js').Coordinate>} coords coords
   * @param {import("../geom/GeometryLayout").default} layout layout
   */


  WkbWriter.prototype.writeLineString = function (coords, layout) {
    this.writeUint32(coords.length); // numPoints

    for (var i = 0; i < coords.length; i++) {
      this.writePoint(coords[i], layout);
    }
  };
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} rings rings
   * @param {import("../geom/GeometryLayout").default} layout layout
   */


  WkbWriter.prototype.writePolygon = function (rings, layout) {
    this.writeUint32(rings.length); // numRings

    for (var i = 0; i < rings.length; i++) {
      this.writeLineString(rings[i], layout); // as a LinearRing
    }
  };
  /**
   * @param {number} wkbType WKB Type ID
   * @param {number} [srid] SRID
   */


  WkbWriter.prototype.writeWkbHeader = function (wkbType, srid) {
    wkbType %= 1000; // Assume 1000 is an upper limit for type ID

    if (this.layout_.indexOf('Z') >= 0) {
      wkbType += this.isEWKB_ ? 0x80000000 : 1000;
    }

    if (this.layout_.indexOf('M') >= 0) {
      wkbType += this.isEWKB_ ? 0x40000000 : 2000;
    }

    if (this.isEWKB_ && Number.isInteger(srid)) {
      wkbType |= 0x20000000;
    }

    this.writeUint8(this.isLittleEndian_ ? 1 : 0);
    this.writeUint32(wkbType);

    if (this.isEWKB_ && Number.isInteger(srid)) {
      this.writeUint32(srid);
    }
  };
  /**
   * @param {Array<import('../coordinate.js').Coordinate>} coords coords
   * @param {string} layout layout
   */


  WkbWriter.prototype.writeMultiPoint = function (coords, layout) {
    this.writeUint32(coords.length); // numItems

    for (var i = 0; i < coords.length; i++) {
      this.writeWkbHeader(1);
      this.writePoint(coords[i], layout);
    }
  };
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} coords coords
   * @param {string} layout layout
   */


  WkbWriter.prototype.writeMultiLineString = function (coords, layout) {
    this.writeUint32(coords.length); // numItems

    for (var i = 0; i < coords.length; i++) {
      this.writeWkbHeader(2);
      this.writeLineString(coords[i], layout);
    }
  };
  /**
   * @param {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords coords
   * @param {string} layout layout
   */


  WkbWriter.prototype.writeMultiPolygon = function (coords, layout) {
    this.writeUint32(coords.length); // numItems

    for (var i = 0; i < coords.length; i++) {
      this.writeWkbHeader(3);
      this.writePolygon(coords[i], layout);
    }
  };
  /**
   * @param {Array<import('../geom/Geometry.js').default>} geometries geometries
   */


  WkbWriter.prototype.writeGeometryCollection = function (geometries) {
    this.writeUint32(geometries.length); // numItems

    for (var i = 0; i < geometries.length; i++) {
      this.writeGeometry(geometries[i]);
    }
  };
  /**
   * @param {import("../geom/Geometry.js").default} geom geometry
   * @param {import("../geom/GeometryLayout.js").default} [layout] layout
   * @return {import("../geom/GeometryLayout.js").default} minumum layout made by common axes
   */


  WkbWriter.prototype.findMinimumLayout = function (geom, layout) {
    if (layout === void 0) {
      layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__["default"].XYZM;
    }
    /**
     * @param {import("../geom/GeometryLayout.js").default} a A
     * @param {import("../geom/GeometryLayout.js").default} b B
     * @return {import("../geom/GeometryLayout.js").default} minumum layout made by common axes
     */


    var GeometryLayout_min = function GeometryLayout_min(a, b) {
      if (a === b) {
        return a;
      }

      if (a === _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__["default"].XYZM) {
        // anything `b` is minimum
        return b;
      }

      if (b === _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__["default"].XYZM) {
        // anything `a` is minimum
        return a;
      } // otherwise, incompatible


      return _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__["default"].XY;
    };

    if (geom instanceof _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_10__["default"]) {
      return GeometryLayout_min(geom.getLayout(), layout);
    }

    if (geom instanceof _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_8__["default"]) {
      var geoms = geom.getGeometriesArray();

      for (var i = 0; i < geoms.length && layout !== _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__["default"].XY; i++) {
        layout = this.findMinimumLayout(geoms[i], layout);
      }
    }

    return layout;
  };
  /**
   * @param {import("../geom/Geometry.js").default} geom geometry
   * @param {number} [srid] SRID
   */


  WkbWriter.prototype.writeGeometry = function (geom, srid) {
    var _a, _b;

    var wkblut = (_a = {}, _a[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].POINT] = WKBGeometryType.POINT, _a[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].LINE_STRING] = WKBGeometryType.LINE_STRING, _a[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].POLYGON] = WKBGeometryType.POLYGON, _a[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].MULTI_POINT] = WKBGeometryType.MULTI_POINT, _a[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].MULTI_LINE_STRING] = WKBGeometryType.MULTI_LINE_STRING, _a[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].MULTI_POLYGON] = WKBGeometryType.MULTI_POLYGON, _a[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].GEOMETRY_COLLECTION] = WKBGeometryType.GEOMETRY_COLLECTION, _a);
    var geomType = geom.getType();
    var typeId = wkblut[geomType];

    if (!typeId) {
      throw new Error('GeometryType ' + geomType + ' is not supported');
    } // first call of writeGeometry() traverse whole geometries to determine its output layout if not specified on constructor.


    if (!this.layout_) {
      this.layout_ = this.findMinimumLayout(geom);
    }

    this.writeWkbHeader(typeId, srid);

    if (geom instanceof _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_10__["default"]) {
      var writerLUT = (_b = {}, _b[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].POINT] = this.writePoint, _b[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].LINE_STRING] = this.writeLineString, _b[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].POLYGON] = this.writePolygon, _b[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].MULTI_POINT] = this.writeMultiPoint, _b[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].MULTI_LINE_STRING] = this.writeMultiLineString, _b[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].MULTI_POLYGON] = this.writeMultiPolygon, _b);
      writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());
    } else if (geom instanceof _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_8__["default"]) {
      this.writeGeometryCollection(geom.getGeometriesArray());
    }
  };

  WkbWriter.prototype.getBuffer = function () {
    var _this = this;

    var byteLength = this.writeQueue_.reduce(function (acc, item) {
      return acc + item[0];
    }, 0);
    var buffer = new ArrayBuffer(byteLength);
    var view = new DataView(buffer);
    var pos = 0;
    this.writeQueue_.forEach(function (item) {
      switch (item[0]) {
        case 1:
          view.setUint8(pos, item[1]);
          break;

        case 4:
          view.setUint32(pos, item[1], _this.isLittleEndian_);
          break;

        case 8:
          view.setFloat64(pos, item[1], _this.isLittleEndian_);
          break;

        default:
          break;
      }

      pos += item[0];
    });
    return buffer;
  };

  return WkbWriter;
}();
/**
 * @typedef {Object} Options
 * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into multiple features on reading.
 * @property {boolean} [hex=true] Returns hex string instead of ArrayBuffer for output. This also is used as a hint internally whether it should load contents as text or ArrayBuffer on reading.
 * @property {boolean} [littleEndian=true] Use littleEndian for output.
 * @property {boolean} [ewkb=true] Use EWKB format for output.
 * @property {import("../geom/GeometryLayout").default} [geometryLayout=null] Use specific coordinate layout for output features (null: auto detect)
 * @property {number} [nodataZ=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of Z.
 * @property {number} [nodataM=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of M.
 * @property {number|boolean} [srid=true] SRID for output. Specify integer value to enforce the value as a SRID. Specify `true` to extract from `dataProjection`. `false` to suppress the output. This option only takes effect when `ewkb` is `true`.
 */

/**
 * @classdesc
 * Geometry format for reading and writing data in the `Well-Known Binary` (WKB) format.
 * Also supports `Extended Well-Known Binary` (EWKB) format, used in PostGIS for example.
 *
 * @api
 */


var WKB =
/** @class */
function (_super) {
  __extends(WKB, _super);
  /**
   * @param {Options} [opt_options] Optional configuration object.
   */


  function WKB(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    _this.splitCollection = Boolean(options.splitCollection);
    _this.viewCache_ = null;
    _this.hex_ = options.hex !== false;
    _this.littleEndian_ = options.littleEndian !== false;
    _this.ewkb_ = options.ewkb !== false;
    _this.layout_ = options.geometryLayout; // null for auto detect

    _this.nodataZ_ = options.nodataZ || 0;
    _this.nodataM_ = options.nodataM || 0;
    _this.srid_ = options.srid;
    return _this;
  }
  /**
   * @return {import("./FormatType.js").default} Format.
   */


  WKB.prototype.getType = function () {
    return this.hex_ ? _FormatType_js__WEBPACK_IMPORTED_MODULE_12__["default"].TEXT : _FormatType_js__WEBPACK_IMPORTED_MODULE_12__["default"].ARRAY_BUFFER;
  };
  /**
   * Read a single feature from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @return {import("../Feature.js").FeatureLike} Feature.
   * @api
   */


  WKB.prototype.readFeature = function (source, opt_options) {
    return new _Feature_js__WEBPACK_IMPORTED_MODULE_13__["default"]({
      geometry: this.readGeometry(source, opt_options)
    });
  };
  /**
   * Read all features from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */


  WKB.prototype.readFeatures = function (source, opt_options) {
    var geometries = [];
    var geometry = this.readGeometry(source, opt_options);

    if (this.splitCollection && geometry instanceof _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_8__["default"]) {
      geometries = geometry.getGeometriesArray();
    } else {
      geometries = [geometry];
    }

    return geometries.map(function (geometry) {
      return new _Feature_js__WEBPACK_IMPORTED_MODULE_13__["default"]({
        geometry: geometry
      });
    });
  };
  /**
   * Read a single geometry from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */


  WKB.prototype.readGeometry = function (source, opt_options) {
    var view = getDataView(source);

    if (!view) {
      return null;
    }

    var reader = new WkbReader(view);
    var geometry = reader.readGeometry();
    this.viewCache_ = view; // cache for internal subsequent call of readProjection()

    var options = this.getReadOptions(source, opt_options);
    this.viewCache_ = null; // release

    return (0,_Feature_js__WEBPACK_IMPORTED_MODULE_14__.transformGeometryWithOptions)(geometry, false, options);
  };
  /**
   * Read the projection from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   * @api
   */


  WKB.prototype.readProjection = function (source) {
    var view = this.viewCache_ || getDataView(source);

    if (!view) {
      return undefined;
    }

    var reader = new WkbReader(view);
    reader.readWkbHeader();
    return reader.getSrid() && (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:' + reader.getSrid()) || undefined;
  };
  /**
   * Encode a feature in this format.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {string|ArrayBuffer} Result.
   * @api
   */


  WKB.prototype.writeFeature = function (feature, opt_options) {
    return this.writeGeometry(feature.getGeometry(), opt_options);
  };
  /**
   * Encode an array of features in this format.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {string|ArrayBuffer} Result.
   * @api
   */


  WKB.prototype.writeFeatures = function (features, opt_options) {
    return this.writeGeometry(new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_8__["default"](features.map(function (f) {
      return f.getGeometry();
    })), opt_options);
  };
  /**
   * Write a single geometry in this format.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {string|ArrayBuffer} Result.
   * @api
   */


  WKB.prototype.writeGeometry = function (geometry, opt_options) {
    var options = this.adaptOptions(opt_options);
    var writer = new WkbWriter({
      layout: this.layout_,
      littleEndian: this.littleEndian_,
      ewkb: this.ewkb_,
      nodata: {
        Z: this.nodataZ_,
        M: this.nodataM_
      }
    }); // extract SRID from `dataProjection`

    var srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;

    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {
      var dataProjection = options.dataProjection && (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.dataProjection);

      if (dataProjection) {
        var code = dataProjection.getCode();

        if (code.indexOf('EPSG:') === 0) {
          srid = Number(code.substring(5));
        }
      }
    }

    writer.writeGeometry((0,_Feature_js__WEBPACK_IMPORTED_MODULE_14__.transformGeometryWithOptions)(geometry, true, options), srid);
    var buffer = writer.getBuffer();
    return this.hex_ ? encodeHexString(buffer) : buffer;
  };

  return WKB;
}(_Feature_js__WEBPACK_IMPORTED_MODULE_14__["default"]);
/**
 * @param {ArrayBuffer} buffer source buffer
 * @return {string} encoded hex string
 */


function encodeHexString(buffer) {
  var view = new Uint8Array(buffer);
  return Array.from(view.values()).map(function (x) {
    return (x < 16 ? '0' : '') + Number(x).toString(16).toUpperCase();
  }).join('');
}
/**
 * @param {string} text source text
 * @return {DataView} decoded binary buffer
 */


function decodeHexString(text) {
  var buffer = new Uint8Array(text.length / 2);

  for (var i = 0; i < text.length / 2; i++) {
    buffer[i] = parseInt(text.substr(i * 2, 2), 16);
  }

  return new DataView(buffer.buffer);
}
/**
 * @param {string | ArrayBuffer | ArrayBufferView} source source
 * @return {DataView} data view
 */


function getDataView(source) {
  if (typeof source === 'string') {
    return decodeHexString(source);
  } else if (ArrayBuffer.isView(source)) {
    if (source instanceof DataView) {
      return source;
    }

    return new DataView(source.buffer, source.byteOffset, source.byteLength);
  } else if (source instanceof ArrayBuffer) {
    return new DataView(source);
  } else {
    return null;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (WKB);

/***/ }),

/***/ "./build/wg/format/WKT.js":
/*!********************************!*\
  !*** ./build/wg/format/WKT.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/GeometryCollection.js */ "./build/wg/geom/GeometryCollection.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./build/wg/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./build/wg/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./build/wg/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _TextFeature_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./TextFeature.js */ "./build/wg/format/TextFeature.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Feature.js */ "./build/wg/format/Feature.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/WKT
 */














/**
 * Geometry constructors
 * @enum {function (new:import("../geom/Geometry.js").default, Array, import("../geom/GeometryLayout.js").default)}
 */

var GeometryConstructor = {
  'POINT': _geom_Point_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  'LINESTRING': _geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  'POLYGON': _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  'MULTIPOINT': _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  'MULTILINESTRING': _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  'MULTIPOLYGON': _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__["default"]
};
/**
 * @typedef {Object} Options
 * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into
 * multiple features on reading.
 */

/**
 * @typedef {Object} Token
 * @property {number} type Type.
 * @property {number|string} [value] Value.
 * @property {number} position Position.
 */

/**
 * @const
 * @type {string}
 */

var EMPTY = 'EMPTY';
/**
 * @const
 * @type {string}
 */

var Z = 'Z';
/**
 * @const
 * @type {string}
 */

var M = 'M';
/**
 * @const
 * @type {string}
 */

var ZM = 'ZM';
/**
 * @const
 * @enum {number}
 */

var TokenType = {
  START: 0,
  TEXT: 1,
  LEFT_PAREN: 2,
  RIGHT_PAREN: 3,
  NUMBER: 4,
  COMMA: 5,
  EOF: 6
};
/**
 * @const
 * @type {Object<string, string>}
 */

var WKTGeometryType = {};

for (var type in _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"]) {
  WKTGeometryType[type] = _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"][type].toUpperCase();
}
/**
 * Class to tokenize a WKT string.
 */


var Lexer =
/** @class */
function () {
  /**
   * @param {string} wkt WKT string.
   */
  function Lexer(wkt) {
    /**
     * @type {string}
     */
    this.wkt = wkt;
    /**
     * @type {number}
     * @private
     */

    this.index_ = -1;
  }
  /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is alphabetic.
   * @private
   */


  Lexer.prototype.isAlpha_ = function (c) {
    return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';
  };
  /**
   * @param {string} c Character.
   * @param {boolean} [opt_decimal] Whether the string number
   *     contains a dot, i.e. is a decimal number.
   * @return {boolean} Whether the character is numeric.
   * @private
   */


  Lexer.prototype.isNumeric_ = function (c, opt_decimal) {
    var decimal = opt_decimal !== undefined ? opt_decimal : false;
    return c >= '0' && c <= '9' || c == '.' && !decimal;
  };
  /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is whitespace.
   * @private
   */


  Lexer.prototype.isWhiteSpace_ = function (c) {
    return c == ' ' || c == '\t' || c == '\r' || c == '\n';
  };
  /**
   * @return {string} Next string character.
   * @private
   */


  Lexer.prototype.nextChar_ = function () {
    return this.wkt.charAt(++this.index_);
  };
  /**
   * Fetch and return the next token.
   * @return {Token} Next string token.
   */


  Lexer.prototype.nextToken = function () {
    var c = this.nextChar_();
    var position = this.index_;
    /** @type {number|string} */

    var value = c;
    var type;

    if (c == '(') {
      type = TokenType.LEFT_PAREN;
    } else if (c == ',') {
      type = TokenType.COMMA;
    } else if (c == ')') {
      type = TokenType.RIGHT_PAREN;
    } else if (this.isNumeric_(c) || c == '-') {
      type = TokenType.NUMBER;
      value = this.readNumber_();
    } else if (this.isAlpha_(c)) {
      type = TokenType.TEXT;
      value = this.readText_();
    } else if (this.isWhiteSpace_(c)) {
      return this.nextToken();
    } else if (c === '') {
      type = TokenType.EOF;
    } else {
      throw new Error('Unexpected character: ' + c);
    }

    return {
      position: position,
      value: value,
      type: type
    };
  };
  /**
   * @return {number} Numeric token value.
   * @private
   */


  Lexer.prototype.readNumber_ = function () {
    var c;
    var index = this.index_;
    var decimal = false;
    var scientificNotation = false;

    do {
      if (c == '.') {
        decimal = true;
      } else if (c == 'e' || c == 'E') {
        scientificNotation = true;
      }

      c = this.nextChar_();
    } while (this.isNumeric_(c, decimal) || // if we haven't detected a scientific number before, 'e' or 'E'
    // hint that we should continue to read
    !scientificNotation && (c == 'e' || c == 'E') || // once we know that we have a scientific number, both '-' and '+'
    // are allowed
    scientificNotation && (c == '-' || c == '+'));

    return parseFloat(this.wkt.substring(index, this.index_--));
  };
  /**
   * @return {string} String token value.
   * @private
   */


  Lexer.prototype.readText_ = function () {
    var c;
    var index = this.index_;

    do {
      c = this.nextChar_();
    } while (this.isAlpha_(c));

    return this.wkt.substring(index, this.index_--).toUpperCase();
  };

  return Lexer;
}();
/**
 * Class to parse the tokens from the WKT string.
 */


var Parser =
/** @class */
function () {
  /**
   * @param {Lexer} lexer The lexer.
   */
  function Parser(lexer) {
    /**
     * @type {Lexer}
     * @private
     */
    this.lexer_ = lexer;
    /**
     * @type {Token}
     * @private
     */

    this.token_ = {
      position: 0,
      type: TokenType.START
    };
    /**
     * @type {import("../geom/GeometryLayout.js").default}
     * @private
     */

    this.layout_ = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_7__["default"].XY;
  }
  /**
   * Fetch the next token form the lexer and replace the active token.
   * @private
   */


  Parser.prototype.consume_ = function () {
    this.token_ = this.lexer_.nextToken();
  };
  /**
   * Tests if the given type matches the type of the current token.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */


  Parser.prototype.isTokenType = function (type) {
    return this.token_.type == type;
  };
  /**
   * If the given type matches the current token, consume it.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */


  Parser.prototype.match = function (type) {
    var isMatch = this.isTokenType(type);

    if (isMatch) {
      this.consume_();
    }

    return isMatch;
  };
  /**
   * Try to parse the tokens provided by the lexer.
   * @return {import("../geom/Geometry.js").default} The geometry.
   */


  Parser.prototype.parse = function () {
    this.consume_();
    return this.parseGeometry_();
  };
  /**
   * Try to parse the dimensional info.
   * @return {import("../geom/GeometryLayout.js").default} The layout.
   * @private
   */


  Parser.prototype.parseGeometryLayout_ = function () {
    var layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_7__["default"].XY;
    var dimToken = this.token_;

    if (this.isTokenType(TokenType.TEXT)) {
      var dimInfo = dimToken.value;

      if (dimInfo === Z) {
        layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_7__["default"].XYZ;
      } else if (dimInfo === M) {
        layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_7__["default"].XYM;
      } else if (dimInfo === ZM) {
        layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_7__["default"].XYZM;
      }

      if (layout !== _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_7__["default"].XY) {
        this.consume_();
      }
    }

    return layout;
  };
  /**
   * @return {Array<import("../geom/Geometry.js").default>} A collection of geometries.
   * @private
   */


  Parser.prototype.parseGeometryCollectionText_ = function () {
    if (this.match(TokenType.LEFT_PAREN)) {
      var geometries = [];

      do {
        geometries.push(this.parseGeometry_());
      } while (this.match(TokenType.COMMA));

      if (this.match(TokenType.RIGHT_PAREN)) {
        return geometries;
      }
    }

    throw new Error(this.formatErrorMessage_());
  };
  /**
   * @return {Array<number>} All values in a point.
   * @private
   */


  Parser.prototype.parsePointText_ = function () {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates = this.parsePoint_();

      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }

    throw new Error(this.formatErrorMessage_());
  };
  /**
   * @return {Array<Array<number>>} All points in a linestring.
   * @private
   */


  Parser.prototype.parseLineStringText_ = function () {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates = this.parsePointList_();

      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }

    throw new Error(this.formatErrorMessage_());
  };
  /**
   * @return {Array<Array<Array<number>>>} All points in a polygon.
   * @private
   */


  Parser.prototype.parsePolygonText_ = function () {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates = this.parseLineStringTextList_();

      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }

    throw new Error(this.formatErrorMessage_());
  };
  /**
   * @return {Array<Array<number>>} All points in a multipoint.
   * @private
   */


  Parser.prototype.parseMultiPointText_ = function () {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates = void 0;

      if (this.token_.type == TokenType.LEFT_PAREN) {
        coordinates = this.parsePointTextList_();
      } else {
        coordinates = this.parsePointList_();
      }

      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }

    throw new Error(this.formatErrorMessage_());
  };
  /**
   * @return {Array<Array<Array<number>>>} All linestring points
   *                                          in a multilinestring.
   * @private
   */


  Parser.prototype.parseMultiLineStringText_ = function () {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates = this.parseLineStringTextList_();

      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }

    throw new Error(this.formatErrorMessage_());
  };
  /**
   * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.
   * @private
   */


  Parser.prototype.parseMultiPolygonText_ = function () {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates = this.parsePolygonTextList_();

      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }

    throw new Error(this.formatErrorMessage_());
  };
  /**
   * @return {Array<number>} A point.
   * @private
   */


  Parser.prototype.parsePoint_ = function () {
    var coordinates = [];
    var dimensions = this.layout_.length;

    for (var i = 0; i < dimensions; ++i) {
      var token = this.token_;

      if (this.match(TokenType.NUMBER)) {
        coordinates.push(
        /** @type {number} */
        token.value);
      } else {
        break;
      }
    }

    if (coordinates.length == dimensions) {
      return coordinates;
    }

    throw new Error(this.formatErrorMessage_());
  };
  /**
   * @return {Array<Array<number>>} An array of points.
   * @private
   */


  Parser.prototype.parsePointList_ = function () {
    var coordinates = [this.parsePoint_()];

    while (this.match(TokenType.COMMA)) {
      coordinates.push(this.parsePoint_());
    }

    return coordinates;
  };
  /**
   * @return {Array<Array<number>>} An array of points.
   * @private
   */


  Parser.prototype.parsePointTextList_ = function () {
    var coordinates = [this.parsePointText_()];

    while (this.match(TokenType.COMMA)) {
      coordinates.push(this.parsePointText_());
    }

    return coordinates;
  };
  /**
   * @return {Array<Array<Array<number>>>} An array of points.
   * @private
   */


  Parser.prototype.parseLineStringTextList_ = function () {
    var coordinates = [this.parseLineStringText_()];

    while (this.match(TokenType.COMMA)) {
      coordinates.push(this.parseLineStringText_());
    }

    return coordinates;
  };
  /**
   * @return {Array<Array<Array<Array<number>>>>} An array of points.
   * @private
   */


  Parser.prototype.parsePolygonTextList_ = function () {
    var coordinates = [this.parsePolygonText_()];

    while (this.match(TokenType.COMMA)) {
      coordinates.push(this.parsePolygonText_());
    }

    return coordinates;
  };
  /**
   * @return {boolean} Whether the token implies an empty geometry.
   * @private
   */


  Parser.prototype.isEmptyGeometry_ = function () {
    var isEmpty = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;

    if (isEmpty) {
      this.consume_();
    }

    return isEmpty;
  };
  /**
   * Create an error message for an unexpected token error.
   * @return {string} Error message.
   * @private
   */


  Parser.prototype.formatErrorMessage_ = function () {
    return 'Unexpected `' + this.token_.value + '` at position ' + this.token_.position + ' in `' + this.lexer_.wkt + '`';
  };
  /**
   * @return {import("../geom/Geometry.js").default} The geometry.
   * @private
   */


  Parser.prototype.parseGeometry_ = function () {
    var token = this.token_;

    if (this.match(TokenType.TEXT)) {
      var geomType =
      /** @type {string} */
      token.value;
      this.layout_ = this.parseGeometryLayout_();
      var isEmpty = this.isEmptyGeometry_();

      if (geomType == 'GEOMETRYCOLLECTION') {
        if (isEmpty) {
          return new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_8__["default"]([]);
        }

        var geometries = this.parseGeometryCollectionText_();
        return new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_8__["default"](geometries);
      } else {
        var ctor = GeometryConstructor[geomType];

        if (!ctor) {
          throw new Error('Invalid geometry type: ' + geomType);
        }

        var coordinates = void 0;

        if (isEmpty) {
          if (geomType == 'POINT') {
            coordinates = [NaN, NaN];
          } else {
            coordinates = [];
          }
        } else {
          switch (geomType) {
            case 'POINT':
              {
                coordinates = this.parsePointText_();
                break;
              }

            case 'LINESTRING':
              {
                coordinates = this.parseLineStringText_();
                break;
              }

            case 'POLYGON':
              {
                coordinates = this.parsePolygonText_();
                break;
              }

            case 'MULTIPOINT':
              {
                coordinates = this.parseMultiPointText_();
                break;
              }

            case 'MULTILINESTRING':
              {
                coordinates = this.parseMultiLineStringText_();
                break;
              }

            case 'MULTIPOLYGON':
              {
                coordinates = this.parseMultiPolygonText_();
                break;
              }

            default:
              break;
          }
        }

        return new ctor(coordinates, this.layout_);
      }
    }

    throw new Error(this.formatErrorMessage_());
  };

  return Parser;
}();
/**
 * @classdesc
 * Geometry format for reading and writing data in the `WellKnownText` (WKT)
 * format.
 *
 * @api
 */


var WKT =
/** @class */
function (_super) {
  __extends(WKT, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function WKT(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * Split GeometryCollection into multiple features.
     * @type {boolean}
     * @private
     */

    _this.splitCollection_ = options.splitCollection !== undefined ? options.splitCollection : false;
    return _this;
  }
  /**
   * Parse a WKT string.
   * @param {string} wkt WKT string.
   * @return {import("../geom/Geometry.js").default}
   *     The geometry created.
   * @private
   */


  WKT.prototype.parse_ = function (wkt) {
    var lexer = new Lexer(wkt);
    var parser = new Parser(lexer);
    return parser.parse();
  };
  /**
   * @protected
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @return {import("../Feature.js").default} Feature.
   */


  WKT.prototype.readFeatureFromText = function (text, opt_options) {
    var geom = this.readGeometryFromText(text, opt_options);
    var feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_9__["default"]();
    feature.setGeometry(geom);
    return feature;
  };
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */


  WKT.prototype.readFeaturesFromText = function (text, opt_options) {
    var geometries = [];
    var geometry = this.readGeometryFromText(text, opt_options);

    if (this.splitCollection_ && geometry.getType() == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].GEOMETRY_COLLECTION) {
      geometries =
      /** @type {GeometryCollection} */
      geometry.getGeometriesArray();
    } else {
      geometries = [geometry];
    }

    var features = [];

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      var feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_9__["default"]();
      feature.setGeometry(geometries[i]);
      features.push(feature);
    }

    return features;
  };
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */


  WKT.prototype.readGeometryFromText = function (text, opt_options) {
    var geometry = this.parse_(text);
    return (0,_Feature_js__WEBPACK_IMPORTED_MODULE_10__.transformGeometryWithOptions)(geometry, false, opt_options);
  };
  /**
   * @param {import("../Feature.js").default} feature Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @protected
   * @return {string} Text.
   */


  WKT.prototype.writeFeatureText = function (feature, opt_options) {
    var geometry = feature.getGeometry();

    if (geometry) {
      return this.writeGeometryText(geometry, opt_options);
    }

    return '';
  };
  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @protected
   * @return {string} Text.
   */


  WKT.prototype.writeFeaturesText = function (features, opt_options) {
    if (features.length == 1) {
      return this.writeFeatureText(features[0], opt_options);
    }

    var geometries = [];

    for (var i = 0, ii = features.length; i < ii; ++i) {
      geometries.push(features[i].getGeometry());
    }

    var collection = new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_8__["default"](geometries);
    return this.writeGeometryText(collection, opt_options);
  };
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @protected
   * @return {string} Text.
   */


  WKT.prototype.writeGeometryText = function (geometry, opt_options) {
    return encode((0,_Feature_js__WEBPACK_IMPORTED_MODULE_10__.transformGeometryWithOptions)(geometry, true, opt_options));
  };

  return WKT;
}(_TextFeature_js__WEBPACK_IMPORTED_MODULE_11__["default"]);
/**
 * @param {Point} geom Point geometry.
 * @return {string} Coordinates part of Point as WKT.
 */


function encodePointGeometry(geom) {
  var coordinates = geom.getCoordinates();

  if (coordinates.length === 0) {
    return '';
  }

  return coordinates.join(' ');
}
/**
 * @param {MultiPoint} geom MultiPoint geometry.
 * @return {string} Coordinates part of MultiPoint as WKT.
 */


function encodeMultiPointGeometry(geom) {
  var array = [];
  var components = geom.getPoints();

  for (var i = 0, ii = components.length; i < ii; ++i) {
    array.push('(' + encodePointGeometry(components[i]) + ')');
  }

  return array.join(',');
}
/**
 * @param {GeometryCollection} geom GeometryCollection geometry.
 * @return {string} Coordinates part of GeometryCollection as WKT.
 */


function encodeGeometryCollectionGeometry(geom) {
  var array = [];
  var geoms = geom.getGeometries();

  for (var i = 0, ii = geoms.length; i < ii; ++i) {
    array.push(encode(geoms[i]));
  }

  return array.join(',');
}
/**
 * @param {LineString|import("../geom/LinearRing.js").default} geom LineString geometry.
 * @return {string} Coordinates part of LineString as WKT.
 */


function encodeLineStringGeometry(geom) {
  var coordinates = geom.getCoordinates();
  var array = [];

  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    array.push(coordinates[i].join(' '));
  }

  return array.join(',');
}
/**
 * @param {MultiLineString} geom MultiLineString geometry.
 * @return {string} Coordinates part of MultiLineString as WKT.
 */


function encodeMultiLineStringGeometry(geom) {
  var array = [];
  var components = geom.getLineStrings();

  for (var i = 0, ii = components.length; i < ii; ++i) {
    array.push('(' + encodeLineStringGeometry(components[i]) + ')');
  }

  return array.join(',');
}
/**
 * @param {Polygon} geom Polygon geometry.
 * @return {string} Coordinates part of Polygon as WKT.
 */


function encodePolygonGeometry(geom) {
  var array = [];
  var rings = geom.getLinearRings();

  for (var i = 0, ii = rings.length; i < ii; ++i) {
    array.push('(' + encodeLineStringGeometry(rings[i]) + ')');
  }

  return array.join(',');
}
/**
 * @param {MultiPolygon} geom MultiPolygon geometry.
 * @return {string} Coordinates part of MultiPolygon as WKT.
 */


function encodeMultiPolygonGeometry(geom) {
  var array = [];
  var components = geom.getPolygons();

  for (var i = 0, ii = components.length; i < ii; ++i) {
    array.push('(' + encodePolygonGeometry(components[i]) + ')');
  }

  return array.join(',');
}
/**
 * @param {import("../geom/SimpleGeometry.js").default} geom SimpleGeometry geometry.
 * @return {string} Potential dimensional information for WKT type.
 */


function encodeGeometryLayout(geom) {
  var layout = geom.getLayout();
  var dimInfo = '';

  if (layout === _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_7__["default"].XYZ || layout === _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_7__["default"].XYZM) {
    dimInfo += Z;
  }

  if (layout === _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_7__["default"].XYM || layout === _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_7__["default"].XYZM) {
    dimInfo += M;
  }

  return dimInfo;
}
/**
 * @const
 * @type {Object<string, function(import("../geom/Geometry.js").default): string>}
 */


var GeometryEncoder = {
  'Point': encodePointGeometry,
  'LineString': encodeLineStringGeometry,
  'Polygon': encodePolygonGeometry,
  'MultiPoint': encodeMultiPointGeometry,
  'MultiLineString': encodeMultiLineStringGeometry,
  'MultiPolygon': encodeMultiPolygonGeometry,
  'GeometryCollection': encodeGeometryCollectionGeometry
};
/**
 * Encode a geometry as WKT.
 * @param {import("../geom/Geometry.js").default} geom The geometry to encode.
 * @return {string} WKT string for the geometry.
 */

function encode(geom) {
  var type = geom.getType();
  var geometryEncoder = GeometryEncoder[type];
  var enc = geometryEncoder(geom);
  type = type.toUpperCase();

  if (typeof
  /** @type {?} */
  geom.getFlatCoordinates === 'function') {
    var dimInfo = encodeGeometryLayout(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    geom);

    if (dimInfo.length > 0) {
      type += ' ' + dimInfo;
    }
  }

  if (enc.length === 0) {
    return type + ' ' + EMPTY;
  }

  return type + '(' + enc + ')';
}

/* harmony default export */ __webpack_exports__["default"] = (WKT);

/***/ }),

/***/ "./build/wg/format/WMSCapabilities.js":
/*!********************************************!*\
  !*** ./build/wg/format/WMSCapabilities.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _XML_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XML.js */ "./build/wg/format/XML.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../xml.js */ "./build/wg/xml.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./xsd.js */ "./build/wg/format/xsd.js");
/* harmony import */ var _xlink_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./xlink.js */ "./build/wg/format/xlink.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/WMSCapabilities
 */






/**
 * @const
 * @type {Array<null|string>}
 */

var NAMESPACE_URIS = [null, 'http://www.opengis.net/wms'];
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Service': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readService),
  'Capability': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readCapability)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var CAPABILITY_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Request': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readRequest),
  'Exception': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readException),
  'Layer': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readCapabilityLayer)
});
/**
 * @classdesc
 * Format for reading WMS capabilities data
 *
 * @api
 */

var WMSCapabilities =
/** @class */
function (_super) {
  __extends(WMSCapabilities, _super);

  function WMSCapabilities() {
    var _this = _super.call(this) || this;
    /**
     * @type {string|undefined}
     */


    _this.version = undefined;
    return _this;
  }
  /**
   * @param {Element} node Node.
   * @return {Object} Object
   */


  WMSCapabilities.prototype.readFromNode = function (node) {
    this.version = node.getAttribute('version').trim();
    var wmsCapabilityObject = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({
      'version': this.version
    }, PARSERS, node, []);
    return wmsCapabilityObject ? wmsCapabilityObject : null;
  };

  return WMSCapabilities;
}(_XML_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var SERVICE_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Name': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'Title': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'Abstract': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'KeywordList': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readKeywordList),
  'OnlineResource': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xlink_js__WEBPACK_IMPORTED_MODULE_3__.readHref),
  'ContactInformation': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readContactInformation),
  'Fees': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'AccessConstraints': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'LayerLimit': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readPositiveInteger),
  'MaxWidth': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readPositiveInteger),
  'MaxHeight': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readPositiveInteger)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var CONTACT_INFORMATION_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'ContactPersonPrimary': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readContactPersonPrimary),
  'ContactPosition': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'ContactAddress': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readContactAddress),
  'ContactVoiceTelephone': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'ContactFacsimileTelephone': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'ContactElectronicMailAddress': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var CONTACT_PERSON_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'ContactPerson': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'ContactOrganization': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var CONTACT_ADDRESS_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'AddressType': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'Address': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'City': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'StateOrProvince': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'PostCode': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'Country': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var EXCEPTION_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Format': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeArrayPusher)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var LAYER_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Name': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'Title': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'Abstract': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'KeywordList': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readKeywordList),
  'CRS': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'EX_GeographicBoundingBox': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readEXGeographicBoundingBox),
  'BoundingBox': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readBoundingBox),
  'Dimension': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readDimension),
  'Attribution': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readAttribution),
  'AuthorityURL': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readAuthorityURL),
  'Identifier': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'MetadataURL': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readMetadataURL),
  'DataURL': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readFormatOnlineresource),
  'FeatureListURL': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readFormatOnlineresource),
  'Style': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readStyle),
  'MinScaleDenominator': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimal),
  'MaxScaleDenominator': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimal),
  'Layer': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readLayer)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var ATTRIBUTION_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Title': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'OnlineResource': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xlink_js__WEBPACK_IMPORTED_MODULE_3__.readHref),
  'LogoURL': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readSizedFormatOnlineresource)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'westBoundLongitude': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimal),
  'eastBoundLongitude': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimal),
  'southBoundLatitude': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimal),
  'northBoundLatitude': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimal)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var REQUEST_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'GetCapabilities': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readOperationType),
  'GetMap': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readOperationType),
  'GetFeatureInfo': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readOperationType)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var OPERATIONTYPE_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Format': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'DCPType': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readDCPType)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var DCPTYPE_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'HTTP': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readHTTP)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var HTTP_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Get': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readFormatOnlineresource),
  'Post': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readFormatOnlineresource)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var STYLE_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Name': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'Title': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'Abstract': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'LegendURL': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readSizedFormatOnlineresource),
  'StyleSheetURL': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readFormatOnlineresource),
  'StyleURL': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readFormatOnlineresource)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var FORMAT_ONLINERESOURCE_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Format': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString),
  'OnlineResource': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xlink_js__WEBPACK_IMPORTED_MODULE_3__.readHref)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var KEYWORDLIST_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Keyword': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeArrayPusher)(_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Attribution object.
 */

function readAttribution(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, ATTRIBUTION_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object} Bounding box object.
 */


function readBoundingBox(node, objectStack) {
  var extent = [(0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimalString)(node.getAttribute('minx')), (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimalString)(node.getAttribute('miny')), (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimalString)(node.getAttribute('maxx')), (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimalString)(node.getAttribute('maxy'))];
  var resolutions = [(0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimalString)(node.getAttribute('resx')), (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimalString)(node.getAttribute('resy'))];
  return {
    'crs': node.getAttribute('CRS'),
    'extent': extent,
    'res': resolutions
  };
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {import("../extent.js").Extent|undefined} Bounding box object.
 */


function readEXGeographicBoundingBox(node, objectStack) {
  var geographicBoundingBox = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS, node, objectStack);

  if (!geographicBoundingBox) {
    return undefined;
  }

  var westBoundLongitude =
  /** @type {number|undefined} */
  geographicBoundingBox['westBoundLongitude'];
  var southBoundLatitude =
  /** @type {number|undefined} */
  geographicBoundingBox['southBoundLatitude'];
  var eastBoundLongitude =
  /** @type {number|undefined} */
  geographicBoundingBox['eastBoundLongitude'];
  var northBoundLatitude =
  /** @type {number|undefined} */
  geographicBoundingBox['northBoundLatitude'];

  if (westBoundLongitude === undefined || southBoundLatitude === undefined || eastBoundLongitude === undefined || northBoundLatitude === undefined) {
    return undefined;
  }

  return [westBoundLongitude, southBoundLatitude, eastBoundLongitude, northBoundLatitude];
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Capability object.
 */


function readCapability(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, CAPABILITY_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Service object.
 */


function readService(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, SERVICE_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Contact information object.
 */


function readContactInformation(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, CONTACT_INFORMATION_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Contact person object.
 */


function readContactPersonPrimary(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, CONTACT_PERSON_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Contact address object.
 */


function readContactAddress(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, CONTACT_ADDRESS_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<string>|undefined} Format array.
 */


function readException(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)([], EXCEPTION_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Layer object.
 */


function readCapabilityLayer(node, objectStack) {
  var layerObject = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, LAYER_PARSERS, node, objectStack);

  if (layerObject['Layer'] === undefined) {
    return Object.assign(layerObject, readLayer(node, objectStack));
  }

  return layerObject;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Layer object.
 */


function readLayer(node, objectStack) {
  var parentLayerObject =
  /**  @type {!Object<string,*>} */
  objectStack[objectStack.length - 1];
  var layerObject = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, LAYER_PARSERS, node, objectStack);

  if (!layerObject) {
    return undefined;
  }

  var queryable = (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readBooleanString)(node.getAttribute('queryable'));

  if (queryable === undefined) {
    queryable = parentLayerObject['queryable'];
  }

  layerObject['queryable'] = queryable !== undefined ? queryable : false;
  var cascaded = (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readNonNegativeIntegerString)(node.getAttribute('cascaded'));

  if (cascaded === undefined) {
    cascaded = parentLayerObject['cascaded'];
  }

  layerObject['cascaded'] = cascaded;
  var opaque = (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readBooleanString)(node.getAttribute('opaque'));

  if (opaque === undefined) {
    opaque = parentLayerObject['opaque'];
  }

  layerObject['opaque'] = opaque !== undefined ? opaque : false;
  var noSubsets = (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readBooleanString)(node.getAttribute('noSubsets'));

  if (noSubsets === undefined) {
    noSubsets = parentLayerObject['noSubsets'];
  }

  layerObject['noSubsets'] = noSubsets !== undefined ? noSubsets : false;
  var fixedWidth = (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimalString)(node.getAttribute('fixedWidth'));

  if (!fixedWidth) {
    fixedWidth = parentLayerObject['fixedWidth'];
  }

  layerObject['fixedWidth'] = fixedWidth;
  var fixedHeight = (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readDecimalString)(node.getAttribute('fixedHeight'));

  if (!fixedHeight) {
    fixedHeight = parentLayerObject['fixedHeight'];
  }

  layerObject['fixedHeight'] = fixedHeight; // See 7.2.4.8

  var addKeys = ['Style', 'CRS', 'AuthorityURL'];
  addKeys.forEach(function (key) {
    if (key in parentLayerObject) {
      var childValue = layerObject[key] || [];
      layerObject[key] = childValue.concat(parentLayerObject[key]);
    }
  });
  var replaceKeys = ['EX_GeographicBoundingBox', 'BoundingBox', 'Dimension', 'Attribution', 'MinScaleDenominator', 'MaxScaleDenominator'];
  replaceKeys.forEach(function (key) {
    if (!(key in layerObject)) {
      var parentValue = parentLayerObject[key];
      layerObject[key] = parentValue;
    }
  });
  return layerObject;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object} Dimension object.
 */


function readDimension(node, objectStack) {
  var dimensionObject = {
    'name': node.getAttribute('name'),
    'units': node.getAttribute('units'),
    'unitSymbol': node.getAttribute('unitSymbol'),
    'default': node.getAttribute('default'),
    'multipleValues': (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readBooleanString)(node.getAttribute('multipleValues')),
    'nearestValue': (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readBooleanString)(node.getAttribute('nearestValue')),
    'current': (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readBooleanString)(node.getAttribute('current')),
    'values': (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readString)(node)
  };
  return dimensionObject;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Online resource object.
 */


function readFormatOnlineresource(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, FORMAT_ONLINERESOURCE_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Request object.
 */


function readRequest(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, REQUEST_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} DCP type object.
 */


function readDCPType(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, DCPTYPE_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} HTTP object.
 */


function readHTTP(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, HTTP_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Operation type object.
 */


function readOperationType(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, OPERATIONTYPE_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Online resource object.
 */


function readSizedFormatOnlineresource(node, objectStack) {
  var formatOnlineresource = readFormatOnlineresource(node, objectStack);

  if (formatOnlineresource) {
    var size = [(0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readNonNegativeIntegerString)(node.getAttribute('width')), (0,_xsd_js__WEBPACK_IMPORTED_MODULE_2__.readNonNegativeIntegerString)(node.getAttribute('height'))];
    formatOnlineresource['size'] = size;
    return formatOnlineresource;
  }

  return undefined;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Authority URL object.
 */


function readAuthorityURL(node, objectStack) {
  var authorityObject = readFormatOnlineresource(node, objectStack);

  if (authorityObject) {
    authorityObject['name'] = node.getAttribute('name');
    return authorityObject;
  }

  return undefined;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Metadata URL object.
 */


function readMetadataURL(node, objectStack) {
  var metadataObject = readFormatOnlineresource(node, objectStack);

  if (metadataObject) {
    metadataObject['type'] = node.getAttribute('type');
    return metadataObject;
  }

  return undefined;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Style object.
 */


function readStyle(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, STYLE_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<string>|undefined} Keyword list.
 */


function readKeywordList(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)([], KEYWORDLIST_PARSERS, node, objectStack);
}

/* harmony default export */ __webpack_exports__["default"] = (WMSCapabilities);

/***/ }),

/***/ "./build/wg/format/WMSGetFeatureInfo.js":
/*!**********************************************!*\
  !*** ./build/wg/format/WMSGetFeatureInfo.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GML2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GML2.js */ "./build/wg/format/GML2.js");
/* harmony import */ var _XMLFeature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./XMLFeature.js */ "./build/wg/format/XMLFeature.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../xml.js */ "./build/wg/xml.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/WMSGetFeatureInfo
 */







/**
 * @typedef {Object} Options
 * @property {Array<string>} [layers] If set, only features of the given layers will be returned by the format when read.
 */

/**
 * @const
 * @type {string}
 */

var featureIdentifier = '_feature';
/**
 * @const
 * @type {string}
 */

var layerIdentifier = '_layer';
/**
 * @classdesc
 * Format for reading WMSGetFeatureInfo format. It uses
 * {@link module:wg/format/GML2~GML2} to read features.
 *
 * @api
 */

var WMSGetFeatureInfo =
/** @class */
function (_super) {
  __extends(WMSGetFeatureInfo, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function WMSGetFeatureInfo(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @private
     * @type {string}
     */

    _this.featureNS_ = 'http://mapserver.gis.umn.edu/mapserver';
    /**
     * @private
     * @type {GML2}
     */

    _this.gmlFormat_ = new _GML2_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
    /**
     * @private
     * @type {Array<string>|null}
     */

    _this.layers_ = options.layers ? options.layers : null;
    return _this;
  }
  /**
   * @return {Array<string>|null} layers
   */


  WMSGetFeatureInfo.prototype.getLayers = function () {
    return this.layers_;
  };
  /**
   * @param {Array<string>|null} layers Layers to parse.
   */


  WMSGetFeatureInfo.prototype.setLayers = function (layers) {
    this.layers_ = layers;
  };
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<import("../Feature.js").default>} Features.
   * @private
   */


  WMSGetFeatureInfo.prototype.readFeatures_ = function (node, objectStack) {
    node.setAttribute('namespaceURI', this.featureNS_);
    var localName = node.localName;
    /** @type {Array<import("../Feature.js").default>} */

    var features = [];

    if (node.childNodes.length === 0) {
      return features;
    }

    if (localName == 'msGMLOutput') {
      for (var i = 0, ii = node.childNodes.length; i < ii; i++) {
        var layer = node.childNodes[i];

        if (layer.nodeType !== Node.ELEMENT_NODE) {
          continue;
        }

        var layerElement =
        /** @type {Element} */
        layer;
        var context = objectStack[0];
        var toRemove = layerIdentifier;
        var layerName = layerElement.localName.replace(toRemove, '');

        if (this.layers_ && !(0,_array_js__WEBPACK_IMPORTED_MODULE_1__.includes)(this.layers_, layerName)) {
          continue;
        }

        var featureType = layerName + featureIdentifier;
        context['featureType'] = featureType;
        context['featureNS'] = this.featureNS_;
        /** @type {Object<string, import("../xml.js").Parser>} */

        var parsers = {};
        parsers[featureType] = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeArrayPusher)(this.gmlFormat_.readFeatureElement, this.gmlFormat_);
        var parsersNS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.makeStructureNS)([context['featureNS'], null], parsers);
        layerElement.setAttribute('namespaceURI', this.featureNS_);
        var layerFeatures = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([], // @ts-ignore
        parsersNS, layerElement, objectStack, this.gmlFormat_);

        if (layerFeatures) {
          (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(features, layerFeatures);
        }
      }
    }

    if (localName == 'FeatureCollection') {
      var gmlFeatures = (0,_xml_js__WEBPACK_IMPORTED_MODULE_2__.pushParseAndPop)([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node, [{}], this.gmlFormat_);

      if (gmlFeatures) {
        features = gmlFeatures;
      }
    }

    return features;
  };
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */


  WMSGetFeatureInfo.prototype.readFeaturesFromNode = function (node, opt_options) {
    var options = {};

    if (opt_options) {
      (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.assign)(options, this.getReadOptions(node, opt_options));
    }

    return this.readFeatures_(node, [options]);
  };

  return WMSGetFeatureInfo;
}(_XMLFeature_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (WMSGetFeatureInfo);

/***/ }),

/***/ "./build/wg/format/WMTSCapabilities.js":
/*!*********************************************!*\
  !*** ./build/wg/format/WMTSCapabilities.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _OWS_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OWS.js */ "./build/wg/format/OWS.js");
/* harmony import */ var _XML_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./XML.js */ "./build/wg/format/XML.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../xml.js */ "./build/wg/xml.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./xsd.js */ "./build/wg/format/xsd.js");
/* harmony import */ var _xlink_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./xlink.js */ "./build/wg/format/xlink.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/WMTSCapabilities
 */








/**
 * @const
 * @type {Array<null|string>}
 */

var NAMESPACE_URIS = [null, 'http://www.opengis.net/wmts/1.0'];
/**
 * @const
 * @type {Array<null|string>}
 */

var OWS_NAMESPACE_URIS = [null, 'http://www.opengis.net/ows/1.1'];
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Contents': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readContents)
});
/**
 * @classdesc
 * Format for reading WMTS capabilities data.
 *
 * @api
 */

var WMTSCapabilities =
/** @class */
function (_super) {
  __extends(WMTSCapabilities, _super);

  function WMTSCapabilities() {
    var _this = _super.call(this) || this;
    /**
     * @type {OWS}
     * @private
     */


    _this.owsParser_ = new _OWS_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
    return _this;
  }
  /**
   * @param {Element} node Node.
   * @return {Object} Object
   */


  WMTSCapabilities.prototype.readFromNode = function (node) {
    var version = node.getAttribute('version');

    if (version) {
      version = version.trim();
    }

    var WMTSCapabilityObject = this.owsParser_.readFromNode(node);

    if (!WMTSCapabilityObject) {
      return null;
    }

    WMTSCapabilityObject['version'] = version;
    WMTSCapabilityObject = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)(WMTSCapabilityObject, PARSERS, node, []);
    return WMTSCapabilityObject ? WMTSCapabilityObject : null;
  };

  return WMTSCapabilities;
}(_XML_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore


var CONTENTS_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Layer': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readLayer),
  'TileMatrixSet': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readTileMatrixSet)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var LAYER_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Style': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readStyle),
  'Format': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'TileMatrixSetLink': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readTileMatrixSetLink),
  'Dimension': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readDimensions),
  'ResourceURL': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readResourceUrl)
}, (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(OWS_NAMESPACE_URIS, {
  'Title': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'Abstract': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'WGS84BoundingBox': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readBoundingBox),
  'Identifier': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString)
}));
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var STYLE_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'LegendURL': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readLegendUrl)
}, (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(OWS_NAMESPACE_URIS, {
  'Title': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'Identifier': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString)
}));
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var TMS_LINKS_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'TileMatrixSet': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'TileMatrixSetLimits': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readTileMatrixLimitsList)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var TMS_LIMITS_LIST_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'TileMatrixLimits': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeArrayPusher)(readTileMatrixLimits)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var TMS_LIMITS_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'TileMatrix': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'MinTileRow': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readPositiveInteger),
  'MaxTileRow': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readPositiveInteger),
  'MinTileCol': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readPositiveInteger),
  'MaxTileCol': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readPositiveInteger)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var DIMENSION_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'Default': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'Value': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString)
}, (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(OWS_NAMESPACE_URIS, {
  'Identifier': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString)
}));
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var WGS84_BBOX_READERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(OWS_NAMESPACE_URIS, {
  'LowerCorner': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeArrayPusher)(readCoordinates),
  'UpperCorner': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeArrayPusher)(readCoordinates)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var TMS_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'WellKnownScaleSet': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'TileMatrix': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertyPusher)(readTileMatrix)
}, (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(OWS_NAMESPACE_URIS, {
  'SupportedCRS': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'Identifier': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString),
  'BoundingBox': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readBoundingBox)
}));
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore

var TM_PARSERS = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(NAMESPACE_URIS, {
  'TopLeftCorner': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(readCoordinates),
  'ScaleDenominator': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readDecimal),
  'TileWidth': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readPositiveInteger),
  'TileHeight': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readPositiveInteger),
  'MatrixWidth': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readPositiveInteger),
  'MatrixHeight': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readPositiveInteger)
}, (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeStructureNS)(OWS_NAMESPACE_URIS, {
  'Identifier': (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.makeObjectPropertySetter)(_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString)
}));
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Attribution object.
 */

function readContents(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, CONTENTS_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Layers object.
 */


function readLayer(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, LAYER_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Tile Matrix Set object.
 */


function readTileMatrixSet(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, TMS_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Style object.
 */


function readStyle(node, objectStack) {
  var style = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, STYLE_PARSERS, node, objectStack);

  if (!style) {
    return undefined;
  }

  var isDefault = node.getAttribute('isDefault') === 'true';
  style['isDefault'] = isDefault;
  return style;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Tile Matrix Set Link object.
 */


function readTileMatrixSetLink(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, TMS_LINKS_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Dimension object.
 */


function readDimensions(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, DIMENSION_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Resource URL object.
 */


function readResourceUrl(node, objectStack) {
  var format = node.getAttribute('format');
  var template = node.getAttribute('template');
  var resourceType = node.getAttribute('resourceType');
  var resource = {};

  if (format) {
    resource['format'] = format;
  }

  if (template) {
    resource['template'] = template;
  }

  if (resourceType) {
    resource['resourceType'] = resourceType;
  }

  return resource;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} BBox object.
 */


function readBoundingBox(node, objectStack) {
  var coordinates = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)([], WGS84_BBOX_READERS, node, objectStack);

  if (coordinates.length != 2) {
    return undefined;
  }

  return (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.boundingExtent)(coordinates);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Legend object.
 */


function readLegendUrl(node, objectStack) {
  var legend = {};
  legend['format'] = node.getAttribute('format');
  legend['href'] = (0,_xlink_js__WEBPACK_IMPORTED_MODULE_5__.readHref)(node);
  return legend;
}
/**
 * @param {Node} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Coordinates object.
 */


function readCoordinates(node, objectStack) {
  var coordinates = (0,_xsd_js__WEBPACK_IMPORTED_MODULE_3__.readString)(node).split(/\s+/);

  if (!coordinates || coordinates.length != 2) {
    return undefined;
  }

  var x = +coordinates[0];
  var y = +coordinates[1];

  if (isNaN(x) || isNaN(y)) {
    return undefined;
  }

  return [x, y];
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} TileMatrix object.
 */


function readTileMatrix(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, TM_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} TileMatrixSetLimits Object.
 */


function readTileMatrixLimitsList(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)([], TMS_LIMITS_LIST_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} TileMatrixLimits Array.
 */


function readTileMatrixLimits(node, objectStack) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.pushParseAndPop)({}, TMS_LIMITS_PARSERS, node, objectStack);
}

/* harmony default export */ __webpack_exports__["default"] = (WMTSCapabilities);

/***/ }),

/***/ "./build/wg/format/XML.js":
/*!********************************!*\
  !*** ./build/wg/format/XML.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../xml.js */ "./build/wg/xml.js");
/**
 * @module wg/format/XML
 */

/**
 * @classdesc
 * Generic format for reading non-feature XML data
 *
 * @abstract
 */

var XML =
/** @class */
function () {
  function XML() {}
  /**
   * Read the source document.
   *
   * @param {Document|Element|string} source The XML source.
   * @return {Object} An object representing the source.
   * @api
   */


  XML.prototype.read = function (source) {
    if (!source) {
      return null;
    } else if (typeof source === 'string') {
      var doc = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.parse)(source);
      return this.readFromDocument(doc);
    } else if ((0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.isDocument)(source)) {
      return this.readFromDocument(
      /** @type {Document} */
      source);
    } else {
      return this.readFromNode(
      /** @type {Element} */
      source);
    }
  };
  /**
   * @param {Document} doc Document.
   * @return {Object} Object
   */


  XML.prototype.readFromDocument = function (doc) {
    for (var n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readFromNode(
        /** @type {Element} */
        n);
      }
    }

    return null;
  };
  /**
   * @abstract
   * @param {Element} node Node.
   * @return {Object} Object
   */


  XML.prototype.readFromNode = function (node) {};

  return XML;
}();

/* harmony default export */ __webpack_exports__["default"] = (XML);

/***/ }),

/***/ "./build/wg/format/XMLFeature.js":
/*!***************************************!*\
  !*** ./build/wg/format/XMLFeature.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _format_Feature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../format/Feature.js */ "./build/wg/format/Feature.js");
/* harmony import */ var _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../format/FormatType.js */ "./build/wg/format/FormatType.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../xml.js */ "./build/wg/xml.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/XMLFeature
 */







/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for XML feature formats.
 *
 * @abstract
 */

var XMLFeature =
/** @class */
function (_super) {
  __extends(XMLFeature, _super);

  function XMLFeature() {
    var _this = _super.call(this) || this;
    /**
     * @type {XMLSerializer}
     * @private
     */


    _this.xmlSerializer_ = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.getXMLSerializer)();
    return _this;
  }
  /**
   * @return {import("./FormatType.js").default} Format.
   */


  XMLFeature.prototype.getType = function () {
    return _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].XML;
  };
  /**
   * Read a single feature.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */


  XMLFeature.prototype.readFeature = function (source, opt_options) {
    if (!source) {
      return null;
    } else if (typeof source === 'string') {
      var doc = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.parse)(source);
      return this.readFeatureFromDocument(doc, opt_options);
    } else if ((0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.isDocument)(source)) {
      return this.readFeatureFromDocument(
      /** @type {Document} */
      source, opt_options);
    } else {
      return this.readFeatureFromNode(
      /** @type {Element} */
      source, opt_options);
    }
  };
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @return {import("../Feature.js").default} Feature.
   */


  XMLFeature.prototype.readFeatureFromDocument = function (doc, opt_options) {
    var features = this.readFeaturesFromDocument(doc, opt_options);

    if (features.length > 0) {
      return features[0];
    } else {
      return null;
    }
  };
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @return {import("../Feature.js").default} Feature.
   */


  XMLFeature.prototype.readFeatureFromNode = function (node, opt_options) {
    return null; // not implemented
  };
  /**
   * Read all features from a feature collection.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */


  XMLFeature.prototype.readFeatures = function (source, opt_options) {
    if (!source) {
      return [];
    } else if (typeof source === 'string') {
      var doc = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.parse)(source);
      return this.readFeaturesFromDocument(doc, opt_options);
    } else if ((0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.isDocument)(source)) {
      return this.readFeaturesFromDocument(
      /** @type {Document} */
      source, opt_options);
    } else {
      return this.readFeaturesFromNode(
      /** @type {Element} */
      source, opt_options);
    }
  };
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */


  XMLFeature.prototype.readFeaturesFromDocument = function (doc, opt_options) {
    /** @type {Array<import("../Feature.js").default>} */
    var features = [];

    for (var n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        (0,_array_js__WEBPACK_IMPORTED_MODULE_2__.extend)(features, this.readFeaturesFromNode(
        /** @type {Element} */
        n, opt_options));
      }
    }

    return features;
  };
  /**
   * @abstract
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */


  XMLFeature.prototype.readFeaturesFromNode = function (node, opt_options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.abstract)();
  };
  /**
   * Read a single geometry from a source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */


  XMLFeature.prototype.readGeometry = function (source, opt_options) {
    if (!source) {
      return null;
    } else if (typeof source === 'string') {
      var doc = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.parse)(source);
      return this.readGeometryFromDocument(doc, opt_options);
    } else if ((0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.isDocument)(source)) {
      return this.readGeometryFromDocument(
      /** @type {Document} */
      source, opt_options);
    } else {
      return this.readGeometryFromNode(
      /** @type {Element} */
      source, opt_options);
    }
  };
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */


  XMLFeature.prototype.readGeometryFromDocument = function (doc, opt_options) {
    return null; // not implemented
  };
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */


  XMLFeature.prototype.readGeometryFromNode = function (node, opt_options) {
    return null; // not implemented
  };
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */


  XMLFeature.prototype.readProjection = function (source) {
    if (!source) {
      return null;
    } else if (typeof source === 'string') {
      var doc = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.parse)(source);
      return this.readProjectionFromDocument(doc);
    } else if ((0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.isDocument)(source)) {
      return this.readProjectionFromDocument(
      /** @type {Document} */
      source);
    } else {
      return this.readProjectionFromNode(
      /** @type {Element} */
      source);
    }
  };
  /**
   * @param {Document} doc Document.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */


  XMLFeature.prototype.readProjectionFromDocument = function (doc) {
    return this.dataProjection;
  };
  /**
   * @param {Element} node Node.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */


  XMLFeature.prototype.readProjectionFromNode = function (node) {
    return this.dataProjection;
  };
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {string} Encoded feature.
   */


  XMLFeature.prototype.writeFeature = function (feature, opt_options) {
    var node = this.writeFeatureNode(feature, opt_options);
    return this.xmlSerializer_.serializeToString(node);
  };
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Options.
   * @protected
   * @return {Node} Node.
   */


  XMLFeature.prototype.writeFeatureNode = function (feature, opt_options) {
    return null; // not implemented
  };
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {string} Result.
   * @api
   */


  XMLFeature.prototype.writeFeatures = function (features, opt_options) {
    var node = this.writeFeaturesNode(features, opt_options);
    return this.xmlSerializer_.serializeToString(node);
  };
  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Options.
   * @return {Node} Node.
   */


  XMLFeature.prototype.writeFeaturesNode = function (features, opt_options) {
    return null; // not implemented
  };
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
   * @return {string} Encoded geometry.
   */


  XMLFeature.prototype.writeGeometry = function (geometry, opt_options) {
    var node = this.writeGeometryNode(geometry, opt_options);
    return this.xmlSerializer_.serializeToString(node);
  };
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [opt_options] Options.
   * @return {Node} Node.
   */


  XMLFeature.prototype.writeGeometryNode = function (geometry, opt_options) {
    return null; // not implemented
  };

  return XMLFeature;
}(_format_Feature_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (XMLFeature);

/***/ }),

/***/ "./build/wg/format/filter.js":
/*!***********************************!*\
  !*** ./build/wg/format/filter.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "and": function() { return /* binding */ and; },
/* harmony export */   "or": function() { return /* binding */ or; },
/* harmony export */   "not": function() { return /* binding */ not; },
/* harmony export */   "bbox": function() { return /* binding */ bbox; },
/* harmony export */   "contains": function() { return /* binding */ contains; },
/* harmony export */   "intersects": function() { return /* binding */ intersects; },
/* harmony export */   "disjoint": function() { return /* binding */ disjoint; },
/* harmony export */   "within": function() { return /* binding */ within; },
/* harmony export */   "dwithin": function() { return /* binding */ dwithin; },
/* harmony export */   "equalTo": function() { return /* binding */ equalTo; },
/* harmony export */   "notEqualTo": function() { return /* binding */ notEqualTo; },
/* harmony export */   "lessThan": function() { return /* binding */ lessThan; },
/* harmony export */   "lessThanOrEqualTo": function() { return /* binding */ lessThanOrEqualTo; },
/* harmony export */   "greaterThan": function() { return /* binding */ greaterThan; },
/* harmony export */   "greaterThanOrEqualTo": function() { return /* binding */ greaterThanOrEqualTo; },
/* harmony export */   "isNull": function() { return /* binding */ isNull; },
/* harmony export */   "between": function() { return /* binding */ between; },
/* harmony export */   "like": function() { return /* binding */ like; },
/* harmony export */   "during": function() { return /* binding */ during; },
/* harmony export */   "resourceId": function() { return /* binding */ resourceId; }
/* harmony export */ });
/* harmony import */ var _filter_And_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter/And.js */ "./build/wg/format/filter/And.js");
/* harmony import */ var _filter_Bbox_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter/Bbox.js */ "./build/wg/format/filter/Bbox.js");
/* harmony import */ var _filter_Contains_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter/Contains.js */ "./build/wg/format/filter/Contains.js");
/* harmony import */ var _filter_DWithin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./filter/DWithin.js */ "./build/wg/format/filter/DWithin.js");
/* harmony import */ var _filter_Disjoint_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./filter/Disjoint.js */ "./build/wg/format/filter/Disjoint.js");
/* harmony import */ var _filter_During_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./filter/During.js */ "./build/wg/format/filter/During.js");
/* harmony import */ var _filter_EqualTo_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./filter/EqualTo.js */ "./build/wg/format/filter/EqualTo.js");
/* harmony import */ var _filter_GreaterThan_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./filter/GreaterThan.js */ "./build/wg/format/filter/GreaterThan.js");
/* harmony import */ var _filter_GreaterThanOrEqualTo_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./filter/GreaterThanOrEqualTo.js */ "./build/wg/format/filter/GreaterThanOrEqualTo.js");
/* harmony import */ var _filter_Intersects_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./filter/Intersects.js */ "./build/wg/format/filter/Intersects.js");
/* harmony import */ var _filter_IsBetween_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./filter/IsBetween.js */ "./build/wg/format/filter/IsBetween.js");
/* harmony import */ var _filter_IsLike_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./filter/IsLike.js */ "./build/wg/format/filter/IsLike.js");
/* harmony import */ var _filter_IsNull_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./filter/IsNull.js */ "./build/wg/format/filter/IsNull.js");
/* harmony import */ var _filter_LessThan_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./filter/LessThan.js */ "./build/wg/format/filter/LessThan.js");
/* harmony import */ var _filter_LessThanOrEqualTo_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./filter/LessThanOrEqualTo.js */ "./build/wg/format/filter/LessThanOrEqualTo.js");
/* harmony import */ var _filter_Not_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter/Not.js */ "./build/wg/format/filter/Not.js");
/* harmony import */ var _filter_NotEqualTo_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./filter/NotEqualTo.js */ "./build/wg/format/filter/NotEqualTo.js");
/* harmony import */ var _filter_Or_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./filter/Or.js */ "./build/wg/format/filter/Or.js");
/* harmony import */ var _filter_ResourceId_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./filter/ResourceId.js */ "./build/wg/format/filter/ResourceId.js");
/* harmony import */ var _filter_Within_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./filter/Within.js */ "./build/wg/format/filter/Within.js");
/**
 * @module wg/format/filter
 */




















/**
 * Create a logical `<And>` operator between two or more filter conditions.
 *
 * @param {...import("./filter/Filter.js").default} conditions Filter conditions.
 * @return {!And} `<And>` operator.
 * @api
 */

function and(conditions) {
  var params = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(_filter_And_js__WEBPACK_IMPORTED_MODULE_0__["default"], params))();
}
/**
 * Create a logical `<Or>` operator between two or more filter conditions.
 *
 * @param {...import("./filter/Filter.js").default} conditions Filter conditions.
 * @return {!Or} `<Or>` operator.
 * @api
 */

function or(conditions) {
  var params = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(_filter_Or_js__WEBPACK_IMPORTED_MODULE_1__["default"], params))();
}
/**
 * Represents a logical `<Not>` operator for a filter condition.
 *
 * @param {!import("./filter/Filter.js").default} condition Filter condition.
 * @return {!Not} `<Not>` operator.
 * @api
 */

function not(condition) {
  return new _filter_Not_js__WEBPACK_IMPORTED_MODULE_2__["default"](condition);
}
/**
 * Create a `<BBOX>` operator to test whether a geometry-valued property
 * intersects a fixed bounding box
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../extent.js").Extent} extent Extent.
 * @param {string} [opt_srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Bbox} `<BBOX>` operator.
 * @api
 */

function bbox(geometryName, extent, opt_srsName) {
  return new _filter_Bbox_js__WEBPACK_IMPORTED_MODULE_3__["default"](geometryName, extent, opt_srsName);
}
/**
 * Create a `<Contains>` operator to test whether a geometry-valued property
 * contains a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [opt_srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Contains} `<Contains>` operator.
 * @api
 */

function contains(geometryName, geometry, opt_srsName) {
  return new _filter_Contains_js__WEBPACK_IMPORTED_MODULE_4__["default"](geometryName, geometry, opt_srsName);
}
/**
 * Create a `<Intersects>` operator to test whether a geometry-valued property
 * intersects a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [opt_srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Intersects} `<Intersects>` operator.
 * @api
 */

function intersects(geometryName, geometry, opt_srsName) {
  return new _filter_Intersects_js__WEBPACK_IMPORTED_MODULE_5__["default"](geometryName, geometry, opt_srsName);
}
/**
 * Create a `<Disjoint>` operator to test whether a geometry-valued property
 * is disjoint to a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [opt_srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Disjoint} `<Disjoint>` operator.
 * @api
 */

function disjoint(geometryName, geometry, opt_srsName) {
  return new _filter_Disjoint_js__WEBPACK_IMPORTED_MODULE_6__["default"](geometryName, geometry, opt_srsName);
}
/**
 * Create a `<Within>` operator to test whether a geometry-valued property
 * is within a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [opt_srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Within} `<Within>` operator.
 * @api
 */

function within(geometryName, geometry, opt_srsName) {
  return new _filter_Within_js__WEBPACK_IMPORTED_MODULE_7__["default"](geometryName, geometry, opt_srsName);
}
/**
 * Create a `<DWithin>` operator to test whether a geometry-valued property
 * is within a distance to a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {!number} distance Distance.
 * @param {!string} unit Unit.
 * @param {string} [opt_srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!DWithin} `<DWithin>` operator.
 * @api
 */

function dwithin(geometryName, geometry, distance, unit, opt_srsName) {
  return new _filter_DWithin_js__WEBPACK_IMPORTED_MODULE_8__["default"](geometryName, geometry, distance, unit, opt_srsName);
}
/**
 * Creates a `<PropertyIsEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!(string|number)} expression The value to compare.
 * @param {boolean} [opt_matchCase] Case-sensitive?
 * @return {!EqualTo} `<PropertyIsEqualTo>` operator.
 * @api
 */

function equalTo(propertyName, expression, opt_matchCase) {
  return new _filter_EqualTo_js__WEBPACK_IMPORTED_MODULE_9__["default"](propertyName, expression, opt_matchCase);
}
/**
 * Creates a `<PropertyIsNotEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!(string|number)} expression The value to compare.
 * @param {boolean} [opt_matchCase] Case-sensitive?
 * @return {!NotEqualTo} `<PropertyIsNotEqualTo>` operator.
 * @api
 */

function notEqualTo(propertyName, expression, opt_matchCase) {
  return new _filter_NotEqualTo_js__WEBPACK_IMPORTED_MODULE_10__["default"](propertyName, expression, opt_matchCase);
}
/**
 * Creates a `<PropertyIsLessThan>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!LessThan} `<PropertyIsLessThan>` operator.
 * @api
 */

function lessThan(propertyName, expression) {
  return new _filter_LessThan_js__WEBPACK_IMPORTED_MODULE_11__["default"](propertyName, expression);
}
/**
 * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.
 * @api
 */

function lessThanOrEqualTo(propertyName, expression) {
  return new _filter_LessThanOrEqualTo_js__WEBPACK_IMPORTED_MODULE_12__["default"](propertyName, expression);
}
/**
 * Creates a `<PropertyIsGreaterThan>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!GreaterThan} `<PropertyIsGreaterThan>` operator.
 * @api
 */

function greaterThan(propertyName, expression) {
  return new _filter_GreaterThan_js__WEBPACK_IMPORTED_MODULE_13__["default"](propertyName, expression);
}
/**
 * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.
 * @api
 */

function greaterThanOrEqualTo(propertyName, expression) {
  return new _filter_GreaterThanOrEqualTo_js__WEBPACK_IMPORTED_MODULE_14__["default"](propertyName, expression);
}
/**
 * Creates a `<PropertyIsNull>` comparison operator to test whether a property value
 * is null.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @return {!IsNull} `<PropertyIsNull>` operator.
 * @api
 */

function isNull(propertyName) {
  return new _filter_IsNull_js__WEBPACK_IMPORTED_MODULE_15__["default"](propertyName);
}
/**
 * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression
 * value lies within a range given by a lower and upper bound (inclusive).
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} lowerBoundary The lower bound of the range.
 * @param {!number} upperBoundary The upper bound of the range.
 * @return {!IsBetween} `<PropertyIsBetween>` operator.
 * @api
 */

function between(propertyName, lowerBoundary, upperBoundary) {
  return new _filter_IsBetween_js__WEBPACK_IMPORTED_MODULE_16__["default"](propertyName, lowerBoundary, upperBoundary);
}
/**
 * Represents a `<PropertyIsLike>` comparison operator that matches a string property
 * value against a text pattern.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!string} pattern Text pattern.
 * @param {string} [opt_wildCard] Pattern character which matches any sequence of
 *    zero or more string characters. Default is '*'.
 * @param {string} [opt_singleChar] pattern character which matches any single
 *    string character. Default is '.'.
 * @param {string} [opt_escapeChar] Escape character which can be used to escape
 *    the pattern characters. Default is '!'.
 * @param {boolean} [opt_matchCase] Case-sensitive?
 * @return {!IsLike} `<PropertyIsLike>` operator.
 * @api
 */

function like(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {
  return new _filter_IsLike_js__WEBPACK_IMPORTED_MODULE_17__["default"](propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase);
}
/**
 * Create a `<During>` temporal operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!string} begin The begin date in ISO-8601 format.
 * @param {!string} end The end date in ISO-8601 format.
 * @return {!During} `<During>` operator.
 * @api
 */

function during(propertyName, begin, end) {
  return new _filter_During_js__WEBPACK_IMPORTED_MODULE_18__["default"](propertyName, begin, end);
}
function resourceId(rid) {
  return new _filter_ResourceId_js__WEBPACK_IMPORTED_MODULE_19__["default"](rid);
}

/***/ }),

/***/ "./build/wg/format/filter/And.js":
/*!***************************************!*\
  !*** ./build/wg/format/filter/And.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LogicalNary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LogicalNary.js */ "./build/wg/format/filter/LogicalNary.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/And
 */



/**
 * @classdesc
 * Represents a logical `<And>` operator between two or more filter conditions.
 *
 * @abstract
 */

var And =
/** @class */
function (_super) {
  __extends(And, _super);
  /**
   * @param {...import("./Filter.js").default} conditions Conditions.
   */


  function And(conditions) {
    return _super.call(this, 'And', Array.prototype.slice.call(arguments)) || this;
  }

  return And;
}(_LogicalNary_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (And);

/***/ }),

/***/ "./build/wg/format/filter/Bbox.js":
/*!****************************************!*\
  !*** ./build/wg/format/filter/Bbox.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Filter.js */ "./build/wg/format/filter/Filter.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/Bbox
 */



/**
 * @classdesc
 * Represents a `<BBOX>` operator to test whether a geometry-valued property
 * intersects a fixed bounding box
 *
 * @api
 */

var Bbox =
/** @class */
function (_super) {
  __extends(Bbox, _super);
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../extent.js").Extent} extent Extent.
   * @param {string} [opt_srsName] SRS name. No srsName attribute will be set
   * on geometries when this is not provided.
   */


  function Bbox(geometryName, extent, opt_srsName) {
    var _this = _super.call(this, 'BBOX') || this;
    /**
     * @type {!string}
     */


    _this.geometryName = geometryName;
    /**
     * @type {import("../../extent.js").Extent}
     */

    _this.extent = extent;

    if (extent.length !== 4) {
      throw new Error('Expected an extent with four values ([minX, minY, maxX, maxY])');
    }
    /**
     * @type {string|undefined}
     */


    _this.srsName = opt_srsName;
    return _this;
  }

  return Bbox;
}(_Filter_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Bbox);

/***/ }),

/***/ "./build/wg/format/filter/Comparison.js":
/*!**********************************************!*\
  !*** ./build/wg/format/filter/Comparison.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Filter.js */ "./build/wg/format/filter/Filter.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/Comparison
 */



/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature property comparison filters.
 *
 * @abstract
 */

var Comparison =
/** @class */
function (_super) {
  __extends(Comparison, _super);
  /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {!string} propertyName Name of the context property to compare.
   */


  function Comparison(tagName, propertyName) {
    var _this = _super.call(this, tagName) || this;
    /**
     * @type {!string}
     */


    _this.propertyName = propertyName;
    return _this;
  }

  return Comparison;
}(_Filter_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Comparison);

/***/ }),

/***/ "./build/wg/format/filter/ComparisonBinary.js":
/*!****************************************************!*\
  !*** ./build/wg/format/filter/ComparisonBinary.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Comparison_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Comparison.js */ "./build/wg/format/filter/Comparison.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/ComparisonBinary
 */



/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature property binary comparison filters.
 *
 * @abstract
 */

var ComparisonBinary =
/** @class */
function (_super) {
  __extends(ComparisonBinary, _super);
  /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!(string|number)} expression The value to compare.
   * @param {boolean} [opt_matchCase] Case-sensitive?
   */


  function ComparisonBinary(tagName, propertyName, expression, opt_matchCase) {
    var _this = _super.call(this, tagName, propertyName) || this;
    /**
     * @type {!(string|number)}
     */


    _this.expression = expression;
    /**
     * @type {boolean|undefined}
     */

    _this.matchCase = opt_matchCase;
    return _this;
  }

  return ComparisonBinary;
}(_Comparison_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (ComparisonBinary);

/***/ }),

/***/ "./build/wg/format/filter/Contains.js":
/*!********************************************!*\
  !*** ./build/wg/format/filter/Contains.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Spatial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Spatial.js */ "./build/wg/format/filter/Spatial.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/Contains
 */



/**
 * @classdesc
 * Represents a `<Contains>` operator to test whether a geometry-valued property
 * contains a given geometry.
 * @api
 */

var Contains =
/** @class */
function (_super) {
  __extends(Contains, _super);
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [opt_srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */


  function Contains(geometryName, geometry, opt_srsName) {
    return _super.call(this, 'Contains', geometryName, geometry, opt_srsName) || this;
  }

  return Contains;
}(_Spatial_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Contains);

/***/ }),

/***/ "./build/wg/format/filter/DWithin.js":
/*!*******************************************!*\
  !*** ./build/wg/format/filter/DWithin.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Spatial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Spatial.js */ "./build/wg/format/filter/Spatial.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/DWithin
 */



/**
 * @classdesc
 * Represents a `<DWithin>` operator to test whether a geometry-valued property
 * is within a distance to a given geometry.
 * @api
 */

var DWithin =
/** @class */
function (_super) {
  __extends(DWithin, _super);
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {!number} distance Distance.
   * @param {!string} unit Unit.
   * @param {string} [opt_srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */


  function DWithin(geometryName, geometry, distance, unit, opt_srsName) {
    var _this = _super.call(this, 'DWithin', geometryName, geometry, opt_srsName) || this;
    /**
     * @public
     * @type {!number}
     */


    _this.distance = distance;
    /**
     * @public
     * @type {!string}
     */

    _this.unit = unit;
    return _this;
  }

  return DWithin;
}(_Spatial_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (DWithin);

/***/ }),

/***/ "./build/wg/format/filter/Disjoint.js":
/*!********************************************!*\
  !*** ./build/wg/format/filter/Disjoint.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Spatial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Spatial.js */ "./build/wg/format/filter/Spatial.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/Disjoint
 */



/**
 * @classdesc
 * Represents a `<Disjoint>` operator to test whether a geometry-valued property
 * is disjoint to a given geometry.
 * @api
 */

var Disjoint =
/** @class */
function (_super) {
  __extends(Disjoint, _super);
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [opt_srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */


  function Disjoint(geometryName, geometry, opt_srsName) {
    return _super.call(this, 'Disjoint', geometryName, geometry, opt_srsName) || this;
  }

  return Disjoint;
}(_Spatial_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Disjoint);

/***/ }),

/***/ "./build/wg/format/filter/During.js":
/*!******************************************!*\
  !*** ./build/wg/format/filter/During.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Comparison_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Comparison.js */ "./build/wg/format/filter/Comparison.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/During
 */



/**
 * @classdesc
 * Represents a `<During>` comparison operator.
 * @api
 */

var During =
/** @class */
function (_super) {
  __extends(During, _super);
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!string} begin The begin date in ISO-8601 format.
   * @param {!string} end The end date in ISO-8601 format.
   */


  function During(propertyName, begin, end) {
    var _this = _super.call(this, 'During', propertyName) || this;
    /**
     * @type {!string}
     */


    _this.begin = begin;
    /**
     * @type {!string}
     */

    _this.end = end;
    return _this;
  }

  return During;
}(_Comparison_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (During);

/***/ }),

/***/ "./build/wg/format/filter/EqualTo.js":
/*!*******************************************!*\
  !*** ./build/wg/format/filter/EqualTo.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ComparisonBinary.js */ "./build/wg/format/filter/ComparisonBinary.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/EqualTo
 */



/**
 * @classdesc
 * Represents a `<PropertyIsEqualTo>` comparison operator.
 * @api
 */

var EqualTo =
/** @class */
function (_super) {
  __extends(EqualTo, _super);
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!(string|number)} expression The value to compare.
   * @param {boolean} [opt_matchCase] Case-sensitive?
   */


  function EqualTo(propertyName, expression, opt_matchCase) {
    return _super.call(this, 'PropertyIsEqualTo', propertyName, expression, opt_matchCase) || this;
  }

  return EqualTo;
}(_ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (EqualTo);

/***/ }),

/***/ "./build/wg/format/filter/Filter.js":
/*!******************************************!*\
  !*** ./build/wg/format/filter/Filter.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/format/filter/Filter
 */

/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature filters.
 *
 * @abstract
 */
var Filter =
/** @class */
function () {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   */
  function Filter(tagName) {
    /**
     * @private
     * @type {!string}
     */
    this.tagName_ = tagName;
  }
  /**
   * The XML tag name for a filter.
   * @return {!string} Name.
   */


  Filter.prototype.getTagName = function () {
    return this.tagName_;
  };

  return Filter;
}();

/* harmony default export */ __webpack_exports__["default"] = (Filter);

/***/ }),

/***/ "./build/wg/format/filter/GreaterThan.js":
/*!***********************************************!*\
  !*** ./build/wg/format/filter/GreaterThan.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ComparisonBinary.js */ "./build/wg/format/filter/ComparisonBinary.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/GreaterThan
 */



/**
 * @classdesc
 * Represents a `<PropertyIsGreaterThan>` comparison operator.
 * @api
 */

var GreaterThan =
/** @class */
function (_super) {
  __extends(GreaterThan, _super);
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */


  function GreaterThan(propertyName, expression) {
    return _super.call(this, 'PropertyIsGreaterThan', propertyName, expression) || this;
  }

  return GreaterThan;
}(_ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (GreaterThan);

/***/ }),

/***/ "./build/wg/format/filter/GreaterThanOrEqualTo.js":
/*!********************************************************!*\
  !*** ./build/wg/format/filter/GreaterThanOrEqualTo.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ComparisonBinary.js */ "./build/wg/format/filter/ComparisonBinary.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/GreaterThanOrEqualTo
 */



/**
 * @classdesc
 * Represents a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.
 * @api
 */

var GreaterThanOrEqualTo =
/** @class */
function (_super) {
  __extends(GreaterThanOrEqualTo, _super);
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */


  function GreaterThanOrEqualTo(propertyName, expression) {
    return _super.call(this, 'PropertyIsGreaterThanOrEqualTo', propertyName, expression) || this;
  }

  return GreaterThanOrEqualTo;
}(_ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (GreaterThanOrEqualTo);

/***/ }),

/***/ "./build/wg/format/filter/Intersects.js":
/*!**********************************************!*\
  !*** ./build/wg/format/filter/Intersects.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Spatial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Spatial.js */ "./build/wg/format/filter/Spatial.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/Intersects
 */



/**
 * @classdesc
 * Represents a `<Intersects>` operator to test whether a geometry-valued property
 * intersects a given geometry.
 * @api
 */

var Intersects =
/** @class */
function (_super) {
  __extends(Intersects, _super);
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [opt_srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */


  function Intersects(geometryName, geometry, opt_srsName) {
    return _super.call(this, 'Intersects', geometryName, geometry, opt_srsName) || this;
  }

  return Intersects;
}(_Spatial_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Intersects);

/***/ }),

/***/ "./build/wg/format/filter/IsBetween.js":
/*!*********************************************!*\
  !*** ./build/wg/format/filter/IsBetween.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Comparison_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Comparison.js */ "./build/wg/format/filter/Comparison.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/IsBetween
 */



/**
 * @classdesc
 * Represents a `<PropertyIsBetween>` comparison operator.
 * @api
 */

var IsBetween =
/** @class */
function (_super) {
  __extends(IsBetween, _super);
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} lowerBoundary The lower bound of the range.
   * @param {!number} upperBoundary The upper bound of the range.
   */


  function IsBetween(propertyName, lowerBoundary, upperBoundary) {
    var _this = _super.call(this, 'PropertyIsBetween', propertyName) || this;
    /**
     * @type {!number}
     */


    _this.lowerBoundary = lowerBoundary;
    /**
     * @type {!number}
     */

    _this.upperBoundary = upperBoundary;
    return _this;
  }

  return IsBetween;
}(_Comparison_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (IsBetween);

/***/ }),

/***/ "./build/wg/format/filter/IsLike.js":
/*!******************************************!*\
  !*** ./build/wg/format/filter/IsLike.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Comparison_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Comparison.js */ "./build/wg/format/filter/Comparison.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/IsLike
 */



/**
 * @classdesc
 * Represents a `<PropertyIsLike>` comparison operator.
 * @api
 */

var IsLike =
/** @class */
function (_super) {
  __extends(IsLike, _super);
  /**
   * [constructor description]
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!string} pattern Text pattern.
   * @param {string} [opt_wildCard] Pattern character which matches any sequence of
   *    zero or more string characters. Default is '*'.
   * @param {string} [opt_singleChar] pattern character which matches any single
   *    string character. Default is '.'.
   * @param {string} [opt_escapeChar] Escape character which can be used to escape
   *    the pattern characters. Default is '!'.
   * @param {boolean} [opt_matchCase] Case-sensitive?
   */


  function IsLike(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {
    var _this = _super.call(this, 'PropertyIsLike', propertyName) || this;
    /**
     * @type {!string}
     */


    _this.pattern = pattern;
    /**
     * @type {!string}
     */

    _this.wildCard = opt_wildCard !== undefined ? opt_wildCard : '*';
    /**
     * @type {!string}
     */

    _this.singleChar = opt_singleChar !== undefined ? opt_singleChar : '.';
    /**
     * @type {!string}
     */

    _this.escapeChar = opt_escapeChar !== undefined ? opt_escapeChar : '!';
    /**
     * @type {boolean|undefined}
     */

    _this.matchCase = opt_matchCase;
    return _this;
  }

  return IsLike;
}(_Comparison_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (IsLike);

/***/ }),

/***/ "./build/wg/format/filter/IsNull.js":
/*!******************************************!*\
  !*** ./build/wg/format/filter/IsNull.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Comparison_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Comparison.js */ "./build/wg/format/filter/Comparison.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/IsNull
 */



/**
 * @classdesc
 * Represents a `<PropertyIsNull>` comparison operator.
 * @api
 */

var IsNull =
/** @class */
function (_super) {
  __extends(IsNull, _super);
  /**
   * @param {!string} propertyName Name of the context property to compare.
   */


  function IsNull(propertyName) {
    return _super.call(this, 'PropertyIsNull', propertyName) || this;
  }

  return IsNull;
}(_Comparison_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (IsNull);

/***/ }),

/***/ "./build/wg/format/filter/LessThan.js":
/*!********************************************!*\
  !*** ./build/wg/format/filter/LessThan.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ComparisonBinary.js */ "./build/wg/format/filter/ComparisonBinary.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/LessThan
 */



/**
 * @classdesc
 * Represents a `<PropertyIsLessThan>` comparison operator.
 * @api
 */

var LessThan =
/** @class */
function (_super) {
  __extends(LessThan, _super);
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */


  function LessThan(propertyName, expression) {
    return _super.call(this, 'PropertyIsLessThan', propertyName, expression) || this;
  }

  return LessThan;
}(_ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (LessThan);

/***/ }),

/***/ "./build/wg/format/filter/LessThanOrEqualTo.js":
/*!*****************************************************!*\
  !*** ./build/wg/format/filter/LessThanOrEqualTo.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ComparisonBinary.js */ "./build/wg/format/filter/ComparisonBinary.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/LessThanOrEqualTo
 */



/**
 * @classdesc
 * Represents a `<PropertyIsLessThanOrEqualTo>` comparison operator.
 * @api
 */

var LessThanOrEqualTo =
/** @class */
function (_super) {
  __extends(LessThanOrEqualTo, _super);
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */


  function LessThanOrEqualTo(propertyName, expression) {
    return _super.call(this, 'PropertyIsLessThanOrEqualTo', propertyName, expression) || this;
  }

  return LessThanOrEqualTo;
}(_ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (LessThanOrEqualTo);

/***/ }),

/***/ "./build/wg/format/filter/LogicalNary.js":
/*!***********************************************!*\
  !*** ./build/wg/format/filter/LogicalNary.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Filter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Filter.js */ "./build/wg/format/filter/Filter.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../asserts.js */ "./build/wg/asserts.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/LogicalNary
 */




/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature n-ary logical filters.
 *
 * @abstract
 */

var LogicalNary =
/** @class */
function (_super) {
  __extends(LogicalNary, _super);
  /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {Array<import("./Filter.js").default>} conditions Conditions.
   */


  function LogicalNary(tagName, conditions) {
    var _this = _super.call(this, tagName) || this;
    /**
     * @type {Array<import("./Filter.js").default>}
     */


    _this.conditions = conditions;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(_this.conditions.length >= 2, 57); // At least 2 conditions are required.

    return _this;
  }

  return LogicalNary;
}(_Filter_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (LogicalNary);

/***/ }),

/***/ "./build/wg/format/filter/Not.js":
/*!***************************************!*\
  !*** ./build/wg/format/filter/Not.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Filter.js */ "./build/wg/format/filter/Filter.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/Not
 */



/**
 * @classdesc
 * Represents a logical `<Not>` operator for a filter condition.
 * @api
 */

var Not =
/** @class */
function (_super) {
  __extends(Not, _super);
  /**
   * @param {!import("./Filter.js").default} condition Filter condition.
   */


  function Not(condition) {
    var _this = _super.call(this, 'Not') || this;
    /**
     * @type {!import("./Filter.js").default}
     */


    _this.condition = condition;
    return _this;
  }

  return Not;
}(_Filter_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Not);

/***/ }),

/***/ "./build/wg/format/filter/NotEqualTo.js":
/*!**********************************************!*\
  !*** ./build/wg/format/filter/NotEqualTo.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ComparisonBinary.js */ "./build/wg/format/filter/ComparisonBinary.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/NotEqualTo
 */



/**
 * @classdesc
 * Represents a `<PropertyIsNotEqualTo>` comparison operator.
 * @api
 */

var NotEqualTo =
/** @class */
function (_super) {
  __extends(NotEqualTo, _super);
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!(string|number)} expression The value to compare.
   * @param {boolean} [opt_matchCase] Case-sensitive?
   */


  function NotEqualTo(propertyName, expression, opt_matchCase) {
    return _super.call(this, 'PropertyIsNotEqualTo', propertyName, expression, opt_matchCase) || this;
  }

  return NotEqualTo;
}(_ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (NotEqualTo);

/***/ }),

/***/ "./build/wg/format/filter/Or.js":
/*!**************************************!*\
  !*** ./build/wg/format/filter/Or.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LogicalNary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LogicalNary.js */ "./build/wg/format/filter/LogicalNary.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/Or
 */



/**
 * @classdesc
 * Represents a logical `<Or>` operator between two ore more filter conditions.
 * @api
 */

var Or =
/** @class */
function (_super) {
  __extends(Or, _super);
  /**
   * @param {...import("./Filter.js").default} conditions Conditions.
   */


  function Or(conditions) {
    return _super.call(this, 'Or', Array.prototype.slice.call(arguments)) || this;
  }

  return Or;
}(_LogicalNary_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Or);

/***/ }),

/***/ "./build/wg/format/filter/ResourceId.js":
/*!**********************************************!*\
  !*** ./build/wg/format/filter/ResourceId.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Filter.js */ "./build/wg/format/filter/Filter.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/ResourceId
 */



/**
 * @classdesc
 *
 * @abstract
 */

var ResourceId =
/** @class */
function (_super) {
  __extends(ResourceId, _super);
  /**
   * @param {!string} rid Resource ID.
   */


  function ResourceId(rid) {
    var _this = _super.call(this, 'ResourceId') || this;
    /**
     * @type {!string}
     */


    _this.rid = rid;
    return _this;
  }

  return ResourceId;
}(_Filter_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (ResourceId);

/***/ }),

/***/ "./build/wg/format/filter/Spatial.js":
/*!*******************************************!*\
  !*** ./build/wg/format/filter/Spatial.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Filter.js */ "./build/wg/format/filter/Filter.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/Spatial
 */



/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Represents a spatial operator to test whether a geometry-valued property
 * relates to a given geometry.
 *
 * @abstract
 */

var Spatial =
/** @class */
function (_super) {
  __extends(Spatial, _super);
  /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [opt_srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */


  function Spatial(tagName, geometryName, geometry, opt_srsName) {
    var _this = _super.call(this, tagName) || this;
    /**
     * @type {!string}
     */


    _this.geometryName = geometryName || 'the_geom';
    /**
     * @type {import("../../geom/Geometry.js").default}
     */

    _this.geometry = geometry;
    /**
     * @type {string|undefined}
     */

    _this.srsName = opt_srsName;
    return _this;
  }

  return Spatial;
}(_Filter_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Spatial);

/***/ }),

/***/ "./build/wg/format/filter/Within.js":
/*!******************************************!*\
  !*** ./build/wg/format/filter/Within.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Spatial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Spatial.js */ "./build/wg/format/filter/Spatial.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/format/filter/Within
 */



/**
 * @classdesc
 * Represents a `<Within>` operator to test whether a geometry-valued property
 * is within a given geometry.
 * @api
 */

var Within =
/** @class */
function (_super) {
  __extends(Within, _super);
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [opt_srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */


  function Within(geometryName, geometry, opt_srsName) {
    return _super.call(this, 'Within', geometryName, geometry, opt_srsName) || this;
  }

  return Within;
}(_Spatial_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Within);

/***/ }),

/***/ "./build/wg/format/xlink.js":
/*!**********************************!*\
  !*** ./build/wg/format/xlink.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "readHref": function() { return /* binding */ readHref; }
/* harmony export */ });
/**
 * @module wg/format/xlink
 */

/**
 * @const
 * @type {string}
 */
var NAMESPACE_URI = 'http://www.w3.org/1999/xlink';
/**
 * @param {Element} node Node.
 * @return {string|undefined} href.
 */

function readHref(node) {
  return node.getAttributeNS(NAMESPACE_URI, 'href');
}

/***/ }),

/***/ "./build/wg/format/xsd.js":
/*!********************************!*\
  !*** ./build/wg/format/xsd.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "readBoolean": function() { return /* binding */ readBoolean; },
/* harmony export */   "readBooleanString": function() { return /* binding */ readBooleanString; },
/* harmony export */   "readDateTime": function() { return /* binding */ readDateTime; },
/* harmony export */   "readDecimal": function() { return /* binding */ readDecimal; },
/* harmony export */   "readDecimalString": function() { return /* binding */ readDecimalString; },
/* harmony export */   "readPositiveInteger": function() { return /* binding */ readPositiveInteger; },
/* harmony export */   "readNonNegativeIntegerString": function() { return /* binding */ readNonNegativeIntegerString; },
/* harmony export */   "readString": function() { return /* binding */ readString; },
/* harmony export */   "writeBooleanTextNode": function() { return /* binding */ writeBooleanTextNode; },
/* harmony export */   "writeCDATASection": function() { return /* binding */ writeCDATASection; },
/* harmony export */   "writeDateTimeTextNode": function() { return /* binding */ writeDateTimeTextNode; },
/* harmony export */   "writeDecimalTextNode": function() { return /* binding */ writeDecimalTextNode; },
/* harmony export */   "writeNonNegativeIntegerTextNode": function() { return /* binding */ writeNonNegativeIntegerTextNode; },
/* harmony export */   "writeStringTextNode": function() { return /* binding */ writeStringTextNode; }
/* harmony export */ });
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../xml.js */ "./build/wg/xml.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../string.js */ "./build/wg/string.js");
/**
 * @module wg/format/xsd
 */


/**
 * @param {Node} node Node.
 * @return {boolean|undefined} Boolean.
 */

function readBoolean(node) {
  var s = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.getAllTextContent)(node, false);
  return readBooleanString(s);
}
/**
 * @param {string} string String.
 * @return {boolean|undefined} Boolean.
 */

function readBooleanString(string) {
  var m = /^\s*(true|1)|(false|0)\s*$/.exec(string);

  if (m) {
    return m[1] !== undefined || false;
  } else {
    return undefined;
  }
}
/**
 * @param {Node} node Node.
 * @return {number|undefined} DateTime in seconds.
 */

function readDateTime(node) {
  var s = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.getAllTextContent)(node, false);
  var dateTime = Date.parse(s);
  return isNaN(dateTime) ? undefined : dateTime / 1000;
}
/**
 * @param {Node} node Node.
 * @return {number|undefined} Decimal.
 */

function readDecimal(node) {
  var s = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.getAllTextContent)(node, false);
  return readDecimalString(s);
}
/**
 * @param {string} string String.
 * @return {number|undefined} Decimal.
 */

function readDecimalString(string) {
  // FIXME check spec
  var m = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);

  if (m) {
    return parseFloat(m[1]);
  } else {
    return undefined;
  }
}
/**
 * @param {Node} node Node.
 * @return {number|undefined} Non negative integer.
 */

function readPositiveInteger(node) {
  var s = (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.getAllTextContent)(node, false);
  return readNonNegativeIntegerString(s);
}
/**
 * @param {string} string String.
 * @return {number|undefined} Non negative integer.
 */

function readNonNegativeIntegerString(string) {
  var m = /^\s*(\d+)\s*$/.exec(string);

  if (m) {
    return parseInt(m[1], 10);
  } else {
    return undefined;
  }
}
/**
 * @param {Node} node Node.
 * @return {string|undefined} String.
 */

function readString(node) {
  return (0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.getAllTextContent)(node, false).trim();
}
/**
 * @param {Node} node Node to append a TextNode with the boolean to.
 * @param {boolean} bool Boolean.
 */

function writeBooleanTextNode(node, bool) {
  writeStringTextNode(node, bool ? '1' : '0');
}
/**
 * @param {Node} node Node to append a CDATA Section with the string to.
 * @param {string} string String.
 */

function writeCDATASection(node, string) {
  node.appendChild((0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)().createCDATASection(string));
}
/**
 * @param {Node} node Node to append a TextNode with the dateTime to.
 * @param {number} dateTime DateTime in seconds.
 */

function writeDateTimeTextNode(node, dateTime) {
  var date = new Date(dateTime * 1000);
  var string = date.getUTCFullYear() + '-' + (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.padNumber)(date.getUTCMonth() + 1, 2) + '-' + (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.padNumber)(date.getUTCDate(), 2) + 'T' + (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.padNumber)(date.getUTCHours(), 2) + ':' + (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.padNumber)(date.getUTCMinutes(), 2) + ':' + (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.padNumber)(date.getUTCSeconds(), 2) + 'Z';
  node.appendChild((0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)().createTextNode(string));
}
/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} decimal Decimal.
 */

function writeDecimalTextNode(node, decimal) {
  var string = decimal.toPrecision();
  node.appendChild((0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)().createTextNode(string));
}
/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} nonNegativeInteger Non negative integer.
 */

function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {
  var string = nonNegativeInteger.toString();
  node.appendChild((0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)().createTextNode(string));
}
/**
 * @param {Node} node Node to append a TextNode with the string to.
 * @param {string} string String.
 */

function writeStringTextNode(node, string) {
  node.appendChild((0,_xml_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)().createTextNode(string));
}

/***/ }),

/***/ "./build/wg/functions.js":
/*!*******************************!*\
  !*** ./build/wg/functions.js ***!
  \*******************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TRUE": function() { return /* binding */ TRUE; },
/* harmony export */   "FALSE": function() { return /* binding */ FALSE; },
/* harmony export */   "VOID": function() { return /* binding */ VOID; },
/* harmony export */   "memoizeOne": function() { return /* binding */ memoizeOne; },
/* harmony export */   "toPromise": function() { return /* binding */ toPromise; }
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./build/wg/array.js");
/**
 * @module wg/functions
 */

/**
 * Always returns true.
 * @return {boolean} true.
 */

function TRUE() {
  return true;
}
/**
 * Always returns false.
 * @return {boolean} false.
 */

function FALSE() {
  return false;
}
/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */

function VOID() {}
/**
 * Wrap a function in another function that remembers the last return.  If the
 * returned function is called twice in a row with the same arguments and the same
 * this object, it will return the value from the first call in the second call.
 *
 * @param {function(...any): ReturnType} fn The function to memoize.
 * @return {function(...any): ReturnType} The memoized function.
 * @template ReturnType
 */

function memoizeOne(fn) {
  var called = false;
  /** @type {ReturnType} */

  var lastResult;
  /** @type {Array<any>} */

  var lastArgs;
  var lastThis;
  return function () {
    var nextArgs = Array.prototype.slice.call(arguments);

    if (!called || this !== lastThis || !(0,_array_js__WEBPACK_IMPORTED_MODULE_0__.equals)(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }

    return lastResult;
  };
}
/**
 * @template T
 * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.
 * @return {Promise<T>} A promise for the value.
 */

function toPromise(getter) {
  function promiseGetter() {
    var value;

    try {
      value = getter();
    } catch (err) {
      return Promise.reject(err);
    }

    if (value instanceof Promise) {
      return value;
    }

    return Promise.resolve(value);
  }

  return promiseGetter();
}

/***/ }),

/***/ "./build/wg/geom/Circle.js":
/*!*********************************!*\
  !*** ./build/wg/geom/Circle.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./build/wg/geom/SimpleGeometry.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flat/deflate.js */ "./build/wg/geom/flat/deflate.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/transform.js */ "./build/wg/geom/flat/transform.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/geom/Circle
 */







/**
 * @classdesc
 * Circle geometry.
 *
 * @api
 */

var Circle =
/** @class */
function (_super) {
  __extends(Circle, _super);
  /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `opt_layout` and no
   *     `opt_radius` are also accepted.
   * @param {number} [opt_radius] Radius.
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   */


  function Circle(center, opt_radius, opt_layout) {
    var _this = _super.call(this) || this;

    if (opt_layout !== undefined && opt_radius === undefined) {
      _this.setFlatCoordinates(opt_layout, center);
    } else {
      var radius = opt_radius ? opt_radius : 0;

      _this.setCenterAndRadius(center, radius, opt_layout);
    }

    return _this;
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @api
   */


  Circle.prototype.clone = function () {
    var circle = new Circle(this.flatCoordinates.slice(), undefined, this.layout);
    circle.applyProperties(this);
    return circle;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  Circle.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    var flatCoordinates = this.flatCoordinates;
    var dx = x - flatCoordinates[0];
    var dy = y - flatCoordinates[1];
    var squaredDistance = dx * dx + dy * dy;

    if (squaredDistance < minSquaredDistance) {
      if (squaredDistance === 0) {
        for (var i = 0; i < this.stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
      } else {
        var delta = this.getRadius() / Math.sqrt(squaredDistance);
        closestPoint[0] = flatCoordinates[0] + delta * dx;
        closestPoint[1] = flatCoordinates[1] + delta * dy;

        for (var i = 2; i < this.stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
      }

      closestPoint.length = this.stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */


  Circle.prototype.containsXY = function (x, y) {
    var flatCoordinates = this.flatCoordinates;
    var dx = x - flatCoordinates[0];
    var dy = y - flatCoordinates[1];
    return dx * dx + dy * dy <= this.getRadiusSquared_();
  };
  /**
   * Return the center of the circle as {@link module:wg/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */


  Circle.prototype.getCenter = function () {
    return this.flatCoordinates.slice(0, this.stride);
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */


  Circle.prototype.computeExtent = function (extent) {
    var flatCoordinates = this.flatCoordinates;
    var radius = flatCoordinates[this.stride] - flatCoordinates[0];
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createOrUpdate)(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);
  };
  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */


  Circle.prototype.getRadius = function () {
    return Math.sqrt(this.getRadiusSquared_());
  };
  /**
   * @private
   * @return {number} Radius squared.
   */


  Circle.prototype.getRadiusSquared_ = function () {
    var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
    var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return dx * dx + dy * dy;
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  Circle.prototype.getType = function () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CIRCLE;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  Circle.prototype.intersectsExtent = function (extent) {
    var circleExtent = this.getExtent();

    if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.intersects)(extent, circleExtent)) {
      var center = this.getCenter();

      if (extent[0] <= center[0] && extent[2] >= center[0]) {
        return true;
      }

      if (extent[1] <= center[1] && extent[3] >= center[1]) {
        return true;
      }

      return (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.forEachCorner)(extent, this.intersectsCoordinate.bind(this));
    }

    return false;
  };
  /**
   * Set the center of the circle as {@link module:wg/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */


  Circle.prototype.setCenter = function (center) {
    var stride = this.stride;
    var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
    var flatCoordinates = center.slice();
    flatCoordinates[stride] = flatCoordinates[0] + radius;

    for (var i = 1; i < stride; ++i) {
      flatCoordinates[stride + i] = center[i];
    }

    this.setFlatCoordinates(this.layout, flatCoordinates);
    this.changed();
  };
  /**
   * Set the center (as {@link module:wg/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   * @api
   */


  Circle.prototype.setCenterAndRadius = function (center, radius, opt_layout) {
    this.setLayout(opt_layout, center, 0);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    /** @type {Array<number>} */


    var flatCoordinates = this.flatCoordinates;
    var offset = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_2__.deflateCoordinate)(flatCoordinates, 0, center, this.stride);
    flatCoordinates[offset++] = flatCoordinates[0] + radius;

    for (var i = 1, ii = this.stride; i < ii; ++i) {
      flatCoordinates[offset++] = flatCoordinates[i];
    }

    flatCoordinates.length = offset;
    this.changed();
  };

  Circle.prototype.getCoordinates = function () {
    return null;
  };

  Circle.prototype.setCoordinates = function (coordinates, opt_layout) {};
  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */


  Circle.prototype.setRadius = function (radius) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
    this.changed();
  };
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */


  Circle.prototype.rotate = function (angle, anchor) {
    var center = this.getCenter();
    var stride = this.getStride();
    this.setCenter((0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.rotate)(center, 0, center.length, stride, angle, anchor, center));
    this.changed();
  };
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */


  Circle.prototype.translate = function (deltaX, deltaY) {
    var center = this.getCenter();
    var stride = this.getStride();
    this.setCenter((0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.translate)(center, 0, center.length, stride, deltaX, deltaY, center));
    this.changed();
  };

  return Circle;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * Transform each coordinate of the circle from one coordinate reference system
 * to another. The geometry is modified in place.
 * If you do not want the geometry modified in place, first clone() it and
 * then use this function on the clone.
 *
 * Internally a circle is currently represented by two points: the center of
 * the circle `[cx, cy]`, and the point to the right of the circle
 * `[cx + r, cy]`. This `transform` function just transforms these two points.
 * So the resulting geometry is also a circle, and that circle does not
 * correspond to the shape that would be obtained by transforming every point
 * of the original circle.
 *
 * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link module:wg/proj/Projection~Projection} object.
 * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link module:wg/proj/Projection~Projection} object.
 * @return {Circle} This geometry.  Note that original geometry is
 *     modified in place.
 * @function
 * @api
 */


Circle.prototype.transform;
/* harmony default export */ __webpack_exports__["default"] = (Circle);

/***/ }),

/***/ "./build/wg/geom/Geometry.js":
/*!***********************************!*\
  !*** ./build/wg/geom/Geometry.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Object.js */ "./build/wg/Object.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj/Units.js */ "./build/wg/proj/Units.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/transform.js */ "./build/wg/geom/flat/transform.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/geom/Geometry
 */










/**
 * @type {import("../transform.js").Transform}
 */

var tmpTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.create)();
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */

var Geometry =
/** @class */
function (_super) {
  __extends(Geometry, _super);

  function Geometry() {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */


    _this.extent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createEmpty)();
    /**
     * @private
     * @type {number}
     */

    _this.extentRevision_ = -1;
    /**
     * @protected
     * @type {number}
     */

    _this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    /**
     * @protected
     * @type {number}
     */

    _this.simplifiedGeometryRevision = 0;
    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} revision The geometry revision.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */

    _this.simplifyTransformedInternal = (0,_functions_js__WEBPACK_IMPORTED_MODULE_3__.memoizeOne)(function (revision, squaredTolerance, opt_transform) {
      if (!opt_transform) {
        return this.getSimplifiedGeometry(squaredTolerance);
      }

      var clone = this.clone();
      clone.applyTransform(opt_transform);
      return clone.getSimplifiedGeometry(squaredTolerance);
    });
    return _this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */


  Geometry.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {
    return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);
  };
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */


  Geometry.prototype.clone = function () {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  };
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  Geometry.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */


  Geometry.prototype.containsXY = function (x, y) {
    var coord = this.getClosestPoint([x, y]);
    return coord[0] === x && coord[1] === y;
  };
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:wg/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [opt_closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */


  Geometry.prototype.getClosestPoint = function (point, opt_closestPoint) {
    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  };
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */


  Geometry.prototype.intersectsCoordinate = function (coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  };
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */


  Geometry.prototype.computeExtent = function (extent) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  };
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [opt_extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */


  Geometry.prototype.getExtent = function (opt_extent) {
    if (this.extentRevision_ != this.getRevision()) {
      var extent = this.computeExtent(this.extent_);

      if (isNaN(extent[0]) || isNaN(extent[1])) {
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createOrUpdateEmpty)(extent);
      }

      this.extentRevision_ = this.getRevision();
    }

    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.returnOrUpdate)(this.extent_, opt_extent);
  };
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */


  Geometry.prototype.rotate = function (angle, anchor) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  };
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [opt_anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */


  Geometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  };
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */


  Geometry.prototype.simplify = function (tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  };
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */


  Geometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  };
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {import("./GeometryType.js").default} Geometry type.
   */


  Geometry.prototype.getType = function () {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  };
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */


  Geometry.prototype.applyTransform = function (transformFn) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */


  Geometry.prototype.intersectsExtent = function (extent) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  };
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */


  Geometry.prototype.translate = function (deltaX, deltaY) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  };
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:wg/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:wg/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */


  Geometry.prototype.transform = function (source, destination) {
    /** @type {import("../proj/Projection.js").default} */
    var sourceProj = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(source);
    var transformFn = sourceProj.getUnits() == _proj_Units_js__WEBPACK_IMPORTED_MODULE_5__["default"].TILE_PIXELS ? function (inCoordinates, outCoordinates, stride) {
      var pixelExtent = sourceProj.getExtent();
      var projectedExtent = sourceProj.getWorldExtent();
      var scale = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(projectedExtent) / (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(pixelExtent);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.compose)(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_6__.transform2D)(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
      return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(sourceProj, destination)(inCoordinates, outCoordinates, stride);
    } : (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  };

  return Geometry;
}(_Object_js__WEBPACK_IMPORTED_MODULE_7__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Geometry);

/***/ }),

/***/ "./build/wg/geom/GeometryCollection.js":
/*!*********************************************!*\
  !*** ./build/wg/geom/GeometryCollection.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Geometry.js */ "./build/wg/geom/Geometry.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./build/wg/events.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/geom/GeometryCollection
 */







/**
 * @classdesc
 * An array of {@link module:wg/geom/Geometry~Geometry} objects.
 *
 * @api
 */

var GeometryCollection =
/** @class */
function (_super) {
  __extends(GeometryCollection, _super);
  /**
   * @param {Array<Geometry>} [opt_geometries] Geometries.
   */


  function GeometryCollection(opt_geometries) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {Array<Geometry>}
     */


    _this.geometries_ = opt_geometries ? opt_geometries : null;
    /**
     * @type {Array<import("../events.js").EventsKey>}
     */

    _this.changeEventsKeys_ = [];

    _this.listenGeometriesChange_();

    return _this;
  }
  /**
   * @private
   */


  GeometryCollection.prototype.unlistenGeometriesChange_ = function () {
    this.changeEventsKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_0__.unlistenByKey);
    this.changeEventsKeys_.length = 0;
  };
  /**
   * @private
   */


  GeometryCollection.prototype.listenGeometriesChange_ = function () {
    if (!this.geometries_) {
      return;
    }

    for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {
      this.changeEventsKeys_.push((0,_events_js__WEBPACK_IMPORTED_MODULE_0__.listen)(this.geometries_[i], _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, this.changed, this));
    }
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   */


  GeometryCollection.prototype.clone = function () {
    var geometryCollection = new GeometryCollection(null);
    geometryCollection.setGeometries(this.geometries_);
    geometryCollection.applyProperties(this);
    return geometryCollection;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  GeometryCollection.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
    }

    return minSquaredDistance;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */


  GeometryCollection.prototype.containsXY = function (x, y) {
    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].containsXY(x, y)) {
        return true;
      }
    }

    return false;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */


  GeometryCollection.prototype.computeExtent = function (extent) {
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createOrUpdateEmpty)(extent);
    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.extend)(extent, geometries[i].getExtent());
    }

    return extent;
  };
  /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */


  GeometryCollection.prototype.getGeometries = function () {
    return cloneGeometries(this.geometries_);
  };
  /**
   * @return {Array<Geometry>} Geometries.
   */


  GeometryCollection.prototype.getGeometriesArray = function () {
    return this.geometries_;
  };
  /**
   * @return {Array<Geometry>} Geometries.
   */


  GeometryCollection.prototype.getGeometriesArrayRecursive = function () {
    /** @type {Array<Geometry>} */
    var geometriesArray = [];
    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].getType() === this.getType()) {
        geometriesArray = geometriesArray.concat(
        /** @type {GeometryCollection} */
        geometries[i].getGeometriesArrayRecursive());
      } else {
        geometriesArray.push(geometries[i]);
      }
    }

    return geometriesArray;
  };
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   */


  GeometryCollection.prototype.getSimplifiedGeometry = function (squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }

    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }

    var simplifiedGeometries = [];
    var geometries = this.geometries_;
    var simplified = false;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      var geometry = geometries[i];
      var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
      simplifiedGeometries.push(simplifiedGeometry);

      if (simplifiedGeometry !== geometry) {
        simplified = true;
      }
    }

    if (simplified) {
      var simplifiedGeometryCollection = new GeometryCollection(null);
      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
      return simplifiedGeometryCollection;
    } else {
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  GeometryCollection.prototype.getType = function () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].GEOMETRY_COLLECTION;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  GeometryCollection.prototype.intersectsExtent = function (extent) {
    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].intersectsExtent(extent)) {
        return true;
      }
    }

    return false;
  };
  /**
   * @return {boolean} Is empty.
   */


  GeometryCollection.prototype.isEmpty = function () {
    return this.geometries_.length === 0;
  };
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */


  GeometryCollection.prototype.rotate = function (angle, anchor) {
    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].rotate(angle, anchor);
    }

    this.changed();
  };
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [opt_anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */


  GeometryCollection.prototype.scale = function (sx, opt_sy, opt_anchor) {
    var anchor = opt_anchor;

    if (!anchor) {
      anchor = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getCenter)(this.getExtent());
    }

    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].scale(sx, opt_sy, anchor);
    }

    this.changed();
  };
  /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */


  GeometryCollection.prototype.setGeometries = function (geometries) {
    this.setGeometriesArray(cloneGeometries(geometries));
  };
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */


  GeometryCollection.prototype.setGeometriesArray = function (geometries) {
    this.unlistenGeometriesChange_();
    this.geometries_ = geometries;
    this.listenGeometriesChange_();
    this.changed();
  };
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */


  GeometryCollection.prototype.applyTransform = function (transformFn) {
    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].applyTransform(transformFn);
    }

    this.changed();
  };
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */


  GeometryCollection.prototype.translate = function (deltaX, deltaY) {
    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].translate(deltaX, deltaY);
    }

    this.changed();
  };
  /**
   * Clean up.
   */


  GeometryCollection.prototype.disposeInternal = function () {
    this.unlistenGeometriesChange_();

    _super.prototype.disposeInternal.call(this);
  };

  return GeometryCollection;
}(_Geometry_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @param {Array<Geometry>} geometries Geometries.
 * @return {Array<Geometry>} Cloned geometries.
 */


function cloneGeometries(geometries) {
  var clonedGeometries = [];

  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    clonedGeometries.push(geometries[i].clone());
  }

  return clonedGeometries;
}

/* harmony default export */ __webpack_exports__["default"] = (GeometryCollection);

/***/ }),

/***/ "./build/wg/geom/GeometryLayout.js":
/*!*****************************************!*\
  !*** ./build/wg/geom/GeometryLayout.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/geom/GeometryLayout
 */

/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available. Supported values are `'XY'`,
 * `'XYZ'`, `'XYM'`, `'XYZM'`.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  XY: 'XY',
  XYZ: 'XYZ',
  XYM: 'XYM',
  XYZM: 'XYZM'
});

/***/ }),

/***/ "./build/wg/geom/GeometryType.js":
/*!***************************************!*\
  !*** ./build/wg/geom/GeometryType.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/geom/GeometryType
 */

/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
});

/***/ }),

/***/ "./build/wg/geom/LineString.js":
/*!*************************************!*\
  !*** ./build/wg/geom/LineString.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./build/wg/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flat/closest.js */ "./build/wg/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/deflate.js */ "./build/wg/geom/flat/deflate.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/simplify.js */ "./build/wg/geom/flat/simplify.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _flat_segments_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/segments.js */ "./build/wg/geom/flat/segments.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/inflate.js */ "./build/wg/geom/flat/inflate.js");
/* harmony import */ var _flat_interpolate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/interpolate.js */ "./build/wg/geom/flat/interpolate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./build/wg/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_length_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/length.js */ "./build/wg/geom/flat/length.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/geom/LineString
 */















/**
 * @classdesc
 * Linestring geometry.
 *
 * @api
 */

var LineString =
/** @class */
function (_super) {
  __extends(LineString, _super);
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   */


  function LineString(coordinates, opt_layout) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */


    _this.flatMidpoint_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.flatMidpointRevision_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;

    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);
    } else {
      _this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      coordinates, opt_layout);
    }

    return _this;
  }
  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */


  LineString.prototype.appendCoordinate = function (coordinate) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = coordinate.slice();
    } else {
      (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.extend)(this.flatCoordinates, coordinate);
    }

    this.changed();
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */


  LineString.prototype.clone = function () {
    var lineString = new LineString(this.flatCoordinates.slice(), this.layout);
    lineString.applyProperties(this);
    return lineString;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  LineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt((0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_2__.maxSquaredDelta)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }

    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_2__.assignClosestPoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
  };
  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */


  LineString.prototype.forEachSegment = function (callback) {
    return (0,_flat_segments_js__WEBPACK_IMPORTED_MODULE_3__.forEach)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
  };
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */


  LineString.prototype.getCoordinateAtM = function (m, opt_extrapolate) {
    if (this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_4__["default"].XYM && this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_4__["default"].XYZM) {
      return null;
    }

    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
    return (0,_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_5__.lineStringCoordinateAtM)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
  };
  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */


  LineString.prototype.getCoordinates = function () {
    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [opt_dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */


  LineString.prototype.getCoordinateAt = function (fraction, opt_dest) {
    return (0,_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_5__.interpolatePoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);
  };
  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */


  LineString.prototype.getLength = function () {
    return (0,_flat_length_js__WEBPACK_IMPORTED_MODULE_7__.lineStringLength)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  /**
   * @return {Array<number>} Flat midpoint.
   */


  LineString.prototype.getFlatMidpoint = function () {
    if (this.flatMidpointRevision_ != this.getRevision()) {
      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
      this.flatMidpointRevision_ = this.getRevision();
    }

    return this.flatMidpoint_;
  };
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */


  LineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_8__.douglasPeucker)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LineString(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_4__["default"].XY);
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  LineString.prototype.getType = function () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_9__["default"].LINE_STRING;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  LineString.prototype.intersectsExtent = function (extent) {
    return (0,_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_10__.intersectsLineString)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
  };
  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   * @api
   */


  LineString.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return LineString;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_12__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (LineString);

/***/ }),

/***/ "./build/wg/geom/LinearRing.js":
/*!*************************************!*\
  !*** ./build/wg/geom/LinearRing.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./build/wg/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./flat/closest.js */ "./build/wg/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/deflate.js */ "./build/wg/geom/flat/deflate.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/simplify.js */ "./build/wg/geom/flat/simplify.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/inflate.js */ "./build/wg/geom/flat/inflate.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flat/area.js */ "./build/wg/geom/flat/area.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/geom/LinearRing
 */











/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */

var LinearRing =
/** @class */
function (_super) {
  __extends(LinearRing, _super);
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   */


  function LinearRing(coordinates, opt_layout) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {number}
     */


    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;

    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);
    } else {
      _this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      coordinates, opt_layout);
    }

    return _this;
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */


  LinearRing.prototype.clone = function () {
    return new LinearRing(this.flatCoordinates.slice(), this.layout);
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  LinearRing.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt((0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_1__.maxSquaredDelta)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }

    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_1__.assignClosestPoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */


  LinearRing.prototype.getArea = function () {
    return (0,_flat_area_js__WEBPACK_IMPORTED_MODULE_2__.linearRing)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */


  LinearRing.prototype.getCoordinates = function () {
    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_3__.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */


  LinearRing.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_4__.douglasPeucker)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LinearRing(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_5__["default"].XY);
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  LinearRing.prototype.getType = function () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].LINEAR_RING;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  LinearRing.prototype.intersectsExtent = function (extent) {
    return false;
  };
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   * @api
   */


  LinearRing.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return LinearRing;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_8__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (LinearRing);

/***/ }),

/***/ "./build/wg/geom/MultiLineString.js":
/*!******************************************!*\
  !*** ./build/wg/geom/MultiLineString.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _LineString_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./build/wg/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flat/closest.js */ "./build/wg/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./flat/deflate.js */ "./build/wg/geom/flat/deflate.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/simplify.js */ "./build/wg/geom/flat/simplify.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/inflate.js */ "./build/wg/geom/flat/inflate.js");
/* harmony import */ var _flat_interpolate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/interpolate.js */ "./build/wg/geom/flat/interpolate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./build/wg/geom/flat/intersectsextent.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/geom/MultiLineString
 */














/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @api
 */

var MultiLineString =
/** @class */
function (_super) {
  __extends(MultiLineString, _super);
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `opt_layout` and `opt_ends` are also accepted.)
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   * @param {Array<number>} [opt_ends] Flat coordinate ends for internal use.
   */


  function MultiLineString(coordinates, opt_layout, opt_ends) {
    var _this = _super.call(this) || this;
    /**
     * @type {Array<number>}
     * @private
     */


    _this.ends_ = [];
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;

    if (Array.isArray(coordinates[0])) {
      _this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      coordinates, opt_layout);
    } else if (opt_layout !== undefined && opt_ends) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);

      _this.ends_ = opt_ends;
    } else {
      var layout = _this.getLayout();

      var lineStrings =
      /** @type {Array<LineString>} */
      coordinates;
      var flatCoordinates = [];
      var ends = [];

      for (var i = 0, ii = lineStrings.length; i < ii; ++i) {
        var lineString = lineStrings[i];

        if (i === 0) {
          layout = lineString.getLayout();
        }

        (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.extend)(flatCoordinates, lineString.getFlatCoordinates());
        ends.push(flatCoordinates.length);
      }

      _this.setFlatCoordinates(layout, flatCoordinates);

      _this.ends_ = ends;
    }

    return _this;
  }
  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */


  MultiLineString.prototype.appendLineString = function (lineString) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = lineString.getFlatCoordinates().slice();
    } else {
      (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.extend)(this.flatCoordinates, lineString.getFlatCoordinates().slice());
    }

    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */


  MultiLineString.prototype.clone = function () {
    var multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
    multiLineString.applyProperties(this);
    return multiLineString;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  MultiLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt((0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_2__.arrayMaxSquaredDelta)(this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }

    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_2__.assignClosestArrayPoint)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
  };
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `opt_interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `opt_interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [opt_interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */


  MultiLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {
    if (this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYM && this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZM || this.flatCoordinates.length === 0) {
      return null;
    }

    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
    var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
    return (0,_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_4__.lineStringsCoordinateAtM)(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
  };
  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */


  MultiLineString.prototype.getCoordinates = function () {
    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_5__.inflateCoordinatesArray)(this.flatCoordinates, 0, this.ends_, this.stride);
  };
  /**
   * @return {Array<number>} Ends.
   */


  MultiLineString.prototype.getEnds = function () {
    return this.ends_;
  };
  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */


  MultiLineString.prototype.getLineString = function (index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }

    return new _LineString_js__WEBPACK_IMPORTED_MODULE_6__["default"](this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
  };
  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */


  MultiLineString.prototype.getLineStrings = function () {
    var flatCoordinates = this.flatCoordinates;
    var ends = this.ends_;
    var layout = this.layout;
    /** @type {Array<LineString>} */

    var lineStrings = [];
    var offset = 0;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var lineString = new _LineString_js__WEBPACK_IMPORTED_MODULE_6__["default"](flatCoordinates.slice(offset, end), layout);
      lineStrings.push(lineString);
      offset = end;
    }

    return lineStrings;
  };
  /**
   * @return {Array<number>} Flat midpoints.
   */


  MultiLineString.prototype.getFlatMidpoints = function () {
    var midpoints = [];
    var flatCoordinates = this.flatCoordinates;
    var offset = 0;
    var ends = this.ends_;
    var stride = this.stride;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var midpoint = (0,_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_4__.interpolatePoint)(flatCoordinates, offset, end, stride, 0.5);
      (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.extend)(midpoints, midpoint);
      offset = end;
    }

    return midpoints;
  };
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */


  MultiLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEnds = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_7__.douglasPeuckerArray)(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new MultiLineString(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY, simplifiedEnds);
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  MultiLineString.prototype.getType = function () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_8__["default"].MULTI_LINE_STRING;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  MultiLineString.prototype.intersectsExtent = function (extent) {
    return (0,_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_9__.intersectsLineStringArray)(this.flatCoordinates, 0, this.ends_, this.stride, extent);
  };
  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {GeometryLayout} [opt_layout] Layout.
   * @api
   */


  MultiLineString.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 2);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    var ends = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_10__.deflateCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  };

  return MultiLineString;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_11__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (MultiLineString);

/***/ }),

/***/ "./build/wg/geom/MultiPoint.js":
/*!*************************************!*\
  !*** ./build/wg/geom/MultiPoint.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./build/wg/geom/SimpleGeometry.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/deflate.js */ "./build/wg/geom/flat/deflate.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/inflate.js */ "./build/wg/geom/flat/inflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/geom/MultiPoint
 */










/**
 * @classdesc
 * Multi-point geometry.
 *
 * @api
 */

var MultiPoint =
/** @class */
function (_super) {
  __extends(MultiPoint, _super);
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   */


  function MultiPoint(coordinates, opt_layout) {
    var _this = _super.call(this) || this;

    if (opt_layout && !Array.isArray(coordinates[0])) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);
    } else {
      _this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      coordinates, opt_layout);
    }

    return _this;
  }
  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */


  MultiPoint.prototype.appendPoint = function (point) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = point.getFlatCoordinates().slice();
    } else {
      (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.extend)(this.flatCoordinates, point.getFlatCoordinates());
    }

    this.changed();
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */


  MultiPoint.prototype.clone = function () {
    var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
    multiPoint.applyProperties(this);
    return multiPoint;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  MultiPoint.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    var flatCoordinates = this.flatCoordinates;
    var stride = this.stride;

    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.squaredDistance)(x, y, flatCoordinates[i], flatCoordinates[i + 1]);

      if (squaredDistance < minSquaredDistance) {
        minSquaredDistance = squaredDistance;

        for (var j = 0; j < stride; ++j) {
          closestPoint[j] = flatCoordinates[i + j];
        }

        closestPoint.length = stride;
      }
    }

    return minSquaredDistance;
  };
  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */


  MultiPoint.prototype.getCoordinates = function () {
    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_3__.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */


  MultiPoint.prototype.getPoint = function (index) {
    var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;

    if (index < 0 || n <= index) {
      return null;
    }

    return new _Point_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
  };
  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */


  MultiPoint.prototype.getPoints = function () {
    var flatCoordinates = this.flatCoordinates;
    var layout = this.layout;
    var stride = this.stride;
    /** @type {Array<Point>} */

    var points = [];

    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var point = new _Point_js__WEBPACK_IMPORTED_MODULE_4__["default"](flatCoordinates.slice(i, i + stride), layout);
      points.push(point);
    }

    return points;
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  MultiPoint.prototype.getType = function () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POINT;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  MultiPoint.prototype.intersectsExtent = function (extent) {
    var flatCoordinates = this.flatCoordinates;
    var stride = this.stride;

    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];

      if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsXY)(extent, x, y)) {
        return true;
      }
    }

    return false;
  };
  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   * @api
   */


  MultiPoint.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return MultiPoint;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_7__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (MultiPoint);

/***/ }),

/***/ "./build/wg/geom/MultiPolygon.js":
/*!***************************************!*\
  !*** ./build/wg/geom/MultiPolygon.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _MultiPoint_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./MultiPoint.js */ "./build/wg/geom/MultiPoint.js");
/* harmony import */ var _Polygon_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./build/wg/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flat/closest.js */ "./build/wg/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./flat/deflate.js */ "./build/wg/geom/flat/deflate.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/interiorpoint.js */ "./build/wg/geom/flat/interiorpoint.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/inflate.js */ "./build/wg/geom/flat/inflate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./build/wg/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_orient_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/orient.js */ "./build/wg/geom/flat/orient.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/area.js */ "./build/wg/geom/flat/area.js");
/* harmony import */ var _flat_center_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/center.js */ "./build/wg/geom/flat/center.js");
/* harmony import */ var _flat_contains_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/contains.js */ "./build/wg/geom/flat/contains.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/simplify.js */ "./build/wg/geom/flat/simplify.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/geom/MultiPolygon
 */



















/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @api
 */

var MultiPolygon =
/** @class */
function (_super) {
  __extends(MultiPolygon, _super);
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   * @param {Array<Array<number>>} [opt_endss] Array of ends for internal use with flat coordinates.
   */


  function MultiPolygon(coordinates, opt_layout, opt_endss) {
    var _this = _super.call(this) || this;
    /**
     * @type {Array<Array<number>>}
     * @private
     */


    _this.endss_ = [];
    /**
     * @private
     * @type {number}
     */

    _this.flatInteriorPointsRevision_ = -1;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.flatInteriorPoints_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.orientedRevision_ = -1;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.orientedFlatCoordinates_ = null;

    if (!opt_endss && !Array.isArray(coordinates[0])) {
      var layout = _this.getLayout();

      var polygons =
      /** @type {Array<Polygon>} */
      coordinates;
      var flatCoordinates = [];
      var endss = [];

      for (var i = 0, ii = polygons.length; i < ii; ++i) {
        var polygon = polygons[i];

        if (i === 0) {
          layout = polygon.getLayout();
        }

        var offset = flatCoordinates.length;
        var ends = polygon.getEnds();

        for (var j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] += offset;
        }

        (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.extend)(flatCoordinates, polygon.getFlatCoordinates());
        endss.push(ends);
      }

      opt_layout = layout;
      coordinates = flatCoordinates;
      opt_endss = endss;
    }

    if (opt_layout !== undefined && opt_endss) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);

      _this.endss_ = opt_endss;
    } else {
      _this.setCoordinates(
      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      coordinates, opt_layout);
    }

    return _this;
  }
  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */


  MultiPolygon.prototype.appendPolygon = function (polygon) {
    /** @type {Array<number>} */
    var ends;

    if (!this.flatCoordinates) {
      this.flatCoordinates = polygon.getFlatCoordinates().slice();
      ends = polygon.getEnds().slice();
      this.endss_.push();
    } else {
      var offset = this.flatCoordinates.length;
      (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.extend)(this.flatCoordinates, polygon.getFlatCoordinates());
      ends = polygon.getEnds().slice();

      for (var i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] += offset;
      }
    }

    this.endss_.push(ends);
    this.changed();
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */


  MultiPolygon.prototype.clone = function () {
    var len = this.endss_.length;
    var newEndss = new Array(len);

    for (var i = 0; i < len; ++i) {
      newEndss[i] = this.endss_[i].slice();
    }

    var multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
    multiPolygon.applyProperties(this);
    return multiPolygon;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  MultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt((0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_2__.multiArrayMaxSquaredDelta)(this.flatCoordinates, 0, this.endss_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }

    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_2__.assignClosestMultiArrayPoint)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */


  MultiPolygon.prototype.containsXY = function (x, y) {
    return (0,_flat_contains_js__WEBPACK_IMPORTED_MODULE_3__.linearRingssContainsXY)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
  };
  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */


  MultiPolygon.prototype.getArea = function () {
    return (0,_flat_area_js__WEBPACK_IMPORTED_MODULE_4__.linearRingss)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
  };
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [opt_right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */


  MultiPolygon.prototype.getCoordinates = function (opt_right) {
    var flatCoordinates;

    if (opt_right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_5__.orientLinearRingsArray)(flatCoordinates, 0, this.endss_, this.stride, opt_right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__.inflateMultiCoordinatesArray)(flatCoordinates, 0, this.endss_, this.stride);
  };
  /**
   * @return {Array<Array<number>>} Endss.
   */


  MultiPolygon.prototype.getEndss = function () {
    return this.endss_;
  };
  /**
   * @return {Array<number>} Flat interior points.
   */


  MultiPolygon.prototype.getFlatInteriorPoints = function () {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      var flatCenters = (0,_flat_center_js__WEBPACK_IMPORTED_MODULE_7__.linearRingss)(this.flatCoordinates, 0, this.endss_, this.stride);
      this.flatInteriorPoints_ = (0,_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_8__.getInteriorPointsOfMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
      this.flatInteriorPointsRevision_ = this.getRevision();
    }

    return this.flatInteriorPoints_;
  };
  /**
   * Return the interior points as {@link module:wg/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */


  MultiPolygon.prototype.getInteriorPoints = function () {
    return new _MultiPoint_js__WEBPACK_IMPORTED_MODULE_9__["default"](this.getFlatInteriorPoints().slice(), _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_10__["default"].XYM);
  };
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */


  MultiPolygon.prototype.getOrientedFlatCoordinates = function () {
    if (this.orientedRevision_ != this.getRevision()) {
      var flatCoordinates = this.flatCoordinates;

      if ((0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_5__.linearRingssAreOriented)(flatCoordinates, 0, this.endss_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_5__.orientLinearRingsArray)(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
      }

      this.orientedRevision_ = this.getRevision();
    }

    return this.orientedFlatCoordinates_;
  };
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */


  MultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEndss = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__.quantizeMultiArray)(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
    return new MultiPolygon(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_10__["default"].XY, simplifiedEndss);
  };
  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */


  MultiPolygon.prototype.getPolygon = function (index) {
    if (index < 0 || this.endss_.length <= index) {
      return null;
    }

    var offset;

    if (index === 0) {
      offset = 0;
    } else {
      var prevEnds = this.endss_[index - 1];
      offset = prevEnds[prevEnds.length - 1];
    }

    var ends = this.endss_[index].slice();
    var end = ends[ends.length - 1];

    if (offset !== 0) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] -= offset;
      }
    }

    return new _Polygon_js__WEBPACK_IMPORTED_MODULE_12__["default"](this.flatCoordinates.slice(offset, end), this.layout, ends);
  };
  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */


  MultiPolygon.prototype.getPolygons = function () {
    var layout = this.layout;
    var flatCoordinates = this.flatCoordinates;
    var endss = this.endss_;
    var polygons = [];
    var offset = 0;

    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i].slice();
      var end = ends[ends.length - 1];

      if (offset !== 0) {
        for (var j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] -= offset;
        }
      }

      var polygon = new _Polygon_js__WEBPACK_IMPORTED_MODULE_12__["default"](flatCoordinates.slice(offset, end), layout, ends);
      polygons.push(polygon);
      offset = end;
    }

    return polygons;
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  MultiPolygon.prototype.getType = function () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].MULTI_POLYGON;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  MultiPolygon.prototype.intersectsExtent = function (extent) {
    return (0,_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__.intersectsLinearRingMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
  };
  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   * @api
   */


  MultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 3);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    var endss = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_15__.deflateMultiCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);

    if (endss.length === 0) {
      this.flatCoordinates.length = 0;
    } else {
      var lastEnds = endss[endss.length - 1];
      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
    }

    this.changed();
  };

  return MultiPolygon;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_16__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (MultiPolygon);

/***/ }),

/***/ "./build/wg/geom/Point.js":
/*!********************************!*\
  !*** ./build/wg/geom/Point.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./build/wg/geom/SimpleGeometry.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/deflate.js */ "./build/wg/geom/flat/deflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/geom/Point
 */







/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */

var Point =
/** @class */
function (_super) {
  __extends(Point, _super);
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   */


  function Point(coordinates, opt_layout) {
    var _this = _super.call(this) || this;

    _this.setCoordinates(coordinates, opt_layout);

    return _this;
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */


  Point.prototype.clone = function () {
    var point = new Point(this.flatCoordinates.slice(), this.layout);
    point.applyProperties(this);
    return point;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  Point.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    var flatCoordinates = this.flatCoordinates;
    var squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x, y, flatCoordinates[0], flatCoordinates[1]);

    if (squaredDistance < minSquaredDistance) {
      var stride = this.stride;

      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }

      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  };
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */


  Point.prototype.getCoordinates = function () {
    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */


  Point.prototype.computeExtent = function (extent) {
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createOrUpdateFromCoordinate)(this.flatCoordinates, extent);
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  Point.prototype.getType = function () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINT;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  Point.prototype.intersectsExtent = function (extent) {
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsXY)(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  };
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   * @api
   */


  Point.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 0);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__.deflateCoordinate)(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return Point;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Point);

/***/ }),

/***/ "./build/wg/geom/Polygon.js":
/*!**********************************!*\
  !*** ./build/wg/geom/Polygon.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "circular": function() { return /* binding */ circular; },
/* harmony export */   "fromExtent": function() { return /* binding */ fromExtent; },
/* harmony export */   "fromCircle": function() { return /* binding */ fromCircle; },
/* harmony export */   "makeRegular": function() { return /* binding */ makeRegular; }
/* harmony export */ });
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _LinearRing_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./LinearRing.js */ "./build/wg/geom/LinearRing.js");
/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./build/wg/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flat/closest.js */ "./build/wg/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./flat/deflate.js */ "./build/wg/geom/flat/deflate.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/interiorpoint.js */ "./build/wg/geom/flat/interiorpoint.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/inflate.js */ "./build/wg/geom/flat/inflate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./build/wg/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_orient_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/orient.js */ "./build/wg/geom/flat/orient.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/area.js */ "./build/wg/geom/flat/area.js");
/* harmony import */ var _flat_contains_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/contains.js */ "./build/wg/geom/flat/contains.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/simplify.js */ "./build/wg/geom/flat/simplify.js");
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../sphere.js */ "./build/wg/sphere.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/geom/Polygon
 */




















/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */

var Polygon =
/** @class */
function (_super) {
  __extends(Polygon, _super);
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `opt_layout` and `opt_ends` are also accepted.)
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   * @param {Array<number>} [opt_ends] Ends (for internal use with flat coordinates).
   */


  function Polygon(coordinates, opt_layout, opt_ends) {
    var _this = _super.call(this) || this;
    /**
     * @type {Array<number>}
     * @private
     */


    _this.ends_ = [];
    /**
     * @private
     * @type {number}
     */

    _this.flatInteriorPointRevision_ = -1;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */

    _this.flatInteriorPoint_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.orientedRevision_ = -1;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.orientedFlatCoordinates_ = null;

    if (opt_layout !== undefined && opt_ends) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);

      _this.ends_ = opt_ends;
    } else {
      _this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      coordinates, opt_layout);
    }

    return _this;
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */


  Polygon.prototype.appendLinearRing = function (linearRing) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing.getFlatCoordinates().slice();
    } else {
      (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.extend)(this.flatCoordinates, linearRing.getFlatCoordinates());
    }

    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */


  Polygon.prototype.clone = function () {
    var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
    polygon.applyProperties(this);
    return polygon;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  Polygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt((0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_2__.arrayMaxSquaredDelta)(this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }

    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_2__.assignClosestArrayPoint)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */


  Polygon.prototype.containsXY = function (x, y) {
    return (0,_flat_contains_js__WEBPACK_IMPORTED_MODULE_3__.linearRingsContainsXY)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
  };
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */


  Polygon.prototype.getArea = function () {
    return (0,_flat_area_js__WEBPACK_IMPORTED_MODULE_4__.linearRings)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
  };
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [opt_right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */


  Polygon.prototype.getCoordinates = function (opt_right) {
    var flatCoordinates;

    if (opt_right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_5__.orientLinearRings)(flatCoordinates, 0, this.ends_, this.stride, opt_right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__.inflateCoordinatesArray)(flatCoordinates, 0, this.ends_, this.stride);
  };
  /**
   * @return {Array<number>} Ends.
   */


  Polygon.prototype.getEnds = function () {
    return this.ends_;
  };
  /**
   * @return {Array<number>} Interior point.
   */


  Polygon.prototype.getFlatInteriorPoint = function () {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      var flatCenter = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getCenter)(this.getExtent());
      this.flatInteriorPoint_ = (0,_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_7__.getInteriorPointOfArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
      this.flatInteriorPointRevision_ = this.getRevision();
    }

    return this.flatInteriorPoint_;
  };
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */


  Polygon.prototype.getInteriorPoint = function () {
    return new _Point_js__WEBPACK_IMPORTED_MODULE_8__["default"](this.getFlatInteriorPoint(), _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XYM);
  };
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */


  Polygon.prototype.getLinearRingCount = function () {
    return this.ends_.length;
  };
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */


  Polygon.prototype.getLinearRing = function (index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }

    return new _LinearRing_js__WEBPACK_IMPORTED_MODULE_10__["default"](this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
  };
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */


  Polygon.prototype.getLinearRings = function () {
    var layout = this.layout;
    var flatCoordinates = this.flatCoordinates;
    var ends = this.ends_;
    var linearRings = [];
    var offset = 0;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var linearRing = new _LinearRing_js__WEBPACK_IMPORTED_MODULE_10__["default"](flatCoordinates.slice(offset, end), layout);
      linearRings.push(linearRing);
      offset = end;
    }

    return linearRings;
  };
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */


  Polygon.prototype.getOrientedFlatCoordinates = function () {
    if (this.orientedRevision_ != this.getRevision()) {
      var flatCoordinates = this.flatCoordinates;

      if ((0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_5__.linearRingsAreOriented)(flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_5__.orientLinearRings)(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
      }

      this.orientedRevision_ = this.getRevision();
    }

    return this.orientedFlatCoordinates_;
  };
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */


  Polygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEnds = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__.quantizeArray)(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new Polygon(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XY, simplifiedEnds);
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  Polygon.prototype.getType = function () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  Polygon.prototype.intersectsExtent = function (extent) {
    return (0,_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_13__.intersectsLinearRingArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
  };
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   * @api
   */


  Polygon.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 2);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    var ends = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_14__.deflateCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  };

  return Polygon;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_15__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Polygon);
/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices in meters.
 * @param {number} [opt_n] Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number} [opt_sphereRadius] Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {Polygon} The "circular" polygon.
 * @api
 */

function circular(center, radius, opt_n, opt_sphereRadius) {
  var n = opt_n ? opt_n : 32;
  /** @type {Array<number>} */

  var flatCoordinates = [];

  for (var i = 0; i < n; ++i) {
    (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.extend)(flatCoordinates, (0,_sphere_js__WEBPACK_IMPORTED_MODULE_16__.offset)(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));
  }

  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  return new Polygon(flatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XY, [flatCoordinates.length]);
}
/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {import("../extent.js").Extent} extent The extent.
 * @return {Polygon} The polygon.
 * @api
 */

function fromExtent(extent) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];
  return new Polygon(flatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_9__["default"].XY, [flatCoordinates.length]);
}
/**
 * Create a regular polygon from a circle.
 * @param {import("./Circle.js").default} circle Circle geometry.
 * @param {number} [opt_sides] Number of sides of the polygon. Default is 32.
 * @param {number} [opt_angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 * @return {Polygon} Polygon geometry.
 * @api
 */

function fromCircle(circle, opt_sides, opt_angle) {
  var sides = opt_sides ? opt_sides : 32;
  var stride = circle.getStride();
  var layout = circle.getLayout();
  var center = circle.getCenter();
  var arrayLength = stride * (sides + 1);
  var flatCoordinates = new Array(arrayLength);

  for (var i = 0; i < arrayLength; i += stride) {
    flatCoordinates[i] = 0;
    flatCoordinates[i + 1] = 0;

    for (var j = 2; j < stride; j++) {
      flatCoordinates[i + j] = center[j];
    }
  }

  var ends = [flatCoordinates.length];
  var polygon = new Polygon(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), opt_angle);
  return polygon;
}
/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {Polygon} polygon Polygon geometry.
 * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number} [opt_angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 */

function makeRegular(polygon, center, radius, opt_angle) {
  var flatCoordinates = polygon.getFlatCoordinates();
  var stride = polygon.getStride();
  var sides = flatCoordinates.length / stride - 1;
  var startAngle = opt_angle ? opt_angle : 0;

  for (var i = 0; i <= sides; ++i) {
    var offset = i * stride;
    var angle = startAngle + (0,_math_js__WEBPACK_IMPORTED_MODULE_17__.modulo)(i, sides) * 2 * Math.PI / sides;
    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
  }

  polygon.changed();
}

/***/ }),

/***/ "./build/wg/geom/SimpleGeometry.js":
/*!*****************************************!*\
  !*** ./build/wg/geom/SimpleGeometry.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getStrideForLayout": function() { return /* binding */ getStrideForLayout; },
/* harmony export */   "transformGeom2D": function() { return /* binding */ transformGeom2D; }
/* harmony export */ });
/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Geometry.js */ "./build/wg/geom/Geometry.js");
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/transform.js */ "./build/wg/geom/flat/transform.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/geom/SimpleGeometry
 */







/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */

var SimpleGeometry =
/** @class */
function (_super) {
  __extends(SimpleGeometry, _super);

  function SimpleGeometry() {
    var _this = _super.call(this) || this;
    /**
     * @protected
     * @type {import("./GeometryLayout.js").default}
     */


    _this.layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__["default"].XY;
    /**
     * @protected
     * @type {number}
     */

    _this.stride = 2;
    /**
     * @protected
     * @type {Array<number>}
     */

    _this.flatCoordinates = null;
    return _this;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */


  SimpleGeometry.prototype.computeExtent = function (extent) {
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createOrUpdateFromFlatCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
  };
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */


  SimpleGeometry.prototype.getCoordinates = function () {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.abstract)();
  };
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */


  SimpleGeometry.prototype.getFirstCoordinate = function () {
    return this.flatCoordinates.slice(0, this.stride);
  };
  /**
   * @return {Array<number>} Flat coordinates.
   */


  SimpleGeometry.prototype.getFlatCoordinates = function () {
    return this.flatCoordinates;
  };
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */


  SimpleGeometry.prototype.getLastCoordinate = function () {
    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
  };
  /**
   * Return the {@link module:wg/geom/GeometryLayout layout} of the geometry.
   * @return {import("./GeometryLayout.js").default} Layout.
   * @api
   */


  SimpleGeometry.prototype.getLayout = function () {
    return this.layout;
  };
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */


  SimpleGeometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    } // If squaredTolerance is negative or if we know that simplification will not
    // have any effect then just return this.


    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }

    var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();

    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      return simplifiedGeometry;
    } else {
      // Simplification did not actually remove any coordinates.  We now know
      // that any calls to getSimplifiedGeometry with a squaredTolerance less
      // than or equal to the current squaredTolerance will also not have any
      // effect.  This allows us to short circuit simplification (saving CPU
      // cycles) and prevents the cache of simplified geometries from filling
      // up with useless identical copies of this geometry (saving memory).
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  };
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */


  SimpleGeometry.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    return this;
  };
  /**
   * @return {number} Stride.
   */


  SimpleGeometry.prototype.getStride = function () {
    return this.stride;
  };
  /**
   * @param {import("./GeometryLayout.js").default} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */


  SimpleGeometry.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  };
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
   */


  SimpleGeometry.prototype.setCoordinates = function (coordinates, opt_layout) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.abstract)();
  };
  /**
   * @param {import("./GeometryLayout.js").default|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */


  SimpleGeometry.prototype.setLayout = function (layout, coordinates, nesting) {
    /** @type {number} */
    var stride;

    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (var i = 0; i < nesting; ++i) {
        if (coordinates.length === 0) {
          this.layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__["default"].XY;
          this.stride = 2;
          return;
        } else {
          coordinates =
          /** @type {Array} */
          coordinates[0];
        }
      }

      stride = coordinates.length;
      layout = getLayoutForStride(stride);
    }

    this.layout = layout;
    this.stride = stride;
  };
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */


  SimpleGeometry.prototype.applyTransform = function (transformFn) {
    if (this.flatCoordinates) {
      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
      this.changed();
    }
  };
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */


  SimpleGeometry.prototype.rotate = function (angle, anchor) {
    var flatCoordinates = this.getFlatCoordinates();

    if (flatCoordinates) {
      var stride = this.getStride();
      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.rotate)(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
      this.changed();
    }
  };
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [opt_anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */


  SimpleGeometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
    var sy = opt_sy;

    if (sy === undefined) {
      sy = sx;
    }

    var anchor = opt_anchor;

    if (!anchor) {
      anchor = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getCenter)(this.getExtent());
    }

    var flatCoordinates = this.getFlatCoordinates();

    if (flatCoordinates) {
      var stride = this.getStride();
      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.scale)(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
      this.changed();
    }
  };
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */


  SimpleGeometry.prototype.translate = function (deltaX, deltaY) {
    var flatCoordinates = this.getFlatCoordinates();

    if (flatCoordinates) {
      var stride = this.getStride();
      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.translate)(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
      this.changed();
    }
  };

  return SimpleGeometry;
}(_Geometry_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * @param {number} stride Stride.
 * @return {import("./GeometryLayout.js").default} layout Layout.
 */


function getLayoutForStride(stride) {
  var layout;

  if (stride == 2) {
    layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__["default"].XY;
  } else if (stride == 3) {
    layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__["default"].XYZ;
  } else if (stride == 4) {
    layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__["default"].XYZM;
  }

  return (
    /** @type {import("./GeometryLayout.js").default} */
    layout
  );
}
/**
 * @param {import("./GeometryLayout.js").default} layout Layout.
 * @return {number} Stride.
 */


function getStrideForLayout(layout) {
  var stride;

  if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__["default"].XY) {
    stride = 2;
  } else if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__["default"].XYZ || layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__["default"].XYM) {
    stride = 3;
  } else if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__["default"].XYZM) {
    stride = 4;
  }

  return (
    /** @type {number} */
    stride
  );
}
/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */

function transformGeom2D(simpleGeometry, transform, opt_dest) {
  var flatCoordinates = simpleGeometry.getFlatCoordinates();

  if (!flatCoordinates) {
    return null;
  } else {
    var stride = simpleGeometry.getStride();
    return (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.transform2D)(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);
  }
}
/* harmony default export */ __webpack_exports__["default"] = (SimpleGeometry);

/***/ }),

/***/ "./build/wg/geom/flat/area.js":
/*!************************************!*\
  !*** ./build/wg/geom/flat/area.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linearRing": function() { return /* binding */ linearRing; },
/* harmony export */   "linearRings": function() { return /* binding */ linearRings; },
/* harmony export */   "linearRingss": function() { return /* binding */ linearRingss; }
/* harmony export */ });
/**
 * @module wg/geom/flat/area
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRing(flatCoordinates, offset, end, stride) {
  var twiceArea = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }

  return twiceArea / 2;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */

function linearRings(flatCoordinates, offset, ends, stride) {
  var area = 0;

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }

  return area;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */

function linearRingss(flatCoordinates, offset, endss, stride) {
  var area = 0;

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    area += linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }

  return area;
}

/***/ }),

/***/ "./build/wg/geom/flat/center.js":
/*!**************************************!*\
  !*** ./build/wg/geom/flat/center.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linearRingss": function() { return /* binding */ linearRingss; }
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/**
 * @module wg/geom/flat/center
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array<number>} Flat centers.
 */

function linearRingss(flatCoordinates, offset, endss, stride) {
  var flatCenters = [];
  var extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createEmpty)();

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createOrUpdateFromFlatCoordinates)(flatCoordinates, offset, ends[0], stride);
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }

  return flatCenters;
}

/***/ }),

/***/ "./build/wg/geom/flat/closest.js":
/*!***************************************!*\
  !*** ./build/wg/geom/flat/closest.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "maxSquaredDelta": function() { return /* binding */ maxSquaredDelta; },
/* harmony export */   "arrayMaxSquaredDelta": function() { return /* binding */ arrayMaxSquaredDelta; },
/* harmony export */   "multiArrayMaxSquaredDelta": function() { return /* binding */ multiArrayMaxSquaredDelta; },
/* harmony export */   "assignClosestPoint": function() { return /* binding */ assignClosestPoint; },
/* harmony export */   "assignClosestArrayPoint": function() { return /* binding */ assignClosestArrayPoint; },
/* harmony export */   "assignClosestMultiArrayPoint": function() { return /* binding */ assignClosestMultiArrayPoint; }
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./build/wg/math.js");
/**
 * @module wg/geom/flat/closest
 */

/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 */

function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  var x1 = flatCoordinates[offset1];
  var y1 = flatCoordinates[offset1 + 1];
  var dx = flatCoordinates[offset2] - x1;
  var dy = flatCoordinates[offset2 + 1] - y1;
  var offset;

  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
      }

      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }

  for (var i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }

  closestPoint.length = stride;
}
/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */


function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];

  for (offset += stride; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    var squaredDelta = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x1, y1, x2, y2);

    if (squaredDelta > max) {
      max = squaredDelta;
    }

    x1 = x2;
    y1 = y2;
  }

  return max;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */

function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }

  return max;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */

function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
    offset = ends[ends.length - 1];
  }

  return max;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [opt_tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */

function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }

  var i, squaredDistance;

  if (maxDelta === 0) {
    // All points are identical, so just test the first point.
    squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);

    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }

      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  }

  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var index = offset + stride;

  while (index < end) {
    assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
    squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);

    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;

      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }

      closestPoint.length = stride;
      index += stride;
    } else {
      // Skip ahead multiple points, because we know that all the skipped
      // points cannot be any closer than the closest point we have found so
      // far.  We know this because we know how close the current point is, how
      // close the closest point we have found so far is, and the maximum
      // distance between consecutive points.  For example, if we're currently
      // at distance 10, the best we've found so far is 3, and that the maximum
      // distance between consecutive points is 2, then we'll need to skip at
      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
      // finding a closer point.  We use Math.max(..., 1) to ensure that we
      // always advance at least one point, to avoid an infinite loop.
      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
  }

  if (isRing) {
    // Check the closing segment.
    assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
    squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);

    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;

      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }

      closestPoint.length = stride;
    }
  }

  return minSquaredDistance;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [opt_tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */

function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = end;
  }

  return minSquaredDistance;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [opt_tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */

function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = ends[ends.length - 1];
  }

  return minSquaredDistance;
}

/***/ }),

/***/ "./build/wg/geom/flat/contains.js":
/*!****************************************!*\
  !*** ./build/wg/geom/flat/contains.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linearRingContainsExtent": function() { return /* binding */ linearRingContainsExtent; },
/* harmony export */   "linearRingContainsXY": function() { return /* binding */ linearRingContainsXY; },
/* harmony export */   "linearRingsContainsXY": function() { return /* binding */ linearRingsContainsXY; },
/* harmony export */   "linearRingssContainsXY": function() { return /* binding */ linearRingssContainsXY; }
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/**
 * @module wg/geom/flat/contains
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */

function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  var outside = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.forEachCorner)(extent,
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains (x, y).
   */
  function (coordinate) {
    return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
  });
  return !outside;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */

function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
  // https://geomalgorithms.com/a03-_inclusion.html
  // Copyright 2000 softSurfer, 2012 Dan Sunday
  // This code may be freely used and modified for any purpose
  // providing that this copyright notice is included with it.
  // SoftSurfer makes no warranty for this code, and cannot be held
  // liable for any real or imagined damage resulting from its use.
  // Users of this code must verify correctness for their application.
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];

    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }

    x1 = x2;
    y1 = y2;
  }

  return wn !== 0;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */

function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }

  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }

  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }

  return true;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */

function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }

    offset = ends[ends.length - 1];
  }

  return false;
}

/***/ }),

/***/ "./build/wg/geom/flat/deflate.js":
/*!***************************************!*\
  !*** ./build/wg/geom/flat/deflate.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deflateCoordinate": function() { return /* binding */ deflateCoordinate; },
/* harmony export */   "deflateCoordinates": function() { return /* binding */ deflateCoordinates; },
/* harmony export */   "deflateCoordinatesArray": function() { return /* binding */ deflateCoordinatesArray; },
/* harmony export */   "deflateMultiCoordinatesArray": function() { return /* binding */ deflateMultiCoordinatesArray; }
/* harmony export */ });
/**
 * @module wg/geom/flat/deflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (var i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }

  return offset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */

function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    var coordinate = coordinates[i];

    for (var j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }

  return offset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>} [opt_ends] Ends.
 * @return {Array<number>} Ends.
 */

function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
  var ends = opt_ends ? opt_ends : [];
  var i = 0;

  for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
    var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
    ends[i++] = end;
    offset = end;
  }

  ends.length = i;
  return ends;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>} [opt_endss] Endss.
 * @return {Array<Array<number>>} Endss.
 */

function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
  var endss = opt_endss ? opt_endss : [];
  var i = 0;

  for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
    var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }

  endss.length = i;
  return endss;
}

/***/ }),

/***/ "./build/wg/geom/flat/flip.js":
/*!************************************!*\
  !*** ./build/wg/geom/flat/flip.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "flipXY": function() { return /* binding */ flipXY; }
/* harmony export */ });
/**
 * @module wg/geom/flat/flip
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<number>} [opt_dest] Destination.
 * @param {number} [opt_destOffset] Destination offset.
 * @return {Array<number>} Flat coordinates.
 */
function flipXY(flatCoordinates, offset, end, stride, opt_dest, opt_destOffset) {
  var dest, destOffset;

  if (opt_dest !== undefined) {
    dest = opt_dest;
    destOffset = opt_destOffset !== undefined ? opt_destOffset : 0;
  } else {
    dest = [];
    destOffset = 0;
  }

  var j = offset;

  while (j < end) {
    var x = flatCoordinates[j++];
    dest[destOffset++] = flatCoordinates[j++];
    dest[destOffset++] = x;

    for (var k = 2; k < stride; ++k) {
      dest[destOffset++] = flatCoordinates[j++];
    }
  }

  dest.length = destOffset;
  return dest;
}

/***/ }),

/***/ "./build/wg/geom/flat/geodesic.js":
/*!****************************************!*\
  !*** ./build/wg/geom/flat/geodesic.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "greatCircleArc": function() { return /* binding */ greatCircleArc; },
/* harmony export */   "meridian": function() { return /* binding */ meridian; },
/* harmony export */   "parallel": function() { return /* binding */ parallel; }
/* harmony export */ });
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math.js */ "./build/wg/math.js");
/**
 * @module wg/geom/flat/geodesic
 */


/**
 * @param {function(number): import("../../coordinate.js").Coordinate} interpolate Interpolate function.
 * @param {import("../../proj.js").TransformFunction} transform Transform from longitude/latitude to
 *     projected coordinates.
 * @param {number} squaredTolerance Squared tolerance.
 * @return {Array<number>} Flat coordinates.
 */

function line(interpolate, transform, squaredTolerance) {
  // FIXME reduce garbage generation
  // FIXME optimize stack operations

  /** @type {Array<number>} */
  var flatCoordinates = [];
  var geoA = interpolate(0);
  var geoB = interpolate(1);
  var a = transform(geoA);
  var b = transform(geoB);
  /** @type {Array<import("../../coordinate.js").Coordinate>} */

  var geoStack = [geoB, geoA];
  /** @type {Array<import("../../coordinate.js").Coordinate>} */

  var stack = [b, a];
  /** @type {Array<number>} */

  var fractionStack = [1, 0];
  /** @type {!Object<string, boolean>} */

  var fractions = {};
  var maxIterations = 1e5;
  var geoM, m, fracA, fracB, fracM, key;

  while (--maxIterations > 0 && fractionStack.length > 0) {
    // Pop the a coordinate off the stack
    fracA = fractionStack.pop();
    geoA = geoStack.pop();
    a = stack.pop(); // Add the a coordinate if it has not been added yet

    key = fracA.toString();

    if (!(key in fractions)) {
      flatCoordinates.push(a[0], a[1]);
      fractions[key] = true;
    } // Pop the b coordinate off the stack


    fracB = fractionStack.pop();
    geoB = geoStack.pop();
    b = stack.pop(); // Find the m point between the a and b coordinates

    fracM = (fracA + fracB) / 2;
    geoM = interpolate(fracM);
    m = transform(geoM);

    if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.squaredSegmentDistance)(m[0], m[1], a[0], a[1], b[0], b[1]) < squaredTolerance) {
      // If the m point is sufficiently close to the straight line, then we
      // discard it.  Just use the b coordinate and move on to the next line
      // segment.
      flatCoordinates.push(b[0], b[1]);
      key = fracB.toString();
      fractions[key] = true;
    } else {
      // Otherwise, we need to subdivide the current line segment.  Split it
      // into two and push the two line segments onto the stack.
      fractionStack.push(fracB, fracM, fracM, fracA);
      stack.push(b, m, m, a);
      geoStack.push(geoB, geoM, geoM, geoA);
    }
  }

  return flatCoordinates;
}
/**
 * Generate a great-circle arcs between two lat/lon points.
 * @param {number} lon1 Longitude 1 in degrees.
 * @param {number} lat1 Latitude 1 in degrees.
 * @param {number} lon2 Longitude 2 in degrees.
 * @param {number} lat2 Latitude 2 in degrees.
 * @param {import("../../proj/Projection.js").default} projection Projection.
 * @param {number} squaredTolerance Squared tolerance.
 * @return {Array<number>} Flat coordinates.
 */


function greatCircleArc(lon1, lat1, lon2, lat2, projection, squaredTolerance) {
  var geoProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:4326');
  var cosLat1 = Math.cos((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.toRadians)(lat1));
  var sinLat1 = Math.sin((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.toRadians)(lat1));
  var cosLat2 = Math.cos((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.toRadians)(lat2));
  var sinLat2 = Math.sin((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.toRadians)(lat2));
  var cosDeltaLon = Math.cos((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.toRadians)(lon2 - lon1));
  var sinDeltaLon = Math.sin((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.toRadians)(lon2 - lon1));
  var d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;
  return line(
  /**
   * @param {number} frac Fraction.
   * @return {import("../../coordinate.js").Coordinate} Coordinate.
   */
  function (frac) {
    if (1 <= d) {
      return [lon2, lat2];
    }

    var D = frac * Math.acos(d);
    var cosD = Math.cos(D);
    var sinD = Math.sin(D);
    var y = sinDeltaLon * cosLat2;
    var x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;
    var theta = Math.atan2(y, x);
    var lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));
    var lon = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.toRadians)(lon1) + Math.atan2(Math.sin(theta) * sinD * cosLat1, cosD - sinLat1 * Math.sin(lat));
    return [(0,_math_js__WEBPACK_IMPORTED_MODULE_1__.toDegrees)(lon), (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.toDegrees)(lat)];
  }, (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(geoProjection, projection), squaredTolerance);
}
/**
 * Generate a meridian (line at constant longitude).
 * @param {number} lon Longitude.
 * @param {number} lat1 Latitude 1.
 * @param {number} lat2 Latitude 2.
 * @param {import("../../proj/Projection.js").default} projection Projection.
 * @param {number} squaredTolerance Squared tolerance.
 * @return {Array<number>} Flat coordinates.
 */

function meridian(lon, lat1, lat2, projection, squaredTolerance) {
  var epsg4326Projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:4326');
  return line(
  /**
   * @param {number} frac Fraction.
   * @return {import("../../coordinate.js").Coordinate} Coordinate.
   */
  function (frac) {
    return [lon, lat1 + (lat2 - lat1) * frac];
  }, (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(epsg4326Projection, projection), squaredTolerance);
}
/**
 * Generate a parallel (line at constant latitude).
 * @param {number} lat Latitude.
 * @param {number} lon1 Longitude 1.
 * @param {number} lon2 Longitude 2.
 * @param {import("../../proj/Projection.js").default} projection Projection.
 * @param {number} squaredTolerance Squared tolerance.
 * @return {Array<number>} Flat coordinates.
 */

function parallel(lat, lon1, lon2, projection, squaredTolerance) {
  var epsg4326Projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:4326');
  return line(
  /**
   * @param {number} frac Fraction.
   * @return {import("../../coordinate.js").Coordinate} Coordinate.
   */
  function (frac) {
    return [lon1 + (lon2 - lon1) * frac, lat];
  }, (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(epsg4326Projection, projection), squaredTolerance);
}

/***/ }),

/***/ "./build/wg/geom/flat/inflate.js":
/*!***************************************!*\
  !*** ./build/wg/geom/flat/inflate.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "inflateCoordinates": function() { return /* binding */ inflateCoordinates; },
/* harmony export */   "inflateCoordinatesArray": function() { return /* binding */ inflateCoordinatesArray; },
/* harmony export */   "inflateMultiCoordinatesArray": function() { return /* binding */ inflateMultiCoordinatesArray; }
/* harmony export */ });
/**
 * @module wg/geom/flat/inflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>} [opt_coordinates] Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */
function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
  var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }

  coordinates.length = i;
  return coordinates;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} [opt_coordinatess] Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */

function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
  var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
  var i = 0;

  for (var j = 0, jj = ends.length; j < jj; ++j) {
    var end = ends[j];
    coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
    offset = end;
  }

  coordinatess.length = i;
  return coordinatess;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} [opt_coordinatesss]
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */

function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
  var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
  var i = 0;

  for (var j = 0, jj = endss.length; j < jj; ++j) {
    var ends = endss[j];
    coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
    offset = ends[ends.length - 1];
  }

  coordinatesss.length = i;
  return coordinatesss;
}

/***/ }),

/***/ "./build/wg/geom/flat/interiorpoint.js":
/*!*********************************************!*\
  !*** ./build/wg/geom/flat/interiorpoint.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getInteriorPointOfArray": function() { return /* binding */ getInteriorPointOfArray; },
/* harmony export */   "getInteriorPointsOfMultiArray": function() { return /* binding */ getInteriorPointsOfMultiArray; }
/* harmony export */ });
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contains.js */ "./build/wg/geom/flat/contains.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./build/wg/array.js");
/**
 * @module wg/geom/flat/interiorpoint
 */


/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */

function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
  var i, ii, x, x1, x2, y1, y2;
  var y = flatCenters[flatCentersOffset + 1];
  /** @type {Array<number>} */

  var intersections = []; // Calculate intersections with the horizontal line

  for (var r = 0, rr = ends.length; r < rr; ++r) {
    var end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];

    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];

      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }

      x1 = x2;
      y1 = y2;
    }
  } // Find the longest segment of the horizontal line that has its center point
  // inside the linear ring.


  var pointX = NaN;
  var maxSegmentLength = -Infinity;
  intersections.sort(_array_js__WEBPACK_IMPORTED_MODULE_0__.numberSafeCompareFunction);
  x1 = intersections[0];

  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    var segmentLength = Math.abs(x2 - x1);

    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;

      if ((0,_contains_js__WEBPACK_IMPORTED_MODULE_1__.linearRingsContainsXY)(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }

    x1 = x2;
  }

  if (isNaN(pointX)) {
    // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
  }

  if (opt_dest) {
    opt_dest.push(pointX, y, maxSegmentLength);
    return opt_dest;
  } else {
    return [pointX, y, maxSegmentLength];
  }
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */

function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
  var interiorPoints = [];

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
    offset = ends[ends.length - 1];
  }

  return interiorPoints;
}

/***/ }),

/***/ "./build/wg/geom/flat/interpolate.js":
/*!*******************************************!*\
  !*** ./build/wg/geom/flat/interpolate.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "interpolatePoint": function() { return /* binding */ interpolatePoint; },
/* harmony export */   "lineStringCoordinateAtM": function() { return /* binding */ lineStringCoordinateAtM; },
/* harmony export */   "lineStringsCoordinateAtM": function() { return /* binding */ lineStringsCoordinateAtM; }
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./build/wg/array.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math.js */ "./build/wg/math.js");
/**
 * @module wg/geom/flat/interpolate
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array<number>} [opt_dest] Destination.
 * @param {number} [opt_dimension] Destination dimension (default is `2`)
 * @return {Array<number>} Destination.
 */

function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {
  var o, t;
  var n = (end - offset) / stride;

  if (n === 1) {
    o = offset;
  } else if (n === 2) {
    o = offset;
    t = fraction;
  } else if (n !== 0) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    var length_1 = 0;
    var cumulativeLengths = [0];

    for (var i = offset + stride; i < end; i += stride) {
      var x2 = flatCoordinates[i];
      var y2 = flatCoordinates[i + 1];
      length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length_1);
      x1 = x2;
      y1 = y2;
    }

    var target = fraction * length_1;
    var index = (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.binarySearch)(cumulativeLengths, target);

    if (index < 0) {
      t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      o = offset + (-index - 2) * stride;
    } else {
      o = offset + index * stride;
    }
  }

  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var dest = opt_dest ? opt_dest : new Array(dimension);

  for (var i = 0; i < dimension; ++i) {
    dest[i] = o === undefined ? NaN : t === undefined ? flatCoordinates[o + i] : (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.lerp)(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
  }

  return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */

function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
  if (end == offset) {
    return null;
  }

  var coordinate;

  if (m < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  } else if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  } // FIXME use O(1) search


  if (m == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }

  var lo = offset / stride;
  var hi = end / stride;

  while (lo < hi) {
    var mid = lo + hi >> 1;

    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }

  var m0 = flatCoordinates[lo * stride - 1];

  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }

  var m1 = flatCoordinates[(lo + 1) * stride - 1];
  var t = (m - m0) / (m1 - m0);
  coordinate = [];

  for (var i = 0; i < stride - 1; ++i) {
    coordinate.push((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.lerp)(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
  }

  coordinate.push(m);
  return coordinate;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */

function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
  if (interpolate) {
    return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
  }

  var coordinate;

  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }

  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];

    if (offset == end) {
      continue;
    }

    if (m < flatCoordinates[offset + stride - 1]) {
      return null;
    } else if (m <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
    }

    offset = end;
  }

  return null;
}

/***/ }),

/***/ "./build/wg/geom/flat/intersectsextent.js":
/*!************************************************!*\
  !*** ./build/wg/geom/flat/intersectsextent.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "intersectsLineString": function() { return /* binding */ intersectsLineString; },
/* harmony export */   "intersectsLineStringArray": function() { return /* binding */ intersectsLineStringArray; },
/* harmony export */   "intersectsLinearRing": function() { return /* binding */ intersectsLinearRing; },
/* harmony export */   "intersectsLinearRingArray": function() { return /* binding */ intersectsLinearRingArray; },
/* harmony export */   "intersectsLinearRingMultiArray": function() { return /* binding */ intersectsLinearRingMultiArray; }
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _segments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./segments.js */ "./build/wg/geom/flat/segments.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contains.js */ "./build/wg/geom/flat/contains.js");
/**
 * @module wg/geom/flat/intersectsextent
 */



/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */

function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
  var coordinatesExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.extendFlatCoordinates)((0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createEmpty)(), flatCoordinates, offset, end, stride);

  if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.intersects)(extent, coordinatesExtent)) {
    return false;
  }

  if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.containsExtent)(extent, coordinatesExtent)) {
    return true;
  }

  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }

  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }

  return (0,_segments_js__WEBPACK_IMPORTED_MODULE_1__.forEach)(flatCoordinates, offset, end, stride,
  /**
   * @param {import("../../coordinate.js").Coordinate} point1 Start point.
   * @param {import("../../coordinate.js").Coordinate} point2 End point.
   * @return {boolean} `true` if the segment and the extent intersect,
   *     `false` otherwise.
   */
  function (point1, point2) {
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.intersectsSegment)(extent, point1, point2);
  });
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */

function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {
      return true;
    }

    offset = ends[i];
  }

  return false;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */

function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }

  if ((0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
    return true;
  }

  if ((0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
    return true;
  }

  if ((0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
    return true;
  }

  if ((0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
    return true;
  }

  return false;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */

function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }

  if (ends.length === 1) {
    return true;
  }

  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if ((0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsExtent)(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
      if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
        return false;
      }
    }
  }

  return true;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */

function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }

    offset = ends[ends.length - 1];
  }

  return false;
}

/***/ }),

/***/ "./build/wg/geom/flat/length.js":
/*!**************************************!*\
  !*** ./build/wg/geom/flat/length.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "lineStringLength": function() { return /* binding */ lineStringLength; },
/* harmony export */   "linearRingLength": function() { return /* binding */ linearRingLength; }
/* harmony export */ });
/**
 * @module wg/geom/flat/length
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */
function lineStringLength(flatCoordinates, offset, end, stride) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  var length = 0;

  for (var i = offset + stride; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }

  return length;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */

function linearRingLength(flatCoordinates, offset, end, stride) {
  var perimeter = lineStringLength(flatCoordinates, offset, end, stride);
  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
}

/***/ }),

/***/ "./build/wg/geom/flat/orient.js":
/*!**************************************!*\
  !*** ./build/wg/geom/flat/orient.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linearRingIsClockwise": function() { return /* binding */ linearRingIsClockwise; },
/* harmony export */   "linearRingsAreOriented": function() { return /* binding */ linearRingsAreOriented; },
/* harmony export */   "linearRingssAreOriented": function() { return /* binding */ linearRingssAreOriented; },
/* harmony export */   "orientLinearRings": function() { return /* binding */ orientLinearRings; },
/* harmony export */   "orientLinearRingsArray": function() { return /* binding */ orientLinearRingsArray; },
/* harmony export */   "inflateEnds": function() { return /* binding */ inflateEnds; }
/* harmony export */ });
/* harmony import */ var _reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse.js */ "./build/wg/geom/flat/reverse.js");
/**
 * @module wg/geom/flat/orient
 */

/**
 * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
 * coordinate origin? For a coordinate system with a top-left coordinate origin,
 * the ring's orientation is clockwise when this function returns false.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */

function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  // https://stackoverflow.com/q/1165647/clockwise-method#1165943
  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp
  var edge = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }

  return edge === 0 ? undefined : edge > 0;
}
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [opt_right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */

function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);

    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }

    offset = end;
  }

  return true;
}
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [opt_right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */

function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {
      return false;
    }

    if (ends.length) {
      offset = ends[ends.length - 1];
    }
  }

  return true;
}
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean} [opt_right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */

function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;

    if (reverse) {
      (0,_reverse_js__WEBPACK_IMPORTED_MODULE_0__.coordinates)(flatCoordinates, offset, end, stride);
    }

    offset = end;
  }

  return offset;
}
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [opt_right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */

function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
  }

  return offset;
}
/**
 * Return a two-dimensional endss
 * @param {Array<number>} flatCoordinates Flat coordinates
 * @param {Array<number>} ends Linear ring end indexes
 * @return {Array<Array<number>>} Two dimensional endss array that can
 * be used to contruct a MultiPolygon
 */

function inflateEnds(flatCoordinates, ends) {
  var endss = [];
  var offset = 0;
  var prevEndIndex = 0;

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i]; // classifies an array of rings into polygons with outer rings and holes

    if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {
      endss.push(ends.slice(prevEndIndex, i + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }

      endss[endss.length - 1].push(ends[prevEndIndex]);
    }

    prevEndIndex = i + 1;
    offset = end;
  }

  return endss;
}

/***/ }),

/***/ "./build/wg/geom/flat/reverse.js":
/*!***************************************!*\
  !*** ./build/wg/geom/flat/reverse.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "coordinates": function() { return /* binding */ coordinates; }
/* harmony export */ });
/**
 * @module wg/geom/flat/reverse
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (var i = 0; i < stride; ++i) {
      var tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }

    offset += stride;
    end -= stride;
  }
}

/***/ }),

/***/ "./build/wg/geom/flat/segments.js":
/*!****************************************!*\
  !*** ./build/wg/geom/flat/segments.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "forEach": function() { return /* binding */ forEach; }
/* harmony export */ });
/**
 * @module wg/geom/flat/segments
 */

/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @return {T|boolean} Value.
 * @template T
 */
function forEach(flatCoordinates, offset, end, stride, callback) {
  var ret;
  offset += stride;

  for (; offset < end; offset += stride) {
    ret = callback(flatCoordinates.slice(offset - stride, offset), flatCoordinates.slice(offset, offset + stride));

    if (ret) {
      return ret;
    }
  }

  return false;
}

/***/ }),

/***/ "./build/wg/geom/flat/simplify.js":
/*!****************************************!*\
  !*** ./build/wg/geom/flat/simplify.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "simplifyLineString": function() { return /* binding */ simplifyLineString; },
/* harmony export */   "douglasPeucker": function() { return /* binding */ douglasPeucker; },
/* harmony export */   "douglasPeuckerArray": function() { return /* binding */ douglasPeuckerArray; },
/* harmony export */   "douglasPeuckerMultiArray": function() { return /* binding */ douglasPeuckerMultiArray; },
/* harmony export */   "radialDistance": function() { return /* binding */ radialDistance; },
/* harmony export */   "snap": function() { return /* binding */ snap; },
/* harmony export */   "quantize": function() { return /* binding */ quantize; },
/* harmony export */   "quantizeArray": function() { return /* binding */ quantizeArray; },
/* harmony export */   "quantizeMultiArray": function() { return /* binding */ quantizeMultiArray; }
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./build/wg/math.js");
/**
 * @module wg/geom/flat/simplify
 */
// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>} [opt_simplifiedFlatCoordinates] Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */

function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {
  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ? opt_simplifiedFlatCoordinates : [];

  if (!highQuality) {
    end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }

  simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  return simplifiedFlatCoordinates;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */

function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  var n = (end - offset) / stride;

  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }

    return simplifiedOffset;
  }
  /** @type {Array<number>} */


  var markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  /** @type {Array<number>} */

  var stack = [offset, end - stride];
  var index = 0;

  while (stack.length > 0) {
    var last = stack.pop();
    var first = stack.pop();
    var maxSquaredDistance = 0;
    var x1 = flatCoordinates[first];
    var y1 = flatCoordinates[first + 1];
    var x2 = flatCoordinates[last];
    var y2 = flatCoordinates[last + 1];

    for (var i = first + stride; i < last; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];
      var squaredDistance_1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredSegmentDistance)(x, y, x1, y1, x2, y2);

      if (squaredDistance_1 > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance_1;
      }
    }

    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;

      if (first + stride < index) {
        stack.push(first, index);
      }

      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }

  for (var i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */

function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */

function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */

function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (end <= offset + stride) {
    // zero or one point, no simplification possible, so copy and return
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }

    return simplifiedOffset;
  }

  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1]; // copy first point

  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  var x2 = x1;
  var y2 = y1;

  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];

    if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x1, y1, x2, y2) > squaredTolerance) {
      // copy point at offset
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }

  if (x2 != x1 || y2 != y1) {
    // copy last point
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }

  return simplifiedOffset;
}
/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */

function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */

function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  // do nothing if the line is empty
  if (offset == end) {
    return simplifiedOffset;
  } // snap the first coordinate (P1)


  var x1 = snap(flatCoordinates[offset], tolerance);
  var y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride; // add the first coordinate to the output

  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1; // find the next coordinate that does not snap to the same value as the first
  // coordinate (P2)

  var x2, y2;

  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;

    if (offset == end) {
      // all coordinates snap to the same value, the line collapses to a point
      // push the last snapped value anyway to ensure that the output contains
      // at least two points
      // FIXME should we really return at least two points anyway?
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);

  while (offset < end) {
    // snap the next coordinate (P3)
    var x3 = snap(flatCoordinates[offset], tolerance);
    var y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride; // skip P3 if it is equal to P2

    if (x3 == x2 && y3 == y2) {
      continue;
    } // calculate the delta between P1 and P2


    var dx1 = x2 - x1;
    var dy1 = y2 - y1; // calculate the delta between P3 and P1

    var dx2 = x3 - x1;
    var dy2 = y3 - y1; // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
    // P1 in the same direction then P2 is on the straight line between P1 and
    // P3

    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      // discard P2 and set P2 = P3
      x2 = x3;
      y2 = y3;
      continue;
    } // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
    // between P3 and P1 or on the opposite half of the line to P2.  add P2,
    // and continue with P1 = P2 and P2 = P3


    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  } // add the last point (P2)


  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */

function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */

function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }

  return simplifiedOffset;
}

/***/ }),

/***/ "./build/wg/geom/flat/straightchunk.js":
/*!*********************************************!*\
  !*** ./build/wg/geom/flat/straightchunk.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "matchingChunk": function() { return /* binding */ matchingChunk; }
/* harmony export */ });
/**
 * @module wg/geom/flat/straightchunk
 */

/**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
  var chunkStart = offset;
  var chunkEnd = offset;
  var chunkM = 0;
  var m = 0;
  var start = offset;
  var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;

  for (i = offset; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];

    if (x1 !== undefined) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);

      if (x12 !== undefined) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));

        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }

          m = 0;
          start = i - stride;
        }
      }

      m12 = m23;
      x12 = x23;
      y12 = y23;
    }

    x1 = x2;
    y1 = y2;
  }

  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}

/***/ }),

/***/ "./build/wg/geom/flat/textpath.js":
/*!****************************************!*\
  !*** ./build/wg/geom/flat/textpath.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "drawTextOnPath": function() { return /* binding */ drawTextOnPath; }
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./build/wg/math.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./build/wg/geom/flat/transform.js");
/**
 * @module wg/geom/flat/textpath
 */


/**
 * @param {Array<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @param {number} scale The product of the text scale and the device pixel ratio.
 * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
 * @param {string} font The font.
 * @param {Object<string, number>} cache A cache of measured widths.
 * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
 * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was
 * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
 */

function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {
  var x2 = flatCoordinates[offset];
  var y2 = flatCoordinates[offset + 1];
  var x1 = 0;
  var y1 = 0;
  var segmentLength = 0;
  var segmentM = 0;

  function advance() {
    x1 = x2;
    y1 = y2;
    offset += stride;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    segmentM += segmentLength;
    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }

  do {
    advance();
  } while (offset < end - stride && segmentM + segmentLength < startM);

  var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
  var beginX = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(x1, x2, interpolate);
  var beginY = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(y1, y2, interpolate);
  var startOffset = offset - stride;
  var startLength = segmentM;
  var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);

  while (offset < end - stride && segmentM + segmentLength < endM) {
    advance();
  }

  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
  var endX = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(x1, x2, interpolate);
  var endY = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(y1, y2, interpolate); // Keep text upright

  var reverse;

  if (rotation) {
    var flat = [beginX, beginY, endX, endY];
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.rotate)(flat, 0, 4, 2, rotation, flat, flat);
    reverse = flat[0] > flat[2];
  } else {
    reverse = beginX > endX;
  }

  var PI = Math.PI;
  var result = [];
  var singleSegment = startOffset + stride === offset;
  offset = startOffset;
  segmentLength = 0;
  segmentM = startLength;
  x2 = flatCoordinates[offset];
  y2 = flatCoordinates[offset + 1];
  var previousAngle; // All on the same segment

  if (singleSegment) {
    advance();
    previousAngle = Math.atan2(y2 - y1, x2 - x1);

    if (reverse) {
      previousAngle += previousAngle > 0 ? -PI : PI;
    }

    var x = (endX + beginX) / 2;
    var y = (endY + beginY) / 2;
    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];
    return result;
  }

  for (var i = 0, ii = text.length; i < ii;) {
    advance();
    var angle = Math.atan2(y2 - y1, x2 - x1);

    if (reverse) {
      angle += angle > 0 ? -PI : PI;
    }

    if (previousAngle !== undefined) {
      var delta = angle - previousAngle;
      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;

      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }

    previousAngle = angle;
    var iStart = i;
    var charLength = 0;

    for (; i < ii; ++i) {
      var index = reverse ? ii - i - 1 : i;
      var len = scale * measureAndCacheTextWidth(font, text[index], cache);

      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
        break;
      }

      charLength += len;
    }

    if (i === iStart) {
      continue;
    }

    var chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
    var x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(x1, x2, interpolate);
    var y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(y1, y2, interpolate);
    result.push([x, y, charLength / 2, angle, chars]);
    startM += charLength;
  }

  return result;
}

/***/ }),

/***/ "./build/wg/geom/flat/topology.js":
/*!****************************************!*\
  !*** ./build/wg/geom/flat/topology.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "lineStringIsClosed": function() { return /* binding */ lineStringIsClosed; }
/* harmony export */ });
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./area.js */ "./build/wg/geom/flat/area.js");
/**
 * @module wg/geom/flat/topology
 */

/**
 * Check if the linestring is a boundary.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} The linestring is a boundary.
 */

function lineStringIsClosed(flatCoordinates, offset, end, stride) {
  var lastCoord = end - stride;

  if (flatCoordinates[offset] === flatCoordinates[lastCoord] && flatCoordinates[offset + 1] === flatCoordinates[lastCoord + 1] && (end - offset) / stride > 3) {
    return !!(0,_area_js__WEBPACK_IMPORTED_MODULE_0__.linearRing)(flatCoordinates, offset, end, stride);
  }

  return false;
}

/***/ }),

/***/ "./build/wg/geom/flat/transform.js":
/*!*****************************************!*\
  !*** ./build/wg/geom/flat/transform.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transform2D": function() { return /* binding */ transform2D; },
/* harmony export */   "rotate": function() { return /* binding */ rotate; },
/* harmony export */   "scale": function() { return /* binding */ scale; },
/* harmony export */   "translate": function() { return /* binding */ translate; }
/* harmony export */ });
/**
 * @module wg/geom/flat/transform
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */

function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}
/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */

function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */

function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}

/***/ }),

/***/ "./build/wg/has.js":
/*!*************************!*\
  !*** ./build/wg/has.js ***!
  \*************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FIREFOX": function() { return /* binding */ FIREFOX; },
/* harmony export */   "SAFARI": function() { return /* binding */ SAFARI; },
/* harmony export */   "WEBKIT": function() { return /* binding */ WEBKIT; },
/* harmony export */   "MAC": function() { return /* binding */ MAC; },
/* harmony export */   "DEVICE_PIXEL_RATIO": function() { return /* binding */ DEVICE_PIXEL_RATIO; },
/* harmony export */   "WORKER_OFFSCREEN_CANVAS": function() { return /* binding */ WORKER_OFFSCREEN_CANVAS; },
/* harmony export */   "IMAGE_DECODE": function() { return /* binding */ IMAGE_DECODE; },
/* harmony export */   "PASSIVE_EVENT_LISTENERS": function() { return /* binding */ PASSIVE_EVENT_LISTENERS; }
/* harmony export */ });
/**
 * @module wg/has
 */
var ua = typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined' ? navigator.userAgent.toLowerCase() : '';
/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */

var FIREFOX = ua.indexOf('firefox') !== -1;
/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */

var SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;
/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */

var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;
/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */

var MAC = ua.indexOf('macintosh') !== -1;
/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */

var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;
/**
 * The execution context is a worker with OffscreenCanvas available.
 * @const
 * @type {boolean}
 */

var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' && typeof OffscreenCanvas !== 'undefined' && self instanceof WorkerGlobalScope; //eslint-disable-line

/**
 * Image.prototype.decode() is supported.
 * @type {boolean}
 */

var IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;
/**
 * @type {boolean}
 */

var PASSIVE_EVENT_LISTENERS = function () {
  var passive = false;

  try {
    var options = Object.defineProperty({}, 'passive', {
      get: function get() {
        passive = true;
      }
    });
    window.addEventListener('_', null, options);
    window.removeEventListener('_', null, options);
  } catch (error) {// passive not supported
  }

  return passive;
}();

/***/ }),

/***/ "./build/wg/interaction.js":
/*!*********************************!*\
  !*** ./build/wg/interaction.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DoubleClickZoom": function() { return /* reexport safe */ _interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]; },
/* harmony export */   "DragAndDrop": function() { return /* reexport safe */ _interaction_DragAndDrop_js__WEBPACK_IMPORTED_MODULE_1__["default"]; },
/* harmony export */   "DragBox": function() { return /* reexport safe */ _interaction_DragBox_js__WEBPACK_IMPORTED_MODULE_2__["default"]; },
/* harmony export */   "DragPan": function() { return /* reexport safe */ _interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_3__["default"]; },
/* harmony export */   "DragRotate": function() { return /* reexport safe */ _interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_4__["default"]; },
/* harmony export */   "DragRotateAndZoom": function() { return /* reexport safe */ _interaction_DragRotateAndZoom_js__WEBPACK_IMPORTED_MODULE_5__["default"]; },
/* harmony export */   "DragZoom": function() { return /* reexport safe */ _interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_6__["default"]; },
/* harmony export */   "Draw": function() { return /* reexport safe */ _interaction_Draw_js__WEBPACK_IMPORTED_MODULE_7__["default"]; },
/* harmony export */   "Extent": function() { return /* reexport safe */ _interaction_Extent_js__WEBPACK_IMPORTED_MODULE_8__["default"]; },
/* harmony export */   "Interaction": function() { return /* reexport safe */ _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_9__["default"]; },
/* harmony export */   "KeyboardPan": function() { return /* reexport safe */ _interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_10__["default"]; },
/* harmony export */   "KeyboardZoom": function() { return /* reexport safe */ _interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_11__["default"]; },
/* harmony export */   "Modify": function() { return /* reexport safe */ _interaction_Modify_js__WEBPACK_IMPORTED_MODULE_12__["default"]; },
/* harmony export */   "MouseWheelZoom": function() { return /* reexport safe */ _interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_13__["default"]; },
/* harmony export */   "PinchRotate": function() { return /* reexport safe */ _interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_14__["default"]; },
/* harmony export */   "PinchZoom": function() { return /* reexport safe */ _interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_15__["default"]; },
/* harmony export */   "Pointer": function() { return /* reexport safe */ _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_16__["default"]; },
/* harmony export */   "Select": function() { return /* reexport safe */ _interaction_Select_js__WEBPACK_IMPORTED_MODULE_17__["default"]; },
/* harmony export */   "Snap": function() { return /* reexport safe */ _interaction_Snap_js__WEBPACK_IMPORTED_MODULE_18__["default"]; },
/* harmony export */   "Translate": function() { return /* reexport safe */ _interaction_Translate_js__WEBPACK_IMPORTED_MODULE_19__["default"]; },
/* harmony export */   "defaults": function() { return /* binding */ defaults; }
/* harmony export */ });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Collection.js */ "./build/wg/Collection.js");
/* harmony import */ var _interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interaction/DoubleClickZoom.js */ "./build/wg/interaction/DoubleClickZoom.js");
/* harmony import */ var _interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interaction/DragPan.js */ "./build/wg/interaction/DragPan.js");
/* harmony import */ var _interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interaction/DragRotate.js */ "./build/wg/interaction/DragRotate.js");
/* harmony import */ var _interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./interaction/DragZoom.js */ "./build/wg/interaction/DragZoom.js");
/* harmony import */ var _interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./interaction/KeyboardPan.js */ "./build/wg/interaction/KeyboardPan.js");
/* harmony import */ var _interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./interaction/KeyboardZoom.js */ "./build/wg/interaction/KeyboardZoom.js");
/* harmony import */ var _Kinetic_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./Kinetic.js */ "./build/wg/Kinetic.js");
/* harmony import */ var _interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./interaction/MouseWheelZoom.js */ "./build/wg/interaction/MouseWheelZoom.js");
/* harmony import */ var _interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./interaction/PinchRotate.js */ "./build/wg/interaction/PinchRotate.js");
/* harmony import */ var _interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./interaction/PinchZoom.js */ "./build/wg/interaction/PinchZoom.js");
/* harmony import */ var _interaction_DragAndDrop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interaction/DragAndDrop.js */ "./build/wg/interaction/DragAndDrop.js");
/* harmony import */ var _interaction_DragBox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interaction/DragBox.js */ "./build/wg/interaction/DragBox.js");
/* harmony import */ var _interaction_DragRotateAndZoom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./interaction/DragRotateAndZoom.js */ "./build/wg/interaction/DragRotateAndZoom.js");
/* harmony import */ var _interaction_Draw_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./interaction/Draw.js */ "./build/wg/interaction/Draw.js");
/* harmony import */ var _interaction_Extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./interaction/Extent.js */ "./build/wg/interaction/Extent.js");
/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./interaction/Interaction.js */ "./build/wg/interaction/Interaction.js");
/* harmony import */ var _interaction_Modify_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./interaction/Modify.js */ "./build/wg/interaction/Modify.js");
/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./interaction/Pointer.js */ "./build/wg/interaction/Pointer.js");
/* harmony import */ var _interaction_Select_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./interaction/Select.js */ "./build/wg/interaction/Select.js");
/* harmony import */ var _interaction_Snap_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./interaction/Snap.js */ "./build/wg/interaction/Snap.js");
/* harmony import */ var _interaction_Translate_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./interaction/Translate.js */ "./build/wg/interaction/Translate.js");
/**
 * @module wg/interaction
 */































/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
 * desired.
 * @property {boolean} [onFocusOnly=false] Interact only when the map has the
 * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
 * useful when page scroll is desired for maps that do not have the browser's
 * focus.
 * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
 * desired.
 * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
 * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
 * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
 * @property {boolean} [dragPan=true] Whether drag pan is desired.
 * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
 * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
 * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
 * @property {number} [zoomDuration] Duration of the zoom animation in
 * milliseconds.
 */

/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link module:wg/interaction/Interaction~Interaction} instances and insert
 * them into a {@link module:wg/Collection~Collection} in the order you want
 * before creating your {@link module:wg/Map~Map} instance. Changing the order can
 * be of interest if the event propagation needs to be stopped at a point.
 * The default set of interactions, in sequence, is:
 * * {@link module:wg/interaction/DragRotate~DragRotate}
 * * {@link module:wg/interaction/DoubleClickZoom~DoubleClickZoom}
 * * {@link module:wg/interaction/DragPan~DragPan}
 * * {@link module:wg/interaction/PinchRotate~PinchRotate}
 * * {@link module:wg/interaction/PinchZoom~PinchZoom}
 * * {@link module:wg/interaction/KeyboardPan~KeyboardPan}
 * * {@link module:wg/interaction/KeyboardZoom~KeyboardZoom}
 * * {@link module:wg/interaction/MouseWheelZoom~MouseWheelZoom}
 * * {@link module:wg/interaction/DragZoom~DragZoom}
 *
 * @param {DefaultsOptions} [opt_options] Defaults options.
 * @return {import("./Collection.js").default<import("./interaction/Interaction.js").default>}
 * A collection of interactions to be used with the {@link module:wg/Map~Map}
 * constructor's `interactions` option.
 * @api
 */

function defaults(opt_options) {
  var options = opt_options ? opt_options : {};
  var interactions = new _Collection_js__WEBPACK_IMPORTED_MODULE_20__["default"]();
  var kinetic = new _Kinetic_js__WEBPACK_IMPORTED_MODULE_21__["default"](-0.005, 0.05, 100);
  var altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;

  if (altShiftDragRotate) {
    interactions.push(new _interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_4__["default"]());
  }

  var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;

  if (doubleClickZoom) {
    interactions.push(new _interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var dragPan = options.dragPan !== undefined ? options.dragPan : true;

  if (dragPan) {
    interactions.push(new _interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      onFocusOnly: options.onFocusOnly,
      kinetic: kinetic
    }));
  }

  var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;

  if (pinchRotate) {
    interactions.push(new _interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_14__["default"]());
  }

  var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;

  if (pinchZoom) {
    interactions.push(new _interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_15__["default"]({
      duration: options.zoomDuration
    }));
  }

  var keyboard = options.keyboard !== undefined ? options.keyboard : true;

  if (keyboard) {
    interactions.push(new _interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_10__["default"]());
    interactions.push(new _interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_11__["default"]({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;

  if (mouseWheelZoom) {
    interactions.push(new _interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_13__["default"]({
      onFocusOnly: options.onFocusOnly,
      duration: options.zoomDuration
    }));
  }

  var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;

  if (shiftDragZoom) {
    interactions.push(new _interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
      duration: options.zoomDuration
    }));
  }

  return interactions;
}

/***/ }),

/***/ "./build/wg/interaction/DoubleClickZoom.js":
/*!*************************************************!*\
  !*** ./build/wg/interaction/DoubleClickZoom.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Interaction.js */ "./build/wg/interaction/Interaction.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./build/wg/MapBrowserEventType.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/DoubleClickZoom
 */




/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */

/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */

var DoubleClickZoom =
/** @class */
function (_super) {
  __extends(DoubleClickZoom, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function DoubleClickZoom(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @private
     * @type {number}
     */

    _this.delta_ = options.delta ? options.delta : 1;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }
  /**
   * Handles the {@link module:wg/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */


  DoubleClickZoom.prototype.handleEvent = function (mapBrowserEvent) {
    var stopEvent = false;

    if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DBLCLICK) {
      var browserEvent =
      /** @type {MouseEvent} */
      mapBrowserEvent.originalEvent;
      var map = mapBrowserEvent.map;
      var anchor = mapBrowserEvent.coordinate;
      var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
      var view = map.getView();
      (0,_Interaction_js__WEBPACK_IMPORTED_MODULE_1__.zoomByDelta)(view, delta, anchor, this.duration_);
      browserEvent.preventDefault();
      stopEvent = true;
    }

    return !stopEvent;
  };

  return DoubleClickZoom;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (DoubleClickZoom);

/***/ }),

/***/ "./build/wg/interaction/DragAndDrop.js":
/*!*********************************************!*\
  !*** ./build/wg/interaction/DragAndDrop.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DragAndDropEvent": function() { return /* binding */ DragAndDropEvent; }
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _format_FormatType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../format/FormatType.js */ "./build/wg/format/FormatType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Interaction.js */ "./build/wg/interaction/Interaction.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./build/wg/events.js");
/**
 * @module wg/interaction/DragAndDrop
 */
// FIXME should handle all geo-referenced data, not just vector data
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();








/**
 * @typedef {Object} Options
 * @property {Array<typeof import("../format/Feature.js").default|import("../format/Feature.js").default>} [formatConstructors] Format constructors
 * (and/or formats pre-constructed with options).
 * @property {import("../source/Vector.js").default} [source] Optional vector source where features will be added.  If a source is provided
 * all existing features will be removed and new features will be added when
 * they are dropped on the target.  If you want to add features to a vector
 * source without removing the existing features (append only), instead of
 * providing the source option listen for the "addfeatures" event.
 * @property {import("../proj.js").ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.
 * @property {HTMLElement} [target] The element that is used as the drop target, default is the viewport element.
 */

/**
 * @enum {string}
 */

var DragAndDropEventType = {
  /**
   * Triggered when features are added
   * @event DragAndDropEvent#addfeatures
   * @api
   */
  ADD_FEATURES: 'addfeatures'
};
/**
 * @classdesc
 * Events emitted by {@link module:wg/interaction/DragAndDrop~DragAndDrop} instances are instances
 * of this type.
 */

var DragAndDropEvent =
/** @class */
function (_super) {
  __extends(DragAndDropEvent, _super);
  /**
   * @param {DragAndDropEventType} type Type.
   * @param {File} file File.
   * @param {Array<import("../Feature.js").default>} [opt_features] Features.
   * @param {import("../proj/Projection.js").default} [opt_projection] Projection.
   */


  function DragAndDropEvent(type, file, opt_features, opt_projection) {
    var _this = _super.call(this, type) || this;
    /**
     * The features parsed from dropped data.
     * @type {Array<import("../Feature.js").FeatureLike>|undefined}
     * @api
     */


    _this.features = opt_features;
    /**
     * The dropped file.
     * @type {File}
     * @api
     */

    _this.file = file;
    /**
     * The feature projection.
     * @type {import("../proj/Projection.js").default|undefined}
     * @api
     */

    _this.projection = opt_projection;
    return _this;
  }

  return DragAndDropEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'addfeatures', DragAndDropEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'addfeatures', Return>} DragAndDropOnSignature
 */

/**
 * @classdesc
 * Handles input of vector data by drag and drop.
 *
 * Note that the DragAndDrop interaction uses the TextDecoder() constructor if the supplied
 * combination of formats read both text string and ArrayBuffer sources. Older browsers such
 * as IE which do not support this will need a TextDecoder polyfill to be loaded before use.
 *
 * @api
 *
 * @fires DragAndDropEvent
 */

var DragAndDrop =
/** @class */
function (_super) {
  __extends(DragAndDrop, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function DragAndDrop(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      handleEvent: _functions_js__WEBPACK_IMPORTED_MODULE_2__.TRUE
    }) || this;
    /***
     * @type {DragAndDropOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {DragAndDropOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {DragAndDropOnSignature<void>}
     */

    _this.un;
    /**
     * @private
     * @type {boolean}
     */

    _this.readAsBuffer_ = false;
    /**
     * @private
     * @type {Array<import("../format/Feature.js").default>}
     */

    _this.formats_ = [];
    var formatConstructors = options.formatConstructors ? options.formatConstructors : [];

    for (var i = 0, ii = formatConstructors.length; i < ii; ++i) {
      var format = formatConstructors[i];

      if (typeof format === 'function') {
        format = new format();
      }

      _this.formats_.push(format);

      _this.readAsBuffer_ = _this.readAsBuffer_ || format.getType() === _format_FormatType_js__WEBPACK_IMPORTED_MODULE_3__["default"].ARRAY_BUFFER;
    }
    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */


    _this.projection_ = options.projection ? (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.projection) : null;
    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */

    _this.dropListenKeys_ = null;
    /**
     * @private
     * @type {import("../source/Vector.js").default}
     */

    _this.source_ = options.source || null;
    /**
     * @private
     * @type {HTMLElement|null}
     */

    _this.target = options.target ? options.target : null;
    return _this;
  }
  /**
   * @param {File} file File.
   * @param {Event} event Load event.
   * @private
   */


  DragAndDrop.prototype.handleResult_ = function (file, event) {
    var result = event.target.result;
    var map = this.getMap();
    var projection = this.projection_;

    if (!projection) {
      var view = map.getView();
      projection = view.getProjection();
    }

    var text;
    var formats = this.formats_;

    for (var i = 0, ii = formats.length; i < ii; ++i) {
      var format = formats[i];
      var input = result;

      if (this.readAsBuffer_ && format.getType() !== _format_FormatType_js__WEBPACK_IMPORTED_MODULE_3__["default"].ARRAY_BUFFER) {
        if (text === undefined) {
          text = new TextDecoder().decode(result);
        }

        input = text;
      }

      var features = this.tryReadFeatures_(format, input, {
        featureProjection: projection
      });

      if (features && features.length > 0) {
        if (this.source_) {
          this.source_.clear();
          this.source_.addFeatures(features);
        }

        this.dispatchEvent(new DragAndDropEvent(DragAndDropEventType.ADD_FEATURES, file, features, projection));
        break;
      }
    }
  };
  /**
   * @private
   */


  DragAndDrop.prototype.registerListeners_ = function () {
    var map = this.getMap();

    if (map) {
      var dropArea = this.target ? this.target : map.getViewport();
      this.dropListenKeys_ = [(0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].DROP, this.handleDrop, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].DRAGENTER, this.handleStop, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].DRAGOVER, this.handleStop, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].DROP, this.handleStop, this)];
    }
  };
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */


  DragAndDrop.prototype.setActive = function (active) {
    if (!this.getActive() && active) {
      this.registerListeners_();
    }

    if (this.getActive() && !active) {
      this.unregisterListeners_();
    }

    _super.prototype.setActive.call(this, active);
  };
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */


  DragAndDrop.prototype.setMap = function (map) {
    this.unregisterListeners_();

    _super.prototype.setMap.call(this, map);

    if (this.getActive()) {
      this.registerListeners_();
    }
  };
  /**
   * @param {import("../format/Feature.js").default} format Format.
   * @param {string} text Text.
   * @param {import("../format/Feature.js").ReadOptions} options Read options.
   * @private
   * @return {Array<import("../Feature.js").default>} Features.
   */


  DragAndDrop.prototype.tryReadFeatures_ = function (format, text, options) {
    try {
      return (
        /** @type {Array<import("../Feature.js").default>} */
        format.readFeatures(text, options)
      );
    } catch (e) {
      return null;
    }
  };
  /**
   * @private
   */


  DragAndDrop.prototype.unregisterListeners_ = function () {
    if (this.dropListenKeys_) {
      this.dropListenKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__.unlistenByKey);
      this.dropListenKeys_ = null;
    }
  };
  /**
   * @param {DragEvent} event Event.
   */


  DragAndDrop.prototype.handleDrop = function (event) {
    var files = event.dataTransfer.files;

    for (var i = 0, ii = files.length; i < ii; ++i) {
      var file = files.item(i);
      var reader = new FileReader();
      reader.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].LOAD, this.handleResult_.bind(this, file));

      if (this.readAsBuffer_) {
        reader.readAsArrayBuffer(file);
      } else {
        reader.readAsText(file);
      }
    }
  };
  /**
   * @param {DragEvent} event Event.
   */


  DragAndDrop.prototype.handleStop = function (event) {
    event.stopPropagation();
    event.preventDefault();
    event.dataTransfer.dropEffect = 'copy';
  };

  return DragAndDrop;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_6__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (DragAndDrop);

/***/ }),

/***/ "./build/wg/interaction/DragBox.js":
/*!*****************************************!*\
  !*** ./build/wg/interaction/DragBox.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DragBoxEvent": function() { return /* binding */ DragBoxEvent; }
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Pointer.js */ "./build/wg/interaction/Pointer.js");
/* harmony import */ var _render_Box_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/Box.js */ "./build/wg/render/Box.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./build/wg/events/condition.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/DragBox
 */
// FIXME draw drag box






/**
 * A function that takes a {@link module:wg/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:wg/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='wg-dragbox'] CSS class name for styling the box.
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link ol/events/condition~mouseActionButton}.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
 * `boxEndCondition` function.
 * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:wg/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:wg/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
 * Default is `true` if the area of the box is bigger than the `minArea` option.
 * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
 * before `boxend` is fired.
 */

/**
 * @enum {string}
 */

var DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: 'boxstart',

  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: 'boxdrag',

  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: 'boxend',

  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: 'boxcancel'
};
/**
 * @classdesc
 * Events emitted by {@link module:wg/interaction/DragBox~DragBox} instances are instances of
 * this type.
 */

var DragBoxEvent =
/** @class */
function (_super) {
  __extends(DragBoxEvent, _super);
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */


  function DragBoxEvent(type, coordinate, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */


    _this.coordinate = coordinate;
    /**
     * @const
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */

    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }

  return DragBoxEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature
 */

/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link module:wg/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:wg/interaction/DragZoom~DragZoom} and
 * {@link module:wg/interaction/DragRotateAndZoom~DragRotateAndZoom}).
 *
 * @fires DragBoxEvent
 * @api
 */

var DragBox =
/** @class */
function (_super) {
  __extends(DragBox, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function DragBox(opt_options) {
    var _this = _super.call(this) || this;
    /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */


    _this.on;
    /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {DragBoxOnSignature<void>}
     */

    _this.un;
    var options = opt_options ? opt_options : {};
    /**
     * @type {import("../render/Box.js").default}
     * @private
     */

    _this.box_ = new _render_Box_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.className || 'wg-dragbox');
    /**
     * @type {number}
     * @private
     */

    _this.minArea_ = options.minArea !== undefined ? options.minArea : 64;

    if (options.onBoxEnd) {
      _this.onBoxEnd = options.onBoxEnd;
    }
    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */


    _this.startPixel_ = null;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_2__.mouseActionButton;
    /**
     * @private
     * @type {EndCondition}
     */

    _this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _this.defaultBoxEndCondition;
    return _this;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */


  DragBox.prototype.defaultBoxEndCondition = function (mapBrowserEvent, startPixel, endPixel) {
    var width = endPixel[0] - startPixel[0];
    var height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  };
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */


  DragBox.prototype.getGeometry = function () {
    return this.box_.getGeometry();
  };
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  DragBox.prototype.handleDragEvent = function (mapBrowserEvent) {
    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragBox.prototype.handleUpEvent = function (mapBrowserEvent) {
    this.box_.setMap(null);
    var completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);

    if (completeBox) {
      this.onBoxEnd(mapBrowserEvent);
    }

    this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
    return false;
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragBox.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
      return true;
    } else {
      return false;
    }
  };
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */


  DragBox.prototype.onBoxEnd = function (event) {};

  return DragBox;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (DragBox);

/***/ }),

/***/ "./build/wg/interaction/DragPan.js":
/*!*****************************************!*\
  !*** ./build/wg/interaction/DragPan.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Pointer.js */ "./build/wg/interaction/Pointer.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./build/wg/events/condition.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../easing.js */ "./build/wg/easing.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../coordinate.js */ "./build/wg/coordinate.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/DragPan
 */







/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:wg/events/condition.noModifierKeys} and {@link module:wg/events/condition.primaryAction}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
 */

/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */

var DragPan =
/** @class */
function (_super) {
  __extends(DragPan, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function DragPan(opt_options) {
    var _this = _super.call(this, {
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_0__.FALSE
    }) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @private
     * @type {import("../Kinetic.js").default|undefined}
     */

    _this.kinetic_ = options.kinetic;
    /**
     * @type {import("../pixel.js").Pixel}
     */

    _this.lastCentroid = null;
    /**
     * @type {number}
     */

    _this.lastPointersCount_;
    /**
     * @type {boolean}
     */

    _this.panning_ = false;
    var condition = options.condition ? options.condition : (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.all)(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.noModifierKeys, _events_condition_js__WEBPACK_IMPORTED_MODULE_1__.primaryAction);
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.onFocusOnly ? (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.all)(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.focusWithTabindex, condition) : condition;
    /**
     * @private
     * @type {boolean}
     */

    _this.noKinetic_ = false;
    return _this;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  DragPan.prototype.handleDragEvent = function (mapBrowserEvent) {
    if (!this.panning_) {
      this.panning_ = true;
      this.getMap().getView().beginInteraction();
    }

    var targetPointers = this.targetPointers;
    var centroid = (0,_Pointer_js__WEBPACK_IMPORTED_MODULE_2__.centroid)(targetPointers);

    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid[0], centroid[1]);
      }

      if (this.lastCentroid) {
        var delta = [this.lastCentroid[0] - centroid[0], centroid[1] - this.lastCentroid[1]];
        var map = mapBrowserEvent.map;
        var view = map.getView();
        (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_3__.scale)(delta, view.getResolution());
        (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_3__.rotate)(delta, view.getRotation());
        view.adjustCenterInternal(delta);
      }
    } else if (this.kinetic_) {
      // reset so we don't overestimate the kinetic energy after
      // after one finger down, tiny drag, second finger down
      this.kinetic_.begin();
    }

    this.lastCentroid = centroid;
    this.lastPointersCount_ = targetPointers.length;
    mapBrowserEvent.originalEvent.preventDefault();
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragPan.prototype.handleUpEvent = function (mapBrowserEvent) {
    var map = mapBrowserEvent.map;
    var view = map.getView();

    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        var distance = this.kinetic_.getDistance();
        var angle = this.kinetic_.getAngle();
        var center = view.getCenterInternal();
        var centerpx = map.getPixelFromCoordinateInternal(center);
        var dest = map.getCoordinateFromPixelInternal([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);
        view.animateInternal({
          center: view.getConstrainedCenter(dest),
          duration: 500,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_4__.easeOut
        });
      }

      if (this.panning_) {
        this.panning_ = false;
        view.endInteraction();
      }

      return false;
    } else {
      if (this.kinetic_) {
        // reset so we don't overestimate the kinetic energy after
        // after one finger up, tiny drag, second finger up
        this.kinetic_.begin();
      }

      this.lastCentroid = null;
      return true;
    }
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragPan.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      this.lastCentroid = null; // stop any current animation

      if (view.getAnimating()) {
        view.cancelAnimations();
      }

      if (this.kinetic_) {
        this.kinetic_.begin();
      } // No kinetic as soon as more than one pointer on the screen is
      // detected. This is to prevent nasty pans after pinch.


      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    } else {
      return false;
    }
  };

  return DragPan;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (DragPan);

/***/ }),

/***/ "./build/wg/interaction/DragRotate.js":
/*!********************************************!*\
  !*** ./build/wg/interaction/DragRotate.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Pointer.js */ "./build/wg/interaction/Pointer.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./build/wg/events/condition.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rotationconstraint.js */ "./build/wg/rotationconstraint.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/DragRotate
 */






/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an
 * {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:wg/events/condition.altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link module:wg/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */

var DragRotate =
/** @class */
function (_super) {
  __extends(DragRotate, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function DragRotate(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_0__.FALSE
    }) || this;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__.altShiftKeysOnly;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastAngle_ = undefined;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  DragRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
    if (!(0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.mouseOnly)(mapBrowserEvent)) {
      return;
    }

    var map = mapBrowserEvent.map;
    var view = map.getView();

    if (view.getConstraints().rotation === _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_2__.disable) {
      return;
    }

    var size = map.getSize();
    var offset = mapBrowserEvent.pixel;
    var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);

    if (this.lastAngle_ !== undefined) {
      var delta = theta - this.lastAngle_;
      view.adjustRotationInternal(-delta);
    }

    this.lastAngle_ = theta;
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
    if (!(0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.mouseOnly)(mapBrowserEvent)) {
      return true;
    }

    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.endInteraction(this.duration_);
    return false;
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (!(0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.mouseOnly)(mapBrowserEvent)) {
      return false;
    }

    if ((0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.mouseActionButton)(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
      var map = mapBrowserEvent.map;
      map.getView().beginInteraction();
      this.lastAngle_ = undefined;
      return true;
    } else {
      return false;
    }
  };

  return DragRotate;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (DragRotate);

/***/ }),

/***/ "./build/wg/interaction/DragRotateAndZoom.js":
/*!***************************************************!*\
  !*** ./build/wg/interaction/DragRotateAndZoom.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Pointer.js */ "./build/wg/interaction/Pointer.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/condition.js */ "./build/wg/events/condition.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/DragRotateAndZoom
 */




/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:wg/events/condition.shiftKeyOnly}.
 * @property {number} [duration=400] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to zoom and rotate the map by clicking and dragging
 * on the map.  By default, this interaction is limited to when the shift
 * key is held down.
 *
 * This interaction is only supported for mouse devices.
 *
 * And this interaction is not included in the default interactions.
 * @api
 */

var DragRotateAndZoom =
/** @class */
function (_super) {
  __extends(DragRotateAndZoom, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function DragRotateAndZoom(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this,
    /** @type {import("./Pointer.js").Options} */
    options) || this;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_0__.shiftKeyOnly;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastAngle_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastMagnitude_ = undefined;
    /**
     * @private
     * @type {number}
     */

    _this.lastScaleDelta_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 400;
    return _this;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  DragRotateAndZoom.prototype.handleDragEvent = function (mapBrowserEvent) {
    if (!(0,_events_condition_js__WEBPACK_IMPORTED_MODULE_0__.mouseOnly)(mapBrowserEvent)) {
      return;
    }

    var map = mapBrowserEvent.map;
    var size = map.getSize();
    var offset = mapBrowserEvent.pixel;
    var deltaX = offset[0] - size[0] / 2;
    var deltaY = size[1] / 2 - offset[1];
    var theta = Math.atan2(deltaY, deltaX);
    var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    var view = map.getView();

    if (this.lastAngle_ !== undefined) {
      var angleDelta = this.lastAngle_ - theta;
      view.adjustRotationInternal(angleDelta);
    }

    this.lastAngle_ = theta;

    if (this.lastMagnitude_ !== undefined) {
      view.adjustResolutionInternal(this.lastMagnitude_ / magnitude);
    }

    if (this.lastMagnitude_ !== undefined) {
      this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
    }

    this.lastMagnitude_ = magnitude;
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragRotateAndZoom.prototype.handleUpEvent = function (mapBrowserEvent) {
    if (!(0,_events_condition_js__WEBPACK_IMPORTED_MODULE_0__.mouseOnly)(mapBrowserEvent)) {
      return true;
    }

    var map = mapBrowserEvent.map;
    var view = map.getView();
    var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
    view.endInteraction(this.duration_, direction);
    this.lastScaleDelta_ = 0;
    return false;
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragRotateAndZoom.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (!(0,_events_condition_js__WEBPACK_IMPORTED_MODULE_0__.mouseOnly)(mapBrowserEvent)) {
      return false;
    }

    if (this.condition_(mapBrowserEvent)) {
      mapBrowserEvent.map.getView().beginInteraction();
      this.lastAngle_ = undefined;
      this.lastMagnitude_ = undefined;
      return true;
    } else {
      return false;
    }
  };

  return DragRotateAndZoom;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (DragRotateAndZoom);

/***/ }),

/***/ "./build/wg/interaction/DragZoom.js":
/*!******************************************!*\
  !*** ./build/wg/interaction/DragZoom.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DragBox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DragBox.js */ "./build/wg/interaction/DragBox.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../easing.js */ "./build/wg/easing.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/condition.js */ "./build/wg/events/condition.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/DragZoom
 */





/**
 * @typedef {Object} Options
 * @property {string} [className='wg-dragzoom'] CSS class name for styling the
 * box.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:wg/events/condition.shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
 * `boxEndCondition` function.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link module:wg/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */

var DragZoom =
/** @class */
function (_super) {
  __extends(DragZoom, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function DragZoom(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var condition = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_0__.shiftKeyOnly;
    _this = _super.call(this, {
      condition: condition,
      className: options.className || 'wg-dragzoom',
      minArea: options.minArea
    }) || this;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 200;
    /**
     * @private
     * @type {boolean}
     */

    _this.out_ = options.out !== undefined ? options.out : false;
    return _this;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */


  DragZoom.prototype.onBoxEnd = function (event) {
    var map = this.getMap();
    var view =
    /** @type {!import("../View.js").default} */
    map.getView();
    var geometry = this.getGeometry();

    if (this.out_) {
      var rotatedExtent = view.rotatedExtentForGeometry(geometry);
      var resolution = view.getResolutionForExtentInternal(rotatedExtent);
      var factor = view.getResolution() / resolution;
      geometry = geometry.clone();
      geometry.scale(factor * factor);
    }

    view.fitInternal(geometry, {
      duration: this.duration_,
      easing: _easing_js__WEBPACK_IMPORTED_MODULE_1__.easeOut
    });
  };

  return DragZoom;
}(_DragBox_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (DragZoom);

/***/ }),

/***/ "./build/wg/interaction/Draw.js":
/*!**************************************!*\
  !*** ./build/wg/interaction/Draw.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DrawEvent": function() { return /* binding */ DrawEvent; },
/* harmony export */   "createRegularPolygon": function() { return /* binding */ createRegularPolygon; },
/* harmony export */   "createBox": function() { return /* binding */ createBox; }
/* harmony export */ });
/* harmony import */ var _geom_Circle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/Circle.js */ "./build/wg/geom/Circle.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Property.js */ "./build/wg/interaction/Property.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../MapBrowserEvent.js */ "./build/wg/MapBrowserEvent.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./build/wg/MapBrowserEventType.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./build/wg/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./build/wg/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./build/wg/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Pointer.js */ "./build/wg/interaction/Pointer.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../layer/Vector.js */ "./build/wg/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../source/Vector.js */ "./build/wg/source/Vector.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../events/condition.js */ "./build/wg/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../style/Style.js */ "./build/wg/style/Style.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../coordinate.js */ "./build/wg/coordinate.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/Draw
 */

























/**
 * @typedef {Object} Options
 * @property {import("../geom/GeometryType.js").default} type Geometry type of
 * the geometries being drawn with this instance.
 * @property {number} [clickTolerance=6] The maximum distance in pixels between
 * "down" and "up" for a "up" event to be considered a "click" event and
 * actually add a point/vertex to the geometry being drawn.  The default of `6`
 * was chosen for the draw interaction to behave correctly on mouse as well as
 * on touch devices.
 * @property {import("../Collection.js").default<Feature>} [features]
 * Destination collection for the drawn features.
 * @property {VectorSource} [source] Destination source for
 * the drawn features.
 * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
 * before the current vertex can be dragged to its exact position.
 * @property {number} [snapTolerance=12] Pixel distance for snapping to the
 * drawing finish. Must be greater than `0`.
 * @property {boolean} [stopClick=false] Stop click, singleclick, and
 * doubleclick events from firing during drawing.
 * @property {number} [maxPoints] The number of points that can be drawn before
 * a polygon ring or line string is finished. By default there is no
 * restriction.
 * @property {number} [minPoints] The number of points that must be drawn
 * before a polygon ring or line string can be finished. Default is `3` for
 * polygon rings and `2` for line strings.
 * @property {import("../events/condition.js").Condition} [finishCondition] A function
 * that takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether the drawing can be finished. Not used when drawing
 * POINT or MULTI_POINT geometries.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style for sketch features.
 * @property {GeometryFunction} [geometryFunction]
 * Function that is called when a geometry's coordinates are updated.
 * @property {string} [geometryName] Geometry name to use for features created
 * by the draw interaction.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default {@link module:wg/events/condition.noModifierKeys}, i.e. a click,
 * adds a vertex or deactivates freehand drawing.
 * @property {boolean} [freehand=false] Operate in freehand mode for lines,
 * polygons, and circles.  This makes the interaction always operate in freehand
 * mode and takes precedence over any `freehandCondition` option.
 * @property {import("../events/condition.js").Condition} [freehandCondition]
 * Condition that activates freehand drawing for lines and polygons. This
 * function takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether that event should be handled. The
 * default is {@link module:wg/events/condition.shiftKeyOnly}, meaning that the
 * Shift key activates freehand drawing.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 */

/**
 * Coordinate type when drawing points.
 * @typedef {import("../coordinate.js").Coordinate} PointCoordType
 */

/**
 * Coordinate type when drawing lines.
 * @typedef {Array<import("../coordinate.js").Coordinate>} LineCoordType
 */

/**
 * Coordinate type when drawing polygons.
 * @typedef {Array<Array<import("../coordinate.js").Coordinate>>} PolyCoordType
 */

/**
 * Types used for drawing coordinates.
 * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType
 */

/**
 * Function that takes an array of coordinates and an optional existing geometry
 * and a projection as arguments, and returns a geometry. The optional existing
 * geometry is the geometry that is returned when the function is called without
 * a second argument.
 * @typedef {function(!SketchCoordType, import("../geom/SimpleGeometry.js").default,
 *     import("../proj/Projection.js").default):
 *     import("../geom/SimpleGeometry.js").default} GeometryFunction
 */

/**
 * Draw mode.  This collapses multi-part geometry types with their single-part
 * cousins.
 * @enum {string}
 */

var Mode = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  CIRCLE: 'Circle'
};
/**
 * @enum {string}
 */

var DrawEventType = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: 'drawstart',

  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: 'drawend',

  /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */
  DRAWABORT: 'drawabort'
};
/**
 * @classdesc
 * Events emitted by {@link module:wg/interaction/Draw~Draw} instances are
 * instances of this type.
 */

var DrawEvent =
/** @class */
function (_super) {
  __extends(DrawEvent, _super);
  /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */


  function DrawEvent(type, feature) {
    var _this = _super.call(this, type) || this;
    /**
     * The feature being drawn.
     * @type {Feature}
     * @api
     */


    _this.feature = feature;
    return _this;
  }

  return DrawEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature
 */

/**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @fires DrawEvent
 * @api
 */

var Draw =
/** @class */
function (_super) {
  __extends(Draw, _super);
  /**
   * @param {Options} options Options.
   */


  function Draw(options) {
    var _this = this;

    var pointerOptions =
    /** @type {import("./Pointer.js").Options} */
    options;

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_2__.FALSE;
    }

    _this = _super.call(this, pointerOptions) || this;
    /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {DrawOnSignature<void>}
     */

    _this.un;
    /**
     * @type {boolean}
     * @private
     */

    _this.shouldHandle_ = false;
    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */

    _this.downPx_ = null;
    /**
     * @type {?}
     * @private
     */

    _this.downTimeout_;
    /**
     * @type {number|undefined}
     * @private
     */

    _this.lastDragTime_;
    /**
     * Pointer type of the last pointermove event
     * @type {string}
     * @private
     */

    _this.pointerType_;
    /**
     * @type {boolean}
     * @private
     */

    _this.freehand_ = false;
    /**
     * Target source for drawn features.
     * @type {VectorSource|null}
     * @private
     */

    _this.source_ = options.source ? options.source : null;
    /**
     * Target collection for drawn features.
     * @type {import("../Collection.js").default<Feature>|null}
     * @private
     */

    _this.features_ = options.features ? options.features : null;
    /**
     * Pixel distance for snapping.
     * @type {number}
     * @private
     */

    _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;
    /**
     * Geometry type.
     * @type {import("../geom/GeometryType.js").default}
     * @private
     */

    _this.type_ =
    /** @type {import("../geom/GeometryType.js").default} */
    options.type;
    /**
     * Drawing mode (derived from geometry type.
     * @type {Mode}
     * @private
     */

    _this.mode_ = getMode(_this.type_);
    /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * Default is `false`.
     * @type {boolean}
     * @private
     */

    _this.stopClick_ = !!options.stopClick;
    /**
     * The number of points that must be drawn before a polygon ring or line
     * string can be finished.  The default is 3 for polygon rings and 2 for
     * line strings.
     * @type {number}
     * @private
     */

    _this.minPoints_ = options.minPoints ? options.minPoints : _this.mode_ === Mode.POLYGON ? 3 : 2;
    /**
     * The number of points that can be drawn before a polygon ring or line string
     * is finished. The default is no restriction.
     * @type {number}
     * @private
     */

    _this.maxPoints_ = _this.mode_ === Mode.CIRCLE ? 2 : options.maxPoints ? options.maxPoints : Infinity;
    /**
     * A function to decide if a potential finish coordinate is permissible
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.finishCondition_ = options.finishCondition ? options.finishCondition : _functions_js__WEBPACK_IMPORTED_MODULE_2__.TRUE;
    var geometryFunction = options.geometryFunction;

    if (!geometryFunction) {
      var mode_1 = _this.mode_;

      if (mode_1 === Mode.CIRCLE) {
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */
        geometryFunction = function geometryFunction(coordinates, geometry, projection) {
          var circle = geometry ?
          /** @type {Circle} */
          geometry : new _geom_Circle_js__WEBPACK_IMPORTED_MODULE_3__["default"]([NaN, NaN]);
          var center = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(coordinates[0], projection);
          var squaredLength = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_4__.squaredDistance)(center, (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(coordinates[coordinates.length - 1], projection));
          circle.setCenterAndRadius(center, Math.sqrt(squaredLength));
          var userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();

          if (userProjection) {
            circle.transform(projection, userProjection);
          }

          return circle;
        };
      } else {
        var Constructor_1;

        if (mode_1 === Mode.POINT) {
          Constructor_1 = _geom_Point_js__WEBPACK_IMPORTED_MODULE_5__["default"];
        } else if (mode_1 === Mode.LINE_STRING) {
          Constructor_1 = _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__["default"];
        } else if (mode_1 === Mode.POLYGON) {
          Constructor_1 = _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__["default"];
        }
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */


        geometryFunction = function geometryFunction(coordinates, geometry, projection) {
          if (geometry) {
            if (mode_1 === Mode.POLYGON) {
              if (coordinates[0].length) {
                // Add a closing coordinate to match the first
                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);
              } else {
                geometry.setCoordinates([]);
              }
            } else {
              geometry.setCoordinates(coordinates);
            }
          } else {
            geometry = new Constructor_1(coordinates);
          }

          return geometry;
        };
      }
    }
    /**
     * @type {GeometryFunction}
     * @private
     */


    _this.geometryFunction_ = geometryFunction;
    /**
     * @type {number}
     * @private
     */

    _this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;
    /**
     * Finish coordinate for the feature (first point for polygons, last point for
     * linestrings).
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.finishCoordinate_ = null;
    /**
     * Sketch feature.
     * @type {Feature<import('../geom/SimpleGeometry.js').default>}
     * @private
     */

    _this.sketchFeature_ = null;
    /**
     * Sketch point.
     * @type {Feature<Point>}
     * @private
     */

    _this.sketchPoint_ = null;
    /**
     * Sketch coordinates. Used when drawing a line or polygon.
     * @type {SketchCoordType}
     * @private
     */

    _this.sketchCoords_ = null;
    /**
     * Sketch line. Used when drawing polygon.
     * @type {Feature<LineString>}
     * @private
     */

    _this.sketchLine_ = null;
    /**
     * Sketch line coordinates. Used when drawing a polygon or circle.
     * @type {LineCoordType}
     * @private
     */

    _this.sketchLineCoords_ = null;
    /**
     * Squared tolerance for handling up events.  If the squared distance
     * between a down and up event is greater than this tolerance, up events
     * will not be handled.
     * @type {number}
     * @private
     */

    _this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;
    /**
     * Draw overlay where our sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */

    _this.overlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
        useSpatialIndex: false,
        wrapX: options.wrapX ? options.wrapX : false
      }),
      style: options.style ? options.style : getDefaultStyleFunction(),
      updateWhileInteracting: true
    });
    /**
     * Name of the geometry attribute for newly created features.
     * @type {string|undefined}
     * @private
     */

    _this.geometryName_ = options.geometryName;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_10__.noModifierKeys;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.freehandCondition_;

    if (options.freehand) {
      _this.freehandCondition_ = _events_condition_js__WEBPACK_IMPORTED_MODULE_10__.always;
    } else {
      _this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_10__.shiftKeyOnly;
    }

    _this.addChangeListener(_Property_js__WEBPACK_IMPORTED_MODULE_11__["default"].ACTIVE, _this.updateState_);

    return _this;
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */


  Draw.prototype.setMap = function (map) {
    _super.prototype.setMap.call(this, map);

    this.updateState_();
  };
  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */


  Draw.prototype.getOverlay = function () {
    return this.overlay_;
  };
  /**
   * Handles the {@link module:wg/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */


  Draw.prototype.handleEvent = function (event) {
    if (event.originalEvent.type === _events_EventType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CONTEXTMENU) {
      // Avoid context menu for long taps when drawing on mobile
      event.originalEvent.preventDefault();
    }

    this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);
    var move = event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POINTERMOVE;
    var pass = true;

    if (!this.freehand_ && this.lastDragTime_ && event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POINTERDRAG) {
      var now = Date.now();

      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
        this.downPx_ = event.pixel;
        this.shouldHandle_ = !this.freehand_;
        move = true;
      } else {
        this.lastDragTime_ = undefined;
      }

      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = undefined;
      }
    }

    if (this.freehand_ && event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POINTERDRAG && this.sketchFeature_ !== null) {
      this.addToDrawing_(event.coordinate);
      pass = false;
    } else if (this.freehand_ && event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POINTERDOWN) {
      pass = false;
    } else if (move && this.getPointerCount() < 2) {
      pass = event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POINTERMOVE;

      if (pass && this.freehand_) {
        this.handlePointerMove_(event);

        if (this.shouldHandle_) {
          // Avoid page scrolling when freehand drawing on mobile
          event.originalEvent.preventDefault();
        }
      } else if (event.originalEvent.pointerType === 'mouse' || event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POINTERDRAG && this.downTimeout_ === undefined) {
        this.handlePointerMove_(event);
      }
    } else if (event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].DBLCLICK) {
      pass = false;
    }

    return _super.prototype.handleEvent.call(this, event) && pass;
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */


  Draw.prototype.handleDownEvent = function (event) {
    this.shouldHandle_ = !this.freehand_;

    if (this.freehand_) {
      this.downPx_ = event.pixel;

      if (!this.finishCoordinate_) {
        this.startDrawing_(event.coordinate);
      }

      return true;
    } else if (this.condition_(event)) {
      this.lastDragTime_ = Date.now();
      this.downTimeout_ = setTimeout(function () {
        this.handlePointerMove_(new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_14__["default"](_MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POINTERMOVE, event.map, event.originalEvent, false, event.frameState));
      }.bind(this), this.dragVertexDelay_);
      this.downPx_ = event.pixel;
      return true;
    } else {
      this.lastDragTime_ = undefined;
      return false;
    }
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */


  Draw.prototype.handleUpEvent = function (event) {
    var pass = true;

    if (this.getPointerCount() === 0) {
      if (this.downTimeout_) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = undefined;
      }

      this.handlePointerMove_(event);

      if (this.shouldHandle_) {
        var startingToDraw = !this.finishCoordinate_;

        if (startingToDraw) {
          this.startDrawing_(event.coordinate);
        }

        if (!startingToDraw && this.freehand_) {
          this.finishDrawing();
        } else if (!this.freehand_ && (!startingToDraw || this.mode_ === Mode.POINT)) {
          if (this.atFinish_(event.pixel)) {
            if (this.finishCondition_(event)) {
              this.finishDrawing();
            }
          } else {
            this.addToDrawing_(event.coordinate);
          }
        }

        pass = false;
      } else if (this.freehand_) {
        this.abortDrawing();
      }
    }

    if (!pass && this.stopClick_) {
      event.preventDefault();
    }

    return pass;
  };
  /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @private
   */


  Draw.prototype.handlePointerMove_ = function (event) {
    this.pointerType_ = event.originalEvent.pointerType;

    if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
      var downPx = this.downPx_;
      var clickPx = event.pixel;
      var dx = downPx[0] - clickPx[0];
      var dy = downPx[1] - clickPx[1];
      var squaredDistance = dx * dx + dy * dy;
      this.shouldHandle_ = this.freehand_ ? squaredDistance > this.squaredClickTolerance_ : squaredDistance <= this.squaredClickTolerance_;

      if (!this.shouldHandle_) {
        return;
      }
    }

    if (this.finishCoordinate_) {
      this.modifyDrawing_(event.coordinate);
    } else {
      this.createOrUpdateSketchPoint_(event.coordinate.slice());
    }
  };
  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */


  Draw.prototype.atFinish_ = function (pixel) {
    var at = false;

    if (this.sketchFeature_) {
      var potentiallyDone = false;
      var potentiallyFinishCoordinates = [this.finishCoordinate_];
      var mode = this.mode_;

      if (mode === Mode.POINT) {
        at = true;
      } else if (mode === Mode.CIRCLE) {
        at = this.sketchCoords_.length === 2;
      } else if (mode === Mode.LINE_STRING) {
        potentiallyDone = this.sketchCoords_.length > this.minPoints_;
      } else if (mode === Mode.POLYGON) {
        var sketchCoords =
        /** @type {PolyCoordType} */
        this.sketchCoords_;
        potentiallyDone = sketchCoords[0].length > this.minPoints_;
        potentiallyFinishCoordinates = [sketchCoords[0][0], sketchCoords[0][sketchCoords[0].length - 2]];
      }

      if (potentiallyDone) {
        var map = this.getMap();

        for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {
          var finishCoordinate = potentiallyFinishCoordinates[i];
          var finishPixel = map.getPixelFromCoordinate(finishCoordinate);
          var dx = pixel[0] - finishPixel[0];
          var dy = pixel[1] - finishPixel[1];
          var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;

          if (at) {
            this.finishCoordinate_ = finishCoordinate;
            break;
          }
        }
      }
    }

    return at;
  };
  /**
   * @param {import("../coordinate").Coordinate} coordinates Coordinate.
   * @private
   */


  Draw.prototype.createOrUpdateSketchPoint_ = function (coordinates) {
    if (!this.sketchPoint_) {
      this.sketchPoint_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_15__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_5__["default"](coordinates));
      this.updateSketchFeatures_();
    } else {
      var sketchPointGeom = this.sketchPoint_.getGeometry();
      sketchPointGeom.setCoordinates(coordinates);
    }
  };
  /**
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @private
   */


  Draw.prototype.createOrUpdateCustomSketchLine_ = function (geometry) {
    if (!this.sketchLine_) {
      this.sketchLine_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_15__["default"]();
    }

    var ring = geometry.getLinearRing(0);
    var sketchLineGeom = this.sketchLine_.getGeometry();

    if (!sketchLineGeom) {
      sketchLineGeom = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__["default"](ring.getFlatCoordinates(), ring.getLayout());
      this.sketchLine_.setGeometry(sketchLineGeom);
    } else {
      sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());
      sketchLineGeom.changed();
    }
  };
  /**
   * Start the drawing.
   * @param {import("../coordinate.js").Coordinate} start Start coordinate.
   * @private
   */


  Draw.prototype.startDrawing_ = function (start) {
    var projection = this.getMap().getView().getProjection();
    this.finishCoordinate_ = start;

    if (this.mode_ === Mode.POINT) {
      this.sketchCoords_ = start.slice();
    } else if (this.mode_ === Mode.POLYGON) {
      this.sketchCoords_ = [[start.slice(), start.slice()]];
      this.sketchLineCoords_ = this.sketchCoords_[0];
    } else {
      this.sketchCoords_ = [start.slice(), start.slice()];
    }

    if (this.sketchLineCoords_) {
      this.sketchLine_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_15__["default"](new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__["default"](this.sketchLineCoords_));
    }

    var geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);
    this.sketchFeature_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_15__["default"]();

    if (this.geometryName_) {
      this.sketchFeature_.setGeometryName(this.geometryName_);
    }

    this.sketchFeature_.setGeometry(geometry);
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  };
  /**
   * Modify the drawing.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @private
   */


  Draw.prototype.modifyDrawing_ = function (coordinate) {
    var map = this.getMap();
    var geometry = this.sketchFeature_.getGeometry();
    var projection = map.getView().getProjection();
    var coordinates, last;

    if (this.mode_ === Mode.POINT) {
      last = this.sketchCoords_;
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates =
      /** @type {PolyCoordType} */
      this.sketchCoords_[0];
      last = coordinates[coordinates.length - 1];

      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {
        // snap to finish
        coordinate = this.finishCoordinate_.slice();
      }
    } else {
      coordinates = this.sketchCoords_;
      last = coordinates[coordinates.length - 1];
    }

    last[0] = coordinate[0];
    last[1] = coordinate[1];
    this.geometryFunction_(
    /** @type {!LineCoordType} */
    this.sketchCoords_, geometry, projection);

    if (this.sketchPoint_) {
      var sketchPointGeom = this.sketchPoint_.getGeometry();
      sketchPointGeom.setCoordinates(coordinate);
    }

    if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_16__["default"].POLYGON && this.mode_ !== Mode.POLYGON) {
      this.createOrUpdateCustomSketchLine_(
      /** @type {Polygon} */
      geometry);
    } else if (this.sketchLineCoords_) {
      var sketchLineGeom = this.sketchLine_.getGeometry();
      sketchLineGeom.setCoordinates(this.sketchLineCoords_);
    }

    this.updateSketchFeatures_();
  };
  /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @private
   */


  Draw.prototype.addToDrawing_ = function (coordinate) {
    var geometry = this.sketchFeature_.getGeometry();
    var projection = this.getMap().getView().getProjection();
    var done;
    var coordinates;
    var mode = this.mode_;

    if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {
      this.finishCoordinate_ = coordinate.slice();
      coordinates =
      /** @type {LineCoordType} */
      this.sketchCoords_;

      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }

      coordinates.push(coordinate.slice());
      this.geometryFunction_(coordinates, geometry, projection);
    } else if (mode === Mode.POLYGON) {
      coordinates =
      /** @type {PolyCoordType} */
      this.sketchCoords_[0];

      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }

      coordinates.push(coordinate.slice());

      if (done) {
        this.finishCoordinate_ = coordinates[0];
      }

      this.geometryFunction_(this.sketchCoords_, geometry, projection);
    }

    this.createOrUpdateSketchPoint_(coordinate.slice());
    this.updateSketchFeatures_();

    if (done) {
      this.finishDrawing();
    }
  };
  /**
   * Remove last point of the feature currently being drawn. Does not do anything when
   * drawing POINT or MULTI_POINT geometries.
   * @api
   */


  Draw.prototype.removeLastPoint = function () {
    if (!this.sketchFeature_) {
      return;
    }

    var geometry = this.sketchFeature_.getGeometry();
    var projection = this.getMap().getView().getProjection();
    var coordinates;
    var mode = this.mode_;

    if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {
      coordinates =
      /** @type {LineCoordType} */
      this.sketchCoords_;
      coordinates.splice(-2, 1);

      if (coordinates.length >= 2) {
        this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
        var finishCoordinate = this.finishCoordinate_.slice();
        coordinates[coordinates.length - 1] = finishCoordinate;
        this.createOrUpdateSketchPoint_(finishCoordinate);
      }

      this.geometryFunction_(coordinates, geometry, projection);

      if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_16__["default"].POLYGON && this.sketchLine_) {
        this.createOrUpdateCustomSketchLine_(
        /** @type {Polygon} */
        geometry);
      }
    } else if (mode === Mode.POLYGON) {
      coordinates =
      /** @type {PolyCoordType} */
      this.sketchCoords_[0];
      coordinates.splice(-2, 1);
      var sketchLineGeom = this.sketchLine_.getGeometry();

      if (coordinates.length >= 2) {
        var finishCoordinate = coordinates[coordinates.length - 2].slice();
        coordinates[coordinates.length - 1] = finishCoordinate;
        this.createOrUpdateSketchPoint_(finishCoordinate);
      }

      sketchLineGeom.setCoordinates(coordinates);
      this.geometryFunction_(this.sketchCoords_, geometry, projection);
    }

    if (coordinates.length === 1) {
      this.abortDrawing();
    }

    this.updateSketchFeatures_();
  };
  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:wg/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @api
   */


  Draw.prototype.finishDrawing = function () {
    var sketchFeature = this.abortDrawing_();

    if (!sketchFeature) {
      return;
    }

    var coordinates = this.sketchCoords_;
    var geometry = sketchFeature.getGeometry();
    var projection = this.getMap().getView().getProjection();

    if (this.mode_ === Mode.LINE_STRING) {
      // remove the redundant last point
      coordinates.pop();
      this.geometryFunction_(coordinates, geometry, projection);
    } else if (this.mode_ === Mode.POLYGON) {
      // remove the redundant last point in ring

      /** @type {PolyCoordType} */
      coordinates[0].pop();
      this.geometryFunction_(coordinates, geometry, projection);
      coordinates = geometry.getCoordinates();
    } // cast multi-part geometries


    if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_16__["default"].MULTI_POINT) {
      sketchFeature.setGeometry(new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_17__["default"]([
      /** @type {PointCoordType} */
      coordinates]));
    } else if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_16__["default"].MULTI_LINE_STRING) {
      sketchFeature.setGeometry(new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_18__["default"]([
      /** @type {LineCoordType} */
      coordinates]));
    } else if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_16__["default"].MULTI_POLYGON) {
      sketchFeature.setGeometry(new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_19__["default"]([
      /** @type {PolyCoordType} */
      coordinates]));
    } // First dispatch event to allow full set up of feature


    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature)); // Then insert feature

    if (this.features_) {
      this.features_.push(sketchFeature);
    }

    if (this.source_) {
      this.source_.addFeature(sketchFeature);
    }
  };
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
   * @private
   */


  Draw.prototype.abortDrawing_ = function () {
    this.finishCoordinate_ = null;
    var sketchFeature = this.sketchFeature_;
    this.sketchFeature_ = null;
    this.sketchPoint_ = null;
    this.sketchLine_ = null;
    this.overlay_.getSource().clear(true);
    return sketchFeature;
  };
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */


  Draw.prototype.abortDrawing = function () {
    var sketchFeature = this.abortDrawing_();

    if (sketchFeature) {
      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
    }
  };
  /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon. If no geometry is being drawn, a new one will be created.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended to
   * the coordinate array.
   * @api
   */


  Draw.prototype.appendCoordinates = function (coordinates) {
    var mode = this.mode_;
    var newDrawing = !this.sketchFeature_;

    if (newDrawing) {
      this.startDrawing_(coordinates[0]);
    }
    /** @type {LineCoordType} */


    var sketchCoords;

    if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {
      sketchCoords =
      /** @type {LineCoordType} */
      this.sketchCoords_;
    } else if (mode === Mode.POLYGON) {
      sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ?
      /** @type {PolyCoordType} */
      this.sketchCoords_[0] : [];
    } else {
      return;
    }

    if (newDrawing) {
      sketchCoords.shift();
    } // Remove last coordinate from sketch drawing (this coordinate follows cursor position)


    sketchCoords.pop(); // Append coordinate list

    for (var i = 0; i < coordinates.length; i++) {
      this.addToDrawing_(coordinates[i]);
    }

    var ending = coordinates[coordinates.length - 1]; // Duplicate last coordinate for sketch drawing (cursor position)

    this.addToDrawing_(ending);
    this.modifyDrawing_(ending);
  };
  /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */


  Draw.prototype.extend = function (feature) {
    var geometry = feature.getGeometry();
    var lineString = geometry;
    this.sketchFeature_ = feature;
    this.sketchCoords_ = lineString.getCoordinates();
    var last = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = last.slice();
    this.sketchCoords_.push(last.slice());
    this.sketchPoint_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_15__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_5__["default"](last));
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  };
  /**
   * Redraw the sketch features.
   * @private
   */


  Draw.prototype.updateSketchFeatures_ = function () {
    var sketchFeatures = [];

    if (this.sketchFeature_) {
      sketchFeatures.push(this.sketchFeature_);
    }

    if (this.sketchLine_) {
      sketchFeatures.push(this.sketchLine_);
    }

    if (this.sketchPoint_) {
      sketchFeatures.push(this.sketchPoint_);
    }

    var overlaySource = this.overlay_.getSource();
    overlaySource.clear(true);
    overlaySource.addFeatures(sketchFeatures);
  };
  /**
   * @private
   */


  Draw.prototype.updateState_ = function () {
    var map = this.getMap();
    var active = this.getActive();

    if (!map || !active) {
      this.abortDrawing();
    }

    this.overlay_.setMap(active ? map : null);
  };

  return Draw;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_20__["default"]);
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */


function getDefaultStyleFunction() {
  var styles = (0,_style_Style_js__WEBPACK_IMPORTED_MODULE_21__.createEditingStyle)();
  return function (feature, resolution) {
    return styles[feature.getGeometry().getType()];
  };
}
/**
 * Create a `geometryFunction` for `type: 'Circle'` that will create a regular
 * polygon with a user specified number of sides and start angle instead of a
 * {@link import("../geom/Circle.js").Circle} geometry.
 * @param {number} [opt_sides] Number of sides of the regular polygon.
 *     Default is 32.
 * @param {number} [opt_angle] Angle of the first point in counter-clockwise
 *     radians. 0 means East.
 *     Default is the angle defined by the heading from the center of the
 *     regular polygon to the current pointer position.
 * @return {GeometryFunction} Function that draws a polygon.
 * @api
 */


function createRegularPolygon(opt_sides, opt_angle) {
  return function (coordinates, opt_geometry, projection) {
    var center = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(
    /** @type {LineCoordType} */
    coordinates[0], projection);
    var end = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(
    /** @type {LineCoordType} */
    coordinates[coordinates.length - 1], projection);
    var radius = Math.sqrt((0,_coordinate_js__WEBPACK_IMPORTED_MODULE_4__.squaredDistance)(center, end));
    var geometry = opt_geometry ?
    /** @type {Polygon} */
    opt_geometry : (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__.fromCircle)(new _geom_Circle_js__WEBPACK_IMPORTED_MODULE_3__["default"](center), opt_sides);
    var angle = opt_angle;

    if (!opt_angle && opt_angle !== 0) {
      var x = end[0] - center[0];
      var y = end[1] - center[1];
      angle = Math.atan2(y, x);
    }

    (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__.makeRegular)(geometry, center, radius, angle);
    var userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();

    if (userProjection) {
      geometry.transform(projection, userProjection);
    }

    return geometry;
  };
}
/**
 * Create a `geometryFunction` that will create a box-shaped polygon (aligned
 * with the coordinate system axes).  Use this with the draw interaction and
 * `type: 'Circle'` to return a box instead of a circle geometry.
 * @return {GeometryFunction} Function that draws a box-shaped polygon.
 * @api
 */

function createBox() {
  return function (coordinates, opt_geometry, projection) {
    var extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_22__.boundingExtent)(
    /** @type {LineCoordType} */
    [coordinates[0], coordinates[coordinates.length - 1]].map(function (coordinate) {
      return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(coordinate, projection);
    }));
    var boxCoordinates = [[(0,_extent_js__WEBPACK_IMPORTED_MODULE_22__.getBottomLeft)(extent), (0,_extent_js__WEBPACK_IMPORTED_MODULE_22__.getBottomRight)(extent), (0,_extent_js__WEBPACK_IMPORTED_MODULE_22__.getTopRight)(extent), (0,_extent_js__WEBPACK_IMPORTED_MODULE_22__.getTopLeft)(extent), (0,_extent_js__WEBPACK_IMPORTED_MODULE_22__.getBottomLeft)(extent)]];
    var geometry = opt_geometry;

    if (geometry) {
      geometry.setCoordinates(boxCoordinates);
    } else {
      geometry = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__["default"](boxCoordinates);
    }

    var userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();

    if (userProjection) {
      geometry.transform(projection, userProjection);
    }

    return geometry;
  };
}
/**
 * Get the drawing mode.  The mode for multi-part geometries is the same as for
 * their single-part cousins.
 * @param {import("../geom/GeometryType.js").default} type Geometry type.
 * @return {Mode} Drawing mode.
 */

function getMode(type) {
  switch (type) {
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_16__["default"].POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_16__["default"].MULTI_POINT:
      return Mode.POINT;

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_16__["default"].LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_16__["default"].MULTI_LINE_STRING:
      return Mode.LINE_STRING;

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_16__["default"].POLYGON:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_16__["default"].MULTI_POLYGON:
      return Mode.POLYGON;

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CIRCLE:
      return Mode.CIRCLE;

    default:
      throw new Error('Invalid type: ' + type);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Draw);

/***/ }),

/***/ "./build/wg/interaction/Extent.js":
/*!****************************************!*\
  !*** ./build/wg/interaction/Extent.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExtentEvent": function() { return /* binding */ ExtentEvent; }
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./build/wg/MapBrowserEventType.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Pointer.js */ "./build/wg/interaction/Pointer.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../layer/Vector.js */ "./build/wg/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../source/Vector.js */ "./build/wg/source/Vector.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./build/wg/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../coordinate.js */ "./build/wg/coordinate.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../style/Style.js */ "./build/wg/style/Style.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/Extent
 */
















/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:wg/events/condition.always}.
 * @property {import("../extent.js").Extent} [extent] Initial extent. Defaults to no
 * initial extent.
 * @property {import("../style/Style.js").StyleLike} [boxStyle]
 * Style for the drawn extent box. Defaults to the `Polygon` editing style
 * documented in {@link module:wg/style/Style~Style}
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike} [pointerStyle]
 * Style for the cursor used to draw the extent. Defaults to the `Point` editing style
 * documented in {@link module:wg/style/Style~Style}
 * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps
 * in the X direction? Only affects visuals, not functionality.
 */

/**
 * @enum {string}
 */

var ExtentEventType = {
  /**
   * Triggered after the extent is changed
   * @event ExtentEvent#extentchanged
   * @api
   */
  EXTENTCHANGED: 'extentchanged'
};
/**
 * @classdesc
 * Events emitted by {@link module:wg/interaction/Extent~Extent} instances are
 * instances of this type.
 */

var ExtentEvent =
/** @class */
function (_super) {
  __extends(ExtentEvent, _super);
  /**
   * @param {import("../extent.js").Extent} extent the new extent
   */


  function ExtentEvent(extent) {
    var _this = _super.call(this, ExtentEventType.EXTENTCHANGED) || this;
    /**
     * The current extent.
     * @type {import("../extent.js").Extent}
     * @api
     */


    _this.extent = extent;
    return _this;
  }

  return ExtentEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'extentchanged', ExtentEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'extentchanged', Return>} ExtentOnSignature
 */

/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map.
 * Once drawn, the vector box can be modified by dragging its vertices or edges.
 * This interaction is only supported for mouse devices.
 *
 * @fires ExtentEvent
 * @api
 */

var Extent =
/** @class */
function (_super) {
  __extends(Extent, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function Extent(opt_options) {
    var _this = this;

    var options = opt_options || {};
    _this = _super.call(this,
    /** @type {import("./Pointer.js").Options} */
    options) || this;
    /***
     * @type {ExtentOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {ExtentOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {ExtentOnSignature<void>}
     */

    _this.un;
    /**
     * Condition
     * @type {import("../events/condition.js").Condition}
     * @private
     */

    _this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_2__.always;
    /**
     * Extent of the drawn box
     * @type {import("../extent.js").Extent}
     * @private
     */

    _this.extent_ = null;
    /**
     * Handler for pointer move events
     * @type {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null}
     * @private
     */

    _this.pointerHandler_ = null;
    /**
     * Pixel threshold to snap to extent
     * @type {number}
     * @private
     */

    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
    /**
     * Is the pointer snapped to an extent vertex
     * @type {boolean}
     * @private
     */

    _this.snappedToVertex_ = false;
    /**
     * Feature for displaying the visible extent
     * @type {Feature}
     * @private
     */

    _this.extentFeature_ = null;
    /**
     * Feature for displaying the visible pointer
     * @type {Feature<Point>}
     * @private
     */

    _this.vertexFeature_ = null;

    if (!opt_options) {
      opt_options = {};
    }
    /**
     * Layer for the extentFeature
     * @type {VectorLayer}
     * @private
     */


    _this.extentOverlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        useSpatialIndex: false,
        wrapX: !!opt_options.wrapX
      }),
      style: opt_options.boxStyle ? opt_options.boxStyle : getDefaultExtentStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });
    /**
     * Layer for the vertexFeature
     * @type {VectorLayer}
     * @private
     */

    _this.vertexOverlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        useSpatialIndex: false,
        wrapX: !!opt_options.wrapX
      }),
      style: opt_options.pointerStyle ? opt_options.pointerStyle : getDefaultPointerStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });

    if (opt_options.extent) {
      _this.setExtent(opt_options.extent);
    }

    return _this;
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel cursor location
   * @param {import("../PluggableMap.js").default} map map
   * @return {import("../coordinate.js").Coordinate|null} snapped vertex on extent
   * @private
   */


  Extent.prototype.snapToVertex_ = function (pixel, map) {
    var pixelCoordinate = map.getCoordinateFromPixelInternal(pixel);

    var sortByDistance = function sortByDistance(a, b) {
      return (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_5__.squaredDistanceToSegment)(pixelCoordinate, a) - (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_5__.squaredDistanceToSegment)(pixelCoordinate, b);
    };

    var extent = this.getExtentInternal();

    if (extent) {
      //convert extents to line segments and find the segment closest to pixelCoordinate
      var segments = getSegments(extent);
      segments.sort(sortByDistance);
      var closestSegment = segments[0];
      var vertex = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_5__.closestOnSegment)(pixelCoordinate, closestSegment);
      var vertexPixel = map.getPixelFromCoordinateInternal(vertex); //if the distance is within tolerance, snap to the segment

      if ((0,_coordinate_js__WEBPACK_IMPORTED_MODULE_5__.distance)(pixel, vertexPixel) <= this.pixelTolerance_) {
        //test if we should further snap to a vertex
        var pixel1 = map.getPixelFromCoordinateInternal(closestSegment[0]);
        var pixel2 = map.getPixelFromCoordinateInternal(closestSegment[1]);
        var squaredDist1 = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_5__.squaredDistance)(vertexPixel, pixel1);
        var squaredDist2 = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_5__.squaredDistance)(vertexPixel, pixel2);
        var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
        this.snappedToVertex_ = dist <= this.pixelTolerance_;

        if (this.snappedToVertex_) {
          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
        }

        return vertex;
      }
    }

    return null;
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent pointer move event
   * @private
   */


  Extent.prototype.handlePointerMove_ = function (mapBrowserEvent) {
    var pixel = mapBrowserEvent.pixel;
    var map = mapBrowserEvent.map;
    var vertex = this.snapToVertex_(pixel, map);

    if (!vertex) {
      vertex = map.getCoordinateFromPixelInternal(pixel);
    }

    this.createOrUpdatePointerFeature_(vertex);
  };
  /**
   * @param {import("../extent.js").Extent} extent extent
   * @return {Feature} extent as featrue
   * @private
   */


  Extent.prototype.createOrUpdateExtentFeature_ = function (extent) {
    var extentFeature = this.extentFeature_;

    if (!extentFeature) {
      if (!extent) {
        extentFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_6__["default"]({});
      } else {
        extentFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_6__["default"]((0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__.fromExtent)(extent));
      }

      this.extentFeature_ = extentFeature;
      this.extentOverlay_.getSource().addFeature(extentFeature);
    } else {
      if (!extent) {
        extentFeature.setGeometry(undefined);
      } else {
        extentFeature.setGeometry((0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__.fromExtent)(extent));
      }
    }

    return extentFeature;
  };
  /**
   * @param {import("../coordinate.js").Coordinate} vertex location of feature
   * @return {Feature} vertex as feature
   * @private
   */


  Extent.prototype.createOrUpdatePointerFeature_ = function (vertex) {
    var vertexFeature = this.vertexFeature_;

    if (!vertexFeature) {
      vertexFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_6__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_8__["default"](vertex));
      this.vertexFeature_ = vertexFeature;
      this.vertexOverlay_.getSource().addFeature(vertexFeature);
    } else {
      var geometry = vertexFeature.getGeometry();
      geometry.setCoordinates(vertex);
    }

    return vertexFeature;
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */


  Extent.prototype.handleEvent = function (mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent || !this.condition_(mapBrowserEvent)) {
      return true;
    } //display pointer (if not dragging)


    if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].POINTERMOVE && !this.handlingDownUpSequence) {
      this.handlePointerMove_(mapBrowserEvent);
    } //call pointer to determine up/down/drag


    _super.prototype.handleEvent.call(this, mapBrowserEvent); //return false to stop propagation


    return false;
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  Extent.prototype.handleDownEvent = function (mapBrowserEvent) {
    var pixel = mapBrowserEvent.pixel;
    var map = mapBrowserEvent.map;
    var extent = this.getExtentInternal();
    var vertex = this.snapToVertex_(pixel, map); //find the extent corner opposite the passed corner

    var getOpposingPoint = function getOpposingPoint(point) {
      var x_ = null;
      var y_ = null;

      if (point[0] == extent[0]) {
        x_ = extent[2];
      } else if (point[0] == extent[2]) {
        x_ = extent[0];
      }

      if (point[1] == extent[1]) {
        y_ = extent[3];
      } else if (point[1] == extent[3]) {
        y_ = extent[1];
      }

      if (x_ !== null && y_ !== null) {
        return [x_, y_];
      }

      return null;
    };

    if (vertex && extent) {
      var x = vertex[0] == extent[0] || vertex[0] == extent[2] ? vertex[0] : null;
      var y = vertex[1] == extent[1] || vertex[1] == extent[3] ? vertex[1] : null; //snap to point

      if (x !== null && y !== null) {
        this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex)); //snap to edge
      } else if (x !== null) {
        this.pointerHandler_ = getEdgeHandler(getOpposingPoint([x, extent[1]]), getOpposingPoint([x, extent[3]]));
      } else if (y !== null) {
        this.pointerHandler_ = getEdgeHandler(getOpposingPoint([extent[0], y]), getOpposingPoint([extent[2], y]));
      } //no snap - new bbox

    } else {
      vertex = map.getCoordinateFromPixelInternal(pixel);
      this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);
      this.pointerHandler_ = getPointHandler(vertex);
    }

    return true; //event handled; start downup sequence
  };
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  Extent.prototype.handleDragEvent = function (mapBrowserEvent) {
    if (this.pointerHandler_) {
      var pixelCoordinate = mapBrowserEvent.coordinate;
      this.setExtent(this.pointerHandler_(pixelCoordinate));
      this.createOrUpdatePointerFeature_(pixelCoordinate);
    }
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  Extent.prototype.handleUpEvent = function (mapBrowserEvent) {
    this.pointerHandler_ = null; //If bbox is zero area, set to null;

    var extent = this.getExtentInternal();

    if (!extent || (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.getArea)(extent) === 0) {
      this.setExtent(null);
    }

    return false; //Stop handling downup sequence
  };
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */


  Extent.prototype.setMap = function (map) {
    this.extentOverlay_.setMap(map);
    this.vertexOverlay_.setMap(map);

    _super.prototype.setMap.call(this, map);
  };
  /**
   * Returns the current drawn extent in the view projection (or user projection if set)
   *
   * @return {import("../extent.js").Extent} Drawn extent in the view projection.
   * @api
   */


  Extent.prototype.getExtent = function () {
    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)(this.getExtentInternal(), this.getMap().getView().getProjection());
  };
  /**
   * Returns the current drawn extent in the view projection
   *
   * @return {import("../extent.js").Extent} Drawn extent in the view projection.
   * @api
   */


  Extent.prototype.getExtentInternal = function () {
    return this.extent_;
  };
  /**
   * Manually sets the drawn extent, using the view projection.
   *
   * @param {import("../extent.js").Extent} extent Extent
   * @api
   */


  Extent.prototype.setExtent = function (extent) {
    //Null extent means no bbox
    this.extent_ = extent ? extent : null;
    this.createOrUpdateExtentFeature_(extent);
    this.dispatchEvent(new ExtentEvent(this.extent_));
  };

  return Extent;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_11__["default"]);
/**
 * Returns the default style for the drawn bbox
 *
 * @return {import("../style/Style.js").StyleFunction} Default Extent style
 */


function getDefaultExtentStyleFunction() {
  var style = (0,_style_Style_js__WEBPACK_IMPORTED_MODULE_12__.createEditingStyle)();
  return function (feature, resolution) {
    return style[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POLYGON];
  };
}
/**
 * Returns the default style for the pointer
 *
 * @return {import("../style/Style.js").StyleFunction} Default pointer style
 */


function getDefaultPointerStyleFunction() {
  var style = (0,_style_Style_js__WEBPACK_IMPORTED_MODULE_12__.createEditingStyle)();
  return function (feature, resolution) {
    return style[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POINT];
  };
}
/**
 * @param {import("../coordinate.js").Coordinate} fixedPoint corner that will be unchanged in the new extent
 * @return {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent} event handler
 */


function getPointHandler(fixedPoint) {
  return function (point) {
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.boundingExtent)([fixedPoint, point]);
  };
}
/**
 * @param {import("../coordinate.js").Coordinate} fixedP1 first corner that will be unchanged in the new extent
 * @param {import("../coordinate.js").Coordinate} fixedP2 second corner that will be unchanged in the new extent
 * @return {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null} event handler
 */


function getEdgeHandler(fixedP1, fixedP2) {
  if (fixedP1[0] == fixedP2[0]) {
    return function (point) {
      return (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.boundingExtent)([fixedP1, [point[0], fixedP2[1]]]);
    };
  } else if (fixedP1[1] == fixedP2[1]) {
    return function (point) {
      return (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.boundingExtent)([fixedP1, [fixedP2[0], point[1]]]);
    };
  } else {
    return null;
  }
}
/**
 * @param {import("../extent.js").Extent} extent extent
 * @return {Array<Array<import("../coordinate.js").Coordinate>>} extent line segments
 */


function getSegments(extent) {
  return [[[extent[0], extent[1]], [extent[0], extent[3]]], [[extent[0], extent[3]], [extent[2], extent[3]]], [[extent[2], extent[3]], [extent[2], extent[1]]], [[extent[2], extent[1]], [extent[0], extent[1]]]];
}

/* harmony default export */ __webpack_exports__["default"] = (Extent);

/***/ }),

/***/ "./build/wg/interaction/Interaction.js":
/*!*********************************************!*\
  !*** ./build/wg/interaction/Interaction.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pan": function() { return /* binding */ pan; },
/* harmony export */   "zoomByDelta": function() { return /* binding */ zoomByDelta; }
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./build/wg/Object.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Property.js */ "./build/wg/interaction/Property.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./build/wg/easing.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/Interaction
 */





/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active', Return>} InteractionOnSignature
 */

/**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return). The interactions
 * are traversed in reverse order of the interactions collection of the map.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:wg/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:wg/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */

var Interaction =
/** @class */
function (_super) {
  __extends(Interaction, _super);
  /**
   * @param {InteractionOptions} [opt_options] Options.
   */


  function Interaction(opt_options) {
    var _this = _super.call(this) || this;
    /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */


    _this.on;
    /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {InteractionOnSignature<void>}
     */

    _this.un;

    if (opt_options && opt_options.handleEvent) {
      _this.handleEvent = opt_options.handleEvent;
    }
    /**
     * @private
     * @type {import("../PluggableMap.js").default|null}
     */


    _this.map_ = null;

    _this.setActive(true);

    return _this;
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */


  Interaction.prototype.getActive = function () {
    return (
      /** @type {boolean} */
      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_0__["default"].ACTIVE)
    );
  };
  /**
   * Get the map associated with this interaction.
   * @return {import("../PluggableMap.js").default|null} Map.
   * @api
   */


  Interaction.prototype.getMap = function () {
    return this.map_;
  };
  /**
   * Handles the {@link module:wg/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */


  Interaction.prototype.handleEvent = function (mapBrowserEvent) {
    return true;
  };
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */


  Interaction.prototype.setActive = function (active) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_0__["default"].ACTIVE, active);
  };
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default|null} map Map.
   */


  Interaction.prototype.setMap = function (map) {
    this.map_ = map;
  };

  return Interaction;
}(_Object_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @param {import("../View.js").default} view View.
 * @param {import("../coordinate.js").Coordinate} delta Delta.
 * @param {number} [opt_duration] Duration.
 */


function pan(view, delta, opt_duration) {
  var currentCenter = view.getCenterInternal();

  if (currentCenter) {
    var center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: opt_duration !== undefined ? opt_duration : 250,
      easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__.linear,
      center: view.getConstrainedCenter(center)
    });
  }
}
/**
 * @param {import("../View.js").default} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {import("../coordinate.js").Coordinate} [opt_anchor] Anchor coordinate in the user projection.
 * @param {number} [opt_duration] Duration.
 */

function zoomByDelta(view, delta, opt_anchor, opt_duration) {
  var currentZoom = view.getZoom();

  if (currentZoom === undefined) {
    return;
  }

  var newZoom = view.getConstrainedZoom(currentZoom + delta);
  var newResolution = view.getResolutionForZoom(newZoom);

  if (view.getAnimating()) {
    view.cancelAnimations();
  }

  view.animate({
    resolution: newResolution,
    anchor: opt_anchor,
    duration: opt_duration !== undefined ? opt_duration : 250,
    easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__.easeOut
  });
}
/* harmony default export */ __webpack_exports__["default"] = (Interaction);

/***/ }),

/***/ "./build/wg/interaction/KeyboardPan.js":
/*!*********************************************!*\
  !*** ./build/wg/interaction/KeyboardPan.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Interaction.js */ "./build/wg/interaction/Interaction.js");
/* harmony import */ var _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/KeyCode.js */ "./build/wg/events/KeyCode.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/condition.js */ "./build/wg/events/condition.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../coordinate.js */ "./build/wg/coordinate.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/KeyboardPan
 */







/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:wg/events/condition.noModifierKeys} and
 * {@link module:wg/events/condition.targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */

/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:wg/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:wg/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */

var KeyboardPan =
/** @class */
function (_super) {
  __extends(KeyboardPan, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function KeyboardPan(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options || {};
    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */

    _this.defaultCondition_ = function (mapBrowserEvent) {
      return (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_0__.noModifierKeys)(mapBrowserEvent) && (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_0__.targetNotEditable)(mapBrowserEvent);
    };
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */


    _this.condition_ = options.condition !== undefined ? options.condition : _this.defaultCondition_;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 100;
    /**
     * @private
     * @type {number}
     */

    _this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;
    return _this;
  }
  /**
   * Handles the {@link module:wg/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {KeyboardPan}
   */


  KeyboardPan.prototype.handleEvent = function (mapBrowserEvent) {
    var stopEvent = false;

    if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].KEYDOWN) {
      var keyEvent =
      /** @type {KeyboardEvent} */
      mapBrowserEvent.originalEvent;
      var keyCode = keyEvent.keyCode;

      if (this.condition_(mapBrowserEvent) && (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].DOWN || keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT || keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT || keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].UP)) {
        var map = mapBrowserEvent.map;
        var view = map.getView();
        var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
        var deltaX = 0,
            deltaY = 0;

        if (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].DOWN) {
          deltaY = -mapUnitsDelta;
        } else if (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT) {
          deltaX = -mapUnitsDelta;
        } else if (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT) {
          deltaX = mapUnitsDelta;
        } else {
          deltaY = mapUnitsDelta;
        }

        var delta = [deltaX, deltaY];
        (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_3__.rotate)(delta, view.getRotation());
        (0,_Interaction_js__WEBPACK_IMPORTED_MODULE_4__.pan)(view, delta, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }

    return !stopEvent;
  };

  return KeyboardPan;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (KeyboardPan);

/***/ }),

/***/ "./build/wg/interaction/KeyboardZoom.js":
/*!**********************************************!*\
  !*** ./build/wg/interaction/KeyboardZoom.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Interaction.js */ "./build/wg/interaction/Interaction.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/condition.js */ "./build/wg/events/condition.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/KeyboardZoom
 */





/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:wg/events/condition.targetNotEditable}.
 * @property {number} [delta=1] The zoom level delta on each key press.
 */

/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:wg/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:wg/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */

var KeyboardZoom =
/** @class */
function (_super) {
  __extends(KeyboardZoom, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function KeyboardZoom(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_0__.targetNotEditable;
    /**
     * @private
     * @type {number}
     */

    _this.delta_ = options.delta ? options.delta : 1;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 100;
    return _this;
  }
  /**
   * Handles the {@link module:wg/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {KeyboardZoom}
   */


  KeyboardZoom.prototype.handleEvent = function (mapBrowserEvent) {
    var stopEvent = false;

    if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].KEYDOWN || mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].KEYPRESS) {
      var keyEvent =
      /** @type {KeyboardEvent} */
      mapBrowserEvent.originalEvent;
      var charCode = keyEvent.charCode;

      if (this.condition_(mapBrowserEvent) && (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
        var map = mapBrowserEvent.map;
        var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;
        var view = map.getView();
        (0,_Interaction_js__WEBPACK_IMPORTED_MODULE_2__.zoomByDelta)(view, delta, undefined, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }

    return !stopEvent;
  };

  return KeyboardZoom;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (KeyboardZoom);

/***/ }),

/***/ "./build/wg/interaction/Modify.js":
/*!****************************************!*\
  !*** ./build/wg/interaction/Modify.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ModifyEvent": function() { return /* binding */ ModifyEvent; }
/* harmony export */ });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Collection.js */ "./build/wg/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../CollectionEventType.js */ "./build/wg/CollectionEventType.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./build/wg/MapBrowserEventType.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./Pointer.js */ "./build/wg/interaction/Pointer.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../structs/RBush.js */ "./build/wg/structs/RBush.js");
/* harmony import */ var _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../source/VectorEventType.js */ "./build/wg/source/VectorEventType.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../layer/Vector.js */ "./build/wg/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../source/Vector.js */ "./build/wg/source/Vector.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./build/wg/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../coordinate.js */ "./build/wg/coordinate.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../style/Style.js */ "./build/wg/style/Style.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/Modify
 */























/**
 * The segment index assigned to a circle's center when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */

var CIRCLE_CENTER_INDEX = 0;
/**
 * The segment index assigned to a circle's circumference when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */

var CIRCLE_CIRCUMFERENCE_INDEX = 1;
var tempExtent = [0, 0, 0, 0];
var tempSegment = [];
/**
 * @enum {string}
 */

var ModifyEventType = {
  /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */
  MODIFYSTART: 'modifystart',

  /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */
  MODIFYEND: 'modifyend'
};
/**
 * @typedef {Object} SegmentData
 * @property {Array<number>} [depth] Depth.
 * @property {import("../Feature").FeatureLike} feature Feature.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} [index] Index.
 * @property {Array<Array<number>>} segment Segment.
 * @property {Array<SegmentData>} [featureSegments] FeatureSegments.
 */

/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event will be considered to add or move a
 * vertex to the sketch. Default is
 * {@link module:wg/events/condition.primaryAction}.
 * @property {import("../events/condition.js").Condition} [deleteCondition] A function
 * that takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. By default,
 * {@link module:wg/events/condition.singleClick} with
 * {@link module:wg/events/condition.altKeyOnly} results in a vertex deletion.
 * @property {import("../events/condition.js").Condition} [insertVertexCondition] A
 * function that takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether a new vertex should be added to the sketch
 * features. Default is {@link module:wg/events/condition.always}.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style used for the modification point or vertex. For linestrings and polygons, this will
 * be the affected vertex, for circles a point along the circle, and for points the actual
 * point. If not configured, the default edit style is used (see {@link module:wg/style/Style~Style}).
 * When using a style function, the point feature passed to the function will have a `features`
 * property - an array whose entries are the features that are being modified, and a `geometries`
 * property - an array whose entries are the geometries that are being modified. Both arrays are
 * in the same order. The `geometries` are only useful when modifying geometry collections, where
 * the geometry will be the particular geometry from the collection that is being modified.
 * @property {VectorSource} [source] The vector source with
 * features to modify.  If a vector source is not provided, a feature collection
 * must be provided with the `features` option.
 * @property {boolean|import("../layer/BaseVector").default} [hitDetection] When configured, point
 * features will be considered for modification based on their visual appearance, instead of being within
 * the `pixelTolerance` from the pointer location. When a {@link module:wg/layer/BaseVector~BaseVectorLayer} is
 * provided, only the rendered representation of the features on that layer will be considered.
 * @property {Collection<Feature>} [features]
 * The features the interaction works on.  If a feature collection is not
 * provided, a vector source must be provided with the `source` option.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 * @property {boolean} [snapToPointer=!hitDetection] The vertex, point or segment being modified snaps to the
 * pointer coordinate when clicked within the `pixelTolerance`.
 */

/**
 * @classdesc
 * Events emitted by {@link module:wg/interaction/Modify~Modify} instances are
 * instances of this type.
 */

var ModifyEvent =
/** @class */
function (_super) {
  __extends(ModifyEvent, _super);
  /**
   * @param {ModifyEventType} type Type.
   * @param {Collection<import("../Feature").FeatureLike>} features
   * The features modified.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent
   * Associated {@link module:wg/MapBrowserEvent~MapBrowserEvent}.
   */


  function ModifyEvent(type, features, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    /**
     * The features being modified.
     * @type {Collection<import("../Feature").FeatureLike>}
     * @api
     */


    _this.features = features;
    /**
     * Associated {@link module:wg/MapBrowserEvent~MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */

    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }

  return ModifyEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'modifyend'|'modifystart', ModifyEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'modifyend'|'modifystart', Return>} ModifyOnSignature
 */

/**
 * @classdesc
 * Interaction for modifying feature geometries.  To modify features that have
 * been added to an existing source, construct the modify interaction with the
 * `source` option.  If you want to modify features in a collection (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.  The interaction must be constructed with either a
 * `source` or `features` option.
 *
 * Cartesian distance from the pointer is used to determine the features that
 * will be modified. This means that geometries will only be considered for
 * modification when they are within the configured `pixelTolerance`. For point
 * geometries, the `hitDetection` option can be used to match their visual
 * appearance.
 *
 * By default, the interaction will allow deletion of vertices when the `alt`
 * key is pressed.  To configure the interaction with a different condition
 * for deletion, use the `deleteCondition` option.
 * @fires ModifyEvent
 * @api
 */

var Modify =
/** @class */
function (_super) {
  __extends(Modify, _super);
  /**
   * @param {Options} options Options.
   */


  function Modify(options) {
    var _this = _super.call(this,
    /** @type {import("./Pointer.js").Options} */
    options) || this;
    /***
     * @type {ModifyOnSignature<import("../events").EventsKey>}
     */


    _this.on;
    /***
     * @type {ModifyOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {ModifyOnSignature<void>}
     */

    _this.un;
    /** @private */

    _this.boundHandleFeatureChange_ = _this.handleFeatureChange_.bind(_this);
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_2__.primaryAction;
    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */

    _this.defaultDeleteCondition_ = function (mapBrowserEvent) {
      return (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.altKeyOnly)(mapBrowserEvent) && (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.singleClick)(mapBrowserEvent);
    };
    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */


    _this.deleteCondition_ = options.deleteCondition ? options.deleteCondition : _this.defaultDeleteCondition_;
    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */

    _this.insertVertexCondition_ = options.insertVertexCondition ? options.insertVertexCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_2__.always;
    /**
     * Editing vertex.
     * @type {Feature<Point>}
     * @private
     */

    _this.vertexFeature_ = null;
    /**
     * Segments intersecting {@link this.vertexFeature_} by segment uid.
     * @type {Object<string, boolean>}
     * @private
     */

    _this.vertexSegments_ = null;
    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */

    _this.lastPixel_ = [0, 0];
    /**
     * Tracks if the next `singleclick` event should be ignored to prevent
     * accidental deletion right after vertex creation.
     * @type {boolean}
     * @private
     */

    _this.ignoreNextSingleClick_ = false;
    /**
     * @type {Collection<import("../Feature").FeatureLike>}
     * @private
     */

    _this.featuresBeingModified_ = null;
    /**
     * Segment RTree for each layer
     * @type {RBush<SegmentData>}
     * @private
     */

    _this.rBush_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
    /**
     * @type {number}
     * @private
     */

    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
    /**
     * @type {boolean}
     * @private
     */

    _this.snappedToVertex_ = false;
    /**
     * Indicate whether the interaction is currently changing a feature's
     * coordinates.
     * @type {boolean}
     * @private
     */

    _this.changingFeature_ = false;
    /**
     * @type {Array}
     * @private
     */

    _this.dragSegments_ = [];
    /**
     * Draw overlay where sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */

    _this.overlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
        useSpatialIndex: false,
        wrapX: !!options.wrapX
      }),
      style: options.style ? options.style : getDefaultStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });
    /**
     * @const
     * @private
     * @type {!Object<string, function(Feature, import("../geom/Geometry.js").default): void>}
     */

    _this.SEGMENT_WRITERS_ = {
      'Point': _this.writePointGeometry_.bind(_this),
      'LineString': _this.writeLineStringGeometry_.bind(_this),
      'LinearRing': _this.writeLineStringGeometry_.bind(_this),
      'Polygon': _this.writePolygonGeometry_.bind(_this),
      'MultiPoint': _this.writeMultiPointGeometry_.bind(_this),
      'MultiLineString': _this.writeMultiLineStringGeometry_.bind(_this),
      'MultiPolygon': _this.writeMultiPolygonGeometry_.bind(_this),
      'Circle': _this.writeCircleGeometry_.bind(_this),
      'GeometryCollection': _this.writeGeometryCollectionGeometry_.bind(_this)
    };
    /**
     * @type {VectorSource}
     * @private
     */

    _this.source_ = null;
    /**
     * @type {boolean|import("../layer/BaseVector").default}
     */

    _this.hitDetection_ = null;
    var features;

    if (options.features) {
      features = options.features;
    } else if (options.source) {
      _this.source_ = options.source;
      features = new _Collection_js__WEBPACK_IMPORTED_MODULE_6__["default"](_this.source_.getFeatures());

      _this.source_.addEventListener(_source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].ADDFEATURE, _this.handleSourceAdd_.bind(_this));

      _this.source_.addEventListener(_source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].REMOVEFEATURE, _this.handleSourceRemove_.bind(_this));
    }

    if (!features) {
      throw new Error('The modify interaction requires features, a source or a layer');
    }

    if (options.hitDetection) {
      _this.hitDetection_ = options.hitDetection;
    }
    /**
     * @type {Collection<import("../Feature.js").FeatureLike>}
     * @private
     */


    _this.features_ = features;

    _this.features_.forEach(_this.addFeature_.bind(_this));

    _this.features_.addEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].ADD, _this.handleFeatureAdd_.bind(_this));

    _this.features_.addEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].REMOVE, _this.handleFeatureRemove_.bind(_this));
    /**
     * @type {import("../MapBrowserEvent.js").default}
     * @private
     */


    _this.lastPointerEvent_ = null;
    /**
     * Delta (x, y in map units) between matched rtree vertex and pointer vertex.
     * @type {Array<number>}
     */

    _this.delta_ = [0, 0];
    /**
     * @private
     */

    _this.snapToPointer_ = options.snapToPointer === undefined ? !_this.hitDetection_ : options.snapToPointer;
    return _this;
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */


  Modify.prototype.addFeature_ = function (feature) {
    var geometry = feature.getGeometry();

    if (geometry) {
      var writer = this.SEGMENT_WRITERS_[geometry.getType()];

      if (writer) {
        writer(feature, geometry);
      }
    }

    var map = this.getMap();

    if (map && map.isRendered() && this.getActive()) {
      this.handlePointerAtPixel_(this.lastPixel_, map);
    }

    feature.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CHANGE, this.boundHandleFeatureChange_);
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.
   * @private
   */


  Modify.prototype.willModifyFeatures_ = function (evt, segments) {
    if (!this.featuresBeingModified_) {
      this.featuresBeingModified_ = new _Collection_js__WEBPACK_IMPORTED_MODULE_6__["default"]();
      var features = this.featuresBeingModified_.getArray();

      for (var i = 0, ii = segments.length; i < ii; ++i) {
        var segment = segments[i];

        for (var s = 0, ss = segment.length; s < ss; ++s) {
          var feature = segment[s].feature;

          if (feature && features.indexOf(feature) === -1) {
            this.featuresBeingModified_.push(feature);
          }
        }
      }

      if (this.featuresBeingModified_.getLength() === 0) {
        this.featuresBeingModified_ = null;
      } else {
        this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART, this.featuresBeingModified_, evt));
      }
    }
  };
  /**
   * @param {Feature} feature Feature.
   * @private
   */


  Modify.prototype.removeFeature_ = function (feature) {
    this.removeFeatureSegmentData_(feature); // Remove the vertex feature if the collection of candidate features is empty.

    if (this.vertexFeature_ && this.features_.getLength() === 0) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }

    feature.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CHANGE, this.boundHandleFeatureChange_);
  };
  /**
   * @param {Feature} feature Feature.
   * @private
   */


  Modify.prototype.removeFeatureSegmentData_ = function (feature) {
    var rBush = this.rBush_;
    /** @type {Array<SegmentData>} */

    var nodesToRemove = [];
    rBush.forEach(
    /**
     * @param {SegmentData} node RTree node.
     */
    function (node) {
      if (feature === node.feature) {
        nodesToRemove.push(node);
      }
    });

    for (var i = nodesToRemove.length - 1; i >= 0; --i) {
      var nodeToRemove = nodesToRemove[i];

      for (var j = this.dragSegments_.length - 1; j >= 0; --j) {
        if (this.dragSegments_[j][0] === nodeToRemove) {
          this.dragSegments_.splice(j, 1);
        }
      }

      rBush.remove(nodeToRemove);
    }
  };
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */


  Modify.prototype.setActive = function (active) {
    if (this.vertexFeature_ && !active) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }

    _super.prototype.setActive.call(this, active);
  };
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */


  Modify.prototype.setMap = function (map) {
    this.overlay_.setMap(map);

    _super.prototype.setMap.call(this, map);
  };
  /**
   * Get the overlay layer that this interaction renders the modification point or vertex to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */


  Modify.prototype.getOverlay = function () {
    return this.overlay_;
  };
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */


  Modify.prototype.handleSourceAdd_ = function (event) {
    if (event.feature) {
      this.features_.push(event.feature);
    }
  };
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */


  Modify.prototype.handleSourceRemove_ = function (event) {
    if (event.feature) {
      this.features_.remove(event.feature);
    }
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Modify.prototype.handleFeatureAdd_ = function (evt) {
    this.addFeature_(
    /** @type {Feature} */
    evt.element);
  };
  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */


  Modify.prototype.handleFeatureChange_ = function (evt) {
    if (!this.changingFeature_) {
      var feature =
      /** @type {Feature} */
      evt.target;
      this.removeFeature_(feature);
      this.addFeature_(feature);
    }
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Modify.prototype.handleFeatureRemove_ = function (evt) {
    var feature =
    /** @type {Feature} */
    evt.element;
    this.removeFeature_(feature);
  };
  /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */


  Modify.prototype.writePointGeometry_ = function (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    /** @type {SegmentData} */

    var segmentData = {
      feature: feature,
      geometry: geometry,
      segment: [coordinates, coordinates]
    };
    this.rBush_.insert(geometry.getExtent(), segmentData);
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeMultiPointGeometry_ = function (feature, geometry) {
    var points = geometry.getCoordinates();

    for (var i = 0, ii = points.length; i < ii; ++i) {
      var coordinates = points[i];
      /** @type {SegmentData} */

      var segmentData = {
        feature: feature,
        geometry: geometry,
        depth: [i],
        index: i,
        segment: [coordinates, coordinates]
      };
      this.rBush_.insert(geometry.getExtent(), segmentData);
    }
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeLineStringGeometry_ = function (feature, geometry) {
    var coordinates = geometry.getCoordinates();

    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      /** @type {SegmentData} */

      var segmentData = {
        feature: feature,
        geometry: geometry,
        index: i,
        segment: segment
      };
      this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.boundingExtent)(segment), segmentData);
    }
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeMultiLineStringGeometry_ = function (feature, geometry) {
    var lines = geometry.getCoordinates();

    for (var j = 0, jj = lines.length; j < jj; ++j) {
      var coordinates = lines[j];

      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        /** @type {SegmentData} */

        var segmentData = {
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment
        };
        this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.boundingExtent)(segment), segmentData);
      }
    }
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writePolygonGeometry_ = function (feature, geometry) {
    var rings = geometry.getCoordinates();

    for (var j = 0, jj = rings.length; j < jj; ++j) {
      var coordinates = rings[j];

      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        /** @type {SegmentData} */

        var segmentData = {
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment
        };
        this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.boundingExtent)(segment), segmentData);
      }
    }
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeMultiPolygonGeometry_ = function (feature, geometry) {
    var polygons = geometry.getCoordinates();

    for (var k = 0, kk = polygons.length; k < kk; ++k) {
      var rings = polygons[k];

      for (var j = 0, jj = rings.length; j < jj; ++j) {
        var coordinates = rings[j];

        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          /** @type {SegmentData} */

          var segmentData = {
            feature: feature,
            geometry: geometry,
            depth: [j, k],
            index: i,
            segment: segment
          };
          this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.boundingExtent)(segment), segmentData);
        }
      }
    }
  };
  /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeCircleGeometry_ = function (feature, geometry) {
    var coordinates = geometry.getCenter();
    /** @type {SegmentData} */

    var centerSegmentData = {
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CENTER_INDEX,
      segment: [coordinates, coordinates]
    };
    /** @type {SegmentData} */

    var circumferenceSegmentData = {
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CIRCUMFERENCE_INDEX,
      segment: [coordinates, coordinates]
    };
    var featureSegments = [centerSegmentData, circumferenceSegmentData];
    centerSegmentData.featureSegments = featureSegments;
    circumferenceSegmentData.featureSegments = featureSegments;
    this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.createOrUpdateFromCoordinate)(coordinates), centerSegmentData);
    var circleGeometry =
    /** @type {import("../geom/Geometry.js").default} */
    geometry;
    var userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();

    if (userProjection && this.getMap()) {
      var projection = this.getMap().getView().getProjection();
      circleGeometry = circleGeometry.clone().transform(userProjection, projection);
      circleGeometry = (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_11__.fromCircle)(
      /** @type {import("../geom/Circle.js").default} */
      circleGeometry).transform(projection, userProjection);
    }

    this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeGeometryCollectionGeometry_ = function (feature, geometry) {
    var geometries = geometry.getGeometriesArray();

    for (var i = 0; i < geometries.length; ++i) {
      var geometry_1 = geometries[i];
      var writer = this.SEGMENT_WRITERS_[geometry_1.getType()];
      writer(feature, geometry_1);
    }
  };
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {Array<import("../Feature").FeatureLike>} features The features being modified.
   * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
   * @return {Feature} Vertex feature.
   * @private
   */


  Modify.prototype.createOrUpdateVertexFeature_ = function (coordinates, features, geometries) {
    var vertexFeature = this.vertexFeature_;

    if (!vertexFeature) {
      vertexFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_12__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_13__["default"](coordinates));
      this.vertexFeature_ = vertexFeature;
      this.overlay_.getSource().addFeature(vertexFeature);
    } else {
      var geometry = vertexFeature.getGeometry();
      geometry.setCoordinates(coordinates);
    }

    vertexFeature.set('features', features);
    vertexFeature.set('geometries', geometries);
    return vertexFeature;
  };
  /**
   * Handles the {@link module:wg/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */


  Modify.prototype.handleEvent = function (mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }

    this.lastPointerEvent_ = mapBrowserEvent;
    var handled;

    if (!mapBrowserEvent.map.getView().getInteracting() && mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_14__["default"].POINTERMOVE && !this.handlingDownUpSequence) {
      this.handlePointerMove_(mapBrowserEvent);
    }

    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
      if (mapBrowserEvent.type != _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_14__["default"].SINGLECLICK || !this.ignoreNextSingleClick_) {
        handled = this.removePoint();
      } else {
        handled = true;
      }
    }

    if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_14__["default"].SINGLECLICK) {
      this.ignoreNextSingleClick_ = false;
    }

    return _super.prototype.handleEvent.call(this, mapBrowserEvent) && !handled;
  };
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   */


  Modify.prototype.handleDragEvent = function (evt) {
    this.ignoreNextSingleClick_ = false;
    this.willModifyFeatures_(evt, this.dragSegments_);
    var vertex = [evt.coordinate[0] + this.delta_[0], evt.coordinate[1] + this.delta_[1]];
    var features = [];
    var geometries = [];

    for (var i = 0, ii = this.dragSegments_.length; i < ii; ++i) {
      var dragSegment = this.dragSegments_[i];
      var segmentData = dragSegment[0];
      var feature = segmentData.feature;

      if (features.indexOf(feature) === -1) {
        features.push(feature);
      }

      var geometry = segmentData.geometry;

      if (geometries.indexOf(geometry) === -1) {
        geometries.push(geometry);
      }

      var depth = segmentData.depth;
      var coordinates = void 0;
      var segment = segmentData.segment;
      var index = dragSegment[1];

      while (vertex.length < geometry.getStride()) {
        vertex.push(segment[index][vertex.length]);
      }

      switch (geometry.getType()) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POINT:
          coordinates = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;

        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POINT:
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index] = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;

        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].LINE_STRING:
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;

        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_LINE_STRING:
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;

        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POLYGON:
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;

        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POLYGON:
          coordinates = geometry.getCoordinates();
          coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;

        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].CIRCLE:
          segment[0] = vertex;
          segment[1] = vertex;

          if (segmentData.index === CIRCLE_CENTER_INDEX) {
            this.changingFeature_ = true;
            geometry.setCenter(vertex);
            this.changingFeature_ = false;
          } else {
            // We're dragging the circle's circumference:
            this.changingFeature_ = true;
            var projection = evt.map.getView().getProjection();
            var radius = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.distance)((0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(geometry.getCenter(), projection), (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(vertex, projection));
            var userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();

            if (userProjection) {
              var circleGeometry = geometry.clone().transform(userProjection, projection);
              circleGeometry.setRadius(radius);
              radius = circleGeometry.transform(projection, userProjection).getRadius();
            }

            geometry.setRadius(radius);
            this.changingFeature_ = false;
          }

          break;

        default: // pass

      }

      if (coordinates) {
        this.setGeometryCoordinates_(geometry, coordinates);
      }
    }

    this.createOrUpdateVertexFeature_(vertex, features, geometries);
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */


  Modify.prototype.handleDownEvent = function (evt) {
    if (!this.condition_(evt)) {
      return false;
    }

    var pixelCoordinate = evt.coordinate;
    this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);
    this.dragSegments_.length = 0;
    this.featuresBeingModified_ = null;
    var vertexFeature = this.vertexFeature_;

    if (vertexFeature) {
      var projection = evt.map.getView().getProjection();
      var insertVertices = [];
      var vertex = vertexFeature.getGeometry().getCoordinates();
      var vertexExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.boundingExtent)([vertex]);
      var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
      var componentSegments = {};
      segmentDataMatches.sort(compareIndexes);

      for (var i = 0, ii = segmentDataMatches.length; i < ii; ++i) {
        var segmentDataMatch = segmentDataMatches[i];
        var segment = segmentDataMatch.segment;
        var uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_17__.getUid)(segmentDataMatch.geometry);
        var depth = segmentDataMatch.depth;

        if (depth) {
          uid += '-' + depth.join('-'); // separate feature components
        }

        if (!componentSegments[uid]) {
          componentSegments[uid] = new Array(2);
        }

        if (segmentDataMatch.geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].CIRCLE && segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {
          var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch, projection);

          if ((0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.equals)(closestVertex, vertex) && !componentSegments[uid][0]) {
            this.dragSegments_.push([segmentDataMatch, 0]);
            componentSegments[uid][0] = segmentDataMatch;
          }

          continue;
        }

        if ((0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.equals)(segment[0], vertex) && !componentSegments[uid][0]) {
          this.dragSegments_.push([segmentDataMatch, 0]);
          componentSegments[uid][0] = segmentDataMatch;
          continue;
        }

        if ((0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.equals)(segment[1], vertex) && !componentSegments[uid][1]) {
          // prevent dragging closed linestrings by the connecting node
          if ((segmentDataMatch.geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].LINE_STRING || segmentDataMatch.geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_LINE_STRING) && componentSegments[uid][0] && componentSegments[uid][0].index === 0) {
            continue;
          }

          this.dragSegments_.push([segmentDataMatch, 1]);
          componentSegments[uid][1] = segmentDataMatch;
          continue;
        }

        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_17__.getUid)(segment) in this.vertexSegments_ && !componentSegments[uid][0] && !componentSegments[uid][1] && this.insertVertexCondition_(evt)) {
          insertVertices.push(segmentDataMatch);
        }
      }

      if (insertVertices.length) {
        this.willModifyFeatures_(evt, [insertVertices]);
      }

      for (var j = insertVertices.length - 1; j >= 0; --j) {
        this.insertVertex_(insertVertices[j], vertex);
      }
    }

    return !!this.vertexFeature_;
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */


  Modify.prototype.handleUpEvent = function (evt) {
    for (var i = this.dragSegments_.length - 1; i >= 0; --i) {
      var segmentData = this.dragSegments_[i][0];
      var geometry = segmentData.geometry;

      if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].CIRCLE) {
        // Update a circle object in the R* bush:
        var coordinates = geometry.getCenter();
        var centerSegmentData = segmentData.featureSegments[0];
        var circumferenceSegmentData = segmentData.featureSegments[1];
        centerSegmentData.segment[0] = coordinates;
        centerSegmentData.segment[1] = coordinates;
        circumferenceSegmentData.segment[0] = coordinates;
        circumferenceSegmentData.segment[1] = coordinates;
        this.rBush_.update((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.createOrUpdateFromCoordinate)(coordinates), centerSegmentData);
        var circleGeometry = geometry;
        var userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();

        if (userProjection) {
          var projection = evt.map.getView().getProjection();
          circleGeometry = circleGeometry.clone().transform(userProjection, projection);
          circleGeometry = (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_11__.fromCircle)(circleGeometry).transform(projection, userProjection);
        }

        this.rBush_.update(circleGeometry.getExtent(), circumferenceSegmentData);
      } else {
        this.rBush_.update((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.boundingExtent)(segmentData.segment), segmentData);
      }
    }

    if (this.featuresBeingModified_) {
      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
      this.featuresBeingModified_ = null;
    }

    return false;
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */


  Modify.prototype.handlePointerMove_ = function (evt) {
    this.lastPixel_ = evt.pixel;
    this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);
  };
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../PluggableMap.js").default} map Map.
   * @param {import("../coordinate.js").Coordinate} [opt_coordinate] The pixel Coordinate.
   * @private
   */


  Modify.prototype.handlePointerAtPixel_ = function (pixel, map, opt_coordinate) {
    var _this = this;

    var pixelCoordinate = opt_coordinate || map.getCoordinateFromPixel(pixel);
    var projection = map.getView().getProjection();

    var sortByDistance = function sortByDistance(a, b) {
      return projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) - projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection);
    };
    /** @type {Array<SegmentData>|undefined} */


    var nodes;
    var hitPointGeometry;

    if (this.hitDetection_) {
      var layerFilter = _typeof(this.hitDetection_) === 'object' ? function (layer) {
        return layer === _this.hitDetection_;
      } : undefined;
      map.forEachFeatureAtPixel(pixel, function (feature, layer, geometry) {
        geometry = geometry ||
        /** @type {import("../geom/SimpleGeometry").default} */
        feature.getGeometry();

        if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POINT && (0,_array_js__WEBPACK_IMPORTED_MODULE_18__.includes)(_this.features_.getArray(), feature)) {
          hitPointGeometry = geometry;
          var coordinate = geometry.getFlatCoordinates().slice(0, 2);
          nodes = [{
            feature: feature,
            geometry: geometry,
            segment: [coordinate, coordinate]
          }];
        }

        return true;
      }, {
        layerFilter: layerFilter
      });
    }

    if (!nodes) {
      var viewExtent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.createOrUpdateFromCoordinate)(pixelCoordinate, tempExtent), projection);
      var buffer = map.getView().getResolution() * this.pixelTolerance_;
      var box = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.buffer)(viewExtent, buffer, tempExtent), projection);
      nodes = this.rBush_.getInExtent(box);
    }

    if (nodes && nodes.length > 0) {
      var node = nodes.sort(sortByDistance)[0];
      var closestSegment = node.segment;
      var vertex = closestOnSegmentData(pixelCoordinate, node, projection);
      var vertexPixel = map.getPixelFromCoordinate(vertex);
      var dist = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.distance)(pixel, vertexPixel);

      if (hitPointGeometry || dist <= this.pixelTolerance_) {
        /** @type {Object<string, boolean>} */
        var vertexSegments = {};
        vertexSegments[(0,_util_js__WEBPACK_IMPORTED_MODULE_17__.getUid)(closestSegment)] = true;

        if (!this.snapToPointer_) {
          this.delta_[0] = vertex[0] - pixelCoordinate[0];
          this.delta_[1] = vertex[1] - pixelCoordinate[1];
        }

        if (node.geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].CIRCLE && node.index === CIRCLE_CIRCUMFERENCE_INDEX) {
          this.snappedToVertex_ = true;
          this.createOrUpdateVertexFeature_(vertex, [node.feature], [node.geometry]);
        } else {
          var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
          var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
          var squaredDist1 = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.squaredDistance)(vertexPixel, pixel1);
          var squaredDist2 = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.squaredDistance)(vertexPixel, pixel2);
          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
          this.snappedToVertex_ = dist <= this.pixelTolerance_;

          if (this.snappedToVertex_) {
            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
          }

          this.createOrUpdateVertexFeature_(vertex, [node.feature], [node.geometry]);
          var geometries = {};
          geometries[(0,_util_js__WEBPACK_IMPORTED_MODULE_17__.getUid)(node.geometry)] = true;

          for (var i = 1, ii = nodes.length; i < ii; ++i) {
            var segment = nodes[i].segment;

            if ((0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.equals)(closestSegment[0], segment[0]) && (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.equals)(closestSegment[1], segment[1]) || (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.equals)(closestSegment[0], segment[1]) && (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.equals)(closestSegment[1], segment[0])) {
              var geometryUid = (0,_util_js__WEBPACK_IMPORTED_MODULE_17__.getUid)(nodes[i].geometry);

              if (!(geometryUid in geometries)) {
                geometries[geometryUid] = true;
                vertexSegments[(0,_util_js__WEBPACK_IMPORTED_MODULE_17__.getUid)(segment)] = true;
              }
            } else {
              break;
            }
          }
        }

        this.vertexSegments_ = vertexSegments;
        return;
      }
    }

    if (this.vertexFeature_) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
  };
  /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @private
   */


  Modify.prototype.insertVertex_ = function (segmentData, vertex) {
    var segment = segmentData.segment;
    var feature = segmentData.feature;
    var geometry = segmentData.geometry;
    var depth = segmentData.depth;
    var index = segmentData.index;
    var coordinates;

    while (vertex.length < geometry.getStride()) {
      vertex.push(0);
    }

    switch (geometry.getType()) {
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;

      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;

      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
        break;

      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates.splice(index + 1, 0, vertex);
        break;

      default:
        return;
    }

    this.setGeometryCoordinates_(geometry, coordinates);
    var rTree = this.rBush_;
    rTree.remove(segmentData);
    this.updateSegmentIndices_(geometry, index, depth, 1);
    /** @type {SegmentData} */

    var newSegmentData = {
      segment: [segment[0], vertex],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index
    };
    rTree.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.boundingExtent)(newSegmentData.segment), newSegmentData);
    this.dragSegments_.push([newSegmentData, 1]);
    /** @type {SegmentData} */

    var newSegmentData2 = {
      segment: [vertex, segment[1]],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index + 1
    };
    rTree.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.boundingExtent)(newSegmentData2.segment), newSegmentData2);
    this.dragSegments_.push([newSegmentData2, 0]);
    this.ignoreNextSingleClick_ = true;
  };
  /**
   * Removes the vertex currently being pointed.
   * @return {boolean} True when a vertex was removed.
   * @api
   */


  Modify.prototype.removePoint = function () {
    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_14__["default"].POINTERDRAG) {
      var evt = this.lastPointerEvent_;
      this.willModifyFeatures_(evt, this.dragSegments_);
      var removed = this.removeVertex_();

      if (this.featuresBeingModified_) {
        this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
      }

      this.featuresBeingModified_ = null;
      return removed;
    }

    return false;
  };
  /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */


  Modify.prototype.removeVertex_ = function () {
    var dragSegments = this.dragSegments_;
    var segmentsByFeature = {};
    var deleted = false;
    var component, coordinates, dragSegment, geometry, i, index, left;
    var newIndex, right, segmentData, uid;

    for (i = dragSegments.length - 1; i >= 0; --i) {
      dragSegment = dragSegments[i];
      segmentData = dragSegment[0];
      uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_17__.getUid)(segmentData.feature);

      if (segmentData.depth) {
        // separate feature components
        uid += '-' + segmentData.depth.join('-');
      }

      if (!(uid in segmentsByFeature)) {
        segmentsByFeature[uid] = {};
      }

      if (dragSegment[1] === 0) {
        segmentsByFeature[uid].right = segmentData;
        segmentsByFeature[uid].index = segmentData.index;
      } else if (dragSegment[1] == 1) {
        segmentsByFeature[uid].left = segmentData;
        segmentsByFeature[uid].index = segmentData.index + 1;
      }
    }

    for (uid in segmentsByFeature) {
      right = segmentsByFeature[uid].right;
      left = segmentsByFeature[uid].left;
      index = segmentsByFeature[uid].index;
      newIndex = index - 1;

      if (left !== undefined) {
        segmentData = left;
      } else {
        segmentData = right;
      }

      if (newIndex < 0) {
        newIndex = 0;
      }

      geometry = segmentData.geometry;
      coordinates = geometry.getCoordinates();
      component = coordinates;
      deleted = false;

      switch (geometry.getType()) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_LINE_STRING:
          if (coordinates[segmentData.depth[0]].length > 2) {
            coordinates[segmentData.depth[0]].splice(index, 1);
            deleted = true;
          }

          break;

        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].LINE_STRING:
          if (coordinates.length > 2) {
            coordinates.splice(index, 1);
            deleted = true;
          }

          break;

        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].MULTI_POLYGON:
          component = component[segmentData.depth[1]];

        /* falls through */

        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POLYGON:
          component = component[segmentData.depth[0]];

          if (component.length > 4) {
            if (index == component.length - 1) {
              index = 0;
            }

            component.splice(index, 1);
            deleted = true;

            if (index === 0) {
              // close the ring again
              component.pop();
              component.push(component[0]);
              newIndex = component.length - 1;
            }
          }

          break;

        default: // pass

      }

      if (deleted) {
        this.setGeometryCoordinates_(geometry, coordinates);
        var segments = [];

        if (left !== undefined) {
          this.rBush_.remove(left);
          segments.push(left.segment[0]);
        }

        if (right !== undefined) {
          this.rBush_.remove(right);
          segments.push(right.segment[1]);
        }

        if (left !== undefined && right !== undefined) {
          /** @type {SegmentData} */
          var newSegmentData = {
            depth: segmentData.depth,
            feature: segmentData.feature,
            geometry: segmentData.geometry,
            index: newIndex,
            segment: segments
          };
          this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.boundingExtent)(newSegmentData.segment), newSegmentData);
        }

        this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);

        if (this.vertexFeature_) {
          this.overlay_.getSource().removeFeature(this.vertexFeature_);
          this.vertexFeature_ = null;
        }

        dragSegments.length = 0;
      }
    }

    return deleted;
  };
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */


  Modify.prototype.setGeometryCoordinates_ = function (geometry, coordinates) {
    this.changingFeature_ = true;
    geometry.setCoordinates(coordinates);
    this.changingFeature_ = false;
  };
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */


  Modify.prototype.updateSegmentIndices_ = function (geometry, index, depth, delta) {
    this.rBush_.forEachInExtent(geometry.getExtent(), function (segmentDataMatch) {
      if (segmentDataMatch.geometry === geometry && (depth === undefined || segmentDataMatch.depth === undefined || (0,_array_js__WEBPACK_IMPORTED_MODULE_18__.equals)(segmentDataMatch.depth, depth)) && segmentDataMatch.index > index) {
        segmentDataMatch.index += delta;
      }
    });
  };

  return Modify;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_19__["default"]);
/**
 * @param {SegmentData} a The first segment data.
 * @param {SegmentData} b The second segment data.
 * @return {number} The difference in indexes.
 */


function compareIndexes(a, b) {
  return a.index - b.index;
}
/**
 * Returns the distance from a point to a line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The coordinates of the point from
 *        which to calculate the distance.
 * @param {SegmentData} segmentData The object describing the line
 *        segment we are calculating the distance to.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {number} The square of the distance between a point and a line segment.
 */


function projectedDistanceToSegmentDataSquared(pointCoordinates, segmentData, projection) {
  var geometry = segmentData.geometry;

  if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].CIRCLE) {
    var circleGeometry =
    /** @type {import("../geom/Circle.js").default} */
    geometry;

    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
      var userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();

      if (userProjection) {
        circleGeometry =
        /** @type {import("../geom/Circle.js").default} */
        circleGeometry.clone().transform(userProjection, projection);
      }

      var distanceToCenterSquared = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.squaredDistance)(circleGeometry.getCenter(), (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(pointCoordinates, projection));
      var distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
      return distanceToCircumference * distanceToCircumference;
    }
  }

  var coordinate = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(pointCoordinates, projection);
  tempSegment[0] = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(segmentData.segment[0], projection);
  tempSegment[1] = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(segmentData.segment[1], projection);
  return (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.squaredDistanceToSegment)(coordinate, tempSegment);
}
/**
 * Returns the point closest to a given line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The point to which a closest point
 *        should be found.
 * @param {SegmentData} segmentData The object describing the line
 *        segment which should contain the closest point.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {import("../coordinate.js").Coordinate} The point closest to the specified line segment.
 */


function closestOnSegmentData(pointCoordinates, segmentData, projection) {
  var geometry = segmentData.geometry;

  if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].CIRCLE && segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
    var circleGeometry =
    /** @type {import("../geom/Circle.js").default} */
    geometry;
    var userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();

    if (userProjection) {
      circleGeometry =
      /** @type {import("../geom/Circle.js").default} */
      circleGeometry.clone().transform(userProjection, projection);
    }

    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)(circleGeometry.getClosestPoint((0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(pointCoordinates, projection)), projection);
  }

  var coordinate = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(pointCoordinates, projection);
  tempSegment[0] = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(segmentData.segment[0], projection);
  tempSegment[1] = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(segmentData.segment[1], projection);
  return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)((0,_coordinate_js__WEBPACK_IMPORTED_MODULE_16__.closestOnSegment)(coordinate, tempSegment), projection);
}
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */


function getDefaultStyleFunction() {
  var style = (0,_style_Style_js__WEBPACK_IMPORTED_MODULE_20__.createEditingStyle)();
  return function (feature, resolution) {
    return style[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POINT];
  };
}

/* harmony default export */ __webpack_exports__["default"] = (Modify);

/***/ }),

/***/ "./build/wg/interaction/MouseWheelZoom.js":
/*!************************************************!*\
  !*** ./build/wg/interaction/MouseWheelZoom.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Mode": function() { return /* binding */ Mode; }
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Interaction.js */ "./build/wg/interaction/Interaction.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../has.js */ "./build/wg/has.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/condition.js */ "./build/wg/events/condition.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/MouseWheelZoom
 */







/**
 * @enum {string}
 */

var Mode = {
  TRACKPAD: 'trackpad',
  WHEEL: 'wheel'
};
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:wg/events/condition.always}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {number} [maxDelta=1] Maximum mouse wheel delta.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
 * event will always animate to the closest zoom level after an interaction;
 * false means intermediary zoom levels are allowed.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */

var MouseWheelZoom =
/** @class */
function (_super) {
  __extends(MouseWheelZoom, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function MouseWheelZoom(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this,
    /** @type {import("./Interaction.js").InteractionOptions} */
    options) || this;
    /**
     * @private
     * @type {number}
     */

    _this.totalDelta_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.lastDelta_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    /**
     * @private
     * @type {number}
     */

    _this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
    /**
     * @private
     * @type {boolean}
     */

    _this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;
    /**
     * @private
     * @type {boolean}
     */

    _this.constrainResolution_ = options.constrainResolution !== undefined ? options.constrainResolution : false;
    var condition = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_0__.always;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.onFocusOnly ? (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_0__.all)(_events_condition_js__WEBPACK_IMPORTED_MODULE_0__.focusWithTabindex, condition) : condition;
    /**
     * @private
     * @type {?import("../coordinate.js").Coordinate}
     */

    _this.lastAnchor_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.startTime_ = undefined;
    /**
     * @private
     * @type {?}
     */

    _this.timeoutId_;
    /**
     * @private
     * @type {Mode|undefined}
     */

    _this.mode_ = undefined;
    /**
     * Trackpad events separated by this delay will be considered separate
     * interactions.
     * @type {number}
     */

    _this.trackpadEventGap_ = 400;
    /**
     * @type {?}
     */

    _this.trackpadTimeoutId_;
    /**
     * The number of delta values per zoom level
     * @private
     * @type {number}
     */

    _this.deltaPerZoom_ = 300;
    return _this;
  }
  /**
   * @private
   */


  MouseWheelZoom.prototype.endInteraction_ = function () {
    this.trackpadTimeoutId_ = undefined;
    var view = this.getMap().getView();
    view.endInteraction(undefined, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
  };
  /**
   * Handles the {@link module:wg/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */


  MouseWheelZoom.prototype.handleEvent = function (mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }

    var type = mapBrowserEvent.type;

    if (type !== _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].WHEEL) {
      return true;
    }

    var map = mapBrowserEvent.map;
    var wheelEvent =
    /** @type {WheelEvent} */
    mapBrowserEvent.originalEvent;
    wheelEvent.preventDefault();

    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.coordinate;
    } // Delta normalisation inspired by
    // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js


    var delta;

    if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].WHEEL) {
      delta = wheelEvent.deltaY;

      if (_has_js__WEBPACK_IMPORTED_MODULE_2__.FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= _has_js__WEBPACK_IMPORTED_MODULE_2__.DEVICE_PIXEL_RATIO;
      }

      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    }

    if (delta === 0) {
      return false;
    } else {
      this.lastDelta_ = delta;
    }

    var now = Date.now();

    if (this.startTime_ === undefined) {
      this.startTime_ = now;
    }

    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ? Mode.TRACKPAD : Mode.WHEEL;
    }

    var view = map.getView();

    if (this.mode_ === Mode.TRACKPAD && !(view.getConstrainResolution() || this.constrainResolution_)) {
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }

        view.beginInteraction();
      }

      this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
      this.startTime_ = now;
      return false;
    }

    this.totalDelta_ += delta;
    var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
    return false;
  };
  /**
   * @private
   * @param {import("../PluggableMap.js").default} map Map.
   */


  MouseWheelZoom.prototype.handleWheelZoom_ = function (map) {
    var view = map.getView();

    if (view.getAnimating()) {
      view.cancelAnimations();
    }

    var delta = -(0,_math_js__WEBPACK_IMPORTED_MODULE_3__.clamp)(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;

    if (view.getConstrainResolution() || this.constrainResolution_) {
      // view has a zoom constraint, zoom by 1
      delta = delta ? delta > 0 ? 1 : -1 : 0;
    }

    (0,_Interaction_js__WEBPACK_IMPORTED_MODULE_4__.zoomByDelta)(view, delta, this.lastAnchor_, this.duration_);
    this.mode_ = undefined;
    this.totalDelta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = undefined;
    this.timeoutId_ = undefined;
  };
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */


  MouseWheelZoom.prototype.setMouseAnchor = function (useAnchor) {
    this.useAnchor_ = useAnchor;

    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  };

  return MouseWheelZoom;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (MouseWheelZoom);

/***/ }),

/***/ "./build/wg/interaction/PinchRotate.js":
/*!*********************************************!*\
  !*** ./build/wg/interaction/PinchRotate.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Pointer.js */ "./build/wg/interaction/Pointer.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rotationconstraint.js */ "./build/wg/rotationconstraint.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/PinchRotate
 */





/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */

/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */

var PinchRotate =
/** @class */
function (_super) {
  __extends(PinchRotate, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function PinchRotate(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var pointerOptions =
    /** @type {import("./Pointer.js").Options} */
    options;

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_0__.FALSE;
    }

    _this = _super.call(this, pointerOptions) || this;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */

    _this.anchor_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastAngle_ = undefined;
    /**
     * @private
     * @type {boolean}
     */

    _this.rotating_ = false;
    /**
     * @private
     * @type {number}
     */

    _this.rotationDelta_ = 0.0;
    /**
     * @private
     * @type {number}
     */

    _this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  PinchRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
    var rotationDelta = 0.0;
    var touch0 = this.targetPointers[0];
    var touch1 = this.targetPointers[1]; // angle between touches

    var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);

    if (this.lastAngle_ !== undefined) {
      var delta = angle - this.lastAngle_;
      this.rotationDelta_ += delta;

      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }

      rotationDelta = delta;
    }

    this.lastAngle_ = angle;
    var map = mapBrowserEvent.map;
    var view = map.getView();

    if (view.getConstraints().rotation === _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_1__.disable) {
      return;
    } // rotate anchor point.
    // FIXME: should be the intersection point between the lines:
    //     touch0,touch1 and previousTouch0,previousTouch1


    var viewportPosition = map.getViewport().getBoundingClientRect();
    var centroid = (0,_Pointer_js__WEBPACK_IMPORTED_MODULE_2__.centroid)(this.targetPointers);
    centroid[0] -= viewportPosition.left;
    centroid[1] -= viewportPosition.top;
    this.anchor_ = map.getCoordinateFromPixelInternal(centroid); // rotate

    if (this.rotating_) {
      map.render();
      view.adjustRotationInternal(rotationDelta, this.anchor_);
    }
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  PinchRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    } else {
      return true;
    }
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  PinchRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      var map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = undefined;
      this.rotating_ = false;
      this.rotationDelta_ = 0.0;

      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }

      return true;
    } else {
      return false;
    }
  };

  return PinchRotate;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (PinchRotate);

/***/ }),

/***/ "./build/wg/interaction/PinchZoom.js":
/*!*******************************************!*\
  !*** ./build/wg/interaction/PinchZoom.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Pointer.js */ "./build/wg/interaction/Pointer.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/PinchZoom
 */




/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */

var PinchZoom =
/** @class */
function (_super) {
  __extends(PinchZoom, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function PinchZoom(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var pointerOptions =
    /** @type {import("./Pointer.js").Options} */
    options;

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_0__.FALSE;
    }

    _this = _super.call(this, pointerOptions) || this;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */

    _this.anchor_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 400;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastDistance_ = undefined;
    /**
     * @private
     * @type {number}
     */

    _this.lastScaleDelta_ = 1;
    return _this;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  PinchZoom.prototype.handleDragEvent = function (mapBrowserEvent) {
    var scaleDelta = 1.0;
    var touch0 = this.targetPointers[0];
    var touch1 = this.targetPointers[1];
    var dx = touch0.clientX - touch1.clientX;
    var dy = touch0.clientY - touch1.clientY; // distance between touches

    var distance = Math.sqrt(dx * dx + dy * dy);

    if (this.lastDistance_ !== undefined) {
      scaleDelta = this.lastDistance_ / distance;
    }

    this.lastDistance_ = distance;
    var map = mapBrowserEvent.map;
    var view = map.getView();

    if (scaleDelta != 1.0) {
      this.lastScaleDelta_ = scaleDelta;
    } // scale anchor point.


    var viewportPosition = map.getViewport().getBoundingClientRect();
    var centroid = (0,_Pointer_js__WEBPACK_IMPORTED_MODULE_1__.centroid)(this.targetPointers);
    centroid[0] -= viewportPosition.left;
    centroid[1] -= viewportPosition.top;
    this.anchor_ = map.getCoordinateFromPixelInternal(centroid); // scale, bypass the resolution constraint

    map.render();
    view.adjustResolutionInternal(scaleDelta, this.anchor_);
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  PinchZoom.prototype.handleUpEvent = function (mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction);
      return false;
    } else {
      return true;
    }
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  PinchZoom.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      var map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = undefined;
      this.lastScaleDelta_ = 1;

      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }

      return true;
    } else {
      return false;
    }
  };

  return PinchZoom;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (PinchZoom);

/***/ }),

/***/ "./build/wg/interaction/Pointer.js":
/*!*****************************************!*\
  !*** ./build/wg/interaction/Pointer.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "centroid": function() { return /* binding */ centroid; }
/* harmony export */ });
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Interaction.js */ "./build/wg/interaction/Interaction.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./build/wg/MapBrowserEventType.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/Pointer
 */





/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events.
 * This functions is also called during a drag sequence, so during a drag
 * sequence both the `handleDragEvent` function and this function are called.
 * If `handleDownEvent` is defined and it returns true this function will not
 * be called during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */

/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */

var PointerInteraction =
/** @class */
function (_super) {
  __extends(PointerInteraction, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function PointerInteraction(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this,
    /** @type {import("./Interaction.js").InteractionOptions} */
    options) || this;

    if (options.handleDownEvent) {
      _this.handleDownEvent = options.handleDownEvent;
    }

    if (options.handleDragEvent) {
      _this.handleDragEvent = options.handleDragEvent;
    }

    if (options.handleMoveEvent) {
      _this.handleMoveEvent = options.handleMoveEvent;
    }

    if (options.handleUpEvent) {
      _this.handleUpEvent = options.handleUpEvent;
    }

    if (options.stopDown) {
      _this.stopDown = options.stopDown;
    }
    /**
     * @type {boolean}
     * @protected
     */


    _this.handlingDownUpSequence = false;
    /**
     * @type {!Object<string, PointerEvent>}
     * @private
     */

    _this.trackedPointers_ = {};
    /**
     * @type {Array<PointerEvent>}
     * @protected
     */

    _this.targetPointers = [];
    return _this;
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */


  PointerInteraction.prototype.getPointerCount = function () {
    return this.targetPointers.length;
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */


  PointerInteraction.prototype.handleDownEvent = function (mapBrowserEvent) {
    return false;
  };
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */


  PointerInteraction.prototype.handleDragEvent = function (mapBrowserEvent) {};
  /**
   * Handles the {@link module:wg/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */


  PointerInteraction.prototype.handleEvent = function (mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }

    var stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);

    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent); // prevent page scrolling during dragging

        mapBrowserEvent.originalEvent.preventDefault();
      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERUP) {
        var handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERDOWN) {
        var handled = this.handleDownEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }

    return !stopEvent;
  };
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */


  PointerInteraction.prototype.handleMoveEvent = function (mapBrowserEvent) {};
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */


  PointerInteraction.prototype.handleUpEvent = function (mapBrowserEvent) {
    return false;
  };
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */


  PointerInteraction.prototype.stopDown = function (handled) {
    return handled;
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */


  PointerInteraction.prototype.updateTrackedPointers_ = function (mapBrowserEvent) {
    if (isPointerDraggingEvent(mapBrowserEvent)) {
      var event_1 = mapBrowserEvent.originalEvent;
      var id = event_1.pointerId.toString();

      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERUP) {
        delete this.trackedPointers_[id];
      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERDOWN) {
        this.trackedPointers_[id] = event_1;
      } else if (id in this.trackedPointers_) {
        // update only when there was a pointerdown event for this pointer
        this.trackedPointers_[id] = event_1;
      }

      this.targetPointers = (0,_obj_js__WEBPACK_IMPORTED_MODULE_1__.getValues)(this.trackedPointers_);
    }
  };

  return PointerInteraction;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * @param {Array<PointerEvent>} pointerEvents List of events.
 * @return {import("../pixel.js").Pixel} Centroid pixel.
 */


function centroid(pointerEvents) {
  var length = pointerEvents.length;
  var clientX = 0;
  var clientY = 0;

  for (var i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }

  return [clientX / length, clientY / length];
}
/**
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
 * @return {boolean} Whether the event is a pointerdown, pointerdrag
 *     or pointerup event.
 */

function isPointerDraggingEvent(mapBrowserEvent) {
  var type = mapBrowserEvent.type;
  return type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERDOWN || type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERDRAG || type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERUP;
}

/* harmony default export */ __webpack_exports__["default"] = (PointerInteraction);

/***/ }),

/***/ "./build/wg/interaction/Property.js":
/*!******************************************!*\
  !*** ./build/wg/interaction/Property.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/interaction/Property
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  ACTIVE: 'active'
});

/***/ }),

/***/ "./build/wg/interaction/Select.js":
/*!****************************************!*\
  !*** ./build/wg/interaction/Select.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectEvent": function() { return /* binding */ SelectEvent; }
/* harmony export */ });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Collection.js */ "./build/wg/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../CollectionEventType.js */ "./build/wg/CollectionEventType.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Interaction.js */ "./build/wg/interaction/Interaction.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../layer/Vector.js */ "./build/wg/layer/Vector.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../style/Style.js */ "./build/wg/style/Style.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./build/wg/events/condition.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/Select
 */














/**
 * @enum {string}
 */

var SelectEventType = {
  /**
   * Triggered when feature(s) has been (de)selected.
   * @event SelectEvent#select
   * @api
   */
  SELECT: 'select'
};
/**
 * A function that takes an {@link module:wg/Feature~Feature} or
 * {@link module:wg/render/Feature~RenderFeature} and an
 * {@link module:wg/layer/Layer~Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default<import("../source/Source").default>):boolean} FilterFunction
 */

/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [addCondition] A function
 * that takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:wg/events/condition.never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is the event
 * for the selected features as a whole. By default, this is
 * {@link module:wg/events/condition.singleClick}. Clicking on a feature selects that
 * feature and removes any that were in the selection. Clicking outside any
 * feature removes all from the selection.
 * See `toggle`, `add`, `remove` options for adding/removing extra features to/
 * from the selection.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} [layers]
 * A list of layers from which features should be selected. Alternatively, a
 * filter function can be provided. The function will be called for each layer
 * in the map and should return `true` for layers that you want to be
 * selectable. If the option is absent, all visible layers will be considered
 * selectable.
 * @property {import("../style/Style.js").StyleLike|null} [style]
 * Style for the selected features. By default the default edit style is used
 * (see {@link module:wg/style/Style~Style}). Set to `null` if this interaction should not apply
 * any style changes for selected features.
 * If set to a falsey value, the selected feature's style will not change.
 * @property {import("../events/condition.js").Condition} [removeCondition] A function
 * that takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:wg/events/condition.never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [toggleCondition] A function
 * that takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is in addition
 * to the `condition` event. By default,
 * {@link module:wg/events/condition.shiftKeyOnly}, i.e. pressing `shift` as
 * well as the `condition` event, adds that feature to the current selection if
 * it is not currently selected, and removes it if it is. See `add` and `remove`
 * if you want to use different events instead of a toggle.
 * @property {boolean} [multi=false] A boolean that determines if the default
 * behaviour should select only single features or all (overlapping) features at
 * the clicked map position. The default of `false` means single select.
 * @property {import("../Collection.js").default<import("../Feature.js").default>} [features]
 * Collection where the interaction will place selected features. Optional. If
 * not set the interaction will create a collection. In any case the collection
 * used by the interaction is returned by
 * {@link module:wg/interaction/Select~Select#getFeatures}.
 * @property {FilterFunction} [filter] A function
 * that takes an {@link module:wg/Feature~Feature} and an
 * {@link module:wg/layer/Layer~Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside
 * the radius around the given position will be checked for features.
 */

/**
 * @classdesc
 * Events emitted by {@link module:wg/interaction/Select~Select} instances are instances of
 * this type.
 */

var SelectEvent =
/** @class */
function (_super) {
  __extends(SelectEvent, _super);
  /**
   * @param {SelectEventType} type The event type.
   * @param {Array<import("../Feature.js").default>} selected Selected features.
   * @param {Array<import("../Feature.js").default>} deselected Deselected features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
   *     {@link module:wg/MapBrowserEvent~MapBrowserEvent}.
   */


  function SelectEvent(type, selected, deselected, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    /**
     * Selected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */


    _this.selected = selected;
    /**
     * Deselected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */

    _this.deselected = deselected;
    /**
     * Associated {@link module:wg/MapBrowserEvent~MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */

    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }

  return SelectEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/**
 * Original feature styles to reset to when features are no longer selected.
 * @type {Object<number, import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction>}
 */

var originalFeatureStyles = {};
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'select', SelectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'select', Return>} SelectOnSignature
 */

/**
 * @classdesc
 * Interaction for selecting vector features. By default, selected features are
 * styled differently, so this interaction can be used for visual highlighting,
 * as well as selecting features for other actions, such as modification or
 * output. There are three ways of controlling which features are selected:
 * using the browser event as defined by the `condition` and optionally the
 * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
 * further feature filter using the `filter` option.
 *
 * @fires SelectEvent
 * @api
 */

var Select =
/** @class */
function (_super) {
  __extends(Select, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function Select(opt_options) {
    var _this = _super.call(this) || this;
    /***
     * @type {SelectOnSignature<import("../events").EventsKey>}
     */


    _this.on;
    /***
     * @type {SelectOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {SelectOnSignature<void>}
     */

    _this.un;
    var options = opt_options ? opt_options : {};
    /**
     * @private
     */

    _this.boundAddFeature_ = _this.addFeature_.bind(_this);
    /**
     * @private
     */

    _this.boundRemoveFeature_ = _this.removeFeature_.bind(_this);
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__.singleClick;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.addCondition_ = options.addCondition ? options.addCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__.never;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.removeCondition_ = options.removeCondition ? options.removeCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__.never;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__.shiftKeyOnly;
    /**
     * @private
     * @type {boolean}
     */

    _this.multi_ = options.multi ? options.multi : false;
    /**
     * @private
     * @type {FilterFunction}
     */

    _this.filter_ = options.filter ? options.filter : _functions_js__WEBPACK_IMPORTED_MODULE_2__.TRUE;
    /**
     * @private
     * @type {number}
     */

    _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
    /**
     * @private
     * @type {import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null}
     */

    _this.style_ = options.style !== undefined ? options.style : getDefaultStyleFunction();
    /**
     * @private
     * @type {import("../Collection.js").default}
     */

    _this.features_ = options.features || new _Collection_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
    /** @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} */

    var layerFilter;

    if (options.layers) {
      if (typeof options.layers === 'function') {
        layerFilter = options.layers;
      } else {
        var layers_1 = options.layers;

        layerFilter = function layerFilter(layer) {
          return (0,_array_js__WEBPACK_IMPORTED_MODULE_4__.includes)(layers_1, layer);
        };
      }
    } else {
      layerFilter = _functions_js__WEBPACK_IMPORTED_MODULE_2__.TRUE;
    }
    /**
     * @private
     * @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean}
     */


    _this.layerFilter_ = layerFilter;
    /**
     * An association between selected feature (key)
     * and layer (value)
     * @private
     * @type {Object<string, import("../layer/Layer.js").default>}
     */

    _this.featureLayerAssociation_ = {};
    return _this;
  }
  /**
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {import("../layer/Layer.js").default} layer Layer.
   * @private
   */


  Select.prototype.addFeatureLayerAssociation_ = function (feature, layer) {
    this.featureLayerAssociation_[(0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(feature)] = layer;
  };
  /**
   * Get the selected features.
   * @return {import("../Collection.js").default<import("../Feature.js").default>} Features collection.
   * @api
   */


  Select.prototype.getFeatures = function () {
    return this.features_;
  };
  /**
   * Returns the Hit-detection tolerance.
   * @return {number} Hit tolerance in pixels.
   * @api
   */


  Select.prototype.getHitTolerance = function () {
    return this.hitTolerance_;
  };
  /**
   * Returns the associated {@link module:wg/layer/Vector~VectorLayer vector layer} of
   * a selected feature.
   * @param {import("../Feature.js").FeatureLike} feature Feature
   * @return {import('../layer/Vector.js').default} Layer.
   * @api
   */


  Select.prototype.getLayer = function (feature) {
    return (
      /** @type {import('../layer/Vector.js').default} */
      this.featureLayerAssociation_[(0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(feature)]
    );
  };
  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */


  Select.prototype.setHitTolerance = function (hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  };
  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {import("../PluggableMap.js").default|null} map Map.
   * @api
   */


  Select.prototype.setMap = function (map) {
    var currentMap = this.getMap();

    if (currentMap && this.style_) {
      this.features_.forEach(this.restorePreviousStyle_.bind(this));
    }

    _super.prototype.setMap.call(this, map);

    if (map) {
      this.features_.addEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].ADD, this.boundAddFeature_);
      this.features_.addEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].REMOVE, this.boundRemoveFeature_);

      if (this.style_) {
        this.features_.forEach(this.applySelectedStyle_.bind(this));
      }
    } else {
      this.features_.removeEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].ADD, this.boundAddFeature_);
      this.features_.removeEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].REMOVE, this.boundRemoveFeature_);
    }
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Select.prototype.addFeature_ = function (evt) {
    var feature = evt.element;

    if (this.style_) {
      this.applySelectedStyle_(feature);
    }

    if (!this.getLayer(feature)) {
      var layer =
      /** @type {VectorLayer} */
      this.getMap().getAllLayers().find(function (layer) {
        if (layer instanceof _layer_Vector_js__WEBPACK_IMPORTED_MODULE_7__["default"] && layer.getSource() && layer.getSource().hasFeature(feature)) {
          return layer;
        }
      });

      if (layer) {
        this.addFeatureLayerAssociation_(feature, layer);
      }
    }
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Select.prototype.removeFeature_ = function (evt) {
    var feature = evt.element;

    if (this.style_) {
      this.restorePreviousStyle_(feature);
    }
  };
  /**
   * @return {import("../style/Style.js").StyleLike|null} Select style.
   */


  Select.prototype.getStyle = function () {
    return this.style_;
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */


  Select.prototype.applySelectedStyle_ = function (feature) {
    var key = (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(feature);

    if (!(key in originalFeatureStyles)) {
      originalFeatureStyles[key] = feature.getStyle();
    }

    feature.setStyle(this.style_);
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */


  Select.prototype.restorePreviousStyle_ = function (feature) {
    var interactions = this.getMap().getInteractions().getArray();

    for (var i = interactions.length - 1; i >= 0; --i) {
      var interaction = interactions[i];

      if (interaction !== this && interaction instanceof Select && interaction.getStyle() && interaction.getFeatures().getArray().lastIndexOf(feature) !== -1) {
        feature.setStyle(interaction.getStyle());
        return;
      }
    }

    var key = (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(feature);
    feature.setStyle(originalFeatureStyles[key]);
    delete originalFeatureStyles[key];
  };
  /**
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @private
   */


  Select.prototype.removeFeatureLayerAssociation_ = function (feature) {
    delete this.featureLayerAssociation_[(0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(feature)];
  };
  /**
   * Handles the {@link module:wg/MapBrowserEvent~MapBrowserEvent map browser event} and may change the
   * selected state of features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {Select}
   */


  Select.prototype.handleEvent = function (mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }

    var add = this.addCondition_(mapBrowserEvent);
    var remove = this.removeCondition_(mapBrowserEvent);
    var toggle = this.toggleCondition_(mapBrowserEvent);
    var set = !add && !remove && !toggle;
    var map = mapBrowserEvent.map;
    var features = this.getFeatures();
    var deselected = [];
    var selected = [];

    if (set) {
      // Replace the currently selected feature(s) with the feature(s) at the
      // pixel, or clear the selected feature(s) if there is no feature at
      // the pixel.
      (0,_obj_js__WEBPACK_IMPORTED_MODULE_8__.clear)(this.featureLayerAssociation_);
      map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
      /**
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {import("../layer/Layer.js").default} layer Layer.
       * @return {boolean|undefined} Continue to iterate over the features.
       */
      function (feature, layer) {
        if (this.filter_(feature, layer)) {
          this.addFeatureLayerAssociation_(feature, layer);
          selected.push(feature);
          return !this.multi_;
        }
      }.bind(this), {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });

      for (var i = features.getLength() - 1; i >= 0; --i) {
        var feature = features.item(i);
        var index = selected.indexOf(feature);

        if (index > -1) {
          // feature is already selected
          selected.splice(index, 1);
        } else {
          features.remove(feature);
          deselected.push(feature);
        }
      }

      if (selected.length !== 0) {
        features.extend(selected);
      }
    } else {
      // Modify the currently selected feature(s).
      map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
      /**
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {import("../layer/Layer.js").default} layer Layer.
       * @return {boolean|undefined} Continue to iterate over the features.
       */
      function (feature, layer) {
        if (this.filter_(feature, layer)) {
          if ((add || toggle) && !(0,_array_js__WEBPACK_IMPORTED_MODULE_4__.includes)(features.getArray(), feature)) {
            this.addFeatureLayerAssociation_(feature, layer);
            selected.push(feature);
          } else if ((remove || toggle) && (0,_array_js__WEBPACK_IMPORTED_MODULE_4__.includes)(features.getArray(), feature)) {
            deselected.push(feature);
            this.removeFeatureLayerAssociation_(feature);
          }

          return !this.multi_;
        }
      }.bind(this), {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });

      for (var j = deselected.length - 1; j >= 0; --j) {
        features.remove(deselected[j]);
      }

      features.extend(selected);
    }

    if (selected.length > 0 || deselected.length > 0) {
      this.dispatchEvent(new SelectEvent(SelectEventType.SELECT, selected, deselected, mapBrowserEvent));
    }

    return true;
  };

  return Select;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_9__["default"]);
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */


function getDefaultStyleFunction() {
  var styles = (0,_style_Style_js__WEBPACK_IMPORTED_MODULE_10__.createEditingStyle)();
  (0,_array_js__WEBPACK_IMPORTED_MODULE_4__.extend)(styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].POLYGON], styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].LINE_STRING]);
  (0,_array_js__WEBPACK_IMPORTED_MODULE_4__.extend)(styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].GEOMETRY_COLLECTION], styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_11__["default"].LINE_STRING]);
  return function (feature) {
    if (!feature.getGeometry()) {
      return null;
    }

    return styles[feature.getGeometry().getType()];
  };
}

/* harmony default export */ __webpack_exports__["default"] = (Select);

/***/ }),

/***/ "./build/wg/interaction/Snap.js":
/*!**************************************!*\
  !*** ./build/wg/interaction/Snap.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../CollectionEventType.js */ "./build/wg/CollectionEventType.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Pointer.js */ "./build/wg/interaction/Pointer.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../structs/RBush.js */ "./build/wg/structs/RBush.js");
/* harmony import */ var _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../source/VectorEventType.js */ "./build/wg/source/VectorEventType.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../coordinate.js */ "./build/wg/coordinate.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events.js */ "./build/wg/events.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/Snap
 */
















/**
 * @typedef {Object} Result
 * @property {boolean} snapped Snapped.
 * @property {import("../coordinate.js").Coordinate|null} vertex Vertex.
 * @property {import("../pixel.js").Pixel|null} vertexPixel VertexPixel.
 */

/**
 * @typedef {Object} SegmentData
 * @property {import("../Feature.js").default} feature Feature.
 * @property {Array<import("../coordinate.js").Coordinate>} segment Segment.
 */

/**
 * @typedef {Object} Options
 * @property {import("../Collection.js").default<import("../Feature.js").default>} [features] Snap to these features. Either this option or source should be provided.
 * @property {boolean} [edge=true] Snap to edges.
 * @property {boolean} [vertex=true] Snap to vertices.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or
 * vertex for snapping.
 * @property {import("../source/Vector.js").default} [source] Snap to features from this source. Either this option or features should be provided
 */

/**
 * @param  {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
 * @return {import("../Feature.js").default} Feature.
 */

function getFeatureFromEvent(evt) {
  if (
  /** @type {import("../source/Vector.js").VectorSourceEvent} */
  evt.feature) {
    return (
      /** @type {import("../source/Vector.js").VectorSourceEvent} */
      evt.feature
    );
  } else if (
  /** @type {import("../Collection.js").CollectionEvent} */
  evt.element) {
    return (
      /** @type {import("../Feature.js").default} */

      /** @type {import("../Collection.js").CollectionEvent} */
      evt.element
    );
  }
}

var tempSegment = [];
/**
 * @classdesc
 * Handles snapping of vector features while modifying or drawing them.  The
 * features can come from a {@link module:wg/source/Vector~VectorSource} or {@link module:wg/Collection~Collection}
 * Any interaction object that allows the user to interact
 * with the features using the mouse can benefit from the snapping, as long
 * as it is added before.
 *
 * The snap interaction modifies map browser event `coordinate` and `pixel`
 * properties to force the snap to occur to any interaction that them.
 *
 * Example:
 *
 *     import Snap from 'wg/interaction/Snap';
 *
 *     const snap = new Snap({
 *       source: source
 *     });
 *
 *     map.addInteraction(snap);
 *
 * @api
 */

var Snap =
/** @class */
function (_super) {
  __extends(Snap, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function Snap(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var pointerOptions =
    /** @type {import("./Pointer.js").Options} */
    options;

    if (!pointerOptions.handleDownEvent) {
      pointerOptions.handleDownEvent = _functions_js__WEBPACK_IMPORTED_MODULE_1__.TRUE;
    }

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_1__.FALSE;
    }

    _this = _super.call(this, pointerOptions) || this;
    /**
     * @type {import("../source/Vector.js").default|null}
     * @private
     */

    _this.source_ = options.source ? options.source : null;
    /**
     * @private
     * @type {boolean}
     */

    _this.vertex_ = options.vertex !== undefined ? options.vertex : true;
    /**
     * @private
     * @type {boolean}
     */

    _this.edge_ = options.edge !== undefined ? options.edge : true;
    /**
     * @type {import("../Collection.js").default<import("../Feature.js").default>|null}
     * @private
     */

    _this.features_ = options.features ? options.features : null;
    /**
     * @type {Array<import("../events.js").EventsKey>}
     * @private
     */

    _this.featuresListenerKeys_ = [];
    /**
     * @type {Object<string, import("../events.js").EventsKey>}
     * @private
     */

    _this.featureChangeListenerKeys_ = {};
    /**
     * Extents are preserved so indexed segment can be quickly removed
     * when its feature geometry changes
     * @type {Object<string, import("../extent.js").Extent>}
     * @private
     */

    _this.indexedFeaturesExtents_ = {};
    /**
     * If a feature geometry changes while a pointer drag|move event occurs, the
     * feature doesn't get updated right away.  It will be at the next 'pointerup'
     * event fired.
     * @type {!Object<string, import("../Feature.js").default>}
     * @private
     */

    _this.pendingFeatures_ = {};
    /**
     * @type {number}
     * @private
     */

    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
    /**
     * Segment RTree for each layer
     * @type {import("../structs/RBush.js").default<SegmentData>}
     * @private
     */

    _this.rBush_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
    /**
     * @const
     * @private
     * @type {Object<string, function(import("../Feature.js").default, import("../geom/Geometry.js").default): void>}
     */

    _this.SEGMENT_WRITERS_ = {
      'Point': _this.writePointGeometry_.bind(_this),
      'LineString': _this.writeLineStringGeometry_.bind(_this),
      'LinearRing': _this.writeLineStringGeometry_.bind(_this),
      'Polygon': _this.writePolygonGeometry_.bind(_this),
      'MultiPoint': _this.writeMultiPointGeometry_.bind(_this),
      'MultiLineString': _this.writeMultiLineStringGeometry_.bind(_this),
      'MultiPolygon': _this.writeMultiPolygonGeometry_.bind(_this),
      'GeometryCollection': _this.writeGeometryCollectionGeometry_.bind(_this),
      'Circle': _this.writeCircleGeometry_.bind(_this)
    };
    return _this;
  }
  /**
   * Add a feature to the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {boolean} [opt_listen] Whether to listen to the feature change or not
   *     Defaults to `true`.
   * @api
   */


  Snap.prototype.addFeature = function (feature, opt_listen) {
    var register = opt_listen !== undefined ? opt_listen : true;
    var feature_uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.getUid)(feature);
    var geometry = feature.getGeometry();

    if (geometry) {
      var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];

      if (segmentWriter) {
        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent((0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.createEmpty)());
        segmentWriter(feature, geometry);
      }
    }

    if (register) {
      this.featureChangeListenerKeys_[feature_uid] = (0,_events_js__WEBPACK_IMPORTED_MODULE_5__.listen)(feature, _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, this.handleFeatureChange_, this);
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @private
   */


  Snap.prototype.forEachFeatureAdd_ = function (feature) {
    this.addFeature(feature);
  };
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @private
   */


  Snap.prototype.forEachFeatureRemove_ = function (feature) {
    this.removeFeature(feature);
  };
  /**
   * @return {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} Features.
   * @private
   */


  Snap.prototype.getFeatures_ = function () {
    var features;

    if (this.features_) {
      features = this.features_;
    } else if (this.source_) {
      features = this.source_.getFeatures();
    }

    return features;
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */


  Snap.prototype.handleEvent = function (evt) {
    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);

    if (result.snapped) {
      evt.coordinate = result.vertex.slice(0, 2);
      evt.pixel = result.vertexPixel;
    }

    return _super.prototype.handleEvent.call(this, evt);
  };
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Snap.prototype.handleFeatureAdd_ = function (evt) {
    var feature = getFeatureFromEvent(evt);
    this.addFeature(feature);
  };
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Snap.prototype.handleFeatureRemove_ = function (evt) {
    var feature = getFeatureFromEvent(evt);
    this.removeFeature(feature);
  };
  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */


  Snap.prototype.handleFeatureChange_ = function (evt) {
    var feature =
    /** @type {import("../Feature.js").default} */
    evt.target;

    if (this.handlingDownUpSequence) {
      var uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.getUid)(feature);

      if (!(uid in this.pendingFeatures_)) {
        this.pendingFeatures_[uid] = feature;
      }
    } else {
      this.updateFeature_(feature);
    }
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */


  Snap.prototype.handleUpEvent = function (evt) {
    var featuresToUpdate = (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.getValues)(this.pendingFeatures_);

    if (featuresToUpdate.length) {
      featuresToUpdate.forEach(this.updateFeature_.bind(this));
      this.pendingFeatures_ = {};
    }

    return false;
  };
  /**
   * Remove a feature from the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature
   * @param {boolean} [opt_unlisten] Whether to unlisten to the feature change
   *     or not. Defaults to `true`.
   * @api
   */


  Snap.prototype.removeFeature = function (feature, opt_unlisten) {
    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;
    var feature_uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.getUid)(feature);
    var extent = this.indexedFeaturesExtents_[feature_uid];

    if (extent) {
      var rBush = this.rBush_;
      var nodesToRemove_1 = [];
      rBush.forEachInExtent(extent, function (node) {
        if (feature === node.feature) {
          nodesToRemove_1.push(node);
        }
      });

      for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {
        rBush.remove(nodesToRemove_1[i]);
      }
    }

    if (unregister) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_5__.unlistenByKey)(this.featureChangeListenerKeys_[feature_uid]);
      delete this.featureChangeListenerKeys_[feature_uid];
    }
  };
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */


  Snap.prototype.setMap = function (map) {
    var currentMap = this.getMap();
    var keys = this.featuresListenerKeys_;
    var features =
    /** @type {Array<import("../Feature.js").default>} */
    this.getFeatures_();

    if (currentMap) {
      keys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_5__.unlistenByKey);
      keys.length = 0;
      features.forEach(this.forEachFeatureRemove_.bind(this));
    }

    _super.prototype.setMap.call(this, map);

    if (map) {
      if (this.features_) {
        keys.push((0,_events_js__WEBPACK_IMPORTED_MODULE_5__.listen)(this.features_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].ADD, this.handleFeatureAdd_, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_5__.listen)(this.features_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].REMOVE, this.handleFeatureRemove_, this));
      } else if (this.source_) {
        keys.push((0,_events_js__WEBPACK_IMPORTED_MODULE_5__.listen)(this.source_, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADDFEATURE, this.handleFeatureAdd_, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_5__.listen)(this.source_, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].REMOVEFEATURE, this.handleFeatureRemove_, this));
      }

      features.forEach(this.forEachFeatureAdd_.bind(this));
    }
  };
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../coordinate.js").Coordinate} pixelCoordinate Coordinate
   * @param {import("../PluggableMap.js").default} map Map.
   * @return {Result} Snap result
   */


  Snap.prototype.snapTo = function (pixel, pixelCoordinate, map) {
    var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);
    var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);
    var box = (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.boundingExtent)([lowerLeft, upperRight]);
    var segments = this.rBush_.getInExtent(box); // If snapping on vertices only, don't consider circles

    if (this.vertex_ && !this.edge_) {
      segments = segments.filter(function (segment) {
        return segment.feature.getGeometry().getType() !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_10__["default"].CIRCLE;
      });
    }

    var snapped = false;
    var vertex = null;
    var vertexPixel = null;

    if (segments.length === 0) {
      return {
        snapped: snapped,
        vertex: vertex,
        vertexPixel: vertexPixel
      };
    }

    var projection = map.getView().getProjection();
    var projectedCoordinate = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(pixelCoordinate, projection);
    var closestSegmentData;
    var minSquaredDistance = Infinity;

    for (var i = 0; i < segments.length; ++i) {
      var segmentData = segments[i];
      tempSegment[0] = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(segmentData.segment[0], projection);
      tempSegment[1] = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(segmentData.segment[1], projection);
      var delta = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_11__.squaredDistanceToSegment)(projectedCoordinate, tempSegment);

      if (delta < minSquaredDistance) {
        closestSegmentData = segmentData;
        minSquaredDistance = delta;
      }
    }

    var closestSegment = closestSegmentData.segment;

    if (this.vertex_ && !this.edge_) {
      var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
      var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
      var squaredDist1 = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_11__.squaredDistance)(pixel, pixel1);
      var squaredDist2 = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_11__.squaredDistance)(pixel, pixel2);
      var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));

      if (dist <= this.pixelTolerance_) {
        snapped = true;
        vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
        vertexPixel = map.getPixelFromCoordinate(vertex);
      }
    } else if (this.edge_) {
      var isCircle = closestSegmentData.feature.getGeometry().getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_10__["default"].CIRCLE;

      if (isCircle) {
        var circleGeometry = closestSegmentData.feature.getGeometry();
        var userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();

        if (userProjection) {
          circleGeometry = circleGeometry.clone().transform(userProjection, projection);
        }

        vertex = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)((0,_coordinate_js__WEBPACK_IMPORTED_MODULE_11__.closestOnCircle)(projectedCoordinate,
        /** @type {import("../geom/Circle.js").default} */
        circleGeometry), projection);
      } else {
        tempSegment[0] = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(closestSegment[0], projection);
        tempSegment[1] = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(closestSegment[1], projection);
        vertex = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)((0,_coordinate_js__WEBPACK_IMPORTED_MODULE_11__.closestOnSegment)(projectedCoordinate, tempSegment), projection);
      }

      vertexPixel = map.getPixelFromCoordinate(vertex);

      if ((0,_coordinate_js__WEBPACK_IMPORTED_MODULE_11__.distance)(pixel, vertexPixel) <= this.pixelTolerance_) {
        snapped = true;

        if (this.vertex_ && !isCircle) {
          var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
          var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
          var squaredDist1 = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_11__.squaredDistance)(vertexPixel, pixel1);
          var squaredDist2 = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_11__.squaredDistance)(vertexPixel, pixel2);
          var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));

          if (dist <= this.pixelTolerance_) {
            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
            vertexPixel = map.getPixelFromCoordinate(vertex);
          }
        }
      }
    }

    if (snapped) {
      vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];
    }

    return {
      snapped: snapped,
      vertex: vertex,
      vertexPixel: vertexPixel
    };
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */


  Snap.prototype.updateFeature_ = function (feature) {
    this.removeFeature(feature, false);
    this.addFeature(feature, false);
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeCircleGeometry_ = function (feature, geometry) {
    var projection = this.getMap().getView().getProjection();
    var circleGeometry = geometry;
    var userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();

    if (userProjection) {
      circleGeometry =
      /** @type {import("../geom/Circle.js").default} */
      circleGeometry.clone().transform(userProjection, projection);
    }

    var polygon = (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_12__.fromCircle)(circleGeometry);

    if (userProjection) {
      polygon.transform(projection, userProjection);
    }

    var coordinates = polygon.getCoordinates()[0];

    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = {
        feature: feature,
        segment: segment
      };
      this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.boundingExtent)(segment), segmentData);
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeGeometryCollectionGeometry_ = function (feature, geometry) {
    var geometries = geometry.getGeometriesArray();

    for (var i = 0; i < geometries.length; ++i) {
      var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];

      if (segmentWriter) {
        segmentWriter(feature, geometries[i]);
      }
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeLineStringGeometry_ = function (feature, geometry) {
    var coordinates = geometry.getCoordinates();

    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = {
        feature: feature,
        segment: segment
      };
      this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.boundingExtent)(segment), segmentData);
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeMultiLineStringGeometry_ = function (feature, geometry) {
    var lines = geometry.getCoordinates();

    for (var j = 0, jj = lines.length; j < jj; ++j) {
      var coordinates = lines[j];

      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = {
          feature: feature,
          segment: segment
        };
        this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.boundingExtent)(segment), segmentData);
      }
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeMultiPointGeometry_ = function (feature, geometry) {
    var points = geometry.getCoordinates();

    for (var i = 0, ii = points.length; i < ii; ++i) {
      var coordinates = points[i];
      var segmentData = {
        feature: feature,
        segment: [coordinates, coordinates]
      };
      this.rBush_.insert(geometry.getExtent(), segmentData);
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeMultiPolygonGeometry_ = function (feature, geometry) {
    var polygons = geometry.getCoordinates();

    for (var k = 0, kk = polygons.length; k < kk; ++k) {
      var rings = polygons[k];

      for (var j = 0, jj = rings.length; j < jj; ++j) {
        var coordinates = rings[j];

        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          var segmentData = {
            feature: feature,
            segment: segment
          };
          this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.boundingExtent)(segment), segmentData);
        }
      }
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/Point.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writePointGeometry_ = function (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    var segmentData = {
      feature: feature,
      segment: [coordinates, coordinates]
    };
    this.rBush_.insert(geometry.getExtent(), segmentData);
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writePolygonGeometry_ = function (feature, geometry) {
    var rings = geometry.getCoordinates();

    for (var j = 0, jj = rings.length; j < jj; ++j) {
      var coordinates = rings[j];

      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = {
          feature: feature,
          segment: segment
        };
        this.rBush_.insert((0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.boundingExtent)(segment), segmentData);
      }
    }
  };

  return Snap;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_13__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Snap);

/***/ }),

/***/ "./build/wg/interaction/Translate.js":
/*!*******************************************!*\
  !*** ./build/wg/interaction/Translate.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TranslateEvent": function() { return /* binding */ TranslateEvent; }
/* harmony export */ });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Collection.js */ "./build/wg/Collection.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Property.js */ "./build/wg/interaction/Property.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Pointer.js */ "./build/wg/interaction/Pointer.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/condition.js */ "./build/wg/events/condition.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/interaction/Translate
 */









/**
 * @enum {string}
 */

var TranslateEventType = {
  /**
   * Triggered upon feature translation start.
   * @event TranslateEvent#translatestart
   * @api
   */
  TRANSLATESTART: 'translatestart',

  /**
   * Triggered upon feature translation.
   * @event TranslateEvent#translating
   * @api
   */
  TRANSLATING: 'translating',

  /**
   * Triggered upon feature translation end.
   * @event TranslateEvent#translateend
   * @api
   */
  TRANSLATEEND: 'translateend'
};
/**
 * A function that takes an {@link module:wg/Feature~Feature} or
 * {@link module:wg/render/Feature~RenderFeature} and an
 * {@link module:wg/layer/Layer~Layer} and returns `true` if the feature may be
 * translated or `false` otherwise.
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default<import("../source/Source").default>):boolean} FilterFunction
 */

/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:wg/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:wg/events/condition.always}.
 * @property {Collection<import("../Feature.js").default>} [features] Features contained in this collection will be able to be translated together.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} [layers] A list of layers from which features should be
 * translated. Alternatively, a filter function can be provided. The
 * function will be called for each layer in the map and should return
 * `true` for layers that you want to be translatable. If the option is
 * absent, all visible layers will be considered translatable.
 * Not used if `features` is provided.
 * @property {FilterFunction} [filter] A function
 * that takes an {@link module:wg/Feature~Feature} and an
 * {@link module:wg/layer/Layer~Layer} and returns `true` if the feature may be
 * translated or `false` otherwise. Not used if `features` is provided.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position
 * will be checked for features.
 */

/**
 * @classdesc
 * Events emitted by {@link module:wg/interaction/Translate~Translate} instances
 * are instances of this type.
 */

var TranslateEvent =
/** @class */
function (_super) {
  __extends(TranslateEvent, _super);
  /**
   * @param {TranslateEventType} type Type.
   * @param {Collection<import("../Feature.js").default>} features The features translated.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../coordinate.js").Coordinate} startCoordinate The original coordinates before.translation started
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   */


  function TranslateEvent(type, features, coordinate, startCoordinate, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    /**
     * The features being translated.
     * @type {Collection<import("../Feature.js").default>}
     * @api
     */


    _this.features = features;
    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */

    _this.coordinate = coordinate;
    /**
     * The coordinate of the start position before translation started.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */

    _this.startCoordinate = startCoordinate;
    /**
     * Associated {@link module:wg/MapBrowserEvent~MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */

    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }

  return TranslateEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'translateend'|'translatestart'|'translating', TranslateEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'translateend'|'translatestart'|'translating', Return>} TranslateOnSignature
 */

/**
 * @classdesc
 * Interaction for translating (moving) features.
 * If you want to translate multiple features in a single action (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.
 *
 * @fires TranslateEvent
 * @api
 */

var Translate =
/** @class */
function (_super) {
  __extends(Translate, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function Translate(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this,
    /** @type {import("./Pointer.js").Options} */
    options) || this;
    /***
     * @type {TranslateOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {TranslateOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {TranslateOnSignature<void>}
     */

    _this.un;
    /**
     * The last position we translated to.
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.lastCoordinate_ = null;
    /**
     * The start position before translation started.
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.startCoordinate_ = null;
    /**
     * @type {Collection<import("../Feature.js").default>|null}
     * @private
     */

    _this.features_ = options.features !== undefined ? options.features : null;
    /** @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} */

    var layerFilter;

    if (options.layers && !_this.features_) {
      if (typeof options.layers === 'function') {
        layerFilter = options.layers;
      } else {
        var layers_1 = options.layers;

        layerFilter = function layerFilter(layer) {
          return (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.includes)(layers_1, layer);
        };
      }
    } else {
      layerFilter = _functions_js__WEBPACK_IMPORTED_MODULE_2__.TRUE;
    }
    /**
     * @private
     * @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean}
     */


    _this.layerFilter_ = layerFilter;
    /**
     * @private
     * @type {FilterFunction}
     */

    _this.filter_ = options.filter && !_this.features_ ? options.filter : _functions_js__WEBPACK_IMPORTED_MODULE_2__.TRUE;
    /**
     * @private
     * @type {number}
     */

    _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_3__.always;
    /**
     * @type {import("../Feature.js").default}
     * @private
     */

    _this.lastFeature_ = null;

    _this.addChangeListener(_Property_js__WEBPACK_IMPORTED_MODULE_4__["default"].ACTIVE, _this.handleActiveChanged_);

    return _this;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */


  Translate.prototype.handleDownEvent = function (event) {
    if (!event.originalEvent || !this.condition_(event)) {
      return false;
    }

    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);

    if (!this.lastCoordinate_ && this.lastFeature_) {
      this.startCoordinate_ = event.coordinate;
      this.lastCoordinate_ = event.coordinate;
      this.handleMoveEvent(event);
      var features = this.features_ || new _Collection_js__WEBPACK_IMPORTED_MODULE_5__["default"]([this.lastFeature_]);
      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATESTART, features, event.coordinate, this.startCoordinate_, event));
      return true;
    }

    return false;
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */


  Translate.prototype.handleUpEvent = function (event) {
    if (this.lastCoordinate_) {
      this.lastCoordinate_ = null;
      this.handleMoveEvent(event);
      var features = this.features_ || new _Collection_js__WEBPACK_IMPORTED_MODULE_5__["default"]([this.lastFeature_]);
      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATEEND, features, event.coordinate, this.startCoordinate_, event)); // cleanup

      this.startCoordinate_ = null;
      return true;
    }

    return false;
  };
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */


  Translate.prototype.handleDragEvent = function (event) {
    if (this.lastCoordinate_) {
      var newCoordinate = event.coordinate;
      var deltaX_1 = newCoordinate[0] - this.lastCoordinate_[0];
      var deltaY_1 = newCoordinate[1] - this.lastCoordinate_[1];
      var features = this.features_ || new _Collection_js__WEBPACK_IMPORTED_MODULE_5__["default"]([this.lastFeature_]);
      features.forEach(function (feature) {
        var geom = feature.getGeometry();
        geom.translate(deltaX_1, deltaY_1);
        feature.setGeometry(geom);
      });
      this.lastCoordinate_ = newCoordinate;
      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATING, features, newCoordinate, this.startCoordinate_, event));
    }
  };
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */


  Translate.prototype.handleMoveEvent = function (event) {
    var elem = event.map.getViewport(); // Change the cursor to grab/grabbing if hovering any of the features managed
    // by the interaction

    if (this.featuresAtPixel_(event.pixel, event.map)) {
      elem.classList.remove(this.lastCoordinate_ ? 'wg-grab' : 'wg-grabbing');
      elem.classList.add(this.lastCoordinate_ ? 'wg-grabbing' : 'wg-grab');
    } else {
      elem.classList.remove('wg-grab', 'wg-grabbing');
    }
  };
  /**
   * Tests to see if the given coordinates intersects any of our selected
   * features.
   * @param {import("../pixel.js").Pixel} pixel Pixel coordinate to test for intersection.
   * @param {import("../PluggableMap.js").default} map Map to test the intersection on.
   * @return {import("../Feature.js").default} Returns the feature found at the specified pixel
   * coordinates.
   * @private
   */


  Translate.prototype.featuresAtPixel_ = function (pixel, map) {
    return map.forEachFeatureAtPixel(pixel, function (feature, layer) {
      if (this.filter_(feature, layer)) {
        if (!this.features_ || (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.includes)(this.features_.getArray(), feature)) {
          return feature;
        }
      }
    }.bind(this), {
      layerFilter: this.layerFilter_,
      hitTolerance: this.hitTolerance_
    });
  };
  /**
   * Returns the Hit-detection tolerance.
   * @return {number} Hit tolerance in pixels.
   * @api
   */


  Translate.prototype.getHitTolerance = function () {
    return this.hitTolerance_;
  };
  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */


  Translate.prototype.setHitTolerance = function (hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  };
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */


  Translate.prototype.setMap = function (map) {
    var oldMap = this.getMap();

    _super.prototype.setMap.call(this, map);

    this.updateState_(oldMap);
  };
  /**
   * @private
   */


  Translate.prototype.handleActiveChanged_ = function () {
    this.updateState_(null);
  };
  /**
   * @param {import("../PluggableMap.js").default} oldMap Old map.
   * @private
   */


  Translate.prototype.updateState_ = function (oldMap) {
    var map = this.getMap();
    var active = this.getActive();

    if (!map || !active) {
      map = map || oldMap;

      if (map) {
        var elem = map.getViewport();
        elem.classList.remove('wg-grab', 'wg-grabbing');
      }
    }
  };

  return Translate;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_6__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Translate);

/***/ }),

/***/ "./build/wg/layer/Base.js":
/*!********************************!*\
  !*** ./build/wg/layer/Base.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Object.js */ "./build/wg/Object.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Property.js */ "./build/wg/layer/Property.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/Base
 */








/**
 * A css color, or a function called with a view resolution returning a css color.
 *
 * @typedef {string|function(number):string} BackgroundColor
 * @api
 */

/**
 * @typedef {import("../ObjectEventType").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|
 *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<BaseLayerObjectEventTypes, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='wg-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:wg/layer/Base~BaseLayer} and all its subclasses, any property set in
 * the options is set as a {@link module:wg/Object~BaseObject} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */

var BaseLayer =
/** @class */
function (_super) {
  __extends(BaseLayer, _super);
  /**
   * @param {Options} options Layer options.
   */


  function BaseLayer(options) {
    var _this = _super.call(this) || this;
    /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */


    _this.on;
    /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {BaseLayerOnSignature<void>}
     */

    _this.un;
    /**
     * @type {BackgroundColor|false}
     * @private
     */

    _this.background_ = options.background;
    /**
     * @type {Object<string, *>}
     */

    var properties = (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options);

    if (_typeof(options.properties) === 'object') {
      delete properties.properties;
      (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.assign)(properties, options.properties);
    }

    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPACITY] = options.opacity !== undefined ? options.opacity : 1;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPACITY] === 'number', 64); // Layer opacity must be a number

    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].VISIBLE] = options.visible !== undefined ? options.visible : true;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].Z_INDEX] = options.zIndex;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_ZOOM] = options.minZoom !== undefined ? options.minZoom : -Infinity;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_ZOOM] = options.maxZoom !== undefined ? options.maxZoom : Infinity;
    /**
     * @type {string}
     * @private
     */

    _this.className_ = properties.className !== undefined ? properties.className : 'wg-layer';
    delete properties.className;

    _this.setProperties(properties);
    /**
     * @type {import("./Layer.js").State}
     * @private
     */


    _this.state_ = null;
    return _this;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */


  BaseLayer.prototype.getBackground = function () {
    return this.background_;
  };
  /**
   * @return {string} CSS class name.
   */


  BaseLayer.prototype.getClassName = function () {
    return this.className_;
  };
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [opt_managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */


  BaseLayer.prototype.getLayerState = function (opt_managed) {
    /** @type {import("./Layer.js").State} */
    var state = this.state_ ||
    /** @type {?} */
    {
      layer: this,
      managed: opt_managed === undefined ? true : opt_managed
    };
    var zIndex = this.getZIndex();
    state.opacity = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.clamp)(Math.round(this.getOpacity() * 100) / 100, 0, 1);
    state.visible = this.getVisible();
    state.extent = this.getExtent();
    state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;
    state.maxResolution = this.getMaxResolution();
    state.minResolution = Math.max(this.getMinResolution(), 0);
    state.minZoom = this.getMinZoom();
    state.maxZoom = this.getMaxZoom();
    this.state_ = state;
    return state;
  };
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [opt_array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */


  BaseLayer.prototype.getLayersArray = function (opt_array) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  };
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [opt_states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */


  BaseLayer.prototype.getLayerStatesArray = function (opt_states) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  };
  /**
   * Return the {@link module:wg/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */


  BaseLayer.prototype.getExtent = function () {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].EXTENT)
    );
  };
  /**
   * Return the maximum resolution of the layer.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getMaxResolution = function () {
    return (
      /** @type {number} */
      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_RESOLUTION)
    );
  };
  /**
   * Return the minimum resolution of the layer.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getMinResolution = function () {
    return (
      /** @type {number} */
      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_RESOLUTION)
    );
  };
  /**
   * Return the minimum zoom level of the layer.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getMinZoom = function () {
    return (
      /** @type {number} */
      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_ZOOM)
    );
  };
  /**
   * Return the maximum zoom level of the layer.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getMaxZoom = function () {
    return (
      /** @type {number} */
      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_ZOOM)
    );
  };
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getOpacity = function () {
    return (
      /** @type {number} */
      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPACITY)
    );
  };
  /**
   * @abstract
   * @return {import("../source/State.js").default} Source state.
   */


  BaseLayer.prototype.getSourceState = function () {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  };
  /**
   * Return the visibility of the layer (`true` or `false`).
   * @return {boolean} The visibility of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getVisible = function () {
    return (
      /** @type {boolean} */
      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].VISIBLE)
    );
  };
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. The default Z-index is 0.
   * @return {number} The Z-index of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getZIndex = function () {
    return (
      /** @type {number} */
      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].Z_INDEX)
    );
  };
  /**
   * Sets the background color.
   * @param {BackgroundColor} [opt_background] Background color.
   */


  BaseLayer.prototype.setBackground = function (opt_background) {
    this.background_ = opt_background;
    this.changed();
  };
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setExtent = function (extent) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].EXTENT, extent);
  };
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setMaxResolution = function (maxResolution) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_RESOLUTION, maxResolution);
  };
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setMinResolution = function (minResolution) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_RESOLUTION, minResolution);
  };
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setMaxZoom = function (maxZoom) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_ZOOM, maxZoom);
  };
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setMinZoom = function (minZoom) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_ZOOM, minZoom);
  };
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setOpacity = function (opacity) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof opacity === 'number', 64); // Layer opacity must be a number

    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPACITY, opacity);
  };
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setVisible = function (visible) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].VISIBLE, visible);
  };
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setZIndex = function (zindex) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].Z_INDEX, zindex);
  };
  /**
   * Clean up.
   */


  BaseLayer.prototype.disposeInternal = function () {
    if (this.state_) {
      this.state_.layer = null;
      this.state_ = null;
    }

    _super.prototype.disposeInternal.call(this);
  };

  return BaseLayer;
}(_Object_js__WEBPACK_IMPORTED_MODULE_5__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (BaseLayer);

/***/ }),

/***/ "./build/wg/layer/BaseImage.js":
/*!*************************************!*\
  !*** ./build/wg/layer/BaseImage.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layer.js */ "./build/wg/layer/Layer.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/BaseImage
 */



/**
 * @template {import("../source/Image.js").default} ImageSourceType
 * @typedef {Object} Options
 * @property {string} [className='wg-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../PluggableMap.js").default#addLayer map.addLayer()}.
 * @property {ImageSourceType} [source] Source for this layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:wg/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Image.js").default} ImageSourceType
 * @template {import("../renderer/Layer.js").default} RendererType
 * @extends {Layer<ImageSourceType, RendererType>}
 * @api
 */

var BaseImageLayer =
/** @class */
function (_super) {
  __extends(BaseImageLayer, _super);
  /**
   * @param {Options<ImageSourceType>} [opt_options] Layer options.
   */


  function BaseImageLayer(opt_options) {
    var options = opt_options ? opt_options : {};
    return _super.call(this, options) || this;
  }

  return BaseImageLayer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (BaseImageLayer);

/***/ }),

/***/ "./build/wg/layer/BaseTile.js":
/*!************************************!*\
  !*** ./build/wg/layer/BaseTile.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Layer.js */ "./build/wg/layer/Layer.js");
/* harmony import */ var _TileProperty_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileProperty.js */ "./build/wg/layer/TileProperty.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/BaseTile
 */





/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:source'|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
 *   'change:source'|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature
 */

/**
 * @template {import("../source/Tile.js").default} TileSourceType
 * @typedef {Object} Options
 * @property {string} [className='wg-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {TileSourceType} [source] Source for this layer.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../PluggableMap.js").default#addLayer map.addLayer()}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:wg/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @template {import("../renderer/Layer.js").default} RendererType
 * @extends {Layer<TileSourceType, RendererType>}
 * @api
 */

var BaseTileLayer =
/** @class */
function (_super) {
  __extends(BaseTileLayer, _super);
  /**
   * @param {Options<TileSourceType>} [opt_options] Tile layer options.
   */


  function BaseTileLayer(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var baseOptions = (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    _this = _super.call(this, baseOptions) || this;
    /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {BaseTileLayerOnSignature<void>}
     */

    _this.un;

    _this.setPreload(options.preload !== undefined ? options.preload : 0);

    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);

    return _this;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */


  BaseTileLayer.prototype.getPreload = function () {
    return (
      /** @type {number} */
      this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].PRELOAD)
    );
  };
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */


  BaseTileLayer.prototype.setPreload = function (preload) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].PRELOAD, preload);
  };
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */


  BaseTileLayer.prototype.getUseInterimTilesOnError = function () {
    return (
      /** @type {boolean} */
      this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_INTERIM_TILES_ON_ERROR)
    );
  };
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */


  BaseTileLayer.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */


  BaseTileLayer.prototype.getData = function (pixel) {
    return _super.prototype.getData.call(this, pixel);
  };

  return BaseTileLayer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (BaseTileLayer);

/***/ }),

/***/ "./build/wg/layer/BaseVector.js":
/*!**************************************!*\
  !*** ./build/wg/layer/BaseVector.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Layer.js */ "./build/wg/layer/Layer.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/rbush.min.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../style/Style.js */ "./build/wg/style/Style.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/BaseVector
 */






/**
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @typedef {Object} Options
 * @property {string} [className='wg-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../PluggableMap.js").default#addLayer map.addLayer()}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 *
 * As an optimization decluttered features from layers with the same `className` are rendered above
 * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this
 * behavior and place declutterd features with their own layer configure the layer with a `className`
 * other than `ol-layer`.
 * @property {import("../style/Style.js").StyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:wg/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @enum {string}
 * @private
 */

var Property = {
  RENDER_ORDER: 'renderOrder'
};
/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:wg/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @template {import("../renderer/canvas/VectorLayer.js").default|import("../renderer/canvas/VectorTileLayer.js").default|import("../renderer/canvas/VectorImageLayer.js").default|import("../renderer/webgl/PointsLayer.js").default} RendererType
 * @extends {Layer<VectorSourceType, RendererType>}
 * @api
 */

var BaseVectorLayer =
/** @class */
function (_super) {
  __extends(BaseVectorLayer, _super);
  /**
   * @param {Options<VectorSourceType>} [opt_options] Options.
   */


  function BaseVectorLayer(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var baseOptions = (0,_obj_js__WEBPACK_IMPORTED_MODULE_1__.assign)({}, options);
    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    _this = _super.call(this, baseOptions) || this;
    /**
     * @private
     * @type {boolean}
     */

    _this.declutter_ = options.declutter !== undefined ? options.declutter : false;
    /**
     * @type {number}
     * @private
     */

    _this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;
    /**
     * User provided style.
     * @type {import("../style/Style.js").StyleLike}
     * @private
     */

    _this.style_ = null;
    /**
     * Style function for use within the library.
     * @type {import("../style/Style.js").StyleFunction|undefined}
     * @private
     */

    _this.styleFunction_ = undefined;

    _this.setStyle(options.style);
    /**
     * @type {boolean}
     * @private
     */


    _this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;
    /**
     * @type {boolean}
     * @private
     */

    _this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;
    return _this;
  }
  /**
   * @return {boolean} Declutter.
   */


  BaseVectorLayer.prototype.getDeclutter = function () {
    return this.declutter_;
  };
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in {@link import("../PluggableMap.js").default#getFeaturesAtPixel}: Text
   * is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
   * @api
   */


  BaseVectorLayer.prototype.getFeatures = function (pixel) {
    return _super.prototype.getFeatures.call(this, pixel);
  };
  /**
   * @return {number|undefined} Render buffer.
   */


  BaseVectorLayer.prototype.getRenderBuffer = function () {
    return this.renderBuffer_;
  };
  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */


  BaseVectorLayer.prototype.getRenderOrder = function () {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(Property.RENDER_ORDER)
    );
  };
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
   * @api
   */


  BaseVectorLayer.prototype.getStyle = function () {
    return this.style_;
  };
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */


  BaseVectorLayer.prototype.getStyleFunction = function () {
    return this.styleFunction_;
  };
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */


  BaseVectorLayer.prototype.getUpdateWhileAnimating = function () {
    return this.updateWhileAnimating_;
  };
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */


  BaseVectorLayer.prototype.getUpdateWhileInteracting = function () {
    return this.updateWhileInteracting_;
  };
  /**
   * Render declutter items for this layer
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  BaseVectorLayer.prototype.renderDeclutter = function (frameState) {
    if (!frameState.declutterTree) {
      frameState.declutterTree = new rbush__WEBPACK_IMPORTED_MODULE_0__(9);
    }
    /** @type {*} */


    this.getRenderer().renderDeclutter(frameState);
  };
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */


  BaseVectorLayer.prototype.setRenderOrder = function (renderOrder) {
    this.set(Property.RENDER_ORDER, renderOrder);
  };
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * {@link module:wg/style/Style~Style} for information on the default style.
   * @param {import("../style/Style.js").StyleLike|null} [opt_style] Layer style.
   * @api
   */


  BaseVectorLayer.prototype.setStyle = function (opt_style) {
    this.style_ = opt_style !== undefined ? opt_style : _style_Style_js__WEBPACK_IMPORTED_MODULE_2__.createDefaultStyle;
    this.styleFunction_ = opt_style === null ? undefined : (0,_style_Style_js__WEBPACK_IMPORTED_MODULE_2__.toFunction)(this.style_);
    this.changed();
  };

  return BaseVectorLayer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (BaseVectorLayer);

/***/ }),

/***/ "./build/wg/layer/Graticule.js":
/*!*************************************!*\
  !*** ./build/wg/layer/Graticule.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Collection.js */ "./build/wg/Collection.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../render/EventType.js */ "./build/wg/render/EventType.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _style_Fill_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../style/Fill.js */ "./build/wg/style/Fill.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../geom/LineString.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _style_Stroke_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../style/Stroke.js */ "./build/wg/style/Stroke.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style/Style.js */ "./build/wg/style/Style.js");
/* harmony import */ var _style_Text_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../style/Text.js */ "./build/wg/style/Text.js");
/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Vector.js */ "./build/wg/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../source/Vector.js */ "./build/wg/source/Vector.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../coordinate.js */ "./build/wg/coordinate.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _render_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../render.js */ "./build/wg/render.js");
/* harmony import */ var _geom_flat_geodesic_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../geom/flat/geodesic.js */ "./build/wg/geom/flat/geodesic.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/Graticule
 */





















/**
 * @type {Stroke}
 * @private
 * @const
 */

var DEFAULT_STROKE_STYLE = new _style_Stroke_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
  color: 'rgba(0,0,0,0.2)'
});
/**
 * @type {Array<number>}
 * @private
 */

var INTERVALS = [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001];
/**
 * @typedef {Object} GraticuleLabelDataType
 * @property {Point} geom Geometry.
 * @property {string} text Text.
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='wg-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [maxLines=100] The maximum number of meridians and
 * parallels from the center of the map. The default value of 100 means that at
 * most 200 meridians and 200 parallels will be displayed. The default value is
 * appropriate for conformal projections like Spherical Mercator. If you
 * increase the value, more lines will be drawn and the drawing performance will
 * decrease.
 * @property {Stroke} [strokeStyle] The
 * stroke style to use for drawing the graticule. If not provided, the following stroke will be used:
 * ```js
 * new Stroke({
 *   color: 'rgba(0, 0, 0, 0.2)' // a not fully opaque black
 * });
 * ```
 * @property {number} [targetSize=100] The target size of the graticule cells,
 * in pixels.
 * @property {boolean} [showLabels=false] Render a label with the respective
 * latitude/longitude for each graticule line.
 * @property {function(number):string} [lonLabelFormatter] Label formatter for
 * longitudes. This function is called with the longitude as argument, and
 * should return a formatted string representing the longitude. By default,
 * labels are formatted as degrees, minutes, seconds and hemisphere.
 * @property {function(number):string} [latLabelFormatter] Label formatter for
 * latitudes. This function is called with the latitude as argument, and
 * should return a formatted string representing the latitude. By default,
 * labels are formatted as degrees, minutes, seconds and hemisphere.
 * @property {number} [lonLabelPosition=0] Longitude label position in fractions
 * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the
 * top.
 * @property {number} [latLabelPosition=1] Latitude label position in fractions
 * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the
 * right.
 * @property {Text} [lonLabelStyle] Longitude label text
 * style. If not provided, the following style will be used:
 * ```js
 * new Text({
 *   font: '12px Calibri,sans-serif',
 *   textBaseline: 'bottom',
 *   fill: new Fill({
 *     color: 'rgba(0,0,0,1)'
 *   }),
 *   stroke: new Stroke({
 *     color: 'rgba(255,255,255,1)',
 *     width: 3
 *   })
 * });
 * ```
 * Note that the default's `textBaseline` configuration will not work well for
 * `lonLabelPosition` configurations that position labels close to the top of
 * the viewport.
 * @property {Text} [latLabelStyle] Latitude label text style.
 * If not provided, the following style will be used:
 * ```js
 * new Text({
 *   font: '12px Calibri,sans-serif',
 *   textAlign: 'end',
 *   fill: new Fill({
 *     color: 'rgba(0,0,0,1)'
 *   }),
 *   stroke: Stroke({
 *     color: 'rgba(255,255,255,1)',
 *     width: 3
 *   })
 * });
 * ```
 * Note that the default's `textAlign` configuration will not work well for
 * `latLabelPosition` configurations that position labels close to the left of
 * the viewport.
 * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001]]
 * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:
 * ```js
 * [30, 10]
 * ```
 * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).
 * Note that the view projection must define both extent and worldExtent.
 *
 * @fires import("../render/Event.js").RenderEvent
 * @extends {VectorLayer<import("../source/Vector.js").default>}
 * @api
 */

var Graticule =
/** @class */
function (_super) {
  __extends(Graticule, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function Graticule(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var baseOptions = (0,_obj_js__WEBPACK_IMPORTED_MODULE_2__.assign)({
      updateWhileAnimating: true,
      updateWhileInteracting: true,
      renderBuffer: 0
    }, options);
    delete baseOptions.maxLines;
    delete baseOptions.strokeStyle;
    delete baseOptions.targetSize;
    delete baseOptions.showLabels;
    delete baseOptions.lonLabelFormatter;
    delete baseOptions.latLabelFormatter;
    delete baseOptions.lonLabelPosition;
    delete baseOptions.latLabelPosition;
    delete baseOptions.lonLabelStyle;
    delete baseOptions.latLabelStyle;
    delete baseOptions.intervals;
    _this = _super.call(this, baseOptions) || this;
    /**
     * @type {import("../proj/Projection.js").default}
     */

    _this.projection_ = null;
    /**
     * @type {number}
     * @private
     */

    _this.maxLat_ = Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.maxLon_ = Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.minLat_ = -Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.minLon_ = -Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.maxX_ = Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.maxY_ = Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.minX_ = -Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.minY_ = -Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.targetSize_ = options.targetSize !== undefined ? options.targetSize : 100;
    /**
     * @type {number}
     * @private
     */

    _this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;
    /**
     * @type {Array<LineString>}
     * @private
     */

    _this.meridians_ = [];
    /**
     * @type {Array<LineString>}
     * @private
     */

    _this.parallels_ = [];
    /**
     * @type {Stroke}
     * @private
     */

    _this.strokeStyle_ = options.strokeStyle !== undefined ? options.strokeStyle : DEFAULT_STROKE_STYLE;
    /**
     * @type {import("../proj.js").TransformFunction|undefined}
     * @private
     */

    _this.fromLonLatTransform_ = undefined;
    /**
     * @type {import("../proj.js").TransformFunction|undefined}
     * @private
     */

    _this.toLonLatTransform_ = undefined;
    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.projectionCenterLonLat_ = null;
    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.bottomLeft_ = null;
    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.bottomRight_ = null;
    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.topLeft_ = null;
    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.topRight_ = null;
    /**
     * @type {Array<GraticuleLabelDataType>}
     * @private
     */

    _this.meridiansLabels_ = null;
    /**
     * @type {Array<GraticuleLabelDataType>}
     * @private
     */

    _this.parallelsLabels_ = null;

    if (options.showLabels) {
      /**
       * @type {null|function(number):string}
       * @private
       */
      _this.lonLabelFormatter_ = options.lonLabelFormatter == undefined ? _coordinate_js__WEBPACK_IMPORTED_MODULE_3__.degreesToStringHDMS.bind(_this, 'EW') : options.lonLabelFormatter;
      /**
       * @type {function(number):string}
       * @private
       */

      _this.latLabelFormatter_ = options.latLabelFormatter == undefined ? _coordinate_js__WEBPACK_IMPORTED_MODULE_3__.degreesToStringHDMS.bind(_this, 'NS') : options.latLabelFormatter;
      /**
       * Longitude label position in fractions (0..1) of view extent. 0 means
       * bottom, 1 means top.
       * @type {number}
       * @private
       */

      _this.lonLabelPosition_ = options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;
      /**
       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1
       * means right.
       * @type {number}
       * @private
       */

      _this.latLabelPosition_ = options.latLabelPosition == undefined ? 1 : options.latLabelPosition;
      /**
       * @type {Style}
       * @private
       */

      _this.lonLabelStyleBase_ = new _style_Style_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        text: options.lonLabelStyle !== undefined ? options.lonLabelStyle.clone() : new _style_Text_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
          font: '12px Calibri,sans-serif',
          textBaseline: 'bottom',
          fill: new _style_Fill_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
            color: 'rgba(0,0,0,1)'
          }),
          stroke: new _style_Stroke_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
            color: 'rgba(255,255,255,1)',
            width: 3
          })
        })
      });
      /**
       * @private
       * @param {import("../Feature").default} feature Feature
       * @return {Style} style
       */

      _this.lonLabelStyle_ = function (feature) {
        var label = feature.get('graticule_label');
        this.lonLabelStyleBase_.getText().setText(label);
        return this.lonLabelStyleBase_;
      }.bind(_this);
      /**
       * @type {Style}
       * @private
       */


      _this.latLabelStyleBase_ = new _style_Style_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        text: options.latLabelStyle !== undefined ? options.latLabelStyle.clone() : new _style_Text_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
          font: '12px Calibri,sans-serif',
          textAlign: 'right',
          fill: new _style_Fill_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
            color: 'rgba(0,0,0,1)'
          }),
          stroke: new _style_Stroke_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
            color: 'rgba(255,255,255,1)',
            width: 3
          })
        })
      });
      /**
       * @private
       * @param {import("../Feature").default} feature Feature
       * @return {Style} style
       */

      _this.latLabelStyle_ = function (feature) {
        var label = feature.get('graticule_label');
        this.latLabelStyleBase_.getText().setText(label);
        return this.latLabelStyleBase_;
      }.bind(_this);

      _this.meridiansLabels_ = [];
      _this.parallelsLabels_ = [];

      _this.addEventListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].POSTRENDER, _this.drawLabels_.bind(_this));
    }
    /**
     * @type {Array<number>}
     * @private
     */


    _this.intervals_ = options.intervals !== undefined ? options.intervals : INTERVALS; // use a source with a custom loader for lines & text

    _this.setSource(new _source_Vector_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
      loader: _this.loaderFunction.bind(_this),
      strategy: _this.strategyFunction.bind(_this),
      features: new _Collection_js__WEBPACK_IMPORTED_MODULE_9__["default"](),
      overlaps: false,
      useSpatialIndex: false,
      wrapX: options.wrapX
    }));
    /**
     * feature pool to use when updating graticule
     * @type {Array<Feature>}
     * @private
     */


    _this.featurePool_ = [];
    /**
     * @type {Style}
     * @private
     */

    _this.lineStyle_ = new _style_Style_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
      stroke: _this.strokeStyle_
    });
    /**
     * @type {?import("../extent.js").Extent}
     * @private
     */

    _this.loadedExtent_ = null;
    /**
     * @type {?import("../extent.js").Extent}
     * @private
     */

    _this.renderedExtent_ = null;
    /**
     * @type {?number}
     * @private
     */

    _this.renderedResolution_ = null;

    _this.setRenderOrder(null);

    return _this;
  }
  /**
   * Strategy function for loading features based on the view's extent and
   * resolution.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @return {Array<import("../extent.js").Extent>} Extents.
   */


  Graticule.prototype.strategyFunction = function (extent, resolution) {
    // extents may be passed in different worlds, to avoid endless loop we use only one
    var realWorldExtent = extent.slice();

    if (this.projection_ && this.getSource().getWrapX()) {
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.wrapX)(realWorldExtent, this.projection_);
    }

    if (this.loadedExtent_) {
      if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.approximatelyEquals)(this.loadedExtent_, realWorldExtent, resolution)) {
        // make sure result is exactly equal to previous extent
        realWorldExtent = this.loadedExtent_.slice();
      } else {
        // we should not keep track of loaded extents
        this.getSource().removeLoadedExtent(this.loadedExtent_);
      }
    }

    return [realWorldExtent];
  };
  /**
   * Update geometries in the source based on current view
   * @param {import("../extent").Extent} extent Extent
   * @param {number} resolution Resolution
   * @param {import("../proj/Projection.js").default} projection Projection
   */


  Graticule.prototype.loaderFunction = function (extent, resolution, projection) {
    this.loadedExtent_ = extent;
    var source = this.getSource(); // only consider the intersection between our own extent & the requested one

    var layerExtent = this.getExtent() || [-Infinity, -Infinity, Infinity, Infinity];
    var renderExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.getIntersection)(layerExtent, extent);

    if (this.renderedExtent_ && (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.equals)(this.renderedExtent_, renderExtent) && this.renderedResolution_ === resolution) {
      return;
    }

    this.renderedExtent_ = renderExtent;
    this.renderedResolution_ = resolution; // bail out if nothing to render

    if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.isEmpty)(renderExtent)) {
      return;
    } // update projection info


    var center = (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.getCenter)(renderExtent);
    var squaredTolerance = resolution * resolution / 4;
    var updateProjectionInfo = !this.projection_ || !(0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(this.projection_, projection);

    if (updateProjectionInfo) {
      this.updateProjectionInfo_(projection);
    }

    this.createGraticule_(renderExtent, center, resolution, squaredTolerance); // first make sure we have enough features in the pool

    var featureCount = this.meridians_.length + this.parallels_.length;

    if (this.meridiansLabels_) {
      featureCount += this.meridians_.length;
    }

    if (this.parallelsLabels_) {
      featureCount += this.parallels_.length;
    }

    var feature;

    while (featureCount > this.featurePool_.length) {
      feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_11__["default"]();
      this.featurePool_.push(feature);
    }

    var featuresColl = source.getFeaturesCollection();
    featuresColl.clear();
    var poolIndex = 0; // add features for the lines & labels

    var i, l;

    for (i = 0, l = this.meridians_.length; i < l; ++i) {
      feature = this.featurePool_[poolIndex++];
      feature.setGeometry(this.meridians_[i]);
      feature.setStyle(this.lineStyle_);
      featuresColl.push(feature);
    }

    for (i = 0, l = this.parallels_.length; i < l; ++i) {
      feature = this.featurePool_[poolIndex++];
      feature.setGeometry(this.parallels_[i]);
      feature.setStyle(this.lineStyle_);
      featuresColl.push(feature);
    }
  };
  /**
   * @param {number} lon Longitude.
   * @param {number} minLat Minimal latitude.
   * @param {number} maxLat Maximal latitude.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} index Index.
   * @return {number} Index.
   * @private
   */


  Graticule.prototype.addMeridian_ = function (lon, minLat, maxLat, squaredTolerance, extent, index) {
    var lineString = this.getMeridian_(lon, minLat, maxLat, squaredTolerance, index);

    if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.intersects)(lineString.getExtent(), extent)) {
      if (this.meridiansLabels_) {
        var text = this.lonLabelFormatter_(lon);

        if (index in this.meridiansLabels_) {
          this.meridiansLabels_[index].text = text;
        } else {
          this.meridiansLabels_[index] = {
            geom: new _geom_Point_js__WEBPACK_IMPORTED_MODULE_12__["default"]([]),
            text: text
          };
        }
      }

      this.meridians_[index++] = lineString;
    }

    return index;
  };
  /**
   * @param {number} lat Latitude.
   * @param {number} minLon Minimal longitude.
   * @param {number} maxLon Maximal longitude.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} index Index.
   * @return {number} Index.
   * @private
   */


  Graticule.prototype.addParallel_ = function (lat, minLon, maxLon, squaredTolerance, extent, index) {
    var lineString = this.getParallel_(lat, minLon, maxLon, squaredTolerance, index);

    if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.intersects)(lineString.getExtent(), extent)) {
      if (this.parallelsLabels_) {
        var text = this.latLabelFormatter_(lat);

        if (index in this.parallelsLabels_) {
          this.parallelsLabels_[index].text = text;
        } else {
          this.parallelsLabels_[index] = {
            geom: new _geom_Point_js__WEBPACK_IMPORTED_MODULE_12__["default"]([]),
            text: text
          };
        }
      }

      this.parallels_[index++] = lineString;
    }

    return index;
  };
  /**
   * @param {import("../render/Event.js").default} event Render event.
   * @private
   */


  Graticule.prototype.drawLabels_ = function (event) {
    var rotation = event.frameState.viewState.rotation;
    var resolution = event.frameState.viewState.resolution;
    var size = event.frameState.size;
    var extent = event.frameState.extent;
    var rotationCenter = (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.getCenter)(extent);
    var rotationExtent = extent;

    if (rotation) {
      var unrotatedWidth = size[0] * resolution;
      var unrotatedHeight = size[1] * resolution;
      rotationExtent = [rotationCenter[0] - unrotatedWidth / 2, rotationCenter[1] - unrotatedHeight / 2, rotationCenter[0] + unrotatedWidth / 2, rotationCenter[1] + unrotatedHeight / 2];
    }

    var startWorld = 0;
    var endWorld = 0;
    var labelsAtStart = this.latLabelPosition_ < 0.5;
    var projectionExtent = this.projection_.getExtent();
    var worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.getWidth)(projectionExtent);

    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.containsExtent)(projectionExtent, extent)) {
      startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);
      endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);
      var inverted = Math.abs(rotation) > Math.PI / 2;
      labelsAtStart = labelsAtStart !== inverted;
    }

    var vectorContext = (0,_render_js__WEBPACK_IMPORTED_MODULE_13__.getVectorContext)(event);

    for (var world = startWorld; world <= endWorld; ++world) {
      var poolIndex = this.meridians_.length + this.parallels_.length;
      var feature = void 0,
          index = void 0,
          l = void 0,
          textPoint = void 0;

      if (this.meridiansLabels_) {
        for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {
          var lineString = this.meridians_[index];

          if (!rotation && world === 0) {
            textPoint = this.getMeridianPoint_(lineString, extent, index);
          } else {
            var clone = lineString.clone();
            clone.translate(world * worldWidth, 0);
            clone.rotate(-rotation, rotationCenter);
            textPoint = this.getMeridianPoint_(clone, rotationExtent, index);
            textPoint.rotate(rotation, rotationCenter);
          }

          feature = this.featurePool_[poolIndex++];
          feature.setGeometry(textPoint);
          feature.set('graticule_label', this.meridiansLabels_[index].text);
          vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));
        }
      }

      if (this.parallelsLabels_) {
        if (world === startWorld && labelsAtStart || world === endWorld && !labelsAtStart) {
          for (index = 0, l = this.parallels_.length; index < l; ++index) {
            var lineString = this.parallels_[index];

            if (!rotation && world === 0) {
              textPoint = this.getParallelPoint_(lineString, extent, index);
            } else {
              var clone = lineString.clone();
              clone.translate(world * worldWidth, 0);
              clone.rotate(-rotation, rotationCenter);
              textPoint = this.getParallelPoint_(clone, rotationExtent, index);
              textPoint.rotate(rotation, rotationCenter);
            }

            feature = this.featurePool_[poolIndex++];
            feature.setGeometry(textPoint);
            feature.set('graticule_label', this.parallelsLabels_[index].text);
            vectorContext.drawFeature(feature, this.latLabelStyle_(feature));
          }
        }
      }
    }
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} squaredTolerance Squared tolerance.
   * @private
   */


  Graticule.prototype.createGraticule_ = function (extent, center, resolution, squaredTolerance) {
    var interval = this.getInterval_(resolution);

    if (interval == -1) {
      this.meridians_.length = 0;
      this.parallels_.length = 0;

      if (this.meridiansLabels_) {
        this.meridiansLabels_.length = 0;
      }

      if (this.parallelsLabels_) {
        this.parallelsLabels_.length = 0;
      }

      return;
    }

    var wrapX = false;
    var projectionExtent = this.projection_.getExtent();
    var worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.getWidth)(projectionExtent);

    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.containsExtent)(projectionExtent, extent)) {
      if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.getWidth)(extent) >= worldWidth) {
        extent[0] = projectionExtent[0];
        extent[2] = projectionExtent[2];
      } else {
        wrapX = true;
      }
    } // Constrain the center to fit into the extent available to the graticule


    var validCenterP = [(0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(center[0], this.minX_, this.maxX_), (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(center[1], this.minY_, this.maxY_)]; // Transform the center to lon lat
    // Some projections may have a void area at the poles
    // so replace any NaN latitudes with the min or max value closest to a pole

    var centerLonLat = this.toLonLatTransform_(validCenterP);

    if (isNaN(centerLonLat[1])) {
      centerLonLat[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;
    }

    var centerLon = (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(centerLonLat[0], this.minLon_, this.maxLon_);
    var centerLat = (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(centerLonLat[1], this.minLat_, this.maxLat_);
    var maxLines = this.maxLines_;
    var cnt, idx, lat, lon; // Limit the extent to fit into the extent available to the graticule

    var validExtentP = extent;

    if (!wrapX) {
      validExtentP = [(0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(extent[0], this.minX_, this.maxX_), (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(extent[1], this.minY_, this.maxY_), (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(extent[2], this.minX_, this.maxX_), (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(extent[3], this.minY_, this.maxY_)];
    } // Transform the extent to get the lon lat ranges for the edges of the extent


    var validExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.applyTransform)(validExtentP, this.toLonLatTransform_, undefined, 8);
    var maxLat = validExtent[3];
    var maxLon = validExtent[2];
    var minLat = validExtent[1];
    var minLon = validExtent[0];

    if (!wrapX) {
      // Check if extremities of the world extent lie inside the extent
      // (for example the pole in a polar projection)
      // and extend the extent as appropriate
      if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.containsCoordinate)(validExtentP, this.bottomLeft_)) {
        minLon = this.minLon_;
        minLat = this.minLat_;
      }

      if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.containsCoordinate)(validExtentP, this.bottomRight_)) {
        maxLon = this.maxLon_;
        minLat = this.minLat_;
      }

      if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.containsCoordinate)(validExtentP, this.topLeft_)) {
        minLon = this.minLon_;
        maxLat = this.maxLat_;
      }

      if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.containsCoordinate)(validExtentP, this.topRight_)) {
        maxLon = this.maxLon_;
        maxLat = this.maxLat_;
      } // The transformed center may also extend the lon lat ranges used for rendering


      maxLat = (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(maxLat, centerLat, this.maxLat_);
      maxLon = (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(maxLon, centerLon, this.maxLon_);
      minLat = (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(minLat, this.minLat_, centerLat);
      minLon = (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(minLon, this.minLon_, centerLon);
    } // Create meridians


    centerLon = Math.floor(centerLon / interval) * interval;
    lon = (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(centerLon, this.minLon_, this.maxLon_);
    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);
    cnt = 0;

    if (wrapX) {
      while ((lon -= interval) >= minLon && cnt++ < maxLines) {
        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
      }
    } else {
      while (lon != this.minLon_ && cnt++ < maxLines) {
        lon = Math.max(lon - interval, this.minLon_);
        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
      }
    }

    lon = (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(centerLon, this.minLon_, this.maxLon_);
    cnt = 0;

    if (wrapX) {
      while ((lon += interval) <= maxLon && cnt++ < maxLines) {
        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
      }
    } else {
      while (lon != this.maxLon_ && cnt++ < maxLines) {
        lon = Math.min(lon + interval, this.maxLon_);
        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
      }
    }

    this.meridians_.length = idx;

    if (this.meridiansLabels_) {
      this.meridiansLabels_.length = idx;
    } // Create parallels


    centerLat = Math.floor(centerLat / interval) * interval;
    lat = (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(centerLat, this.minLat_, this.maxLat_);
    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);
    cnt = 0;

    while (lat != this.minLat_ && cnt++ < maxLines) {
      lat = Math.max(lat - interval, this.minLat_);
      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);
    }

    lat = (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(centerLat, this.minLat_, this.maxLat_);
    cnt = 0;

    while (lat != this.maxLat_ && cnt++ < maxLines) {
      lat = Math.min(lat + interval, this.maxLat_);
      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);
    }

    this.parallels_.length = idx;

    if (this.parallelsLabels_) {
      this.parallelsLabels_.length = idx;
    }
  };
  /**
   * @param {number} resolution Resolution.
   * @return {number} The interval in degrees.
   * @private
   */


  Graticule.prototype.getInterval_ = function (resolution) {
    var centerLon = this.projectionCenterLonLat_[0];
    var centerLat = this.projectionCenterLonLat_[1];
    var interval = -1;
    var target = Math.pow(this.targetSize_ * resolution, 2);
    /** @type {Array<number>} **/

    var p1 = [];
    /** @type {Array<number>} **/

    var p2 = [];

    for (var i = 0, ii = this.intervals_.length; i < ii; ++i) {
      var delta = (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(this.intervals_[i] / 2, 0, 90); // Don't attempt to transform latitudes beyond the poles!

      var clampedLat = (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(centerLat, -90 + delta, 90 - delta);
      p1[0] = centerLon - delta;
      p1[1] = clampedLat - delta;
      p2[0] = centerLon + delta;
      p2[1] = clampedLat + delta;
      this.fromLonLatTransform_(p1, p1);
      this.fromLonLatTransform_(p2, p2);
      var dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);

      if (dist <= target) {
        break;
      }

      interval = this.intervals_[i];
    }

    return interval;
  };
  /**
   * @param {number} lon Longitude.
   * @param {number} minLat Minimal latitude.
   * @param {number} maxLat Maximal latitude.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} The meridian line string.
   * @param {number} index Index.
   * @private
   */


  Graticule.prototype.getMeridian_ = function (lon, minLat, maxLat, squaredTolerance, index) {
    var flatCoordinates = (0,_geom_flat_geodesic_js__WEBPACK_IMPORTED_MODULE_15__.meridian)(lon, minLat, maxLat, this.projection_, squaredTolerance);
    var lineString = this.meridians_[index];

    if (!lineString) {
      lineString = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_16__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_17__["default"].XY);
      this.meridians_[index] = lineString;
    } else {
      lineString.setFlatCoordinates(_geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_17__["default"].XY, flatCoordinates);
      lineString.changed();
    }

    return lineString;
  };
  /**
   * @param {LineString} lineString Meridian
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} index Index.
   * @return {Point} Meridian point.
   * @private
   */


  Graticule.prototype.getMeridianPoint_ = function (lineString, extent, index) {
    var flatCoordinates = lineString.getFlatCoordinates();
    var bottom = 1;
    var top = flatCoordinates.length - 1;

    if (flatCoordinates[bottom] > flatCoordinates[top]) {
      bottom = top;
      top = 1;
    }

    var clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);
    var clampedTop = Math.min(extent[3], flatCoordinates[top]);
    var lat = (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_, clampedBottom, clampedTop);
    var coordinate0 = flatCoordinates[bottom - 1] + (flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) * (lat - flatCoordinates[bottom]) / (flatCoordinates[top] - flatCoordinates[bottom]);
    var coordinate = [coordinate0, lat];
    var point = this.meridiansLabels_[index].geom;
    point.setCoordinates(coordinate);
    return point;
  };
  /**
   * Get the list of meridians.  Meridians are lines of equal longitude.
   * @return {Array<LineString>} The meridians.
   * @api
   */


  Graticule.prototype.getMeridians = function () {
    return this.meridians_;
  };
  /**
   * @param {number} lat Latitude.
   * @param {number} minLon Minimal longitude.
   * @param {number} maxLon Maximal longitude.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} The parallel line string.
   * @param {number} index Index.
   * @private
   */


  Graticule.prototype.getParallel_ = function (lat, minLon, maxLon, squaredTolerance, index) {
    var flatCoordinates = (0,_geom_flat_geodesic_js__WEBPACK_IMPORTED_MODULE_15__.parallel)(lat, minLon, maxLon, this.projection_, squaredTolerance);
    var lineString = this.parallels_[index];

    if (!lineString) {
      lineString = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_16__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_17__["default"].XY);
    } else {
      lineString.setFlatCoordinates(_geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_17__["default"].XY, flatCoordinates);
      lineString.changed();
    }

    return lineString;
  };
  /**
   * @param {LineString} lineString Parallels.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} index Index.
   * @return {Point} Parallel point.
   * @private
   */


  Graticule.prototype.getParallelPoint_ = function (lineString, extent, index) {
    var flatCoordinates = lineString.getFlatCoordinates();
    var left = 0;
    var right = flatCoordinates.length - 2;

    if (flatCoordinates[left] > flatCoordinates[right]) {
      left = right;
      right = 0;
    }

    var clampedLeft = Math.max(extent[0], flatCoordinates[left]);
    var clampedRight = Math.min(extent[2], flatCoordinates[right]);
    var lon = (0,_math_js__WEBPACK_IMPORTED_MODULE_14__.clamp)(extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_, clampedLeft, clampedRight);
    var coordinate1 = flatCoordinates[left + 1] + (flatCoordinates[right + 1] - flatCoordinates[left + 1]) * (lon - flatCoordinates[left]) / (flatCoordinates[right] - flatCoordinates[left]);
    var coordinate = [lon, coordinate1];
    var point = this.parallelsLabels_[index].geom;
    point.setCoordinates(coordinate);
    return point;
  };
  /**
   * Get the list of parallels.  Parallels are lines of equal latitude.
   * @return {Array<LineString>} The parallels.
   * @api
   */


  Graticule.prototype.getParallels = function () {
    return this.parallels_;
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @private
   */


  Graticule.prototype.updateProjectionInfo_ = function (projection) {
    var epsg4326Projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:4326');
    var worldExtent = projection.getWorldExtent();
    this.maxLat_ = worldExtent[3];
    this.maxLon_ = worldExtent[2];
    this.minLat_ = worldExtent[1];
    this.minLon_ = worldExtent[0]; // If the world extent crosses the dateline define a custom transform to
    // return longitudes which wrap the dateline

    var toLonLatTransform = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(projection, epsg4326Projection);

    if (this.minLon_ < this.maxLon_) {
      this.toLonLatTransform_ = toLonLatTransform;
    } else {
      var split_1 = this.minLon_ + this.maxLon_ / 2;
      this.maxLon_ += 360;

      this.toLonLatTransform_ = function (coordinates, opt_output, opt_dimension) {
        var dimension = opt_dimension || 2;
        var lonLatCoordinates = toLonLatTransform(coordinates, opt_output, dimension);

        for (var i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {
          if (lonLatCoordinates[i] < split_1) {
            lonLatCoordinates[i] += 360;
          }
        }

        return lonLatCoordinates;
      };
    } // Transform the extent to get the limits of the view projection extent
    // which should be available to the graticule


    this.fromLonLatTransform_ = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(epsg4326Projection, projection);
    var worldExtentP = (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.applyTransform)([this.minLon_, this.minLat_, this.maxLon_, this.maxLat_], this.fromLonLatTransform_, undefined, 8);
    this.minX_ = worldExtentP[0];
    this.maxX_ = worldExtentP[2];
    this.minY_ = worldExtentP[1];
    this.maxY_ = worldExtentP[3]; // Determine the view projection coordinates of the extremities of the world extent
    // as these may lie inside a view extent (for example the pole in a polar projection)

    this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);
    this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);
    this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);
    this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]); // Transform the projection center to lon lat
    // Some projections may have a void area at the poles
    // so replace any NaN latitudes with the min or max value closest to a pole

    this.projectionCenterLonLat_ = this.toLonLatTransform_((0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.getCenter)(projection.getExtent()));

    if (isNaN(this.projectionCenterLonLat_[1])) {
      this.projectionCenterLonLat_[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;
    }

    this.projection_ = projection;
  };

  return Graticule;
}(_Vector_js__WEBPACK_IMPORTED_MODULE_18__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Graticule);

/***/ }),

/***/ "./build/wg/layer/Group.js":
/*!*********************************!*\
  !*** ./build/wg/layer/Group.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GroupEvent": function() { return /* binding */ GroupEvent; }
/* harmony export */ });
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Base.js */ "./build/wg/layer/Base.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Collection.js */ "./build/wg/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../CollectionEventType.js */ "./build/wg/CollectionEventType.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../ObjectEventType.js */ "./build/wg/ObjectEventType.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../source/State.js */ "./build/wg/source/State.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./build/wg/events.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/Group
 */














/**
 * @typedef {'addlayer'|'removelayer'} EventType
 */

/**
 * @classdesc
 * A layer group triggers 'addlayer' and 'removelayer' events when layers are added to or removed from
 * the group or one of its child groups.  When a layer group is added to or removed from another layer group,
 * a single event will be triggered (instead of one per layer in the group added or removed).
 */

var GroupEvent =
/** @class */
function (_super) {
  __extends(GroupEvent, _super);
  /**
   * @param {EventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */


  function GroupEvent(type, layer) {
    var _this = _super.call(this, type) || this;
    /**
     * The added or removed layer.
     * @type {BaseLayer}
     * @api
     */


    _this.layer = layer;
    return _this;
  }

  return GroupEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:layers', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:layers', Return>} GroupOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<import("./Base.js").default>|import("../Collection.js").default<import("./Base.js").default>} [layers] Child layers.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @enum {string}
 * @private
 */

var Property = {
  LAYERS: 'layers'
};
/**
 * @classdesc
 * A {@link module:wg/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */

var LayerGroup =
/** @class */
function (_super) {
  __extends(LayerGroup, _super);
  /**
   * @param {Options} [opt_options] Layer options.
   */


  function LayerGroup(opt_options) {
    var _this = this;

    var options = opt_options || {};
    var baseOptions =
    /** @type {Options} */
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_1__.assign)({}, options);
    delete baseOptions.layers;
    var layers = options.layers;
    _this = _super.call(this, baseOptions) || this;
    /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {GroupOnSignature<void>}
     */

    _this.un;
    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */

    _this.layersListenerKeys_ = [];
    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */

    _this.listenerKeys_ = {};

    _this.addChangeListener(Property.LAYERS, _this.handleLayersChanged_);

    if (layers) {
      if (Array.isArray(layers)) {
        layers = new _Collection_js__WEBPACK_IMPORTED_MODULE_2__["default"](layers.slice(), {
          unique: true
        });
      } else {
        (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(typeof
        /** @type {?} */
        layers.getArray === 'function', 43); // Expected `layers` to be an array or a `Collection`
      }
    } else {
      layers = new _Collection_js__WEBPACK_IMPORTED_MODULE_2__["default"](undefined, {
        unique: true
      });
    }

    _this.setLayers(layers);

    return _this;
  }
  /**
   * @private
   */


  LayerGroup.prototype.handleLayerChange_ = function () {
    this.changed();
  };
  /**
   * @private
   */


  LayerGroup.prototype.handleLayersChanged_ = function () {
    this.layersListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__.unlistenByKey);
    this.layersListenerKeys_.length = 0;
    var layers = this.getLayers();
    this.layersListenerKeys_.push((0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(layers, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].ADD, this.handleLayersAdd_, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(layers, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].REMOVE, this.handleLayersRemove_, this));

    for (var id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__.unlistenByKey);
    }

    (0,_obj_js__WEBPACK_IMPORTED_MODULE_1__.clear)(this.listenerKeys_);
    var layersArray = layers.getArray();

    for (var i = 0, ii = layersArray.length; i < ii; i++) {
      var layer = layersArray[i];
      this.registerLayerListeners_(layer);
      this.dispatchEvent(new GroupEvent('addlayer', layer));
    }

    this.changed();
  };
  /**
   * @param {BaseLayer} layer The layer.
   */


  LayerGroup.prototype.registerLayerListeners_ = function (layer) {
    var listenerKeys = [(0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(layer, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].PROPERTYCHANGE, this.handleLayerChange_, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(layer, _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, this.handleLayerChange_, this)];

    if (layer instanceof LayerGroup) {
      listenerKeys.push((0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(layer, 'addlayer', this.handleLayerGroupAdd_, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(layer, 'removelayer', this.handleLayerGroupRemove_, this));
    }

    this.listenerKeys_[(0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(layer)] = listenerKeys;
  };
  /**
   * @param {GroupEvent} event The layer group event.
   */


  LayerGroup.prototype.handleLayerGroupAdd_ = function (event) {
    this.dispatchEvent(new GroupEvent('addlayer', event.layer));
  };
  /**
   * @param {GroupEvent} event The layer group event.
   */


  LayerGroup.prototype.handleLayerGroupRemove_ = function (event) {
    this.dispatchEvent(new GroupEvent('removelayer', event.layer));
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
   * @private
   */


  LayerGroup.prototype.handleLayersAdd_ = function (collectionEvent) {
    var layer =
    /** @type {import("./Base.js").default} */
    collectionEvent.element;
    this.registerLayerListeners_(layer);
    this.dispatchEvent(new GroupEvent('addlayer', layer));
    this.changed();
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
   * @private
   */


  LayerGroup.prototype.handleLayersRemove_ = function (collectionEvent) {
    var layer =
    /** @type {import("./Base.js").default} */
    collectionEvent.element;
    var key = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(layer);
    this.listenerKeys_[key].forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__.unlistenByKey);
    delete this.listenerKeys_[key];
    this.dispatchEvent(new GroupEvent('removelayer', layer));
    this.changed();
  };
  /**
   * Returns the {@link module:wg/Collection~Collection collection} of {@link module:wg/layer/Layer~Layer layers}
   * in this group.
   * @return {!import("../Collection.js").default<import("./Base.js").default>} Collection of
   *   {@link module:wg/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */


  LayerGroup.prototype.getLayers = function () {
    return (
      /** @type {!import("../Collection.js").default<import("./Base.js").default>} */
      this.get(Property.LAYERS)
    );
  };
  /**
   * Set the {@link module:wg/Collection~Collection collection} of {@link module:wg/layer/Layer~Layer layers}
   * in this group.
   * @param {!import("../Collection.js").default<import("./Base.js").default>} layers Collection of
   *   {@link module:wg/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */


  LayerGroup.prototype.setLayers = function (layers) {
    var collection = this.getLayers();

    if (collection) {
      var currentLayers = collection.getArray();

      for (var i = 0, ii = currentLayers.length; i < ii; ++i) {
        this.dispatchEvent(new GroupEvent('removelayer', currentLayers[i]));
      }
    }

    this.set(Property.LAYERS, layers);
  };
  /**
   * @param {Array<import("./Layer.js").default>} [opt_array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */


  LayerGroup.prototype.getLayersArray = function (opt_array) {
    var array = opt_array !== undefined ? opt_array : [];
    this.getLayers().forEach(function (layer) {
      layer.getLayersArray(array);
    });
    return array;
  };
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If opt_states is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [opt_states] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */


  LayerGroup.prototype.getLayerStatesArray = function (opt_states) {
    var states = opt_states !== undefined ? opt_states : [];
    var pos = states.length;
    this.getLayers().forEach(function (layer) {
      layer.getLayerStatesArray(states);
    });
    var ownLayerState = this.getLayerState();
    var defaultZIndex = ownLayerState.zIndex;

    if (!opt_states && ownLayerState.zIndex === undefined) {
      defaultZIndex = 0;
    }

    for (var i = pos, ii = states.length; i < ii; i++) {
      var layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
      layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);

      if (ownLayerState.extent !== undefined) {
        if (layerState.extent !== undefined) {
          layerState.extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_9__.getIntersection)(layerState.extent, ownLayerState.extent);
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }

      if (layerState.zIndex === undefined) {
        layerState.zIndex = defaultZIndex;
      }
    }

    return states;
  };
  /**
   * @return {import("../source/State.js").default} Source state.
   */


  LayerGroup.prototype.getSourceState = function () {
    return _source_State_js__WEBPACK_IMPORTED_MODULE_10__["default"].READY;
  };

  return LayerGroup;
}(_Base_js__WEBPACK_IMPORTED_MODULE_11__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (LayerGroup);

/***/ }),

/***/ "./build/wg/layer/Heatmap.js":
/*!***********************************!*\
  !*** ./build/wg/layer/Heatmap.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BaseVector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BaseVector.js */ "./build/wg/layer/BaseVector.js");
/* harmony import */ var _renderer_webgl_PointsLayer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/webgl/PointsLayer.js */ "./build/wg/renderer/webgl/PointsLayer.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom.js */ "./build/wg/dom.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/Heatmap
 */







/**
 * @typedef {Object} Options
 * @property {string} [className='wg-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<string>} [gradient=['#00f', '#0ff', '#0f0', '#ff0', '#f00']] The color gradient
 * of the heatmap, specified as an array of CSS color strings.
 * @property {number} [radius=8] Radius size in pixels.
 * @property {number} [blur=15] Blur size in pixels.
 * @property {string|function(import("../Feature.js").default):number} [weight='weight'] The feature
 * attribute to use for the weight or a function that returns a weight from a feature. Weight values
 * should range from 0 to 1 (and values outside will be clamped to that range).
 * @property {import("../source/Vector.js").default<import("../geom/Point.js").default>} [source] Point source.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @enum {string}
 * @private
 */

var Property = {
  BLUR: 'blur',
  GRADIENT: 'gradient',
  RADIUS: 'radius'
};
/**
 * @const
 * @type {Array<string>}
 */

var DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];
/**
 * @classdesc
 * Layer for rendering vector data as a heatmap.
 * Note that any property set in the options is set as a {@link module:wg/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @fires import("../render/Event.js").RenderEvent
 * @extends {BaseVector<import("../source/Vector.js").default, WebGLPointsLayerRenderer>}
 * @api
 */

var Heatmap =
/** @class */
function (_super) {
  __extends(Heatmap, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function Heatmap(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var baseOptions = (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options);
    delete baseOptions.gradient;
    delete baseOptions.radius;
    delete baseOptions.blur;
    delete baseOptions.weight;
    _this = _super.call(this, baseOptions) || this;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.gradient_ = null;

    _this.addChangeListener(Property.GRADIENT, _this.handleGradientChanged_);

    _this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);

    _this.setBlur(options.blur !== undefined ? options.blur : 15);

    _this.setRadius(options.radius !== undefined ? options.radius : 8);

    var weight = options.weight ? options.weight : 'weight';

    if (typeof weight === 'string') {
      _this.weightFunction_ = function (feature) {
        return feature.get(weight);
      };
    } else {
      _this.weightFunction_ = weight;
    } // For performance reasons, don't sort the features before rendering.
    // The render order is not relevant for a heatmap representation.


    _this.setRenderOrder(null);

    return _this;
  }
  /**
   * Return the blur size in pixels.
   * @return {number} Blur size in pixels.
   * @api
   * @observable
   */


  Heatmap.prototype.getBlur = function () {
    return (
      /** @type {number} */
      this.get(Property.BLUR)
    );
  };
  /**
   * Return the gradient colors as array of strings.
   * @return {Array<string>} Colors.
   * @api
   * @observable
   */


  Heatmap.prototype.getGradient = function () {
    return (
      /** @type {Array<string>} */
      this.get(Property.GRADIENT)
    );
  };
  /**
   * Return the size of the radius in pixels.
   * @return {number} Radius size in pixel.
   * @api
   * @observable
   */


  Heatmap.prototype.getRadius = function () {
    return (
      /** @type {number} */
      this.get(Property.RADIUS)
    );
  };
  /**
   * @private
   */


  Heatmap.prototype.handleGradientChanged_ = function () {
    this.gradient_ = createGradient(this.getGradient());
  };
  /**
   * Set the blur size in pixels.
   * @param {number} blur Blur size in pixels.
   * @api
   * @observable
   */


  Heatmap.prototype.setBlur = function (blur) {
    this.set(Property.BLUR, blur);
  };
  /**
   * Set the gradient colors as array of strings.
   * @param {Array<string>} colors Gradient.
   * @api
   * @observable
   */


  Heatmap.prototype.setGradient = function (colors) {
    this.set(Property.GRADIENT, colors);
  };
  /**
   * Set the size of the radius in pixels.
   * @param {number} radius Radius size in pixel.
   * @api
   * @observable
   */


  Heatmap.prototype.setRadius = function (radius) {
    this.set(Property.RADIUS, radius);
  };

  Heatmap.prototype.createRenderer = function () {
    return new _renderer_webgl_PointsLayer_js__WEBPACK_IMPORTED_MODULE_1__["default"](this, {
      className: this.getClassName(),
      attributes: [{
        name: 'weight',
        callback: function (feature) {
          var weight = this.weightFunction_(feature);
          return weight !== undefined ? (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(weight, 0, 1) : 1;
        }.bind(this)
      }],
      vertexShader: "\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_weight = a_weight;\n        }",
      fragmentShader: "\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\n        }",
      hitVertexShader: "\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n        attribute vec4 a_hitColor;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_hitColor = a_hitColor;\n          v_weight = a_weight;\n        }",
      hitFragmentShader: "\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          if (alpha < 0.05) {\n            discard;\n          }\n\n          gl_FragColor = v_hitColor;\n        }",
      uniforms: {
        u_size: function () {
          return (this.get(Property.RADIUS) + this.get(Property.BLUR)) * 2;
        }.bind(this),
        u_blurSlope: function () {
          return this.get(Property.RADIUS) / Math.max(1, this.get(Property.BLUR));
        }.bind(this)
      },
      postProcesses: [{
        fragmentShader: "\n            precision mediump float;\n\n            uniform sampler2D u_image;\n            uniform sampler2D u_gradientTexture;\n            uniform float u_opacity;\n\n            varying vec2 v_texCoord;\n\n            void main() {\n              vec4 color = texture2D(u_image, v_texCoord);\n              gl_FragColor.a = color.a * u_opacity;\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\n              gl_FragColor.rgb *= gl_FragColor.a;\n            }",
        uniforms: {
          u_gradientTexture: function () {
            return this.gradient_;
          }.bind(this),
          u_opacity: function () {
            return this.getOpacity();
          }.bind(this)
        }
      }]
    });
  };

  Heatmap.prototype.renderDeclutter = function () {};

  return Heatmap;
}(_BaseVector_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * @param {Array<string>} colors A list of colored.
 * @return {HTMLCanvasElement} canvas with gradient texture.
 */


function createGradient(colors) {
  var width = 1;
  var height = 256;
  var context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_4__.createCanvasContext2D)(width, height);
  var gradient = context.createLinearGradient(0, 0, width, height);
  var step = 1 / (colors.length - 1);

  for (var i = 0, ii = colors.length; i < ii; ++i) {
    gradient.addColorStop(i * step, colors[i]);
  }

  context.fillStyle = gradient;
  context.fillRect(0, 0, width, height);
  return context.canvas;
}

/* harmony default export */ __webpack_exports__["default"] = (Heatmap);

/***/ }),

/***/ "./build/wg/layer/Image.js":
/*!*********************************!*\
  !*** ./build/wg/layer/Image.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BaseImage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseImage.js */ "./build/wg/layer/BaseImage.js");
/* harmony import */ var _renderer_canvas_ImageLayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer/canvas/ImageLayer.js */ "./build/wg/renderer/canvas/ImageLayer.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/Image
 */




/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:wg/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Image.js").default} ImageSourceType
 * @extends {BaseImageLayer<ImageSourceType, CanvasImageLayerRenderer>}
 * @api
 */

var ImageLayer =
/** @class */
function (_super) {
  __extends(ImageLayer, _super);
  /**
   * @param {import("./BaseImage.js").Options<ImageSourceType>} [opt_options] Layer options.
   */


  function ImageLayer(opt_options) {
    return _super.call(this, opt_options) || this;
  }

  ImageLayer.prototype.createRenderer = function () {
    return new _renderer_canvas_ImageLayer_js__WEBPACK_IMPORTED_MODULE_0__["default"](this);
  };
  /**
   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the
   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the
   * source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */


  ImageLayer.prototype.getData = function (pixel) {
    return _super.prototype.getData.call(this, pixel);
  };

  return ImageLayer;
}(_BaseImage_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (ImageLayer);

/***/ }),

/***/ "./build/wg/layer/Layer.js":
/*!*********************************!*\
  !*** ./build/wg/layer/Layer.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "inView": function() { return /* binding */ inView; }
/* harmony export */ });
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Base.js */ "./build/wg/layer/Base.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Property.js */ "./build/wg/layer/Property.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../render/EventType.js */ "./build/wg/render/EventType.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../source/State.js */ "./build/wg/source/State.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./build/wg/events.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/Layer
 */










/**
 * @typedef {function(import("../PluggableMap.js").FrameState):HTMLElement} RenderFunction
 */

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:source', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:source'|
 *     import("../render/EventType").LayerRenderEventTypes, Return>} LayerOnSignature
 */

/**
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @typedef {Object} Options
 * @property {string} [className='wg-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:wg/layer/Layer~Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../PluggableMap.js").default|null} [map] Map.
 * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
 * HTML element. Will overwrite the default rendering for the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @typedef {Object} State
 * @property {import("./Layer.js").default} layer Layer.
 * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
 * @property {import("../source/Source.js").default|undefined} source Source being rendered (only for multi-source layers).
 * @property {boolean} visible Visible.
 * @property {boolean} managed Managed.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {number} zIndex ZIndex.
 * @property {number} maxResolution Maximum resolution.
 * @property {number} minResolution Minimum resolution.
 * @property {number} minZoom Minimum zoom.
 * @property {number} maxZoom Maximum zoom.
 */

/**
 * @classdesc
 * Base class from which all layer types are derived. This should only be instantiated
 * in the case where a custom layer is added to the map with a custom `render` function.
 * Such a function can be specified in the `options` object, and is expected to return an HTML element.
 *
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with {@link import("../PluggableMap.js").default#addLayer map.addLayer()}. Components
 * like {@link module:wg/interaction/Draw~Draw} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * {@link module:wg/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * Please note that for performance reasons several layers might get rendered to
 * the same HTML element, which will cause {@link import("../PluggableMap.js").default#forEachLayerAtPixel map.forEachLayerAtPixel()} to
 * give false positives. To avoid this, apply different `className` properties to the
 * layers at creation time.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 *
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @template {import("../renderer/Layer.js").default} [RendererType=import("../renderer/Layer.js").default]
 * @api
 */

var Layer =
/** @class */
function (_super) {
  __extends(Layer, _super);
  /**
   * @param {Options<SourceType>} options Layer options.
   */


  function Layer(options) {
    var _this = this;

    var baseOptions = (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options);
    delete baseOptions.source;
    _this = _super.call(this, baseOptions) || this;
    /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {LayerOnSignature<void>}
     */

    _this.un;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */

    _this.mapPrecomposeKey_ = null;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */

    _this.mapRenderKey_ = null;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */

    _this.sourceChangeKey_ = null;
    /**
     * @private
     * @type {RendererType}
     */

    _this.renderer_ = null;
    /**
     * @protected
     * @type {boolean}
     */

    _this.rendered = false; // Overwrite default render method with a custom one

    if (options.render) {
      _this.render = options.render;
    }

    if (options.map) {
      _this.setMap(options.map);
    }

    _this.addChangeListener(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].SOURCE, _this.handleSourcePropertyChange_);

    var source = options.source ?
    /** @type {SourceType} */
    options.source : null;

    _this.setSource(source);

    return _this;
  }
  /**
   * @param {Array<import("./Layer.js").default>} [opt_array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */


  Layer.prototype.getLayersArray = function (opt_array) {
    var array = opt_array ? opt_array : [];
    array.push(this);
    return array;
  };
  /**
   * @param {Array<import("./Layer.js").State>} [opt_states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */


  Layer.prototype.getLayerStatesArray = function (opt_states) {
    var states = opt_states ? opt_states : [];
    states.push(this.getLayerState());
    return states;
  };
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */


  Layer.prototype.getSource = function () {
    return (
      /** @type {SourceType} */
      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].SOURCE) || null
    );
  };
  /**
   * @return {SourceType|null} The source being rendered.
   */


  Layer.prototype.getRenderSource = function () {
    return this.getSource();
  };
  /**
   * @return {import("../source/State.js").default} Source state.
   */


  Layer.prototype.getSourceState = function () {
    var source = this.getSource();
    return !source ? _source_State_js__WEBPACK_IMPORTED_MODULE_2__["default"].UNDEFINED : source.getState();
  };
  /**
   * @private
   */


  Layer.prototype.handleSourceChange_ = function () {
    this.changed();
  };
  /**
   * @private
   */


  Layer.prototype.handleSourcePropertyChange_ = function () {
    if (this.sourceChangeKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_3__.unlistenByKey)(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }

    var source = this.getSource();

    if (source) {
      this.sourceChangeKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_3__.listen)(source, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE, this.handleSourceChange_, this);
    }

    this.changed();
  };
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
   * an array of features.
   */


  Layer.prototype.getFeatures = function (pixel) {
    if (!this.renderer_) {
      return new Promise(function (resolve) {
        return resolve([]);
      });
    }

    return this.renderer_.getFeatures(pixel);
  };
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */


  Layer.prototype.getData = function (pixel) {
    if (!this.renderer_ || !this.rendered) {
      return null;
    }

    return this.renderer_.getData(pixel);
  };
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement} The rendered element.
   */


  Layer.prototype.render = function (frameState, target) {
    var layerRenderer = this.getRenderer();

    if (layerRenderer.prepareFrame(frameState)) {
      this.rendered = true;
      return layerRenderer.renderFrame(frameState, target);
    }
  };
  /**
   * Called when a layer is not visible during a map render.
   */


  Layer.prototype.unrender = function () {
    this.rendered = false;
  };
  /**
   * For use inside the library only.
   * @param {import("../PluggableMap.js").default|null} map Map.
   */


  Layer.prototype.setMapInternal = function (map) {
    if (!map) {
      this.unrender();
    }

    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAP, map);
  };
  /**
   * For use inside the library only.
   * @return {import("../PluggableMap.js").default|null} Map.
   */


  Layer.prototype.getMapInternal = function () {
    return this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAP);
  };
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection, and the callback in
   * {@link module:wg/Map~Map#forEachLayerAtPixel} will receive `null` as layer. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:wg/Map~Map#addLayer} instead.
   * @param {import("../PluggableMap.js").default|null} map Map.
   * @api
   */


  Layer.prototype.setMap = function (map) {
    if (this.mapPrecomposeKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_3__.unlistenByKey)(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }

    if (!map) {
      this.changed();
    }

    if (this.mapRenderKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_3__.unlistenByKey)(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }

    if (map) {
      this.mapPrecomposeKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_3__.listen)(map, _render_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].PRECOMPOSE, function (evt) {
        var renderEvent =
        /** @type {import("../render/Event.js").default} */
        evt;
        var layerStatesArray = renderEvent.frameState.layerStatesArray;
        var layerState = this.getLayerState(false); // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.

        (0,_asserts_js__WEBPACK_IMPORTED_MODULE_6__.assert)(!layerStatesArray.some(function (arrayLayerState) {
          return arrayLayerState.layer === layerState.layer;
        }), 67);
        layerStatesArray.push(layerState);
      }, this);
      this.mapRenderKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_3__.listen)(this, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE, map.render, map);
      this.changed();
    }
  };
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */


  Layer.prototype.setSource = function (source) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].SOURCE, source);
  };
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */


  Layer.prototype.getRenderer = function () {
    if (!this.renderer_) {
      this.renderer_ = this.createRenderer();
    }

    return this.renderer_;
  };
  /**
   * @return {boolean} The layer has a renderer.
   */


  Layer.prototype.hasRenderer = function () {
    return !!this.renderer_;
  };
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */


  Layer.prototype.createRenderer = function () {
    return null;
  };
  /**
   * Clean up.
   */


  Layer.prototype.disposeInternal = function () {
    if (this.renderer_) {
      this.renderer_.dispose();
      delete this.renderer_;
    }

    this.setSource(null);

    _super.prototype.disposeInternal.call(this);
  };

  return Layer;
}(_Base_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
/**
 * Return `true` if the layer is visible and if the provided view state
 * has resolution and zoom levels that are in range of the layer's min/max.
 * @param {State} layerState Layer state.
 * @param {import("../View.js").State} viewState View state.
 * @return {boolean} The layer is visible at the given view state.
 */


function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }

  var resolution = viewState.resolution;

  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }

  var zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
/* harmony default export */ __webpack_exports__["default"] = (Layer);

/***/ }),

/***/ "./build/wg/layer/MapboxVector.js":
/*!****************************************!*\
  !*** ./build/wg/layer/MapboxVector.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getMapboxPath": function() { return /* binding */ getMapboxPath; },
/* harmony export */   "normalizeSpriteUrl": function() { return /* binding */ normalizeSpriteUrl; },
/* harmony export */   "normalizeGlyphsUrl": function() { return /* binding */ normalizeGlyphsUrl; },
/* harmony export */   "normalizeStyleUrl": function() { return /* binding */ normalizeStyleUrl; },
/* harmony export */   "normalizeSourceUrl": function() { return /* binding */ normalizeSourceUrl; }
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _format_MVT_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../format/MVT.js */ "./build/wg/format/MVT.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../source/State.js */ "./build/wg/source/State.js");
/* harmony import */ var _layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../layer/VectorTile.js */ "./build/wg/layer/VectorTile.js");
/* harmony import */ var _source_VectorTile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../source/VectorTile.js */ "./build/wg/source/VectorTile.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/MapboxVector
 */








var mapboxBaseUrl = 'https://api.mapbox.com';
/**
 * Gets the path from a mapbox:// URL.
 * @param {string} url The Mapbox URL.
 * @return {string} The path.
 * @private
 */

function getMapboxPath(url) {
  var startsWith = 'mapbox://';

  if (url.indexOf(startsWith) !== 0) {
    return '';
  }

  return url.slice(startsWith.length);
}
/**
 * Turns mapbox:// sprite URLs into resolvable URLs.
 * @param {string} url The sprite URL.
 * @param {string} token The access token.
 * @param {string} styleUrl The style URL.
 * @return {string} A resolvable URL.
 * @private
 */

function normalizeSpriteUrl(url, token, styleUrl) {
  var mapboxPath = getMapboxPath(url);

  if (!mapboxPath) {
    return decodeURI(new URL(url, styleUrl).href);
  }

  var startsWith = 'sprites/';

  if (mapboxPath.indexOf(startsWith) !== 0) {
    throw new Error("unexpected sprites url: ".concat(url));
  }

  var sprite = mapboxPath.slice(startsWith.length);
  return "".concat(mapboxBaseUrl, "/styles/v1/").concat(sprite, "/sprite?access_token=").concat(token);
}
/**
 * Turns mapbox:// glyphs URLs into resolvable URLs.
 * @param {string} url The glyphs URL.
 * @param {string} token The access token.
 * @param {string} styleUrl The style URL.
 * @return {string} A resolvable URL.
 * @private
 */

function normalizeGlyphsUrl(url, token, styleUrl) {
  var mapboxPath = getMapboxPath(url);

  if (!mapboxPath) {
    return decodeURI(new URL(url, styleUrl).href);
  }

  var startsWith = 'fonts/';

  if (mapboxPath.indexOf(startsWith) !== 0) {
    throw new Error("unexpected fonts url: ".concat(url));
  }

  var font = mapboxPath.slice(startsWith.length);
  return "".concat(mapboxBaseUrl, "/fonts/v1/").concat(font, "/0-255.pbf?access_token=").concat(token);
}
/**
 * Turns mapbox:// style URLs into resolvable URLs.
 * @param {string} url The style URL.
 * @param {string} token The access token.
 * @return {string} A resolvable URL.
 * @private
 */

function normalizeStyleUrl(url, token) {
  var mapboxPath = getMapboxPath(url);

  if (!mapboxPath) {
    return decodeURI(new URL(url, location.href).href);
  }

  var startsWith = 'styles/';

  if (mapboxPath.indexOf(startsWith) !== 0) {
    throw new Error("unexpected style url: ".concat(url));
  }

  var style = mapboxPath.slice(startsWith.length);
  return "".concat(mapboxBaseUrl, "/styles/v1/").concat(style, "?&access_token=").concat(token);
}
/**
 * Turns mapbox:// source URLs into vector tile URL templates.
 * @param {string} url The source URL.
 * @param {string} token The access token.
 * @param {string} tokenParam The access token key.
 * @param {string} styleUrl The style URL.
 * @return {string} A vector tile template.
 * @private
 */

function normalizeSourceUrl(url, token, tokenParam, styleUrl) {
  var urlObject = new URL(url, styleUrl);
  var mapboxPath = getMapboxPath(url);

  if (!mapboxPath) {
    if (!token) {
      return decodeURI(urlObject.href);
    }

    urlObject.searchParams.set(tokenParam, token);
    return decodeURI(urlObject.href);
  }

  return "https://{a-d}.tiles.mapbox.com/v4/".concat(mapboxPath, "/{z}/{x}/{y}.vector.pbf?access_token=").concat(token);
}
/**
 * @classdesc
 * Event emitted on configuration or loading error.
 */

var ErrorEvent =
/** @class */
function (_super) {
  __extends(ErrorEvent, _super);
  /**
   * @param {Error} error error object.
   */


  function ErrorEvent(error) {
    var _this = _super.call(this, _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR) || this;
    /**
     * @type {Error}
     */


    _this.error = error;
    return _this;
  }

  return ErrorEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * @typedef {Object} StyleObject
 * @property {Object<string, SourceObject>} sources The style sources.
 * @property {string} sprite The sprite URL.
 * @property {string} glyphs The glyphs URL.
 * @property {Array<LayerObject>} layers The style layers.
 */

/**
 * @typedef {Object} SourceObject
 * @property {string} url The source URL.
 * @property {SourceType} type The source type.
 * @property {Array<string>} [tiles] TileJSON tiles.
 */

/**
 * The Mapbox source type.
 * @enum {string}
 */


var SourceType = {
  VECTOR: 'vector'
};
/**
 * @typedef {Object} LayerObject
 * @property {string} id The layer id.
 * @property {string} type The layer type.
 * @property {string} source The source id.
 * @property {Object} layout The layout.
 * @property {Object} paint The paint.
 */

/**
 * @typedef {Object} Options
 * @property {string} styleUrl The URL of the Mapbox style object to use for this layer.  For a
 * style created with Mapbox Studio and hosted on Mapbox, this will look like
 * 'mapbox://styles/you/your-style'.
 * @property {string} [accessToken] The access token for your Mapbox style. This has to be provided
 * for `mapbox://` style urls. For `https://` and other urls, any access key must be the last query
 * parameter of the style url.
 * @property {string} [source] If your style uses more than one source, you need to use either the
 * `source` property or the `layers` property to limit rendering to a single vector source.  The
 * `source` property corresponds to the id of a vector source in your Mapbox style.
 * @property {Array<string>} [layers] Limit rendering to the list of included layers.  All layers
 * must share the same vector source.  If your style uses more than one source, you need to use
 * either the `source` property or the `layers` property to limit rendering to a single vector
 * source.
 * @property {boolean} [declutter=true] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 *
 * As an optimization decluttered features from layers with the same `className` are rendered above
 * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this
 * behavior and place declutterd features with their own layer configure the layer with a `className`
 * other than `ol-layer`.
 * @property {import("./Base.js").BackgroundColor|false} [background] Background color for the layer.
 * If not specified, the background from the Mapbox style object will be used. Set to `false` to prevent
 * the Mapbox style's background from being used.
 * @property {string} [className='wg-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible. If neither `maxResolution` nor `minZoom` are defined, the layer's `maxResolution` will
 * match the style source's `minzoom`.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will
 * be visible. If neither `maxResolution` nor `minZoom` are defined, the layer's `minZoom` will match
 * the style source's `minzoom`.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the
 * renderer when getting features from the vector tile for the rendering or hit-detection.
 * Recommended value: Vector tiles are usually generated with a buffer, so this value should match
 * the largest possible buffer of the used tiles. It should be at least the size of the largest
 * point symbol or line width.
 * @property {import("./VectorTileRenderType.js").default|string} [renderMode='hybrid'] Render mode for vector tiles:
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom
 *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on
 *    rotated views.
 *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved performance on vector
 *    tile layers with only a few rendered features (e.g. for highlighting a subset of features of
 *    another layer with the same source).
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../PluggableMap.js").default#addLayer map.addLayer()}.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be
 * recreated during animations. This means that no vectors will be shown clipped, but the setting
 * will have a performance impact for large amounts of vector data. When set to `false`, batches
 * will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be
 * recreated during interactions. See also `updateWhileAnimating`.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * A vector tile layer based on a Mapbox style that uses a single vector source.  Configure
 * the layer with the `styleUrl` and `accessToken` shown in Mapbox Studio's share panel.
 * If the style uses more than one source, use the `source` property to choose a single
 * vector source.  If you want to render a subset of the layers in the style, use the `layers`
 * property (all layers must share the same vector source).  See the constructor options for
 * more detail.
 *
 *     var map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1
 *       }),
 *       layers: [
 *         new MapboxVectorLayer({
 *           styleUrl: 'mapbox://styles/mapbox/bright-v9',
 *           accessToken: 'your-mapbox-access-token-here'
 *         })
 *       ],
 *       target: 'map'
 *     });
 *
 * On configuration or loading error, the layer will trigger an `'error'` event.  Listeners
 * will receive an object with an `error` property that can be used to diagnose the problem.
 *
 * @param {Options} options Options.
 * @extends {VectorTileLayer}
 * @fires module:wg/events/Event~BaseEvent#event:error
 * @api
 */

var MapboxVectorLayer =
/** @class */
function (_super) {
  __extends(MapboxVectorLayer, _super);
  /**
   * @param {Options} options Layer options.  At a minimum, `styleUrl` and `accessToken`
   * must be provided.
   */


  function MapboxVectorLayer(options) {
    var _this = this;

    var declutter = 'declutter' in options ? options.declutter : true;
    var source = new _source_VectorTile_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
      state: _source_State_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADING,
      format: new _format_MVT_js__WEBPACK_IMPORTED_MODULE_4__["default"]()
    });
    _this = _super.call(this, {
      source: source,
      background: options.background,
      declutter: declutter,
      className: options.className,
      opacity: options.opacity,
      visible: options.visible,
      zIndex: options.zIndex,
      minResolution: options.minResolution,
      maxResolution: options.maxResolution,
      minZoom: options.minZoom,
      maxZoom: options.maxZoom,
      renderOrder: options.renderOrder,
      renderBuffer: options.renderBuffer,
      renderMode: options.renderMode,
      map: options.map,
      updateWhileAnimating: options.updateWhileAnimating,
      updateWhileInteracting: options.updateWhileInteracting,
      preload: options.preload,
      useInterimTilesOnError: options.useInterimTilesOnError,
      properties: options.properties
    }) || this;
    _this.setMaxResolutionFromTileGrid_ = options.maxResolution === undefined && options.minZoom === undefined;
    _this.sourceId = options.source;
    _this.layers = options.layers;

    if (options.accessToken) {
      _this.accessToken = options.accessToken;
    } else {
      var url = new URL(options.styleUrl, location.href); // The last search parameter is the access token

      url.searchParams.forEach(function (value, key) {
        _this.accessToken = value;
        _this.accessTokenParam_ = key;
      });
    }

    _this.fetchStyle(options.styleUrl);

    return _this;
  }
  /**
   * Fetch the style object.
   * @param {string} styleUrl The URL of the style to load.
   * @protected
   */


  MapboxVectorLayer.prototype.fetchStyle = function (styleUrl) {
    var _this = this;

    var url = normalizeStyleUrl(styleUrl, this.accessToken);
    fetch(url).then(function (response) {
      if (!response.ok) {
        throw new Error("unexpected response when fetching style: ".concat(response.status));
      }

      return response.json();
    }).then(function (style) {
      _this.onStyleLoad(style, url.startsWith('data:') ? location.href : url);
    }).catch(function (error) {
      _this.handleError(error);
    });
  };
  /**
   * Handle the loaded style object.
   * @param {StyleObject} style The loaded style.
   * @param {string} styleUrl The URL of the style.
   * @protected
   */


  MapboxVectorLayer.prototype.onStyleLoad = function (style, styleUrl) {
    var _this = this;

    var sourceId;
    var sourceIdOrLayersList;

    if (this.layers) {
      // confirm all layers share the same source
      var lookup = {};

      for (var i = 0; i < style.layers.length; ++i) {
        var layer = style.layers[i];

        if (layer.source) {
          lookup[layer.id] = layer.source;
        }
      }

      var firstSource = void 0;

      for (var i = 0; i < this.layers.length; ++i) {
        var candidate = lookup[this.layers[i]];

        if (!candidate) {
          this.handleError(new Error("could not find source for ".concat(this.layers[i])));
          return;
        }

        if (!firstSource) {
          firstSource = candidate;
        } else if (firstSource !== candidate) {
          this.handleError(new Error("layers can only use a single source, found ".concat(firstSource, " and ").concat(candidate)));
          return;
        }
      }

      sourceId = firstSource;
      sourceIdOrLayersList = this.layers;
    } else {
      sourceId = this.sourceId;
      sourceIdOrLayersList = sourceId;
    }

    if (!sourceIdOrLayersList) {
      // default to the first source in the style
      sourceId = Object.keys(style.sources)[0];
      sourceIdOrLayersList = sourceId;
    }

    if (style.sprite) {
      style.sprite = normalizeSpriteUrl(style.sprite, this.accessToken, styleUrl);
    }

    if (style.glyphs) {
      style.glyphs = normalizeGlyphsUrl(style.glyphs, this.accessToken, styleUrl);
    }

    var styleSource = style.sources[sourceId];

    if (styleSource.type !== SourceType.VECTOR) {
      this.handleError(new Error("only works for vector sources, found ".concat(styleSource.type)));
      return;
    }

    var source = this.getSource();

    if (styleSource.url && styleSource.url.indexOf('mapbox://') === 0) {
      // Tile source url, handle it directly
      source.setUrl(normalizeSourceUrl(styleSource.url, this.accessToken, this.accessTokenParam_, styleUrl));
      applyStyle(this, style, sourceIdOrLayersList).then(function () {
        _this.configureSource(source, style);
      }).catch(function (error) {
        _this.handleError(error);
      });
    } else {
      // TileJSON url, let ol-mapbox-style handle it
      if (styleSource.tiles) {
        styleSource.tiles = styleSource.tiles.map(function (url) {
          return normalizeSourceUrl(url, _this.accessToken, _this.accessTokenParam_, styleUrl);
        });
      }

      setupVectorSource(styleSource, styleSource.url ? normalizeSourceUrl(styleSource.url, this.accessToken, this.accessTokenParam_, styleUrl) : undefined).then(function (source) {
        applyStyle(_this, style, sourceIdOrLayersList).then(function () {
          _this.configureSource(source, style);
        }).catch(function (error) {
          _this.configureSource(source, style);

          _this.handleError(error);
        });
      });
    }
  };
  /**
   * Applies configuration from the provided source to this layer's source,
   * and reconfigures the loader to add a feature that renders the background,
   * if the style is configured with a background.
   * @param {import("../source/VectorTile.js").default} source The source to configure from.
   * @param {StyleObject} style The style to configure the background from.
   */


  MapboxVectorLayer.prototype.configureSource = function (source, style) {
    var targetSource = this.getSource();

    if (source !== targetSource) {
      targetSource.setAttributions(source.getAttributions());
      targetSource.setTileUrlFunction(source.getTileUrlFunction());
      targetSource.setTileLoadFunction(source.getTileLoadFunction());
      targetSource.tileGrid = source.tileGrid;
    }

    if (this.getBackground() === undefined) {
      applyBackground(this, style);
    }

    if (this.setMaxResolutionFromTileGrid_) {
      var tileGrid = targetSource.getTileGrid();
      this.setMaxResolution(tileGrid.getResolution(tileGrid.getMinZoom()));
    }

    targetSource.setState(_source_State_js__WEBPACK_IMPORTED_MODULE_3__["default"].READY);
  };
  /**
   * Handle configuration or loading error.
   * @param {Error} error The error.
   * @protected
   */


  MapboxVectorLayer.prototype.handleError = function (error) {
    this.dispatchEvent(new ErrorEvent(error));
    var source = this.getSource();
    source.setState(_source_State_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR);
  };

  return MapboxVectorLayer;
}(_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_5__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (MapboxVectorLayer);

/***/ }),

/***/ "./build/wg/layer/Property.js":
/*!************************************!*\
  !*** ./build/wg/layer/Property.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/layer/Property
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  OPACITY: 'opacity',
  VISIBLE: 'visible',
  EXTENT: 'extent',
  Z_INDEX: 'zIndex',
  MAX_RESOLUTION: 'maxResolution',
  MIN_RESOLUTION: 'minResolution',
  MAX_ZOOM: 'maxZoom',
  MIN_ZOOM: 'minZoom',
  SOURCE: 'source',
  MAP: 'map'
});

/***/ }),

/***/ "./build/wg/layer/Tile.js":
/*!********************************!*\
  !*** ./build/wg/layer/Tile.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BaseTile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseTile.js */ "./build/wg/layer/BaseTile.js");
/* harmony import */ var _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer/canvas/TileLayer.js */ "./build/wg/renderer/canvas/TileLayer.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/Tile
 */




/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:wg/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>
 * @api
 */

var TileLayer =
/** @class */
function (_super) {
  __extends(TileLayer, _super);
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [opt_options] Tile layer options.
   */


  function TileLayer(opt_options) {
    return _super.call(this, opt_options) || this;
  }

  TileLayer.prototype.createRenderer = function () {
    return new _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__["default"](this);
  };

  return TileLayer;
}(_BaseTile_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (TileLayer);

/***/ }),

/***/ "./build/wg/layer/TileProperty.js":
/*!****************************************!*\
  !*** ./build/wg/layer/TileProperty.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/layer/TileProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  PRELOAD: 'preload',
  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
});

/***/ }),

/***/ "./build/wg/layer/Vector.js":
/*!**********************************!*\
  !*** ./build/wg/layer/Vector.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BaseVector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseVector.js */ "./build/wg/layer/BaseVector.js");
/* harmony import */ var _renderer_canvas_VectorLayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer/canvas/VectorLayer.js */ "./build/wg/renderer/canvas/VectorLayer.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/Vector
 */




/**
 * @classdesc
 * Vector data is rendered client-side, as vectors. This layer type provides most accurate rendering
 * even during animations. Points and labels stay upright on rotated views. For very large
 * amounts of vector data, performance may suffer during pan and zoom animations. In this case,
 * try {@link module:wg/layer/VectorImage~VectorImageLayer}.
 *
 * Note that any property set in the options is set as a {@link module:wg/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorLayerRenderer>}
 * @api
 */

var VectorLayer =
/** @class */
function (_super) {
  __extends(VectorLayer, _super);
  /**
   * @param {import("./BaseVector.js").Options<VectorSourceType>} [opt_options] Options.
   */


  function VectorLayer(opt_options) {
    return _super.call(this, opt_options) || this;
  }

  VectorLayer.prototype.createRenderer = function () {
    return new _renderer_canvas_VectorLayer_js__WEBPACK_IMPORTED_MODULE_0__["default"](this);
  };

  return VectorLayer;
}(_BaseVector_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VectorLayer);

/***/ }),

/***/ "./build/wg/layer/VectorImage.js":
/*!***************************************!*\
  !*** ./build/wg/layer/VectorImage.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BaseVector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseVector.js */ "./build/wg/layer/BaseVector.js");
/* harmony import */ var _renderer_canvas_VectorImageLayer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/canvas/VectorImageLayer.js */ "./build/wg/renderer/canvas/VectorImageLayer.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/VectorImage
 */





/**
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @typedef {Object} Options
 * @property {string} [className='wg-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../PluggableMap.js").default#addLayer map.addLayer()}.
 * @property {boolean} [declutter=false] Declutter images and text on this layer. The priority is defined
 * by the `zIndex` of the style and the render order of features. Higher z-index means higher priority.
 * Within the same z-index, a feature rendered before another has higher priority.
 * @property {import("../style/Style.js").StyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:wg/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {number} [imageRatio=1] Ratio by which the rendered extent should be larger than the
 * viewport extent. A larger ratio avoids cut images during panning, but will cause a decrease in performance.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * Vector data is rendered client-side, to an image. This layer type provides great performance
 * during panning and zooming, but point symbols and texts are always rotated with the view and
 * pixels are scaled during zoom animations. For more accurate rendering of vector data, use
 * {@link module:wg/layer/Vector~VectorLayer} instead.
 *
 * Note that any property set in the options is set as a {@link module:wg/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorImageLayerRenderer>}
 * @api
 */

var VectorImageLayer =
/** @class */
function (_super) {
  __extends(VectorImageLayer, _super);
  /**
   * @param {Options<VectorSourceType>} [opt_options] Options.
   */


  function VectorImageLayer(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var baseOptions = (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options);
    delete baseOptions.imageRatio;
    _this = _super.call(this, baseOptions) || this;
    /**
     * @type {number}
     * @private
     */

    _this.imageRatio_ = options.imageRatio !== undefined ? options.imageRatio : 1;
    return _this;
  }
  /**
   * @return {number} Ratio between rendered extent size and viewport extent size.
   */


  VectorImageLayer.prototype.getImageRatio = function () {
    return this.imageRatio_;
  };

  VectorImageLayer.prototype.createRenderer = function () {
    return new _renderer_canvas_VectorImageLayer_js__WEBPACK_IMPORTED_MODULE_1__["default"](this);
  };

  return VectorImageLayer;
}(_BaseVector_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VectorImageLayer);

/***/ }),

/***/ "./build/wg/layer/VectorTile.js":
/*!**************************************!*\
  !*** ./build/wg/layer/VectorTile.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BaseVector_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BaseVector.js */ "./build/wg/layer/BaseVector.js");
/* harmony import */ var _renderer_canvas_VectorTileLayer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/canvas/VectorTileLayer.js */ "./build/wg/renderer/canvas/VectorTileLayer.js");
/* harmony import */ var _TileProperty_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TileProperty.js */ "./build/wg/layer/TileProperty.js");
/* harmony import */ var _VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VectorTileRenderType.js */ "./build/wg/layer/VectorTileRenderType.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/VectorTile
 */








/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:source'|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
 *     'change:source'|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} VectorTileLayerOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='wg-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the
 * renderer when getting features from the vector tile for the rendering or hit-detection.
 * Recommended value: Vector tiles are usually generated with a buffer, so this value should match
 * the largest possible buffer of the used tiles. It should be at least the size of the largest
 * point symbol or line width.
 * @property {import("./VectorTileRenderType.js").default|string} [renderMode='hybrid'] Render mode for vector tiles:
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom
 *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on
 *    rotated views.
 *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved performance on vector
 *    tile layers with only a few rendered features (e.g. for highlighting a subset of features of
 *    another layer with the same source).
 * @property {import("../source/VectorTile.js").default} [source] Source.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../PluggableMap.js").default#addLayer map.addLayer()}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 *
 * As an optimization decluttered features from layers with the same `className` are rendered above
 * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this
 * behavior and place declutterd features with their own layer configure the layer with a `className`
 * other than `ol-layer`.
 * @property {import("../style/Style.js").StyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:wg/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor|false} [background] Background color for the layer. If not specified, no
 * background will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be
 * recreated during animations. This means that no vectors will be shown clipped, but the setting
 * will have a performance impact for large amounts of vector data. When set to `false`, batches
 * will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be
 * recreated during interactions. See also `updateWhileAnimating`.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * Layer for vector tile data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:wg/Object~BaseObject BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @param {Options} [opt_options] Options.
 * @extends {BaseVectorLayer<import("../source/VectorTile.js").default, CanvasVectorTileLayerRenderer>}
 * @api
 */

var VectorTileLayer =
/** @class */
function (_super) {
  __extends(VectorTileLayer, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function VectorTileLayer(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var baseOptions =
    /** @type {Object} */
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    _this = _super.call(this,
    /** @type {import("./BaseVector.js").Options<import("../source/VectorTile.js").default>} */
    baseOptions) || this;
    /***
     * @type {VectorTileLayerOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {VectorTileLayerOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {VectorTileLayerOnSignature<void>}
     */

    _this.un;

    if (options.renderMode === _VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].IMAGE) {
      //FIXME deprecated - remove this check in v7.
      //eslint-disable-next-line
      console.warn('renderMode: "image" is deprecated. Option ignored.');
      options.renderMode = undefined;
    }

    var renderMode = options.renderMode || _VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].HYBRID;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_2__.assert)(renderMode == _VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].HYBRID || renderMode == _VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].VECTOR, 28); // `renderMode` must be `'hybrid'` or `'vector'`.

    /**
     * @private
     * @type {import("./VectorTileRenderType.js").default}
     */

    _this.renderMode_ = renderMode;

    _this.setPreload(options.preload ? options.preload : 0);

    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);
    /**
     * @return {import("./Base.js").BackgroundColor} Background color.
     * @function
     * @api
     */


    _this.getBackground;
    /**
     * @param {import("./Base.js").BackgroundColor} background Background color.
     * @function
     * @api
     */

    _this.setBackground;
    return _this;
  }

  VectorTileLayer.prototype.createRenderer = function () {
    return new _renderer_canvas_VectorTileLayer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this);
  };
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in {@link import("../PluggableMap.js").default#getFeaturesAtPixel map.getFeaturesAtPixel()}: Text
   * is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
   * @api
   */


  VectorTileLayer.prototype.getFeatures = function (pixel) {
    return _super.prototype.getFeatures.call(this, pixel);
  };
  /**
   * @return {import("./VectorTileRenderType.js").default} The render mode.
   */


  VectorTileLayer.prototype.getRenderMode = function () {
    return this.renderMode_;
  };
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */


  VectorTileLayer.prototype.getPreload = function () {
    return (
      /** @type {number} */
      this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_4__["default"].PRELOAD)
    );
  };
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */


  VectorTileLayer.prototype.getUseInterimTilesOnError = function () {
    return (
      /** @type {boolean} */
      this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_4__["default"].USE_INTERIM_TILES_ON_ERROR)
    );
  };
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */


  VectorTileLayer.prototype.setPreload = function (preload) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_4__["default"].PRELOAD, preload);
  };
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */


  VectorTileLayer.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_4__["default"].USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };

  return VectorTileLayer;
}(_BaseVector_js__WEBPACK_IMPORTED_MODULE_5__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VectorTileLayer);

/***/ }),

/***/ "./build/wg/layer/VectorTileRenderType.js":
/*!************************************************!*\
  !*** ./build/wg/layer/VectorTileRenderType.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/layer/VectorTileRenderType
 */

/**
 * @enum {string}
 * Render mode for vector tiles:
 * @api
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Vector tiles are rendered as images. Great performance, but
   * point symbols and texts are always rotated with the view and pixels are
   * scaled during zoom animations
   * @api
   * @deprecated
   */
  IMAGE: 'image',

  /**
   * Polygon and line elements are rendered as images, so pixels
   * are scaled during zoom animations. Point symbols and texts are accurately
   * rendered as vectors and can stay upright on rotated views.
   * @api
   */
  HYBRID: 'hybrid',

  /**
   * Everything is rendered as vectors. Use this mode for improved
   * performance on vector tile layers with only a few rendered features (e.g.
   * for highlighting a subset of features of another layer with the same
   * source).
   * @api
   */
  VECTOR: 'vector'
});

/***/ }),

/***/ "./build/wg/layer/WebGLPoints.js":
/*!***************************************!*\
  !*** ./build/wg/layer/WebGLPoints.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Layer.js */ "./build/wg/layer/Layer.js");
/* harmony import */ var _renderer_webgl_PointsLayer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/webgl/PointsLayer.js */ "./build/wg/renderer/webgl/PointsLayer.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _webgl_ShaderBuilder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/ShaderBuilder.js */ "./build/wg/webgl/ShaderBuilder.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/WebGLPoints
 */






/**
 * @template {import("../source/Vector.js").default<import("../geom/Point.js").default>} VectorSourceType
 * @typedef {Object} Options
 * @property {import('../style/literal.js').LiteralStyle} style Literal style to apply to the layer features.
 * @property {string} [className='wg-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {VectorSourceType} [source] Point source.
 * @property {boolean} [disableHitDetection=false] Setting this to true will provide a slight performance boost, but will
 * prevent all hit detection on the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * Layer optimized for rendering large point datasets. Takes a `style` property which
 * is a serializable JSON object describing how the layer should be rendered.
 *
 * Here are a few samples of literal style objects:
 * ```js
 * const style = {
 *   symbol: {
 *     symbolType: 'circle',
 *     size: 8,
 *     color: '#33AAFF',
 *     opacity: 0.9
 *   }
 * }
 * ```
 *
 * ```js
 * const style = {
 *   symbol: {
 *     symbolType: 'image',
 *     offset: [0, 12],
 *     size: [4, 8],
 *     src: '../static/exclamation-mark.png'
 *   }
 * }
 * ```
 *
 * **Important: a `WebGLPoints` layer must be manually disposed when removed, otherwise the underlying WebGL context
 * will not be garbage collected.**
 *
 * Note that any property set in the options is set as a {@link module:wg/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default<import("../geom/Point.js").default>} VectorSourceType
 * @extends {Layer<VectorSourceType, WebGLPointsLayerRenderer>}
 * @fires import("../render/Event.js").RenderEvent
 */

var WebGLPointsLayer =
/** @class */
function (_super) {
  __extends(WebGLPointsLayer, _super);
  /**
   * @param {Options<VectorSourceType>} options Options.
   */


  function WebGLPointsLayer(options) {
    var _this = this;

    var baseOptions = (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options);
    _this = _super.call(this, baseOptions) || this;
    /**
     * @private
     * @type {import('../webgl/ShaderBuilder.js').StyleParseResult}
     */

    _this.parseResult_ = (0,_webgl_ShaderBuilder_js__WEBPACK_IMPORTED_MODULE_1__.parseLiteralStyle)(options.style);
    /**
     * @type {Object<string, (string|number)>}
     * @private
     */

    _this.styleVariables_ = options.style.variables || {};
    /**
     * @private
     * @type {boolean}
     */

    _this.hitDetectionDisabled_ = !!options.disableHitDetection;
    return _this;
  }

  WebGLPointsLayer.prototype.createRenderer = function () {
    return new _renderer_webgl_PointsLayer_js__WEBPACK_IMPORTED_MODULE_2__["default"](this, {
      vertexShader: this.parseResult_.builder.getSymbolVertexShader(),
      fragmentShader: this.parseResult_.builder.getSymbolFragmentShader(),
      hitVertexShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolVertexShader(true),
      hitFragmentShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolFragmentShader(true),
      uniforms: this.parseResult_.uniforms,
      attributes: this.parseResult_.attributes
    });
  };
  /**
   * Update any variables used by the layer style and trigger a re-render.
   * @param {Object<string, number>} variables Variables to update.
   */


  WebGLPointsLayer.prototype.updateStyleVariables = function (variables) {
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.assign)(this.styleVariables_, variables);
    this.changed();
  };

  return WebGLPointsLayer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (WebGLPointsLayer);

/***/ }),

/***/ "./build/wg/layer/WebGLTile.js":
/*!*************************************!*\
  !*** ./build/wg/layer/WebGLTile.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BaseTile_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BaseTile.js */ "./build/wg/layer/BaseTile.js");
/* harmony import */ var _layer_Property_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../layer/Property.js */ "./build/wg/layer/Property.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../source/State.js */ "./build/wg/source/State.js");
/* harmony import */ var _renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer/webgl/TileLayer.js */ "./build/wg/renderer/webgl/TileLayer.js");
/* harmony import */ var _style_expressions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../style/expressions.js */ "./build/wg/style/expressions.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/layer/WebGLTile
 */








/**
 * @typedef {import("../source/DataTile.js").default|import("../source/TileImage.js").default} SourceType
 */

/**
 * @typedef {Object} Style
 * Translates tile data to rendered pixels.
 *
 * @property {Object<string, (string|number)>} [variables] Style variables.  Each variable must hold a number or string.  These
 * variables can be used in the `color`, `brightness`, `contrast`, `exposure`, `saturation` and `gamma`
 * {@link import("../style/expressions.js").ExpressionValue expressions}, using the `['var', 'varName']` operator.
 * To update style variables, use the {@link import("./WebGLTile.js").default#updateStyleVariables} method.
 * @property {import("../style/expressions.js").ExpressionValue} [color] An expression applied to color values.
 * @property {import("../style/expressions.js").ExpressionValue} [brightness=0] Value used to decrease or increase
 * the layer brightness.  Values range from -1 to 1.
 * @property {import("../style/expressions.js").ExpressionValue} [contrast=0] Value used to decrease or increase
 * the layer contrast.  Values range from -1 to 1.
 * @property {import("../style/expressions.js").ExpressionValue} [exposure=0] Value used to decrease or increase
 * the layer exposure.  Values range from -1 to 1.
 * @property {import("../style/expressions.js").ExpressionValue} [saturation=0] Value used to decrease or increase
 * the layer saturation.  Values range from -1 to 1.
 * @property {import("../style/expressions.js").ExpressionValue} [gamma=1] Apply a gamma correction to the layer.
 * Values range from 0 to infinity.
 */

/**
 * @typedef {Object} Options
 * @property {Style} [style] Style to apply to the layer.
 * @property {string} [className='wg-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {SourceType} [source] Source for this layer.
 * @property {Array<SourceType>|function(import("../extent.js").Extent, number):Array<SourceType>} [sources] Array
 * of sources for this layer. Takes precedence over `source`. Can either be an array of sources, or a function that
 * expects an extent and a resolution (in view projection units per pixel) and returns an array of sources. See
 * {@link module:wg/source.sourcesFromTileGrid} for a helper function to generate sources that are organized in a
 * pyramid following the same pattern as a tile grid.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:wg/Map~Map#addLayer}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render
 * two zoom levels worth of tiles.
 */

/**
 * @typedef {Object} ParsedStyle
 * @property {string} vertexShader The vertex shader.
 * @property {string} fragmentShader The fragment shader.
 * @property {Object<string,import("../webgl/Helper.js").UniformValue>} uniforms Uniform definitions.
 * @property {Array<import("../webgl/PaletteTexture.js").default>} paletteTextures Palette textures.
 */

/**
 * @param {Style} style The layer style.
 * @param {number} [bandCount] The number of bands.
 * @return {ParsedStyle} Shaders and uniforms generated from the style.
 */

function parseStyle(style, bandCount) {
  var vertexShader = "\n    attribute vec2 ".concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Attributes.TEXTURE_COORD, ";\n    uniform mat4 ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TILE_TRANSFORM, ";\n    uniform float ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TEXTURE_PIXEL_WIDTH, ";\n    uniform float ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n    uniform float ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TEXTURE_RESOLUTION, ";\n    uniform float ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TEXTURE_ORIGIN_X, ";\n    uniform float ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TEXTURE_ORIGIN_Y, ";\n    uniform float ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.DEPTH, ";\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n\n    void main() {\n      v_textureCoord = ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Attributes.TEXTURE_COORD, ";\n      v_mapCoord = vec2(\n        ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TEXTURE_ORIGIN_X, " + ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TEXTURE_RESOLUTION, " * ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TEXTURE_PIXEL_WIDTH, " * v_textureCoord[0],\n        ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TEXTURE_ORIGIN_Y, " - ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TEXTURE_RESOLUTION, " * ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TEXTURE_PIXEL_HEIGHT, " * v_textureCoord[1]\n      );\n      gl_Position = ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TILE_TRANSFORM, " * vec4(").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Attributes.TEXTURE_COORD, ", ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.DEPTH, ", 1.0);\n    }\n  ");
  /**
   * @type {import("../style/expressions.js").ParsingContext}
   */

  var context = {
    inFragmentShader: true,
    variables: [],
    attributes: [],
    stringLiteralsMap: {},
    functions: {},
    bandCount: bandCount
  };
  var pipeline = [];

  if (style.color !== undefined) {
    var color = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_1__.expressionToGlsl)(context, style.color, _style_expressions_js__WEBPACK_IMPORTED_MODULE_1__.ValueTypes.COLOR);
    pipeline.push("color = ".concat(color, ";"));
  }

  if (style.contrast !== undefined) {
    var contrast = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_1__.expressionToGlsl)(context, style.contrast, _style_expressions_js__WEBPACK_IMPORTED_MODULE_1__.ValueTypes.NUMBER);
    pipeline.push("color.rgb = clamp((".concat(contrast, " + 1.0) * color.rgb - (").concat(contrast, " / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));"));
  }

  if (style.exposure !== undefined) {
    var exposure = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_1__.expressionToGlsl)(context, style.exposure, _style_expressions_js__WEBPACK_IMPORTED_MODULE_1__.ValueTypes.NUMBER);
    pipeline.push("color.rgb = clamp((".concat(exposure, " + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));"));
  }

  if (style.saturation !== undefined) {
    var saturation = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_1__.expressionToGlsl)(context, style.saturation, _style_expressions_js__WEBPACK_IMPORTED_MODULE_1__.ValueTypes.NUMBER);
    pipeline.push("\n      float saturation = ".concat(saturation, " + 1.0;\n      float sr = (1.0 - saturation) * 0.2126;\n      float sg = (1.0 - saturation) * 0.7152;\n      float sb = (1.0 - saturation) * 0.0722;\n      mat3 saturationMatrix = mat3(\n        sr + saturation, sr, sr,\n        sg, sg + saturation, sg,\n        sb, sb, sb + saturation\n      );\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    "));
  }

  if (style.gamma !== undefined) {
    var gamma = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_1__.expressionToGlsl)(context, style.gamma, _style_expressions_js__WEBPACK_IMPORTED_MODULE_1__.ValueTypes.NUMBER);
    pipeline.push("color.rgb = pow(color.rgb, vec3(1.0 / ".concat(gamma, "));"));
  }

  if (style.brightness !== undefined) {
    var brightness = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_1__.expressionToGlsl)(context, style.brightness, _style_expressions_js__WEBPACK_IMPORTED_MODULE_1__.ValueTypes.NUMBER);
    pipeline.push("color.rgb = clamp(color.rgb + ".concat(brightness, ", vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));"));
  }
  /** @type {Object<string,import("../webgl/Helper").UniformValue>} */


  var uniforms = {};
  var numVariables = context.variables.length;

  if (numVariables > 1 && !style.variables) {
    throw new Error("Missing variables in style (expected ".concat(context.variables, ")"));
  }

  var _loop_1 = function _loop_1(i) {
    var variableName = context.variables[i];

    if (!(variableName in style.variables)) {
      throw new Error("Missing '".concat(variableName, "' in style variables"));
    }

    var uniformName = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_1__.uniformNameForVariable)(variableName);

    uniforms[uniformName] = function () {
      var value = style.variables[variableName];

      if (typeof value === 'string') {
        value = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_1__.getStringNumberEquivalent)(context, value);
      }

      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal
    };
  };

  for (var i = 0; i < numVariables; ++i) {
    _loop_1(i);
  }

  var uniformDeclarations = Object.keys(uniforms).map(function (name) {
    return "uniform float ".concat(name, ";");
  });
  var textureCount = Math.ceil(bandCount / 4);
  uniformDeclarations.push("uniform sampler2D ".concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TILE_TEXTURE_ARRAY, "[").concat(textureCount, "];"));

  if (context.paletteTextures) {
    uniformDeclarations.push("uniform sampler2D ".concat(_style_expressions_js__WEBPACK_IMPORTED_MODULE_1__.PALETTE_TEXTURE_ARRAY, "[").concat(context.paletteTextures.length, "];"));
  }

  var functionDefintions = Object.keys(context.functions).map(function (name) {
    return context.functions[name];
  });
  var fragmentShader = "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n    uniform vec4 ".concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.RENDER_EXTENT, ";\n    uniform float ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TRANSITION_ALPHA, ";\n    uniform float ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TEXTURE_PIXEL_WIDTH, ";\n    uniform float ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n    uniform float ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.RESOLUTION, ";\n    uniform float ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.ZOOM, ";\n\n    ").concat(uniformDeclarations.join('\n'), "\n\n    ").concat(functionDefintions.join('\n'), "\n\n    void main() {\n      if (\n        v_mapCoord[0] < ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.RENDER_EXTENT, "[0] ||\n        v_mapCoord[1] < ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.RENDER_EXTENT, "[1] ||\n        v_mapCoord[0] > ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.RENDER_EXTENT, "[2] ||\n        v_mapCoord[1] > ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.RENDER_EXTENT, "[3]\n      ) {\n        discard;\n      }\n\n      vec4 color = texture2D(").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TILE_TEXTURE_ARRAY, "[0],  v_textureCoord);\n\n      ").concat(pipeline.join('\n'), "\n\n      if (color.a == 0.0) {\n        discard;\n      }\n\n      gl_FragColor = color;\n      gl_FragColor.rgb *= gl_FragColor.a;\n      gl_FragColor *= ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__.Uniforms.TRANSITION_ALPHA, ";\n    }");
  return {
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    uniforms: uniforms,
    paletteTextures: context.paletteTextures
  };
}
/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:wg/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @extends BaseTileLayer<SourceType, WebGLTileLayerRenderer>
 * @api
 */


var WebGLTileLayer =
/** @class */
function (_super) {
  __extends(WebGLTileLayer, _super);
  /**
   * @param {Options} opt_options Tile layer options.
   */


  function WebGLTileLayer(opt_options) {
    var _this = this;

    var options = opt_options ? (0,_obj_js__WEBPACK_IMPORTED_MODULE_2__.assign)({}, opt_options) : {};
    var style = options.style || {};
    delete options.style;
    var cacheSize = options.cacheSize;
    delete options.cacheSize;
    _this = _super.call(this, options) || this;
    /**
     * @type {Array<SourceType>|function(import("../extent.js").Extent, number):Array<SourceType>}
     * @private
     */

    _this.sources_ = options.sources;
    /**
     * @type {number}
     * @private
     */

    _this.renderedResolution_ = NaN;
    /**
     * @type {Style}
     * @private
     */

    _this.style_ = style;
    /**
     * @type {number}
     * @private
     */

    _this.cacheSize_ = cacheSize;
    /**
     * @type {Object<string, (string|number)>}
     * @private
     */

    _this.styleVariables_ = _this.style_.variables || {};

    _this.addChangeListener(_layer_Property_js__WEBPACK_IMPORTED_MODULE_3__["default"].SOURCE, _this.handleSourceUpdate_);

    return _this;
  }
  /**
   * Gets the sources for this layer, for a given extent and resolution.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @return {Array<SourceType>} Sources.
   */


  WebGLTileLayer.prototype.getSources = function (extent, resolution) {
    var source = this.getSource();
    return this.sources_ ? typeof this.sources_ === 'function' ? this.sources_(extent, resolution) : this.sources_ : source ? [source] : [];
  };
  /**
   * @return {SourceType} The source being rendered.
   */


  WebGLTileLayer.prototype.getRenderSource = function () {
    return (
      /** @type {SourceType} */
      this.getLayerState().source || this.getSource()
    );
  };
  /**
   * @return {import("../source/State.js").default} Source state.
   */


  WebGLTileLayer.prototype.getSourceState = function () {
    var source = this.getRenderSource();
    return source ? source.getState() : _source_State_js__WEBPACK_IMPORTED_MODULE_4__["default"].UNDEFINED;
  };
  /**
   * @private
   */


  WebGLTileLayer.prototype.handleSourceUpdate_ = function () {
    if (this.getSource()) {
      this.setStyle(this.style_);
    }
  };
  /**
   * @private
   * @return {number} The number of source bands.
   */


  WebGLTileLayer.prototype.getSourceBandCount_ = function () {
    var source = this.getSource();
    return source && 'bandCount' in source ? source.bandCount : 4;
  };

  WebGLTileLayer.prototype.createRenderer = function () {
    var parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());
    return new _renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_0__["default"](this, {
      vertexShader: parsedStyle.vertexShader,
      fragmentShader: parsedStyle.fragmentShader,
      uniforms: parsedStyle.uniforms,
      cacheSize: this.cacheSize_,
      paletteTextures: parsedStyle.paletteTextures
    });
  };
  /**
   * @param {import("../PluggableMap").FrameState} frameState Frame state.
   * @param {Array<SourceType>} sources Sources.
   * @return {HTMLElement} Canvas.
   */


  WebGLTileLayer.prototype.renderSources = function (frameState, sources) {
    var layerRenderer = this.getRenderer();
    var canvas;

    for (var i = 0, ii = sources.length; i < ii; ++i) {
      this.getLayerState().source = sources[i];

      if (layerRenderer.prepareFrame(frameState)) {
        canvas = layerRenderer.renderFrame(frameState);
      }
    }

    return canvas;
  };
  /**
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement} The rendered element.
   */


  WebGLTileLayer.prototype.render = function (frameState, target) {
    var _this = this;

    this.rendered = true;
    var viewState = frameState.viewState;
    var sources = this.getSources(frameState.extent, viewState.resolution);
    var ready = true;

    var _loop_2 = function _loop_2(i, ii) {
      var source = sources[i];
      var sourceState = source.getState();

      if (sourceState == _source_State_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADING) {
        var onChange_1 = function onChange_1() {
          if (source.getState() == _source_State_js__WEBPACK_IMPORTED_MODULE_4__["default"].READY) {
            source.removeEventListener('change', onChange_1);

            _this.changed();
          }
        };

        source.addEventListener('change', onChange_1);
      }

      ready = ready && sourceState == _source_State_js__WEBPACK_IMPORTED_MODULE_4__["default"].READY;
    };

    for (var i = 0, ii = sources.length; i < ii; ++i) {
      _loop_2(i, ii);
    }

    var canvas = this.renderSources(frameState, sources);

    if (this.getRenderer().renderComplete && ready) {
      // Fully rendered, done.
      this.renderedResolution_ = viewState.resolution;
      return canvas;
    } // Render sources from previously fully rendered frames


    if (this.renderedResolution_ > 0.5 * viewState.resolution) {
      var altSources = this.getSources(frameState.extent, this.renderedResolution_).filter(function (source) {
        return !sources.includes(source);
      });

      if (altSources.length > 0) {
        return this.renderSources(frameState, altSources);
      }
    }

    return canvas;
  };
  /**
   * Update the layer style.  The `updateStyleVariables` function is a more efficient
   * way to update layer rendering.  In cases where the whole style needs to be updated,
   * this method may be called instead.  Note that calling this method will also replace
   * any previously set variables, so the new style also needs to include new variables,
   * if needed.
   * @param {Style} style The new style.
   */


  WebGLTileLayer.prototype.setStyle = function (style) {
    this.styleVariables_ = style.variables || {};
    this.style_ = style;
    var parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());
    var renderer = this.getRenderer();
    renderer.reset({
      vertexShader: parsedStyle.vertexShader,
      fragmentShader: parsedStyle.fragmentShader,
      uniforms: parsedStyle.uniforms,
      paletteTextures: parsedStyle.paletteTextures
    });
    this.changed();
  };
  /**
   * Update any variables used by the layer style and trigger a re-render.
   * @param {Object<string, number>} variables Variables to update.
   * @api
   */


  WebGLTileLayer.prototype.updateStyleVariables = function (variables) {
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_2__.assign)(this.styleVariables_, variables);
    this.changed();
  };

  return WebGLTileLayer;
}(_BaseTile_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * Clean up underlying WebGL resources.
 * @function
 * @api
 */


WebGLTileLayer.prototype.dispose;
/* harmony default export */ __webpack_exports__["default"] = (WebGLTileLayer);

/***/ }),

/***/ "./build/wg/loadingstrategy.js":
/*!*************************************!*\
  !*** ./build/wg/loadingstrategy.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "all": function() { return /* binding */ all; },
/* harmony export */   "bbox": function() { return /* binding */ bbox; },
/* harmony export */   "tile": function() { return /* binding */ tile; }
/* harmony export */ });
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./build/wg/proj.js");
/**
 * @module wg/loadingstrategy
 */

/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */

function all(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}
/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */

function bbox(extent, resolution) {
  return [extent];
}
/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number, import("./proj.js").Projection): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */

function tile(tileGrid) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj.js").Projection} projection Projection.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */
    function (extent, resolution, projection) {
      var z = tileGrid.getZForResolution((0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserResolution)(resolution, projection));
      var tileRange = tileGrid.getTileRangeForExtentAndZ((0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(extent, projection), z);
      /** @type {Array<import("./extent.js").Extent>} */

      var extents = [];
      /** @type {import("./tilecoord.js").TileCoord} */

      var tileCoord = [z, 0, 0];

      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
          extents.push((0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)(tileGrid.getTileCoordExtent(tileCoord), projection));
        }
      }

      return extents;
    }
  );
}

/***/ }),

/***/ "./build/wg/math.js":
/*!**************************!*\
  !*** ./build/wg/math.js ***!
  \**************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clamp": function() { return /* binding */ clamp; },
/* harmony export */   "cosh": function() { return /* binding */ cosh; },
/* harmony export */   "log2": function() { return /* binding */ log2; },
/* harmony export */   "squaredSegmentDistance": function() { return /* binding */ squaredSegmentDistance; },
/* harmony export */   "squaredDistance": function() { return /* binding */ squaredDistance; },
/* harmony export */   "solveLinearSystem": function() { return /* binding */ solveLinearSystem; },
/* harmony export */   "toDegrees": function() { return /* binding */ toDegrees; },
/* harmony export */   "toRadians": function() { return /* binding */ toRadians; },
/* harmony export */   "modulo": function() { return /* binding */ modulo; },
/* harmony export */   "lerp": function() { return /* binding */ lerp; },
/* harmony export */   "toFixed": function() { return /* binding */ toFixed; },
/* harmony export */   "round": function() { return /* binding */ round; },
/* harmony export */   "floor": function() { return /* binding */ floor; },
/* harmony export */   "ceil": function() { return /* binding */ ceil; }
/* harmony export */ });
/**
 * @module wg/math
 */

/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */

var cosh = function () {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var cosh;

  if ('cosh' in Math) {
    // The environment supports the native Math.cosh function, use it…
    cosh = Math.cosh;
  } else {
    // … else, use the reference implementation of MDN:
    cosh = function cosh(x) {
      var y =
      /** @type {Math} */
      Math.exp(x);
      return (y + 1 / y) / 2;
    };
  }

  return cosh;
}();
/**
 * Return the base 2 logarithm of a given number. The method will use the
 * native `Math.log2` function if it is available, otherwise the base 2
 * logarithm will be calculated via the reference implementation of the
 * Mozilla developer network.
 *
 * @param {number} x X.
 * @return {number} Base 2 logarithm of x.
 */

var log2 = function () {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var log2;

  if ('log2' in Math) {
    // The environment supports the native Math.log2 function, use it…
    log2 = Math.log2;
  } else {
    // … else, use the reference implementation of MDN:
    log2 = function log2(x) {
      return Math.log(x) * Math.LOG2E;
    };
  }

  return log2;
}();
/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */

function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;

  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }

  return squaredDistance(x, y, x1, y1);
}
/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */

function squaredDistance(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
}
/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>} The resulting vector.
 */

function solveLinearSystem(mat) {
  var n = mat.length;

  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);

    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);

      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    } // Swap max row with i-th (current) row


    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp; // Subtract the i-th row to make all the remaining rows 0 in the i-th column

    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];

      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  } // Solve Ax=b for upper triangular matrix A (mat)


  var x = new Array(n);

  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];

    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }

  return x;
}
/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */

function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}
/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */

function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */

function modulo(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
}
/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */

function lerp(a, b, x) {
  return a + x * (b - a);
}
/**
 * Returns a number with a limited number of decimal digits.
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The input number with a limited number of decimal digits.
 */

function toFixed(n, decimals) {
  var factor = Math.pow(10, decimals);
  return Math.round(n * factor) / factor;
}
/**
 * Rounds a number to the nearest integer value considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The nearest integer.
 */

function round(n, decimals) {
  return Math.round(toFixed(n, decimals));
}
/**
 * Rounds a number to the next smaller integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next smaller integer.
 */

function floor(n, decimals) {
  return Math.floor(toFixed(n, decimals));
}
/**
 * Rounds a number to the next bigger integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next bigger integer.
 */

function ceil(n, decimals) {
  return Math.ceil(toFixed(n, decimals));
}

/***/ }),

/***/ "./build/wg/net.js":
/*!*************************!*\
  !*** ./build/wg/net.js ***!
  \*************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "jsonp": function() { return /* binding */ jsonp; },
/* harmony export */   "ResponseError": function() { return /* binding */ ResponseError; },
/* harmony export */   "ClientError": function() { return /* binding */ ClientError; },
/* harmony export */   "getJSON": function() { return /* binding */ getJSON; },
/* harmony export */   "resolveUrl": function() { return /* binding */ resolveUrl; },
/* harmony export */   "overrideXHR": function() { return /* binding */ overrideXHR; },
/* harmony export */   "restoreXHR": function() { return /* binding */ restoreXHR; }
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./build/wg/util.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/net
 */



/**
 * Simple JSONP helper. Supports error callbacks and a custom callback param.
 * The error callback will be called when no JSONP is executed after 10 seconds.
 *
 * @param {string} url Request url. A 'callback' query parameter will be
 *     appended.
 * @param {Function} callback Callback on success.
 * @param {Function} [opt_errback] Callback on error.
 * @param {string} [opt_callbackParam] Custom query parameter for the JSONP
 *     callback. Default is 'callback'.
 */

function jsonp(url, callback, opt_errback, opt_callbackParam) {
  var script = document.createElement('script');
  var key = 'wgc_' + (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getUid)(callback);

  function cleanup() {
    delete window[key];
    script.parentNode.removeChild(script);
  }

  script.async = true;
  script.src = url + (url.indexOf('?') == -1 ? '?' : '&') + (opt_callbackParam || 'callback') + '=' + key;
  var timer = setTimeout(function () {
    cleanup();

    if (opt_errback) {
      opt_errback();
    }
  }, 10000);

  window[key] = function (data) {
    clearTimeout(timer);
    cleanup();
    callback(data);
  };

  document.getElementsByTagName('head')[0].appendChild(script);
}

var ResponseError =
/** @class */
function (_super) {
  __extends(ResponseError, _super);
  /**
   * @param {XMLHttpRequest} response The XHR object.
   */


  function ResponseError(response) {
    var _this = this;

    var message = 'Unexpected response status: ' + response.status;
    _this = _super.call(this, message) || this;
    /**
     * @type {string}
     */

    _this.name = 'ResponseError';
    /**
     * @type {XMLHttpRequest}
     */

    _this.response = response;
    return _this;
  }

  return ResponseError;
}(Error);



var ClientError =
/** @class */
function (_super) {
  __extends(ClientError, _super);
  /**
   * @param {XMLHttpRequest} client The XHR object.
   */


  function ClientError(client) {
    var _this = _super.call(this, 'Failed to issue request') || this;
    /**
     * @type {string}
     */


    _this.name = 'ClientError';
    /**
     * @type {XMLHttpRequest}
     */

    _this.client = client;
    return _this;
  }

  return ClientError;
}(Error);


/**
 * @param {string} url The URL.
 * @return {Promise<Object>} A promise that resolves to the JSON response.
 */

function getJSON(url) {
  return new Promise(function (resolve, reject) {
    /**
     * @param {ProgressEvent<XMLHttpRequest>} event The load event.
     */
    function onLoad(event) {
      var client = event.target; // status will be 0 for file:// urls

      if (!client.status || client.status >= 200 && client.status < 300) {
        var data = void 0;

        try {
          data = JSON.parse(client.responseText);
        } catch (err) {
          var message = 'Error parsing response text as JSON: ' + err.message;
          reject(new Error(message));
          return;
        }

        resolve(data);
        return;
      }

      reject(new ResponseError(client));
    }
    /**
     * @param {ProgressEvent<XMLHttpRequest>} event The error event.
     */


    function onError(event) {
      reject(new ClientError(event.target));
    }

    var client = new XMLHttpRequest();
    client.addEventListener('load', onLoad);
    client.addEventListener('error', onError);
    client.open('GET', url);
    client.setRequestHeader('Accept', 'application/json');
    client.send();
  });
}
/**
 * @param {string} base The base URL.
 * @param {string} url The potentially relative URL.
 * @return {string} The full URL.
 */

function resolveUrl(base, url) {
  if (url.indexOf('://') >= 0) {
    return url;
  }

  return new URL(url, base).href;
}
var originalXHR;
function overrideXHR(xhr) {
  if (typeof XMLHttpRequest !== 'undefined') {
    originalXHR = XMLHttpRequest;
  }

  global.XMLHttpRequest = xhr;
}
function restoreXHR() {
  global.XMLHttpRequest = originalXHR;
}

/***/ }),

/***/ "./build/wg/obj.js":
/*!*************************!*\
  !*** ./build/wg/obj.js ***!
  \*************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assign": function() { return /* binding */ assign; },
/* harmony export */   "clear": function() { return /* binding */ clear; },
/* harmony export */   "getValues": function() { return /* binding */ getValues; },
/* harmony export */   "isEmpty": function() { return /* binding */ isEmpty; }
/* harmony export */ });
/**
 * @module wg/obj
 */

/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
 *
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */
var assign = typeof Object.assign === 'function' ? Object.assign : function (target, var_sources) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);

  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments[i];

    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }

  return output;
};
/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */

function clear(object) {
  for (var property in object) {
    delete object[property];
  }
}
/**
 * Polyfill for Object.values().  Get an array of property values from an object.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values
 *
 * @param {!Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */

var getValues = typeof Object.values === 'function' ? Object.values : function (object) {
  var values = [];

  for (var property in object) {
    values.push(object[property]);
  }

  return values;
};
/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */

function isEmpty(object) {
  var property;

  for (property in object) {
    return false;
  }

  return !property;
}

/***/ }),

/***/ "./build/wg/pointer/EventType.js":
/*!***************************************!*\
  !*** ./build/wg/pointer/EventType.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/pointer/EventType
 */

/**
 * Constants for event names.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
});

/***/ }),

/***/ "./build/wg/proj.js":
/*!**************************!*\
  !*** ./build/wg/proj.js ***!
  \**************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "METERS_PER_UNIT": function() { return /* reexport safe */ _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT; },
/* harmony export */   "Projection": function() { return /* reexport safe */ _proj_Projection_js__WEBPACK_IMPORTED_MODULE_1__["default"]; },
/* harmony export */   "disableCoordinateWarning": function() { return /* binding */ disableCoordinateWarning; },
/* harmony export */   "cloneTransform": function() { return /* binding */ cloneTransform; },
/* harmony export */   "identityTransform": function() { return /* binding */ identityTransform; },
/* harmony export */   "addProjection": function() { return /* binding */ addProjection; },
/* harmony export */   "addProjections": function() { return /* binding */ addProjections; },
/* harmony export */   "get": function() { return /* binding */ get; },
/* harmony export */   "getPointResolution": function() { return /* binding */ getPointResolution; },
/* harmony export */   "addEquivalentProjections": function() { return /* binding */ addEquivalentProjections; },
/* harmony export */   "addEquivalentTransforms": function() { return /* binding */ addEquivalentTransforms; },
/* harmony export */   "clearAllProjections": function() { return /* binding */ clearAllProjections; },
/* harmony export */   "createProjection": function() { return /* binding */ createProjection; },
/* harmony export */   "createTransformFromCoordinateTransform": function() { return /* binding */ createTransformFromCoordinateTransform; },
/* harmony export */   "addCoordinateTransforms": function() { return /* binding */ addCoordinateTransforms; },
/* harmony export */   "fromLonLat": function() { return /* binding */ fromLonLat; },
/* harmony export */   "toLonLat": function() { return /* binding */ toLonLat; },
/* harmony export */   "equivalent": function() { return /* binding */ equivalent; },
/* harmony export */   "getTransformFromProjections": function() { return /* binding */ getTransformFromProjections; },
/* harmony export */   "getTransform": function() { return /* binding */ getTransform; },
/* harmony export */   "transform": function() { return /* binding */ transform; },
/* harmony export */   "transformExtent": function() { return /* binding */ transformExtent; },
/* harmony export */   "transformWithProjections": function() { return /* binding */ transformWithProjections; },
/* harmony export */   "setUserProjection": function() { return /* binding */ setUserProjection; },
/* harmony export */   "clearUserProjection": function() { return /* binding */ clearUserProjection; },
/* harmony export */   "getUserProjection": function() { return /* binding */ getUserProjection; },
/* harmony export */   "useGeographic": function() { return /* binding */ useGeographic; },
/* harmony export */   "toUserCoordinate": function() { return /* binding */ toUserCoordinate; },
/* harmony export */   "fromUserCoordinate": function() { return /* binding */ fromUserCoordinate; },
/* harmony export */   "toUserExtent": function() { return /* binding */ toUserExtent; },
/* harmony export */   "fromUserExtent": function() { return /* binding */ fromUserExtent; },
/* harmony export */   "toUserResolution": function() { return /* binding */ toUserResolution; },
/* harmony export */   "fromUserResolution": function() { return /* binding */ fromUserResolution; },
/* harmony export */   "createSafeCoordinateTransform": function() { return /* binding */ createSafeCoordinateTransform; },
/* harmony export */   "addCommon": function() { return /* binding */ addCommon; }
/* harmony export */ });
/* harmony import */ var _proj_Projection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./proj/Projection.js */ "./build/wg/proj/Projection.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj/Units.js */ "./build/wg/proj/Units.js");
/* harmony import */ var _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./proj/epsg3857.js */ "./build/wg/proj/epsg3857.js");
/* harmony import */ var _proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./proj/epsg4326.js */ "./build/wg/proj/epsg4326.js");
/* harmony import */ var _proj_projections_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proj/projections.js */ "./build/wg/proj/projections.js");
/* harmony import */ var _proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proj/transforms.js */ "./build/wg/proj/transforms.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extent.js */ "./build/wg/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./math.js */ "./build/wg/math.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coordinate.js */ "./build/wg/coordinate.js");
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sphere.js */ "./build/wg/sphere.js");
/**
 * @module wg/proj
 */

/**
 * The ol/proj module stores:
 * * a list of {@link module:wg/proj/Projection~Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:wg/proj.addCoordinateTransforms}. To use this, you must first create
 * a {@link module:wg/proj/Projection~Projection} object for the new projection and add it with
 * {@link module:wg/proj.addProjection}. You can then add the forward and inverse
 * functions with {@link module:wg/proj.addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:wg/proj/Projection~Projection} with
 * {@link module:wg/proj.addProjection}. See examples/wms-no-proj for an example of
 * this.
 */










/**
 * A projection as {@link module:wg/proj/Projection~Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */

/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */



var showCoordinateWarning = true;
/**
 * @param {boolean} [opt_disable = true] Disable console info about `useGeographic()`
 */

function disableCoordinateWarning(opt_disable) {
  var hide = opt_disable === undefined ? true : opt_disable;
  showCoordinateWarning = !hide;
}
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */

function cloneTransform(input, opt_output, opt_dimension) {
  var output;

  if (opt_output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }

    output = opt_output;
  } else {
    output = input.slice();
  }

  return output;
}
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension.
 * @return {Array<number>} Input coordinate array (same array as input).
 */

function identityTransform(input, opt_output, opt_dimension) {
  if (opt_output !== undefined && input !== opt_output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }

    input = opt_output;
  }

  return input;
}
/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */

function addProjection(projection) {
  (0,_proj_projections_js__WEBPACK_IMPORTED_MODULE_2__.add)(projection.getCode(), projection);
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(projection, projection, cloneTransform);
}
/**
 * @param {Array<Projection>} projections Projections.
 */

function addProjections(projections) {
  projections.forEach(addProjection);
}
/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection|null} Projection object, or null if not in list.
 * @api
 */

function get(projectionLike) {
  return typeof projectionLike === 'string' ? (0,_proj_projections_js__WEBPACK_IMPORTED_MODULE_2__.get)(
  /** @type {string} */
  projectionLike) :
  /** @type {Projection} */
  projectionLike || null;
}
/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the `point` pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:wg/proj/Projection~Projection} constructor or by using
 * {@link module:wg/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {import("./proj/Units.js").default} [opt_units] Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */

function getPointResolution(projection, resolution, point, opt_units) {
  projection = get(projection);
  var pointResolution;
  var getter = projection.getPointResolutionFunc();

  if (getter) {
    pointResolution = getter(resolution, point);

    if (opt_units && opt_units !== projection.getUnits()) {
      var metersPerUnit = projection.getMetersPerUnit();

      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[opt_units];
      }
    }
  } else {
    var units = projection.getUnits();

    if (units == _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEGREES && !opt_units || opt_units == _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEGREES) {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      var toEPSG4326_1 = getTransformFromProjections(projection, get('EPSG:4326'));

      if (toEPSG4326_1 === identityTransform && units !== _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEGREES) {
        // no transform is available
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];
        vertices = toEPSG4326_1(vertices, vertices, 2);
        var width = (0,_sphere_js__WEBPACK_IMPORTED_MODULE_4__.getDistance)(vertices.slice(0, 2), vertices.slice(2, 4));
        var height = (0,_sphere_js__WEBPACK_IMPORTED_MODULE_4__.getDistance)(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }

      var metersPerUnit = opt_units ? _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();

      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }

  return pointResolution;
}
/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */

function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function (source) {
    projections.forEach(function (destination) {
      if (source !== destination) {
        (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(source, destination, cloneTransform);
      }
    });
  });
}
/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */

function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function (projection1) {
    projections2.forEach(function (projection2) {
      (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(projection1, projection2, forwardTransform);
      (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(projection2, projection1, inverseTransform);
    });
  });
}
/**
 * Clear all cached projections and transforms.
 */

function clearAllProjections() {
  (0,_proj_projections_js__WEBPACK_IMPORTED_MODULE_2__.clear)();
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.clear)();
}
/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */

function createProjection(projection, defaultCode) {
  if (!projection) {
    return get(defaultCode);
  } else if (typeof projection === 'string') {
    return get(projection);
  } else {
    return (
      /** @type {Projection} */
      projection
    );
  }
}
/**
 * Creates a {@link module:wg/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */

function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [opt_output] Output.
     * @param {number} [opt_dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function (input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension !== undefined ? opt_dimension : 2;
      var output = opt_output !== undefined ? opt_output : new Array(length);

      for (var i = 0; i < length; i += dimension) {
        var point = coordTransform([input[i], input[i + 1]]);
        output[i] = point[0];
        output[i + 1] = point[1];

        for (var j = dimension - 1; j >= 2; --j) {
          output[i + j] = input[i + j];
        }
      }

      return output;
    }
  );
}
/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:wg/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:wg/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:wg/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:wg/coordinate~Coordinate}.
 * @api
 */

function addCoordinateTransforms(source, destination, forward, inverse) {
  var sourceProj = get(source);
  var destProj = get(destination);
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}
/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike} [opt_projection] Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */

function fromLonLat(coordinate, opt_projection) {
  disableCoordinateWarning();
  return transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');
}
/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike} [opt_projection] Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */

function toLonLat(coordinate, opt_projection) {
  var lonLat = transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
  var lon = lonLat[0];

  if (lon < -180 || lon > 180) {
    lonLat[0] = (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.modulo)(lon + 180, 360) - 180;
  }

  return lonLat;
}
/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */

function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }

  var equalUnits = projection1.getUnits() === projection2.getUnits();

  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
  }
}
/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */

function getTransformFromProjections(sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transformFunc = (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.get)(sourceCode, destinationCode);

  if (!transformFunc) {
    transformFunc = identityTransform;
  }

  return transformFunc;
}
/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */

function getTransform(source, destination) {
  var sourceProjection = get(source);
  var destinationProjection = get(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:wg/proj.transformExtent} for extent transformation.
 * See the transform method of {@link module:wg/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */

function transform(coordinate, source, destination) {
  var transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, undefined, coordinate.length);
}
/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @param {number} [opt_stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */

function transformExtent(extent, source, destination, opt_stops) {
  var transformFunc = getTransform(source, destination);
  return (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.applyTransform)(extent, transformFunc, undefined, opt_stops);
}
/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */

function transformWithProjections(point, sourceProjection, destinationProjection) {
  var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
  return transformFunc(point);
}
/**
 * @type {Projection|null}
 */

var userProjection = null;
/**
 * Set the projection for coordinates supplied from and returned by API methods.
 * This includes all API methods except for those interacting with tile grids.
 * @param {ProjectionLike} projection The user projection.
 * @api
 */

function setUserProjection(projection) {
  userProjection = get(projection);
}
/**
 * Clear the user projection if set.
 * @api
 */

function clearUserProjection() {
  userProjection = null;
}
/**
 * Get the projection for coordinates supplied from and returned by API methods.
 * Note that this method is not yet a part of the stable API.  Support for user
 * projections is not yet complete and should be considered experimental.
 * @return {Projection|null} The user projection (or null if not set).
 * @api
 */

function getUserProjection() {
  return userProjection;
}
/**
 * Use geographic coordinates (WGS-84 datum) in API methods.  This includes all API
 * methods except for those interacting with tile grids.
 * @api
 */

function useGeographic() {
  setUserProjection('EPSG:4326');
}
/**
 * Return a coordinate transformed into the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} sourceProjection The input coordinate projection.
 * @return {Array<number>} The input coordinate in the user projection.
 */

function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }

  return transform(coordinate, sourceProjection, userProjection);
}
/**
 * Return a coordinate transformed from the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {Array<number>} The input coordinate transformed.
 */

function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (showCoordinateWarning && !(0,_coordinate_js__WEBPACK_IMPORTED_MODULE_7__.equals)(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false; // eslint-disable-next-line no-console

      console.warn('Call useGeographic() wg/proj once to work with [longitude, latitude] coordinates.');
    }

    return coordinate;
  }

  return transform(coordinate, userProjection, destProjection);
}
/**
 * Return an extent transformed into the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} sourceProjection The input extent projection.
 * @return {import("./extent.js").Extent} The input extent in the user projection.
 */

function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }

  return transformExtent(extent, sourceProjection, userProjection);
}
/**
 * Return an extent transformed from the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {import("./extent.js").Extent} The input extent transformed.
 */

function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }

  return transformExtent(extent, userProjection, destProjection);
}
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in input projection units per pixel.
 * @param {ProjectionLike} sourceProjection The input projection.
 * @return {number} Resolution in user projection units per pixel.
 */

function toUserResolution(resolution, sourceProjection) {
  if (!userProjection) {
    return resolution;
  }

  var sourceUnits = get(sourceProjection).getUnits();
  var userUnits = userProjection.getUnits();
  return sourceUnits && userUnits ? resolution * _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[sourceUnits] / _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[userUnits] : resolution;
}
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in user projection units per pixel.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {number} Resolution in destination projection units per pixel.
 */

function fromUserResolution(resolution, destProjection) {
  if (!userProjection) {
    return resolution;
  }

  var sourceUnits = get(destProjection).getUnits();
  var userUnits = userProjection.getUnits();
  return sourceUnits && userUnits ? resolution * _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[userUnits] / _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[sourceUnits] : resolution;
}
/**
 * Creates a safe coordinate transform function from a coordinate transform function.
 * "Safe" means that it can handle wrapping of x-coordinates for global projections,
 * and that coordinates exceeding the source projection validity extent's range will be
 * clamped to the validity range.
 * @param {Projection} sourceProj Source projection.
 * @param {Projection} destProj Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destiation).
 * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destiation).
 */

function createSafeCoordinateTransform(sourceProj, destProj, transform) {
  return function (coord) {
    var sourceX = coord[0];
    var sourceY = coord[1];
    var transformed, worldsAway;

    if (sourceProj.canWrapX()) {
      var sourceExtent = sourceProj.getExtent();
      var sourceExtentWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.getWidth)(sourceExtent);
      worldsAway = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_7__.getWorldsAway)(coord, sourceProj, sourceExtentWidth);

      if (worldsAway) {
        // Move x to the real world
        sourceX = sourceX - worldsAway * sourceExtentWidth;
      }

      sourceX = (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.clamp)(sourceX, sourceExtent[0], sourceExtent[2]);
      sourceY = (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.clamp)(sourceY, sourceExtent[1], sourceExtent[3]);
      transformed = transform([sourceX, sourceY]);
    } else {
      transformed = transform(coord);
    }

    if (worldsAway && destProj.canWrapX()) {
      // Move transformed coordinate back to the offset world
      transformed[0] += worldsAway * (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.getWidth)(destProj.getExtent());
    }

    return transformed;
  };
}
/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */

function addCommon() {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  addEquivalentProjections(_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_8__.PROJECTIONS);
  addEquivalentProjections(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_9__.PROJECTIONS); // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.

  addEquivalentTransforms(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_9__.PROJECTIONS, _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_8__.PROJECTIONS, _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_8__.fromEPSG4326, _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_8__.toEPSG4326);
}
addCommon();

/***/ }),

/***/ "./build/wg/proj/Projection.js":
/*!*************************************!*\
  !*** ./build/wg/proj/Projection.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Units.js */ "./build/wg/proj/Units.js");
/**
 * @module wg/proj/Projection
 */

/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").default|string} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link module:wg/proj/Units~METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `number` view resolution and a {@link module:wg/coordinate~Coordinate Coordinate} as arguments, and returns
 * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:wg/proj.getPointResolution getPointResolution()} function will be used.
 */

/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:wg/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:wg/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:wg/proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:wg/proj/proj4.register} function.
 *
 * @api
 */

var Projection =
/** @class */
function () {
  /**
   * @param {Options} options Projection options.
   */
  function Projection(options) {
    /**
     * @private
     * @type {string}
     */
    this.code_ = options.code;
    /**
     * Units of projected coordinates. When set to `TILE_PIXELS`, a
     * `this.extent_` and `this.worldExtent_` must be configured properly for each
     * tile.
     * @private
     * @type {import("./Units.js").default}
     */

    this.units_ =
    /** @type {import("./Units.js").default} */
    options.units;
    /**
     * Validity extent of the projection in projected coordinates. For projections
     * with `TILE_PIXELS` units, this is the extent of the tile in
     * tile pixel space.
     * @private
     * @type {import("../extent.js").Extent}
     */

    this.extent_ = options.extent !== undefined ? options.extent : null;
    /**
     * Extent of the world in EPSG:4326. For projections with
     * `TILE_PIXELS` units, this is the extent of the tile in
     * projected coordinate space.
     * @private
     * @type {import("../extent.js").Extent}
     */

    this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;
    /**
     * @private
     * @type {string}
     */

    this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
    /**
     * @private
     * @type {boolean}
     */

    this.global_ = options.global !== undefined ? options.global : false;
    /**
     * @private
     * @type {boolean}
     */

    this.canWrapX_ = !!(this.global_ && this.extent_);
    /**
     * @private
     * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
     */

    this.getPointResolutionFunc_ = options.getPointResolution;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */

    this.defaultTileGrid_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    this.metersPerUnit_ = options.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */


  Projection.prototype.canWrapX = function () {
    return this.canWrapX_;
  };
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */


  Projection.prototype.getCode = function () {
    return this.code_;
  };
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  Projection.prototype.getExtent = function () {
    return this.extent_;
  };
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").default} Units.
   * @api
   */


  Projection.prototype.getUnits = function () {
    return this.units_;
  };
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */


  Projection.prototype.getMetersPerUnit = function () {
    return this.metersPerUnit_ || _Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[this.units_];
  };
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  Projection.prototype.getWorldExtent = function () {
    return this.worldExtent_;
  };
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */


  Projection.prototype.getAxisOrientation = function () {
    return this.axisOrientation_;
  };
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */


  Projection.prototype.isGlobal = function () {
    return this.global_;
  };
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */


  Projection.prototype.setGlobal = function (global) {
    this.global_ = global;
    this.canWrapX_ = !!(global && this.extent_);
  };
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */


  Projection.prototype.getDefaultTileGrid = function () {
    return this.defaultTileGrid_;
  };
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */


  Projection.prototype.setDefaultTileGrid = function (tileGrid) {
    this.defaultTileGrid_ = tileGrid;
  };
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */


  Projection.prototype.setExtent = function (extent) {
    this.extent_ = extent;
    this.canWrapX_ = !!(this.global_ && extent);
  };
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */


  Projection.prototype.setWorldExtent = function (worldExtent) {
    this.worldExtent_ = worldExtent;
  };
  /**
   * Set the getPointResolution function (see {@link module:wg/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */


  Projection.prototype.setGetPointResolution = function (func) {
    this.getPointResolutionFunc_ = func;
  };
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */


  Projection.prototype.getPointResolutionFunc = function () {
    return this.getPointResolutionFunc_;
  };

  return Projection;
}();

/* harmony default export */ __webpack_exports__["default"] = (Projection);

/***/ }),

/***/ "./build/wg/proj/Units.js":
/*!********************************!*\
  !*** ./build/wg/proj/Units.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fromCode": function() { return /* binding */ fromCode; },
/* harmony export */   "METERS_PER_UNIT": function() { return /* binding */ METERS_PER_UNIT; }
/* harmony export */ });
/**
 * @module wg/proj/Units
 */

/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */
var Units = {
  /**
   * Radians
   * @api
   */
  RADIANS: 'radians',

  /**
   * Degrees
   * @api
   */
  DEGREES: 'degrees',

  /**
   * Feet
   * @api
   */
  FEET: 'ft',

  /**
   * Meters
   * @api
   */
  METERS: 'm',

  /**
   * Pixels
   * @api
   */
  PIXELS: 'pixels',

  /**
   * Tile Pixels
   * @api
   */
  TILE_PIXELS: 'tile-pixels',

  /**
   * US Feet
   * @api
   */
  USFEET: 'us-ft'
};
/**
 * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt
 * @type {Object<number, Units>}
 */

var unitByCode = {
  '9001': Units.METERS,
  '9002': Units.FEET,
  '9003': Units.USFEET,
  '9101': Units.RADIANS,
  '9102': Units.DEGREES
};
/**
 * @param {number} code Unit code.
 * @return {Units} Units.
 */

function fromCode(code) {
  return unitByCode[code];
}
/**
 * Meters per unit lookup table.
 * @const
 * @type {Object<Units, number>}
 * @api
 */

var METERS_PER_UNIT = {}; // use the radius of the Normal sphere

METERS_PER_UNIT[Units.RADIANS] = 6370997 / (2 * Math.PI);
METERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
METERS_PER_UNIT[Units.FEET] = 0.3048;
METERS_PER_UNIT[Units.METERS] = 1;
METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;
/* harmony default export */ __webpack_exports__["default"] = (Units);

/***/ }),

/***/ "./build/wg/proj/epsg3857.js":
/*!***********************************!*\
  !*** ./build/wg/proj/epsg3857.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RADIUS": function() { return /* binding */ RADIUS; },
/* harmony export */   "HALF_SIZE": function() { return /* binding */ HALF_SIZE; },
/* harmony export */   "EXTENT": function() { return /* binding */ EXTENT; },
/* harmony export */   "WORLD_EXTENT": function() { return /* binding */ WORLD_EXTENT; },
/* harmony export */   "MAX_SAFE_Y": function() { return /* binding */ MAX_SAFE_Y; },
/* harmony export */   "PROJECTIONS": function() { return /* binding */ PROJECTIONS; },
/* harmony export */   "fromEPSG4326": function() { return /* binding */ fromEPSG4326; },
/* harmony export */   "toEPSG4326": function() { return /* binding */ toEPSG4326; }
/* harmony export */ });
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Projection.js */ "./build/wg/proj/Projection.js");
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Units.js */ "./build/wg/proj/Units.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/proj/epsg3857
 */





/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */

var RADIUS = 6378137;
/**
 * @const
 * @type {number}
 */

var HALF_SIZE = Math.PI * RADIUS;
/**
 * @const
 * @type {import("../extent.js").Extent}
 */

var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
/**
 * @const
 * @type {import("../extent.js").Extent}
 */

var WORLD_EXTENT = [-180, -85, 180, 85];
/**
 * Maximum safe value in y direction
 * @const
 * @type {number}
 */

var MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */

var EPSG3857Projection =
/** @class */
function (_super) {
  __extends(EPSG3857Projection, _super);
  /**
   * @param {string} code Code.
   */


  function EPSG3857Projection(code) {
    return _super.call(this, {
      code: code,
      units: _Units_js__WEBPACK_IMPORTED_MODULE_0__["default"].METERS,
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function getPointResolution(resolution, point) {
        return resolution / (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cosh)(point[1] / RADIUS);
      }
    }) || this;
  }

  return EPSG3857Projection;
}(_Projection_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */


var PROJECTIONS = [new EPSG3857Projection('EPSG:3857'), new EPSG3857Projection('EPSG:102100'), new EPSG3857Projection('EPSG:102113'), new EPSG3857Projection('EPSG:900913'), new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'), new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')];
/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */

function fromEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;

  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }

  for (var i = 0; i < length; i += dimension) {
    output[i] = HALF_SIZE * input[i] / 180;
    var y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));

    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }

    output[i + 1] = y;
  }

  return output;
}
/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */

function toEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;

  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }

  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }

  return output;
}

/***/ }),

/***/ "./build/wg/proj/epsg4326.js":
/*!***********************************!*\
  !*** ./build/wg/proj/epsg4326.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RADIUS": function() { return /* binding */ RADIUS; },
/* harmony export */   "EXTENT": function() { return /* binding */ EXTENT; },
/* harmony export */   "METERS_PER_UNIT": function() { return /* binding */ METERS_PER_UNIT; },
/* harmony export */   "PROJECTIONS": function() { return /* binding */ PROJECTIONS; }
/* harmony export */ });
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Projection.js */ "./build/wg/proj/Projection.js");
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Units.js */ "./build/wg/proj/Units.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/proj/epsg4326
 */




/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */

var RADIUS = 6378137;
/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {import("../extent.js").Extent}
 */

var EXTENT = [-180, -90, 180, 90];
/**
 * @const
 * @type {number}
 */

var METERS_PER_UNIT = Math.PI * RADIUS / 180;
/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */

var EPSG4326Projection =
/** @class */
function (_super) {
  __extends(EPSG4326Projection, _super);
  /**
   * @param {string} code Code.
   * @param {string} [opt_axisOrientation] Axis orientation.
   */


  function EPSG4326Projection(code, opt_axisOrientation) {
    return _super.call(this, {
      code: code,
      units: _Units_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEGREES,
      extent: EXTENT,
      axisOrientation: opt_axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT,
      worldExtent: EXTENT
    }) || this;
  }

  return EPSG4326Projection;
}(_Projection_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */


var PROJECTIONS = [new EPSG4326Projection('CRS:84'), new EPSG4326Projection('EPSG:4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'), new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'), new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'), new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'), new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu')];

/***/ }),

/***/ "./build/wg/proj/proj4.js":
/*!********************************!*\
  !*** ./build/wg/proj/proj4.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "register": function() { return /* binding */ register; }
/* harmony export */ });
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Projection.js */ "./build/wg/proj/Projection.js");
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Units.js */ "./build/wg/proj/Units.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _transforms_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transforms.js */ "./build/wg/proj/transforms.js");
/**
 * @module wg/proj/proj4
 */




/**
 * Make projections defined in proj4 (with `proj4.defs()`) available in
 * OpenLayers.
 *
 * This function should be called whenever changes are made to the proj4
 * registry, e.g. after calling `proj4.defs()`. Existing transforms will not be
 * modified by this function.
 *
 * @param {?} proj4 Proj4.
 * @api
 */

function register(proj4) {
  var projCodes = Object.keys(proj4.defs);
  var len = projCodes.length;
  var i, j;

  for (i = 0; i < len; ++i) {
    var code = projCodes[i];

    if (!(0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(code)) {
      var def = proj4.defs(code);
      var units = def.units;

      if (!units && def.projName === 'longlat') {
        units = _Units_js__WEBPACK_IMPORTED_MODULE_1__["default"].DEGREES;
      }

      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.addProjection)(new _Projection_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
        code: code,
        axisOrientation: def.axis,
        metersPerUnit: def.to_meter,
        units: units
      }));
    }
  }

  for (i = 0; i < len; ++i) {
    var code1 = projCodes[i];
    var proj1 = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(code1);

    for (j = 0; j < len; ++j) {
      var code2 = projCodes[j];
      var proj2 = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(code2);

      if (!(0,_transforms_js__WEBPACK_IMPORTED_MODULE_3__.get)(code1, code2)) {
        if (proj4.defs[code1] === proj4.defs[code2]) {
          (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.addEquivalentProjections)([proj1, proj2]);
        } else {
          var transform = proj4(code1, code2);
          (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.addCoordinateTransforms)(proj1, proj2, (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.createSafeCoordinateTransform)(proj1, proj2, transform.forward), (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.createSafeCoordinateTransform)(proj2, proj1, transform.inverse));
        }
      }
    }
  }
}

/***/ }),

/***/ "./build/wg/proj/projections.js":
/*!**************************************!*\
  !*** ./build/wg/proj/projections.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clear": function() { return /* binding */ clear; },
/* harmony export */   "get": function() { return /* binding */ get; },
/* harmony export */   "add": function() { return /* binding */ add; }
/* harmony export */ });
/**
 * @module wg/proj/projections
 */

/**
 * @type {Object<string, import("./Projection.js").default>}
 */
var cache = {};
/**
 * Clear the projections cache.
 */

function clear() {
  cache = {};
}
/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */

function get(code) {
  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] || null;
}
/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */

function add(code, projection) {
  cache[code] = projection;
}

/***/ }),

/***/ "./build/wg/proj/transforms.js":
/*!*************************************!*\
  !*** ./build/wg/proj/transforms.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clear": function() { return /* binding */ clear; },
/* harmony export */   "add": function() { return /* binding */ add; },
/* harmony export */   "remove": function() { return /* binding */ remove; },
/* harmony export */   "get": function() { return /* binding */ get; }
/* harmony export */ });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/**
 * @module wg/proj/transforms
 */

/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */

var transforms = {};
/**
 * Clear the transform cache.
 */

function clear() {
  transforms = {};
}
/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */

function add(source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();

  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }

  transforms[sourceCode][destinationCode] = transformFn;
}
/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */

function remove(source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];

  if ((0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }

  return transform;
}
/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */

function get(sourceCode, destinationCode) {
  var transform;

  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }

  return transform;
}

/***/ }),

/***/ "./build/wg/render.js":
/*!****************************!*\
  !*** ./build/wg/render.js ***!
  \****************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toContext": function() { return /* binding */ toContext; },
/* harmony export */   "getVectorContext": function() { return /* binding */ getVectorContext; },
/* harmony export */   "getRenderPixel": function() { return /* binding */ getRenderPixel; }
/* harmony export */ });
/* harmony import */ var _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./render/canvas/Immediate.js */ "./build/wg/render/canvas/Immediate.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./has.js */ "./build/wg/has.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transform.js */ "./build/wg/transform.js");
/* harmony import */ var _renderer_vector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderer/vector.js */ "./build/wg/renderer/vector.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./build/wg/proj.js");
/**
 * @module wg/render
 */





/**
 * @typedef {Object} State
 * @property {CanvasRenderingContext2D} context Canvas context that the layer is being rendered to.
 * @property {import("./Feature.js").FeatureLike} feature Feature.
 * @property {import("./geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} pixelRatio Pixel ratio used by the layer renderer.
 * @property {number} resolution Resolution that the render batch was created and optimized for.
 * This is not the view's resolution that is being rendered.
 * @property {number} rotation Rotation of the rendered layer in radians.
 */

/**
 * A function to be used when sorting features before rendering.
 * It takes two instances of {@link module:wg/Feature~Feature} or
 * {@link module:wg/render/Feature~RenderFeature} and returns a `{number}`.
 *
 * @typedef {function(import("./Feature.js").FeatureLike, import("./Feature.js").FeatureLike):number} OrderFunction
 */

/**
 * @typedef {Object} ToContextOptions
 * @property {import("./size.js").Size} [size] Desired size of the canvas in css
 * pixels. When provided, both canvas and css size will be set according to the
 * `pixelRatio`. If not provided, the current canvas and css sizes will not be
 * altered.
 * @property {number} [pixelRatio=window.devicePixelRatio] Pixel ratio (canvas
 * pixel to css pixel ratio) for the canvas.
 */

/**
 * Binds a Canvas Immediate API to a canvas context, to allow drawing geometries
 * to the context's canvas.
 *
 * The units for geometry coordinates are css pixels relative to the top left
 * corner of the canvas element.
 * ```js
 * import {toContext} from 'wg/render';
 * import Fill from 'wg/style/Fill';
 * import Polygon from 'wg/geom/Polygon';
 *
 * var canvas = document.createElement('canvas');
 * var render = toContext(canvas.getContext('2d'),
 *     { size: [100, 100] });
 * render.setFillStrokeStyle(new Fill({ color: blue }));
 * render.drawPolygon(
 *     new Polygon([[[0, 0], [100, 100], [100, 0], [0, 0]]]));
 * ```
 *
 * @param {CanvasRenderingContext2D} context Canvas context.
 * @param {ToContextOptions} [opt_options] Options.
 * @return {CanvasImmediateRenderer} Canvas Immediate.
 * @api
 */

function toContext(context, opt_options) {
  var canvas = context.canvas;
  var options = opt_options ? opt_options : {};
  var pixelRatio = options.pixelRatio || _has_js__WEBPACK_IMPORTED_MODULE_1__.DEVICE_PIXEL_RATIO;
  var size = options.size;

  if (size) {
    canvas.width = size[0] * pixelRatio;
    canvas.height = size[1] * pixelRatio;
    canvas.style.width = size[0] + 'px';
    canvas.style.height = size[1] + 'px';
  }

  var extent = [0, 0, canvas.width, canvas.height];
  var transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.scale)((0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)(), pixelRatio, pixelRatio);
  return new _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_3__["default"](context, pixelRatio, extent, transform, 0);
}
/**
 * Gets a vector context for drawing to the event's canvas.
 * @param {import("./render/Event.js").default} event Render event.
 * @return {CanvasImmediateRenderer} Vector context.
 * @api
 */

function getVectorContext(event) {
  if (!(event.context instanceof CanvasRenderingContext2D)) {
    throw new Error('Only works for render events from Canvas 2D layers');
  } // canvas may be at a different pixel ratio than frameState.pixelRatio


  var canvasPixelRatio = event.inversePixelTransform[0];
  var frameState = event.frameState;
  var transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.multiply)(event.inversePixelTransform.slice(), frameState.coordinateToPixelTransform);
  var squaredTolerance = (0,_renderer_vector_js__WEBPACK_IMPORTED_MODULE_4__.getSquaredTolerance)(frameState.viewState.resolution, canvasPixelRatio);
  var userTransform;
  var userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();

  if (userProjection) {
    userTransform = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransformFromProjections)(userProjection, frameState.viewState.projection);
  }

  return new _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_3__["default"](event.context, canvasPixelRatio, frameState.extent, transform, frameState.viewState.rotation, squaredTolerance, userTransform);
}
/**
 * Gets the pixel of the event's canvas context from the map viewport's CSS pixel.
 * @param {import("./render/Event.js").default} event Render event.
 * @param {import("./pixel.js").Pixel} pixel CSS pixel relative to the top-left
 * corner of the map viewport.
 * @return {import("./pixel.js").Pixel} Pixel on the event's canvas context.
 * @api
 */

function getRenderPixel(event, pixel) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(event.inversePixelTransform, pixel.slice(0));
}

/***/ }),

/***/ "./build/wg/render/Box.js":
/*!********************************!*\
  !*** ./build/wg/render/Box.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Disposable.js */ "./build/wg/Disposable.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geom/Polygon.js */ "./build/wg/geom/Polygon.js");
/**
 * @module wg/render/Box
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();




var RenderBox =
/** @class */
function (_super) {
  __extends(RenderBox, _super);
  /**
   * @param {string} className CSS class name.
   */


  function RenderBox(className) {
    var _this = _super.call(this) || this;
    /**
     * @type {import("../geom/Polygon.js").default}
     * @private
     */


    _this.geometry_ = null;
    /**
     * @type {HTMLDivElement}
     * @private
     */

    _this.element_ = document.createElement('div');
    _this.element_.style.position = 'absolute';
    _this.element_.style.pointerEvents = 'auto';
    _this.element_.className = 'wg-box ' + className;
    /**
     * @private
     * @type {import("../PluggableMap.js").default|null}
     */

    _this.map_ = null;
    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */

    _this.startPixel_ = null;
    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */

    _this.endPixel_ = null;
    return _this;
  }
  /**
   * Clean up.
   */


  RenderBox.prototype.disposeInternal = function () {
    this.setMap(null);
  };
  /**
   * @private
   */


  RenderBox.prototype.render_ = function () {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var px = 'px';
    var style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  };
  /**
   * @param {import("../PluggableMap.js").default|null} map Map.
   */


  RenderBox.prototype.setMap = function (map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      var style = this.element_.style;
      style.left = 'inherit';
      style.top = 'inherit';
      style.width = 'inherit';
      style.height = 'inherit';
    }

    this.map_ = map;

    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  };
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */


  RenderBox.prototype.setPixels = function (startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  };
  /**
   * Creates or updates the cached geometry.
   */


  RenderBox.prototype.createOrUpdateGeometry = function () {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var pixels = [startPixel, [startPixel[0], endPixel[1]], endPixel, [endPixel[0], startPixel[1]]];
    var coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_); // close the polygon

    coordinates[4] = coordinates[0].slice();

    if (!this.geometry_) {
      this.geometry_ = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_0__["default"]([coordinates]);
    } else {
      this.geometry_.setCoordinates([coordinates]);
    }
  };
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */


  RenderBox.prototype.getGeometry = function () {
    return this.geometry_;
  };

  return RenderBox;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (RenderBox);

/***/ }),

/***/ "./build/wg/render/Event.js":
/*!**********************************!*\
  !*** ./build/wg/render/Event.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./build/wg/events/Event.js");
/**
 * @module wg/render/Event
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();



var RenderEvent =
/** @class */
function (_super) {
  __extends(RenderEvent, _super);
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [opt_inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../PluggableMap.js").FrameState} [opt_frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [opt_context] Context.
   */


  function RenderEvent(type, opt_inversePixelTransform, opt_frameState, opt_context) {
    var _this = _super.call(this, type) || this;
    /**
     * Transform from CSS pixels (relative to the top-left corner of the map viewport)
     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.
     * @type {import("../transform.js").Transform|undefined}
     * @api
     */


    _this.inversePixelTransform = opt_inversePixelTransform;
    /**
     * An object representing the current render frame state.
     * @type {import("../PluggableMap.js").FrameState|undefined}
     * @api
     */

    _this.frameState = opt_frameState;
    /**
     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,
     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL
     * context.
     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}
     * @api
     */

    _this.context = opt_context;
    return _this;
  }

  return RenderEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (RenderEvent);

/***/ }),

/***/ "./build/wg/render/EventType.js":
/*!**************************************!*\
  !*** ./build/wg/render/EventType.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/render/EventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered before a layer is rendered.
   * @event module:wg/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: 'prerender',

  /**
   * Triggered after a layer is rendered.
   * @event module:wg/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:wg/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: 'precompose',

  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:wg/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: 'postcompose',

  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:wg/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: 'rendercomplete'
});
/**
 * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes
 */

/**
 * @typedef {'postrender'|'prerender'} LayerRenderEventTypes
 */

/***/ }),

/***/ "./build/wg/render/Feature.js":
/*!************************************!*\
  !*** ./build/wg/render/Feature.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toGeometry": function() { return /* binding */ toGeometry; },
/* harmony export */   "toFeature": function() { return /* binding */ toFeature; }
/* harmony export */ });
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./build/wg/geom/GeometryLayout.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _geom_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _geom_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom.js */ "./build/wg/geom/MultiPoint.js");
/* harmony import */ var _geom_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom.js */ "./build/wg/geom/LineString.js");
/* harmony import */ var _geom_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom.js */ "./build/wg/geom/MultiLineString.js");
/* harmony import */ var _geom_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../geom.js */ "./build/wg/geom/MultiPolygon.js");
/* harmony import */ var _geom_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../geom.js */ "./build/wg/geom/Polygon.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/flat/interiorpoint.js */ "./build/wg/geom/flat/interiorpoint.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geom/flat/orient.js */ "./build/wg/geom/flat/orient.js");
/* harmony import */ var _geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/flat/interpolate.js */ "./build/wg/geom/flat/interpolate.js");
/* harmony import */ var _geom_flat_center_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/flat/center.js */ "./build/wg/geom/flat/center.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/flat/transform.js */ "./build/wg/geom/flat/transform.js");
/**
 * @module wg/render/Feature
 */













/**
 * @type {import("../transform.js").Transform}
 */

var tmpTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.create)();
/**
 * Lightweight, read-only, {@link module:wg/Feature~Feature} and {@link module:wg/geom/Geometry~Geometry} like
 * structure, optimized for vector tile rendering and styling. Geometry access
 * through the API is limited to getting the type and extent of the geometry.
 */

var RenderFeature =
/** @class */
function () {
  /**
   * @param {import("../geom/GeometryType.js").default} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>|Array<Array<number>>} ends Ends or Endss.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  function RenderFeature(type, flatCoordinates, ends, properties, id) {
    /**
     * @type {import("../style/Style.js").StyleFunction|undefined}
     */
    this.styleFunction;
    /**
     * @private
     * @type {import("../extent.js").Extent|undefined}
     */

    this.extent_;
    /**
     * @private
     * @type {number|string|undefined}
     */

    this.id_ = id;
    /**
     * @private
     * @type {import("../geom/GeometryType.js").default}
     */

    this.type_ = type;
    /**
     * @private
     * @type {Array<number>}
     */

    this.flatCoordinates_ = flatCoordinates;
    /**
     * @private
     * @type {Array<number>}
     */

    this.flatInteriorPoints_ = null;
    /**
     * @private
     * @type {Array<number>}
     */

    this.flatMidpoints_ = null;
    /**
     * @private
     * @type {Array<number>|Array<Array<number>>}
     */

    this.ends_ = ends;
    /**
     * @private
     * @type {Object<string, *>}
     */

    this.properties_ = properties;
  }
  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */


  RenderFeature.prototype.get = function (key) {
    return this.properties_[key];
  };
  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  RenderFeature.prototype.getExtent = function () {
    if (!this.extent_) {
      this.extent_ = this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINT ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.createOrUpdateFromCoordinate)(this.flatCoordinates_) : (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.createOrUpdateFromFlatCoordinates)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);
    }

    return this.extent_;
  };
  /**
   * @return {Array<number>} Flat interior points.
   */


  RenderFeature.prototype.getFlatInteriorPoint = function () {
    if (!this.flatInteriorPoints_) {
      var flatCenter = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getCenter)(this.getExtent());
      this.flatInteriorPoints_ = (0,_geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_4__.getInteriorPointOfArray)(this.flatCoordinates_, 0,
      /** @type {Array<number>} */
      this.ends_, 2, flatCenter, 0);
    }

    return this.flatInteriorPoints_;
  };
  /**
   * @return {Array<number>} Flat interior points.
   */


  RenderFeature.prototype.getFlatInteriorPoints = function () {
    if (!this.flatInteriorPoints_) {
      var flatCenters = (0,_geom_flat_center_js__WEBPACK_IMPORTED_MODULE_5__.linearRingss)(this.flatCoordinates_, 0,
      /** @type {Array<Array<number>>} */
      this.ends_, 2);
      this.flatInteriorPoints_ = (0,_geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_4__.getInteriorPointsOfMultiArray)(this.flatCoordinates_, 0,
      /** @type {Array<Array<number>>} */
      this.ends_, 2, flatCenters);
    }

    return this.flatInteriorPoints_;
  };
  /**
   * @return {Array<number>} Flat midpoint.
   */


  RenderFeature.prototype.getFlatMidpoint = function () {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = (0,_geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_6__.interpolatePoint)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);
    }

    return this.flatMidpoints_;
  };
  /**
   * @return {Array<number>} Flat midpoints.
   */


  RenderFeature.prototype.getFlatMidpoints = function () {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      var flatCoordinates = this.flatCoordinates_;
      var offset = 0;
      var ends =
      /** @type {Array<number>} */
      this.ends_;

      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        var midpoint = (0,_geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_6__.interpolatePoint)(flatCoordinates, offset, end, 2, 0.5);
        (0,_array_js__WEBPACK_IMPORTED_MODULE_7__.extend)(this.flatMidpoints_, midpoint);
        offset = end;
      }
    }

    return this.flatMidpoints_;
  };
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */


  RenderFeature.prototype.getId = function () {
    return this.id_;
  };
  /**
   * @return {Array<number>} Flat coordinates.
   */


  RenderFeature.prototype.getOrientedFlatCoordinates = function () {
    return this.flatCoordinates_;
  };
  /**
   * For API compatibility with {@link module:wg/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */


  RenderFeature.prototype.getGeometry = function () {
    return this;
  };
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */


  RenderFeature.prototype.getSimplifiedGeometry = function (squaredTolerance) {
    return this;
  };
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */


  RenderFeature.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {
    return this;
  };
  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */


  RenderFeature.prototype.getProperties = function () {
    return this.properties_;
  };
  /**
   * @return {number} Stride.
   */


  RenderFeature.prototype.getStride = function () {
    return 2;
  };
  /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */


  RenderFeature.prototype.getStyleFunction = function () {
    return this.styleFunction;
  };
  /**
   * Get the type of this feature's geometry.
   * @return {import("../geom/GeometryType.js").default} Geometry type.
   * @api
   */


  RenderFeature.prototype.getType = function () {
    return this.type_;
  };
  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */


  RenderFeature.prototype.transform = function (projection) {
    projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection);
    var pixelExtent = projection.getExtent();
    var projectedExtent = projection.getWorldExtent();

    if (pixelExtent && projectedExtent) {
      var scale = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getHeight)(projectedExtent) / (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getHeight)(pixelExtent);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.compose)(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
      (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_8__.transform2D)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);
    }
  };
  /**
   * @return {Array<number>|Array<Array<number>>} Ends or endss.
   */


  RenderFeature.prototype.getEnds = function () {
    return this.ends_;
  };

  return RenderFeature;
}();

RenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;
/**
 * @return {Array<number>} Flat coordinates.
 */

RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
/**
 * Create a geometry from an `ol/render/Feature`
 * @param {RenderFeature} renderFeature
 * Render Feature
 * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}
 * New geometry instance.
 * @api
 */

function toGeometry(renderFeature) {
  var geometryType = renderFeature.getType();

  switch (geometryType) {
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINT:
      return new _geom_js__WEBPACK_IMPORTED_MODULE_9__["default"](renderFeature.getFlatCoordinates());

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].MULTI_POINT:
      return new _geom_js__WEBPACK_IMPORTED_MODULE_10__["default"](renderFeature.getFlatCoordinates(), _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XY);

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].LINE_STRING:
      return new _geom_js__WEBPACK_IMPORTED_MODULE_12__["default"](renderFeature.getFlatCoordinates(), _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XY);

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].MULTI_LINE_STRING:
      return new _geom_js__WEBPACK_IMPORTED_MODULE_13__["default"](renderFeature.getFlatCoordinates(), _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XY,
      /** @type {Array<number>} */
      renderFeature.getEnds());

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POLYGON:
      var flatCoordinates = renderFeature.getFlatCoordinates();
      var ends =
      /** @type {Array<number>} */
      renderFeature.getEnds();
      var endss = (0,_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_14__.inflateEnds)(flatCoordinates, ends);
      return endss.length > 1 ? new _geom_js__WEBPACK_IMPORTED_MODULE_15__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XY, endss) : new _geom_js__WEBPACK_IMPORTED_MODULE_16__["default"](flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_11__["default"].XY, ends);

    default:
      throw new Error('Invalid geometry type:' + geometryType);
  }
}
/**
 * Create an `ol/Feature` from an `ol/render/Feature`
 * @param {RenderFeature} renderFeature RenderFeature
 * @param {string} [opt_geometryName='geometry'] Geometry name to use
 * when creating the Feature.
 * @return {Feature} Newly constructed `ol/Feature` with properties,
 * geometry, and id copied over.
 * @api
 */

function toFeature(renderFeature, opt_geometryName) {
  var id = renderFeature.getId();
  var geometry = toGeometry(renderFeature);
  var properties = renderFeature.getProperties();
  var feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_17__["default"]();

  if (opt_geometryName !== undefined) {
    feature.setGeometryName(opt_geometryName);
  }

  feature.setGeometry(geometry);

  if (id !== undefined) {
    feature.setId(id);
  }

  feature.setProperties(properties, true);
  return feature;
}
/* harmony default export */ __webpack_exports__["default"] = (RenderFeature);

/***/ }),

/***/ "./build/wg/render/VectorContext.js":
/*!******************************************!*\
  !*** ./build/wg/render/VectorContext.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/render/VectorContext
 */

/**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */
var VectorContext =
/** @class */
function () {
  function VectorContext() {}
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */


  VectorContext.prototype.drawCustom = function (geometry, feature, renderer, hitDetectionRenderer) {};
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */


  VectorContext.prototype.drawGeometry = function (geometry) {};
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */


  VectorContext.prototype.setStyle = function (style) {};
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   */


  VectorContext.prototype.drawCircle = function (circleGeometry, feature) {};
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   */


  VectorContext.prototype.drawFeature = function (feature, style) {};
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   */


  VectorContext.prototype.drawGeometryCollection = function (geometryCollectionGeometry, feature) {};
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawLineString = function (lineStringGeometry, feature) {};
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {};
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawMultiPoint = function (multiPointGeometry, feature) {};
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {};
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawPoint = function (pointGeometry, feature) {};
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawPolygon = function (polygonGeometry, feature) {};
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawText = function (geometry, feature) {};
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */


  VectorContext.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {};
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("./canvas.js").DeclutterImageWithText} [opt_declutterImageWithText] Shared data for combined decluttering with a text style.
   */


  VectorContext.prototype.setImageStyle = function (imageStyle, opt_declutterImageWithText) {};
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("./canvas.js").DeclutterImageWithText} [opt_declutterImageWithText] Shared data for combined decluttering with an image style.
   */


  VectorContext.prototype.setTextStyle = function (textStyle, opt_declutterImageWithText) {};

  return VectorContext;
}();

/* harmony default export */ __webpack_exports__["default"] = (VectorContext);

/***/ }),

/***/ "./build/wg/render/canvas.js":
/*!***********************************!*\
  !*** ./build/wg/render/canvas.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultFont": function() { return /* binding */ defaultFont; },
/* harmony export */   "defaultFillStyle": function() { return /* binding */ defaultFillStyle; },
/* harmony export */   "defaultLineCap": function() { return /* binding */ defaultLineCap; },
/* harmony export */   "defaultLineDash": function() { return /* binding */ defaultLineDash; },
/* harmony export */   "defaultLineDashOffset": function() { return /* binding */ defaultLineDashOffset; },
/* harmony export */   "defaultLineJoin": function() { return /* binding */ defaultLineJoin; },
/* harmony export */   "defaultMiterLimit": function() { return /* binding */ defaultMiterLimit; },
/* harmony export */   "defaultStrokeStyle": function() { return /* binding */ defaultStrokeStyle; },
/* harmony export */   "defaultTextAlign": function() { return /* binding */ defaultTextAlign; },
/* harmony export */   "defaultTextBaseline": function() { return /* binding */ defaultTextBaseline; },
/* harmony export */   "defaultPadding": function() { return /* binding */ defaultPadding; },
/* harmony export */   "defaultLineWidth": function() { return /* binding */ defaultLineWidth; },
/* harmony export */   "checkedFonts": function() { return /* binding */ checkedFonts; },
/* harmony export */   "labelCache": function() { return /* binding */ labelCache; },
/* harmony export */   "textHeights": function() { return /* binding */ textHeights; },
/* harmony export */   "registerFont": function() { return /* binding */ registerFont; },
/* harmony export */   "measureTextHeight": function() { return /* binding */ measureTextHeight; },
/* harmony export */   "measureTextWidth": function() { return /* binding */ measureTextWidth; },
/* harmony export */   "measureAndCacheTextWidth": function() { return /* binding */ measureAndCacheTextWidth; },
/* harmony export */   "getTextDimensions": function() { return /* binding */ getTextDimensions; },
/* harmony export */   "rotateAtOffset": function() { return /* binding */ rotateAtOffset; },
/* harmony export */   "drawImageOrLabel": function() { return /* binding */ drawImageOrLabel; }
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Object.js */ "./build/wg/Object.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/Target.js */ "./build/wg/events/Target.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../has.js */ "./build/wg/has.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom.js */ "./build/wg/dom.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../css.js */ "./build/wg/css.js");
/**
 * @module wg/render/canvas
 */






/**
 * @typedef {Object} FillState
 * @property {import("../colorlike.js").ColorLike} fillStyle FillStyle.
 */

/**
 * @typedef Label
 * @property {number} width Width.
 * @property {number} height Height.
 * @property {Array<string|number>} contextInstructions ContextInstructions.
 */

/**
 * @typedef {Object} FillStrokeState
 * @property {import("../colorlike.js").ColorLike} [currentFillStyle] Current FillStyle.
 * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle] Current StrokeStyle.
 * @property {CanvasLineCap} [currentLineCap] Current LineCap.
 * @property {Array<number>} currentLineDash Current LineDash.
 * @property {number} [currentLineDashOffset] Current LineDashOffset.
 * @property {CanvasLineJoin} [currentLineJoin] Current LineJoin.
 * @property {number} [currentLineWidth] Current LineWidth.
 * @property {number} [currentMiterLimit] Current MiterLimit.
 * @property {number} [lastStroke] Last stroke.
 * @property {import("../colorlike.js").ColorLike} [fillStyle] FillStyle.
 * @property {import("../colorlike.js").ColorLike} [strokeStyle] StrokeStyle.
 * @property {CanvasLineCap} [lineCap] LineCap.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} [lineDashOffset] LineDashOffset.
 * @property {CanvasLineJoin} [lineJoin] LineJoin.
 * @property {number} [lineWidth] LineWidth.
 * @property {number} [miterLimit] MiterLimit.
 */

/**
 * @typedef {Object} StrokeState
 * @property {CanvasLineCap} lineCap LineCap.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} lineWidth LineWidth.
 * @property {number} miterLimit MiterLimit.
 * @property {import("../colorlike.js").ColorLike} strokeStyle StrokeStyle.
 */

/**
 * @typedef {Object} TextState
 * @property {string} font Font.
 * @property {string} [textAlign] TextAlign.
 * @property {string} textBaseline TextBaseline.
 * @property {string} [placement] Placement.
 * @property {number} [maxAngle] MaxAngle.
 * @property {boolean} [overflow] Overflow.
 * @property {import("../style/Fill.js").default} [backgroundFill] BackgroundFill.
 * @property {import("../style/Stroke.js").default} [backgroundStroke] BackgroundStroke.
 * @property {import("../size.js").Size} [scale] Scale.
 * @property {Array<number>} [padding] Padding.
 */

/**
 * @typedef {Object} SerializableInstructions
 * @property {Array<*>} instructions The rendering instructions.
 * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
 * @property {Array<number>} coordinates The array of all coordinates.
 * @property {!Object<string, TextState>} [textStates] The text states (decluttering).
 * @property {!Object<string, FillState>} [fillStates] The fill states (decluttering).
 * @property {!Object<string, StrokeState>} [strokeStates] The stroke states (decluttering).
 */

/**
 * @typedef {Object<number, import("./canvas/Executor.js").ReplayImageOrLabelArgs>} DeclutterImageWithText
 */

/**
 * @const
 * @type {string}
 */

var defaultFont = '10px sans-serif';
/**
 * @const
 * @type {import("../colorlike.js").ColorLike}
 */

var defaultFillStyle = '#000';
/**
 * @const
 * @type {CanvasLineCap}
 */

var defaultLineCap = 'round';
/**
 * @const
 * @type {Array<number>}
 */

var defaultLineDash = [];
/**
 * @const
 * @type {number}
 */

var defaultLineDashOffset = 0;
/**
 * @const
 * @type {CanvasLineJoin}
 */

var defaultLineJoin = 'round';
/**
 * @const
 * @type {number}
 */

var defaultMiterLimit = 10;
/**
 * @const
 * @type {import("../colorlike.js").ColorLike}
 */

var defaultStrokeStyle = '#000';
/**
 * @const
 * @type {string}
 */

var defaultTextAlign = 'center';
/**
 * @const
 * @type {string}
 */

var defaultTextBaseline = 'middle';
/**
 * @const
 * @type {Array<number>}
 */

var defaultPadding = [0, 0, 0, 0];
/**
 * @const
 * @type {number}
 */

var defaultLineWidth = 1;
/**
 * @type {BaseObject}
 */

var checkedFonts = new _Object_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
/**
 * The label cache for text rendering. To change the default cache size of 2048
 * entries, use {@link module:wg/structs/LRUCache~LRUCache#setSize cache.setSize()}.
 * Deprecated - there is no label cache any more.
 * @type {?}
 * @api
 * @deprecated
 */

var labelCache = new _events_Target_js__WEBPACK_IMPORTED_MODULE_1__["default"]();

labelCache.setSize = function () {
  console.warn('labelCache is deprecated.'); //eslint-disable-line
};
/**
 * @type {CanvasRenderingContext2D}
 */


var measureContext = null;
/**
 * @type {string}
 */

var measureFont;
/**
 * @type {!Object<string, number>}
 */

var textHeights = {};
/**
 * Clears the label cache when a font becomes available.
 * @param {string} fontSpec CSS font spec.
 */

var registerFont = function () {
  var retries = 100;
  var size = '32px ';
  var referenceFonts = ['monospace', 'serif'];
  var len = referenceFonts.length;
  var text = "wmytzilWMYTZIL@#/&?$%10\uF013";
  var interval, referenceWidth;
  /**
   * @param {string} fontStyle Css font-style
   * @param {string} fontWeight Css font-weight
   * @param {*} fontFamily Css font-family
   * @return {boolean} Font with style and weight is available
   */

  function isAvailable(fontStyle, fontWeight, fontFamily) {
    var available = true;

    for (var i = 0; i < len; ++i) {
      var referenceFont = referenceFonts[i];
      referenceWidth = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + referenceFont, text);

      if (fontFamily != referenceFont) {
        var width = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + fontFamily + ',' + referenceFont, text); // If width and referenceWidth are the same, then the fallback was used
        // instead of the font we wanted, so the font is not available.

        available = available && width != referenceWidth;
      }
    }

    if (available) {
      return true;
    }

    return false;
  }

  function check() {
    var done = true;
    var fonts = checkedFonts.getKeys();

    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];

      if (checkedFonts.get(font) < retries) {
        if (isAvailable.apply(this, font.split('\n'))) {
          (0,_obj_js__WEBPACK_IMPORTED_MODULE_2__.clear)(textHeights); // Make sure that loaded fonts are picked up by Safari

          measureContext = null;
          measureFont = undefined;
          checkedFonts.set(font, retries);
        } else {
          checkedFonts.set(font, checkedFonts.get(font) + 1, true);
          done = false;
        }
      }
    }

    if (done) {
      clearInterval(interval);
      interval = undefined;
    }
  }

  return function (fontSpec) {
    var font = (0,_css_js__WEBPACK_IMPORTED_MODULE_3__.getFontParameters)(fontSpec);

    if (!font) {
      return;
    }

    var families = font.families;

    for (var i = 0, ii = families.length; i < ii; ++i) {
      var family = families[i];
      var key = font.style + '\n' + font.weight + '\n' + family;

      if (checkedFonts.get(key) === undefined) {
        checkedFonts.set(key, retries, true);

        if (!isAvailable(font.style, font.weight, family)) {
          checkedFonts.set(key, 0, true);

          if (interval === undefined) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
}();
/**
 * @param {string} font Font to use for measuring.
 * @return {import("../size.js").Size} Measurement.
 */

var measureTextHeight = function () {
  /**
   * @type {HTMLDivElement}
   */
  var measureElement;
  return function (fontSpec) {
    var height = textHeights[fontSpec];

    if (height == undefined) {
      if (_has_js__WEBPACK_IMPORTED_MODULE_4__.WORKER_OFFSCREEN_CANVAS) {
        var font = (0,_css_js__WEBPACK_IMPORTED_MODULE_3__.getFontParameters)(fontSpec);
        var metrics = measureText(fontSpec, 'Žg');
        var lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
        height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
      } else {
        if (!measureElement) {
          measureElement = document.createElement('div');
          measureElement.innerHTML = 'M';
          measureElement.style.minHeight = '0';
          measureElement.style.maxHeight = 'none';
          measureElement.style.height = 'auto';
          measureElement.style.padding = '0';
          measureElement.style.border = 'none';
          measureElement.style.position = 'absolute';
          measureElement.style.display = 'block';
          measureElement.style.left = '-99999px';
        }

        measureElement.style.font = fontSpec;
        document.body.appendChild(measureElement);
        height = measureElement.offsetHeight;
        document.body.removeChild(measureElement);
      }

      textHeights[fontSpec] = height;
    }

    return height;
  };
}();
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {TextMetrics} Text metrics.
 */

function measureText(font, text) {
  if (!measureContext) {
    measureContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_5__.createCanvasContext2D)(1, 1);
  }

  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }

  return measureContext.measureText(text);
}
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */


function measureTextWidth(font, text) {
  return measureText(font, text).width;
}
/**
 * Measure text width using a cache.
 * @param {string} font The font.
 * @param {string} text The text to measure.
 * @param {Object<string, number>} cache A lookup of cached widths by text.
 * @return {number} The text width.
 */

function measureAndCacheTextWidth(font, text, cache) {
  if (text in cache) {
    return cache[text];
  }

  var width = measureTextWidth(font, text);
  cache[text] = width;
  return width;
}
/**
 * @param {TextState} baseStyle Base style.
 * @param {Array<string>} chunks Text chunks to measure.
 * @return {{width: number, height: number, widths: Array<number>, heights: Array<number>, lineWidths: Array<number>}}} Text metrics.
 */

function getTextDimensions(baseStyle, chunks) {
  var widths = [];
  var heights = [];
  var lineWidths = [];
  var width = 0;
  var lineWidth = 0;
  var height = 0;
  var lineHeight = 0;

  for (var i = 0, ii = chunks.length; i <= ii; i += 2) {
    var text = chunks[i];

    if (text === '\n' || i === ii) {
      width = Math.max(width, lineWidth);
      lineWidths.push(lineWidth);
      lineWidth = 0;
      height += lineHeight;
      continue;
    }

    var font = chunks[i + 1] || baseStyle.font;
    var currentWidth = measureTextWidth(font, text);
    widths.push(currentWidth);
    lineWidth += currentWidth;
    var currentHeight = measureTextHeight(font);
    heights.push(currentHeight);
    lineHeight = Math.max(lineHeight, currentHeight);
  }

  return {
    width: width,
    height: height,
    widths: widths,
    heights: heights,
    lineWidths: lineWidths
  };
}
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */

function rotateAtOffset(context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
}
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {import("../size.js").Size} scale Scale.
 */

function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
  context.save();

  if (opacity !== 1) {
    context.globalAlpha *= opacity;
  }

  if (transform) {
    context.setTransform.apply(context, transform);
  }

  if (
  /** @type {*} */
  labelOrImage.contextInstructions) {
    // label
    context.translate(x, y);
    context.scale(scale[0], scale[1]);
    executeLabelInstructions(
    /** @type {Label} */
    labelOrImage, context);
  } else if (scale[0] < 0 || scale[1] < 0) {
    // flipped image
    context.translate(x, y);
    context.scale(scale[0], scale[1]);
    context.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    labelOrImage, originX, originY, w, h, 0, 0, w, h);
  } else {
    // if image not flipped translate and scale can be avoided
    context.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    labelOrImage, originX, originY, w, h, x, y, w * scale[0], h * scale[1]);
  }

  context.restore();
}
/**
 * @param {Label} label Label.
 * @param {CanvasRenderingContext2D} context Context.
 */

function executeLabelInstructions(label, context) {
  var contextInstructions = label.contextInstructions;

  for (var i = 0, ii = contextInstructions.length; i < ii; i += 2) {
    if (Array.isArray(contextInstructions[i + 1])) {
      context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
    } else {
      context[contextInstructions[i]] = contextInstructions[i + 1];
    }
  }
}

/***/ }),

/***/ "./build/wg/render/canvas/Builder.js":
/*!*******************************************!*\
  !*** ./build/wg/render/canvas/Builder.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction.js */ "./build/wg/render/canvas/Instruction.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extent/Relationship.js */ "./build/wg/extent/Relationship.js");
/* harmony import */ var _VectorContext_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../VectorContext.js */ "./build/wg/render/VectorContext.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../colorlike.js */ "./build/wg/colorlike.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../canvas.js */ "./build/wg/render/canvas.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../array.js */ "./build/wg/array.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geom/flat/inflate.js */ "./build/wg/geom/flat/inflate.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/render/canvas/Builder
 */












var CanvasBuilder =
/** @class */
function (_super) {
  __extends(CanvasBuilder, _super);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */


  function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    var _this = _super.call(this) || this;
    /**
     * @protected
     * @type {number}
     */


    _this.tolerance = tolerance;
    /**
     * @protected
     * @const
     * @type {import("../../extent.js").Extent}
     */

    _this.maxExtent = maxExtent;
    /**
     * @protected
     * @type {number}
     */

    _this.pixelRatio = pixelRatio;
    /**
     * @protected
     * @type {number}
     */

    _this.maxLineWidth = 0;
    /**
     * @protected
     * @const
     * @type {number}
     */

    _this.resolution = resolution;
    /**
     * @private
     * @type {Array<*>}
     */

    _this.beginGeometryInstruction1_ = null;
    /**
     * @private
     * @type {Array<*>}
     */

    _this.beginGeometryInstruction2_ = null;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    _this.bufferedMaxExtent_ = null;
    /**
     * @protected
     * @type {Array<*>}
     */

    _this.instructions = [];
    /**
     * @protected
     * @type {Array<number>}
     */

    _this.coordinates = [];
    /**
     * @private
     * @type {import("../../coordinate.js").Coordinate}
     */

    _this.tmpCoordinate_ = [];
    /**
     * @protected
     * @type {Array<*>}
     */

    _this.hitDetectionInstructions = [];
    /**
     * @protected
     * @type {import("../canvas.js").FillStrokeState}
     */

    _this.state =
    /** @type {import("../canvas.js").FillStrokeState} */
    {};
    return _this;
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */


  CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {
    var pixelRatio = this.pixelRatio;
    return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {
      return dash * pixelRatio;
    });
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */


  CanvasBuilder.prototype.appendFlatPointCoordinates = function (flatCoordinates, stride) {
    var extent = this.getBufferedMaxExtent();
    var tmpCoord = this.tmpCoordinate_;
    var coordinates = this.coordinates;
    var myEnd = coordinates.length;

    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      tmpCoord[0] = flatCoordinates[i];
      tmpCoord[1] = flatCoordinates[i + 1];

      if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.containsCoordinate)(extent, tmpCoord)) {
        coordinates[myEnd++] = tmpCoord[0];
        coordinates[myEnd++] = tmpCoord[1];
      }
    }

    return myEnd;
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */


  CanvasBuilder.prototype.appendFlatLineCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {
    var coordinates = this.coordinates;
    var myEnd = coordinates.length;
    var extent = this.getBufferedMaxExtent();

    if (skipFirst) {
      offset += stride;
    }

    var lastXCoord = flatCoordinates[offset];
    var lastYCoord = flatCoordinates[offset + 1];
    var nextCoord = this.tmpCoordinate_;
    var skipped = true;
    var i, lastRel, nextRel;

    for (i = offset + stride; i < end; i += stride) {
      nextCoord[0] = flatCoordinates[i];
      nextCoord[1] = flatCoordinates[i + 1];
      nextRel = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.coordinateRelationship)(extent, nextCoord);

      if (nextRel !== lastRel) {
        if (skipped) {
          coordinates[myEnd++] = lastXCoord;
          coordinates[myEnd++] = lastYCoord;
          skipped = false;
        }

        coordinates[myEnd++] = nextCoord[0];
        coordinates[myEnd++] = nextCoord[1];
      } else if (nextRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERSECTING) {
        coordinates[myEnd++] = nextCoord[0];
        coordinates[myEnd++] = nextCoord[1];
        skipped = false;
      } else {
        skipped = true;
      }

      lastXCoord = nextCoord[0];
      lastYCoord = nextCoord[1];
      lastRel = nextRel;
    } // Last coordinate equals first or only one point to append:


    if (closed && skipped || i === offset + stride) {
      coordinates[myEnd++] = lastXCoord;
      coordinates[myEnd++] = lastYCoord;
    }

    return myEnd;
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */


  CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
      builderEnds.push(builderEnd);
      offset = end;
    }

    return offset;
  };
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */


  CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer, hitDetectionRenderer) {
    this.beginGeometry(geometry, feature);
    var type = geometry.getType();
    var stride = geometry.getStride();
    var builderBegin = this.coordinates.length;
    var flatCoordinates, builderEnd, builderEnds, builderEndss;
    var offset;

    switch (type) {
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].MULTI_POLYGON:
        flatCoordinates =
        /** @type {import("../../geom/MultiPolygon.js").default} */
        geometry.getOrientedFlatCoordinates();
        builderEndss = [];
        var endss =
        /** @type {import("../../geom/MultiPolygon.js").default} */
        geometry.getEndss();
        offset = 0;

        for (var i = 0, ii = endss.length; i < ii; ++i) {
          var myEnds = [];
          offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
          builderEndss.push(myEnds);
        }

        this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM, builderBegin, builderEndss, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateMultiCoordinatesArray]);
        this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM, builderBegin, builderEndss, geometry, hitDetectionRenderer || renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateMultiCoordinatesArray]);
        break;

      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POLYGON:
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].MULTI_LINE_STRING:
        builderEnds = [];
        flatCoordinates = type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POLYGON ?
        /** @type {import("../../geom/Polygon.js").default} */
        geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
        offset = this.drawCustomCoordinates_(flatCoordinates, 0,
        /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
        geometry.getEnds(), stride, builderEnds);
        this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM, builderBegin, builderEnds, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinatesArray]);
        this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM, builderBegin, builderEnds, geometry, hitDetectionRenderer || renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinatesArray]);
        break;

      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].LINE_STRING:
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CIRCLE:
        flatCoordinates = geometry.getFlatCoordinates();
        builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
        this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM, builderBegin, builderEnd, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates]);
        this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates]);
        break;

      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].MULTI_POINT:
        flatCoordinates = geometry.getFlatCoordinates();
        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);

        if (builderEnd > builderBegin) {
          this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM, builderBegin, builderEnd, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates]);
          this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates]);
        }

        break;

      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINT:
        flatCoordinates = geometry.getFlatCoordinates();
        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
        builderEnd = this.coordinates.length;
        this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM, builderBegin, builderEnd, geometry, renderer]);
        this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer]);
        break;

      default:
    }

    this.endGeometry(feature);
  };
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {
    this.beginGeometryInstruction1_ = [_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].BEGIN_GEOMETRY, feature, 0, geometry];
    this.instructions.push(this.beginGeometryInstruction1_);
    this.beginGeometryInstruction2_ = [_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].BEGIN_GEOMETRY, feature, 0, geometry];
    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  };
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */


  CanvasBuilder.prototype.finish = function () {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  };
  /**
   * Reverse the hit detection instructions.
   */


  CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {
    var hitDetectionInstructions = this.hitDetectionInstructions; // step 1 - reverse array

    hitDetectionInstructions.reverse(); // step 2 - reverse instructions within geometry blocks

    var i;
    var n = hitDetectionInstructions.length;
    var instruction;
    var type;
    var begin = -1;

    for (i = 0; i < n; ++i) {
      instruction = hitDetectionInstructions[i];
      type =
      /** @type {import("./Instruction.js").default} */
      instruction[0];

      if (type == _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].END_GEOMETRY) {
        begin = i;
      } else if (type == _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].BEGIN_GEOMETRY) {
        instruction[2] = i;
        (0,_array_js__WEBPACK_IMPORTED_MODULE_5__.reverseSubArray)(this.hitDetectionInstructions, begin, i);
        begin = -1;
      }
    }
  };
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */


  CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
    var state = this.state;

    if (fillStyle) {
      var fillStyleColor = fillStyle.getColor();
      state.fillStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_6__.asColorLike)(fillStyleColor ? fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultFillStyle);
    } else {
      state.fillStyle = undefined;
    }

    if (strokeStyle) {
      var strokeStyleColor = strokeStyle.getColor();
      state.strokeStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_6__.asColorLike)(strokeStyleColor ? strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultStrokeStyle);
      var strokeStyleLineCap = strokeStyle.getLineCap();
      state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineCap;
      var strokeStyleLineDash = strokeStyle.getLineDash();
      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineDash;
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineDashOffset;
      var strokeStyleLineJoin = strokeStyle.getLineJoin();
      state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineJoin;
      var strokeStyleWidth = strokeStyle.getWidth();
      state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineWidth;
      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultMiterLimit;

      if (state.lineWidth > this.maxLineWidth) {
        this.maxLineWidth = state.lineWidth; // invalidate the buffered max extent cache

        this.bufferedMaxExtent_ = null;
      }
    } else {
      state.strokeStyle = undefined;
      state.lineCap = undefined;
      state.lineDash = null;
      state.lineDashOffset = undefined;
      state.lineJoin = undefined;
      state.lineWidth = undefined;
      state.miterLimit = undefined;
    }
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */


  CanvasBuilder.prototype.createFill = function (state) {
    var fillStyle = state.fillStyle;
    /** @type {Array<*>} */

    var fillInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_FILL_STYLE, fillStyle];

    if (typeof fillStyle !== 'string') {
      // Fill is a pattern or gradient - align it!
      fillInstruction.push(true);
    }

    return fillInstruction;
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */


  CanvasBuilder.prototype.applyStroke = function (state) {
    this.instructions.push(this.createStroke(state));
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */


  CanvasBuilder.prototype.createStroke = function (state) {
    return [_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */


  CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {
    var fillStyle = state.fillStyle;

    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
      if (fillStyle !== undefined) {
        this.instructions.push(createFill.call(this, state));
      }

      state.currentFillStyle = fillStyle;
    }
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */


  CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {
    var strokeStyle = state.strokeStyle;
    var lineCap = state.lineCap;
    var lineDash = state.lineDash;
    var lineDashOffset = state.lineDashOffset;
    var lineJoin = state.lineJoin;
    var lineWidth = state.lineWidth;
    var miterLimit = state.miterLimit;

    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !(0,_array_js__WEBPACK_IMPORTED_MODULE_5__.equals)(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
      if (strokeStyle !== undefined) {
        applyStroke.call(this, state);
      }

      state.currentStrokeStyle = strokeStyle;
      state.currentLineCap = lineCap;
      state.currentLineDash = lineDash;
      state.currentLineDashOffset = lineDashOffset;
      state.currentLineJoin = lineJoin;
      state.currentLineWidth = lineWidth;
      state.currentMiterLimit = miterLimit;
    }
  };
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasBuilder.prototype.endGeometry = function (feature) {
    this.beginGeometryInstruction1_[2] = this.instructions.length;
    this.beginGeometryInstruction1_ = null;
    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
    this.beginGeometryInstruction2_ = null;
    var endGeometryInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].END_GEOMETRY, feature];
    this.instructions.push(endGeometryInstruction);
    this.hitDetectionInstructions.push(endGeometryInstruction);
  };
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */


  CanvasBuilder.prototype.getBufferedMaxExtent = function () {
    if (!this.bufferedMaxExtent_) {
      this.bufferedMaxExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.clone)(this.maxExtent);

      if (this.maxLineWidth > 0) {
        var width = this.resolution * (this.maxLineWidth + 1) / 2;
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.buffer)(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
      }
    }

    return this.bufferedMaxExtent_;
  };

  return CanvasBuilder;
}(_VectorContext_js__WEBPACK_IMPORTED_MODULE_8__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CanvasBuilder);

/***/ }),

/***/ "./build/wg/render/canvas/BuilderGroup.js":
/*!************************************************!*\
  !*** ./build/wg/render/canvas/BuilderGroup.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Builder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Builder.js */ "./build/wg/render/canvas/Builder.js");
/* harmony import */ var _ImageBuilder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ImageBuilder.js */ "./build/wg/render/canvas/ImageBuilder.js");
/* harmony import */ var _LineStringBuilder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LineStringBuilder.js */ "./build/wg/render/canvas/LineStringBuilder.js");
/* harmony import */ var _PolygonBuilder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PolygonBuilder.js */ "./build/wg/render/canvas/PolygonBuilder.js");
/* harmony import */ var _TextBuilder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TextBuilder.js */ "./build/wg/render/canvas/TextBuilder.js");
/**
 * @module wg/render/canvas/BuilderGroup
 */





/**
 * @type {Object<import("./BuilderType").default, typeof Builder>}
 */

var BATCH_CONSTRUCTORS = {
  'Circle': _PolygonBuilder_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  'Default': _Builder_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  'Image': _ImageBuilder_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  'LineString': _LineStringBuilder_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  'Polygon': _PolygonBuilder_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  'Text': _TextBuilder_js__WEBPACK_IMPORTED_MODULE_4__["default"]
};

var BuilderGroup =
/** @class */
function () {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  function BuilderGroup(tolerance, maxExtent, resolution, pixelRatio) {
    /**
     * @private
     * @type {number}
     */
    this.tolerance_ = tolerance;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    this.maxExtent_ = maxExtent;
    /**
     * @private
     * @type {number}
     */

    this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {number}
     */

    this.resolution_ = resolution;
    /**
     * @private
     * @type {!Object<string, !Object<import("./BuilderType").default, Builder>>}
     */

    this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("./BuilderType").default, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */


  BuilderGroup.prototype.finish = function () {
    var builderInstructions = {};

    for (var zKey in this.buildersByZIndex_) {
      builderInstructions[zKey] = builderInstructions[zKey] || {};
      var builders = this.buildersByZIndex_[zKey];

      for (var builderKey in builders) {
        var builderInstruction = builders[builderKey].finish();
        builderInstructions[zKey][builderKey] = builderInstruction;
      }
    }

    return builderInstructions;
  };
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("./BuilderType.js").default} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */


  BuilderGroup.prototype.getBuilder = function (zIndex, builderType) {
    var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
    var replays = this.buildersByZIndex_[zIndexKey];

    if (replays === undefined) {
      replays = {};
      this.buildersByZIndex_[zIndexKey] = replays;
    }

    var replay = replays[builderType];

    if (replay === undefined) {
      var Constructor = BATCH_CONSTRUCTORS[builderType];
      replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
      replays[builderType] = replay;
    }

    return replay;
  };

  return BuilderGroup;
}();

/* harmony default export */ __webpack_exports__["default"] = (BuilderGroup);

/***/ }),

/***/ "./build/wg/render/canvas/BuilderType.js":
/*!***********************************************!*\
  !*** ./build/wg/render/canvas/BuilderType.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/render/canvas/BuilderType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  CIRCLE: 'Circle',
  DEFAULT: 'Default',
  IMAGE: 'Image',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  TEXT: 'Text'
});

/***/ }),

/***/ "./build/wg/render/canvas/Executor.js":
/*!********************************************!*\
  !*** ./build/wg/render/canvas/Executor.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Instruction.js */ "./build/wg/render/canvas/Instruction.js");
/* harmony import */ var _TextBuilder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextBuilder.js */ "./build/wg/render/canvas/TextBuilder.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../has.js */ "./build/wg/has.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../canvas.js */ "./build/wg/render/canvas.js");
/* harmony import */ var _geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../geom/flat/textpath.js */ "./build/wg/geom/flat/textpath.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../array.js */ "./build/wg/array.js");
/* harmony import */ var _geom_flat_length_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../geom/flat/length.js */ "./build/wg/geom/flat/length.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./build/wg/geom/flat/transform.js");
/**
 * @module wg/render/canvas/Executor
 */










/**
 * @typedef {Object} BBox
 * @property {number} minX Minimal x.
 * @property {number} minY Minimal y.
 * @property {number} maxX Maximal x.
 * @property {number} maxY Maximal y
 * @property {*} value Value.
 */

/**
 * @typedef {Object} ImageOrLabelDimensions
 * @property {number} drawImageX DrawImageX.
 * @property {number} drawImageY DrawImageY.
 * @property {number} drawImageW DrawImageW.
 * @property {number} drawImageH DrawImageH.
 * @property {number} originX OriginX.
 * @property {number} originY OriginY.
 * @property {Array<number>} scale Scale.
 * @property {BBox} declutterBox DeclutterBox.
 * @property {import("../../transform.js").Transform} canvasTransform CanvasTransform.
 */

/**
 * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs
 */

/**
 * @template T
 * @typedef {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default): T} FeatureCallback
 */

/**
 * @type {import("../../extent.js").Extent}
 */

var tmpExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createEmpty)();
/** @type {import("../../coordinate.js").Coordinate} */

var p1 = [];
/** @type {import("../../coordinate.js").Coordinate} */

var p2 = [];
/** @type {import("../../coordinate.js").Coordinate} */

var p3 = [];
/** @type {import("../../coordinate.js").Coordinate} */

var p4 = [];
/**
 * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel
 * @return {BBox} Declutter bbox.
 */

function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}

var rtlRegEx = new RegExp(
/* eslint-disable prettier/prettier */
'[' + String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) + String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) + String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) + String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) + String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) + ']'
/* eslint-enable prettier/prettier */
);
/**
 * @param {string} text Text.
 * @param {string} align Alignment.
 * @return {number} Text alignment.
 */

function horizontalTextAlign(text, align) {
  if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {
    align = align === 'start' ? 'left' : 'right';
  }

  return _TextBuilder_js__WEBPACK_IMPORTED_MODULE_1__.TEXT_ALIGN[align];
}
/**
 * @param {Array<string>} acc Accumulator.
 * @param {string} line Line of text.
 * @param {number} i Index
 * @return {Array<string>} Accumulator.
 */


function createTextChunks(acc, line, i) {
  if (i > 0) {
    acc.push('\n', '');
  }

  acc.push(line, '');
  return acc;
}

var Executor =
/** @class */
function () {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
   */
  function Executor(resolution, pixelRatio, overlaps, instructions) {
    /**
     * @protected
     * @type {boolean}
     */
    this.overlaps = overlaps;
    /**
     * @protected
     * @type {number}
     */

    this.pixelRatio = pixelRatio;
    /**
     * @protected
     * @const
     * @type {number}
     */

    this.resolution = resolution;
    /**
     * @private
     * @type {boolean}
     */

    this.alignFill_;
    /**
     * @protected
     * @type {Array<*>}
     */

    this.instructions = instructions.instructions;
    /**
     * @protected
     * @type {Array<number>}
     */

    this.coordinates = instructions.coordinates;
    /**
     * @private
     * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
     */

    this.coordinateCache_ = {};
    /**
     * @private
     * @type {!import("../../transform.js").Transform}
     */

    this.renderedTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();
    /**
     * @protected
     * @type {Array<*>}
     */

    this.hitDetectionInstructions = instructions.hitDetectionInstructions;
    /**
     * @private
     * @type {Array<number>}
     */

    this.pixelCoordinates_ = null;
    /**
     * @private
     * @type {number}
     */

    this.viewRotation_ = 0;
    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */

    this.fillStates = instructions.fillStates || {};
    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */

    this.strokeStates = instructions.strokeStates || {};
    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */

    this.textStates = instructions.textStates || {};
    /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */

    this.widths_ = {};
    /**
     * @private
     * @type {Object<string, import("../canvas.js").Label>}
     */

    this.labels_ = {};
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */


  Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {
    var key = text + textKey + fillKey + strokeKey;

    if (this.labels_[key]) {
      return this.labels_[key];
    }

    var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
    var fillState = fillKey ? this.fillStates[fillKey] : null;
    var textState = this.textStates[textKey];
    var pixelRatio = this.pixelRatio;
    var scale = [textState.scale[0] * pixelRatio, textState.scale[1] * pixelRatio];
    var textIsArray = Array.isArray(text);
    var align = horizontalTextAlign(textIsArray ? text[0] : text, textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultTextAlign);
    var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
    var chunks = textIsArray ? text : text.split('\n').reduce(createTextChunks, []);

    var _a = (0,_canvas_js__WEBPACK_IMPORTED_MODULE_3__.getTextDimensions)(textState, chunks),
        width = _a.width,
        height = _a.height,
        widths = _a.widths,
        heights = _a.heights,
        lineWidths = _a.lineWidths;

    var renderWidth = width + strokeWidth;
    var contextInstructions = []; // make canvas 2 pixels wider to account for italic text width measurement errors

    var w = (renderWidth + 2) * scale[0];
    var h = (height + strokeWidth) * scale[1];
    /** @type {import("../canvas.js").Label} */

    var label = {
      width: w < 0 ? Math.floor(w) : Math.ceil(w),
      height: h < 0 ? Math.floor(h) : Math.ceil(h),
      contextInstructions: contextInstructions
    };

    if (scale[0] != 1 || scale[1] != 1) {
      contextInstructions.push('scale', scale);
    }

    if (strokeKey) {
      contextInstructions.push('strokeStyle', strokeState.strokeStyle);
      contextInstructions.push('lineWidth', strokeWidth);
      contextInstructions.push('lineCap', strokeState.lineCap);
      contextInstructions.push('lineJoin', strokeState.lineJoin);
      contextInstructions.push('miterLimit', strokeState.miterLimit); // eslint-disable-next-line

      var Context = _has_js__WEBPACK_IMPORTED_MODULE_4__.WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;

      if (Context.prototype.setLineDash) {
        contextInstructions.push('setLineDash', [strokeState.lineDash]);
        contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);
      }
    }

    if (fillKey) {
      contextInstructions.push('fillStyle', fillState.fillStyle);
    }

    contextInstructions.push('textBaseline', 'middle');
    contextInstructions.push('textAlign', 'center');
    var leftRight = 0.5 - align;
    var x = align * renderWidth + leftRight * strokeWidth;
    var strokeInstructions = [];
    var fillInstructions = [];
    var lineHeight = 0;
    var lineOffset = 0;
    var widthHeightIndex = 0;
    var lineWidthIndex = 0;
    var previousFont;

    for (var i = 0, ii = chunks.length; i < ii; i += 2) {
      var text_1 = chunks[i];

      if (text_1 === '\n') {
        lineOffset += lineHeight;
        lineHeight = 0;
        x = align * renderWidth + leftRight * strokeWidth;
        ++lineWidthIndex;
        continue;
      }

      var font = chunks[i + 1] || textState.font;

      if (font !== previousFont) {
        if (strokeKey) {
          strokeInstructions.push('font', font);
        }

        if (fillKey) {
          fillInstructions.push('font', font);
        }

        previousFont = font;
      }

      lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
      var fillStrokeArgs = [text_1, x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]), 0.5 * (strokeWidth + lineHeight) + lineOffset];
      x += widths[widthHeightIndex];

      if (strokeKey) {
        strokeInstructions.push('strokeText', fillStrokeArgs);
      }

      if (fillKey) {
        fillInstructions.push('fillText', fillStrokeArgs);
      }

      ++widthHeightIndex;
    }

    Array.prototype.push.apply(contextInstructions, strokeInstructions);
    Array.prototype.push.apply(contextInstructions, fillInstructions);
    this.labels_[key] = label;
    return label;
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */


  Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
    context.beginPath();
    context.moveTo.apply(context, p1);
    context.lineTo.apply(context, p2);
    context.lineTo.apply(context, p3);
    context.lineTo.apply(context, p4);
    context.lineTo.apply(context, p1);

    if (fillInstruction) {
      this.alignFill_ =
      /** @type {boolean} */
      fillInstruction[2];
      this.fill_(context);
    }

    if (strokeInstruction) {
      this.setStrokeStyle_(context,
      /** @type {Array<*>} */
      strokeInstruction);
      context.stroke();
    }
  };
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */


  Executor.prototype.calculateImageOrLabelDimensions_ = function (sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {
    anchorX *= scale[0];
    anchorY *= scale[1];
    var x = centerX - anchorX;
    var y = centerY - anchorY;
    var w = width + originX > sheetWidth ? sheetWidth - originX : width;
    var h = height + originY > sheetHeight ? sheetHeight - originY : height;
    var boxW = padding[3] + w * scale[0] + padding[1];
    var boxH = padding[0] + h * scale[1] + padding[2];
    var boxX = x - padding[3];
    var boxY = y - padding[0];

    if (fillStroke || rotation !== 0) {
      p1[0] = boxX;
      p4[0] = boxX;
      p1[1] = boxY;
      p2[1] = boxY;
      p2[0] = boxX + boxW;
      p3[0] = p2[0];
      p3[1] = boxY + boxH;
      p4[1] = p3[1];
    }

    var transform;

    if (rotation !== 0) {
      transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.compose)((0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(transform, p1);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(transform, p2);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(transform, p3);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(transform, p4);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createOrUpdate)(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
    } else {
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createOrUpdate)(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);
    }

    if (snapToPixel) {
      x = Math.round(x);
      y = Math.round(y);
    }

    return {
      drawImageX: x,
      drawImageY: y,
      drawImageW: w,
      drawImageH: h,
      originX: originX,
      originY: originY,
      declutterBox: {
        minX: tmpExtent[0],
        minY: tmpExtent[1],
        maxX: tmpExtent[2],
        maxY: tmpExtent[3],
        value: feature
      },
      canvasTransform: transform,
      scale: scale
    };
  };
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */


  Executor.prototype.replayImageOrLabel_ = function (context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {
    var fillStroke = !!(fillInstruction || strokeInstruction);
    var box = dimensions.declutterBox;
    var canvas = context.canvas;
    var strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;
    var intersects = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;

    if (intersects) {
      if (fillStroke) {
        this.replayTextBackground_(context, p1, p2, p3, p4,
        /** @type {Array<*>} */
        fillInstruction,
        /** @type {Array<*>} */
        strokeInstruction);
      }

      (0,_canvas_js__WEBPACK_IMPORTED_MODULE_3__.drawImageOrLabel)(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
    }

    return true;
  };
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */


  Executor.prototype.fill_ = function (context) {
    if (this.alignFill_) {
      var origin_1 = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(this.renderedTransform_, [0, 0]);
      var repeatSize = 512 * this.pixelRatio;
      context.save();
      context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);
      context.rotate(this.viewRotation_);
    }

    context.fill();

    if (this.alignFill_) {
      context.restore();
    }
  };
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */


  Executor.prototype.setStrokeStyle_ = function (context, instruction) {
    context['strokeStyle'] =
    /** @type {import("../../colorlike.js").ColorLike} */
    instruction[1];
    context.lineWidth =
    /** @type {number} */
    instruction[2];
    context.lineCap =
    /** @type {CanvasLineCap} */
    instruction[3];
    context.lineJoin =
    /** @type {CanvasLineJoin} */
    instruction[4];
    context.miterLimit =
    /** @type {number} */
    instruction[5];

    if (context.setLineDash) {
      context.lineDashOffset =
      /** @type {number} */
      instruction[7];
      context.setLineDash(
      /** @type {Array<number>} */
      instruction[6]);
    }
  };
  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */


  Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {
    var textState = this.textStates[textKey];
    var label = this.createLabel(text, textKey, fillKey, strokeKey);
    var strokeState = this.strokeStates[strokeKey];
    var pixelRatio = this.pixelRatio;
    var align = horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultTextAlign);
    var baseline = _TextBuilder_js__WEBPACK_IMPORTED_MODULE_1__.TEXT_ALIGN[textState.textBaseline || _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultTextBaseline];
    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0; // Remove the 2 pixels we added in createLabel() for the anchor

    var width = label.width / pixelRatio - 2 * textState.scale[0];
    var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
    return {
      label: label,
      anchorX: anchorX,
      anchorY: anchorY
    };
  };
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [opt_hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [opt_declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */


  Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {
    /** @type {Array<number>} */
    var pixelCoordinates;

    if (this.pixelCoordinates_ && (0,_array_js__WEBPACK_IMPORTED_MODULE_5__.equals)(transform, this.renderedTransform_)) {
      pixelCoordinates = this.pixelCoordinates_;
    } else {
      if (!this.pixelCoordinates_) {
        this.pixelCoordinates_ = [];
      }

      pixelCoordinates = (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_6__.transform2D)(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.setFromArray)(this.renderedTransform_, transform);
    }

    var i = 0; // instruction index

    var ii = instructions.length; // end of instructions

    var d = 0; // data index

    var dd; // end of per-instruction data

    var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
    var pendingFill = 0;
    var pendingStroke = 0;
    var lastFillInstruction = null;
    var lastStrokeInstruction = null;
    var coordinateCache = this.coordinateCache_;
    var viewRotation = this.viewRotation_;
    var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;
    var state =
    /** @type {import("../../render.js").State} */
    {
      context: context,
      pixelRatio: this.pixelRatio,
      resolution: this.resolution,
      rotation: viewRotation
    }; // When the batch size gets too big, performance decreases. 200 is a good
    // balance between batch size and number of fill/stroke instructions.

    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
    var
    /** @type {import("../../Feature.js").FeatureLike} */
    feature;
    var x, y, currentGeometry;

    while (i < ii) {
      var instruction = instructions[i];
      var type =
      /** @type {import("./Instruction.js").default} */
      instruction[0];

      switch (type) {
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_7__["default"].BEGIN_GEOMETRY:
          feature =
          /** @type {import("../../Feature.js").FeatureLike} */
          instruction[1];
          currentGeometry = instruction[3];

          if (!feature.getGeometry()) {
            i =
            /** @type {number} */
            instruction[2];
          } else if (opt_hitExtent !== undefined && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.intersects)(opt_hitExtent, currentGeometry.getExtent())) {
            i =
            /** @type {number} */
            instruction[2] + 1;
          } else {
            ++i;
          }

          break;

        case _Instruction_js__WEBPACK_IMPORTED_MODULE_7__["default"].BEGIN_PATH:
          if (pendingFill > batchSize) {
            this.fill_(context);
            pendingFill = 0;
          }

          if (pendingStroke > batchSize) {
            context.stroke();
            pendingStroke = 0;
          }

          if (!pendingFill && !pendingStroke) {
            context.beginPath();
            prevX = NaN;
            prevY = NaN;
          }

          ++i;
          break;

        case _Instruction_js__WEBPACK_IMPORTED_MODULE_7__["default"].CIRCLE:
          d =
          /** @type {number} */
          instruction[1];
          var x1 = pixelCoordinates[d];
          var y1 = pixelCoordinates[d + 1];
          var x2 = pixelCoordinates[d + 2];
          var y2 = pixelCoordinates[d + 3];
          var dx = x2 - x1;
          var dy = y2 - y1;
          var r = Math.sqrt(dx * dx + dy * dy);
          context.moveTo(x1 + r, y1);
          context.arc(x1, y1, r, 0, 2 * Math.PI, true);
          ++i;
          break;

        case _Instruction_js__WEBPACK_IMPORTED_MODULE_7__["default"].CLOSE_PATH:
          context.closePath();
          ++i;
          break;

        case _Instruction_js__WEBPACK_IMPORTED_MODULE_7__["default"].CUSTOM:
          d =
          /** @type {number} */
          instruction[1];
          dd = instruction[2];
          var geometry =
          /** @type {import("../../geom/SimpleGeometry.js").default} */
          instruction[3];
          var renderer = instruction[4];
          var fn = instruction.length == 6 ? instruction[5] : undefined;
          state.geometry = geometry;
          state.feature = feature;

          if (!(i in coordinateCache)) {
            coordinateCache[i] = [];
          }

          var coords = coordinateCache[i];

          if (fn) {
            fn(pixelCoordinates, d, dd, 2, coords);
          } else {
            coords[0] = pixelCoordinates[d];
            coords[1] = pixelCoordinates[d + 1];
            coords.length = 2;
          }

          renderer(coords, state);
          ++i;
          break;

        case _Instruction_js__WEBPACK_IMPORTED_MODULE_7__["default"].DRAW_IMAGE:
          d =
          /** @type {number} */
          instruction[1];
          dd =
          /** @type {number} */
          instruction[2];
          image =
          /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          instruction[3]; // Remaining arguments in DRAW_IMAGE are in alphabetical order

          anchorX =
          /** @type {number} */
          instruction[4];
          anchorY =
          /** @type {number} */
          instruction[5];
          var height =
          /** @type {number} */
          instruction[6];
          var opacity =
          /** @type {number} */
          instruction[7];
          var originX =
          /** @type {number} */
          instruction[8];
          var originY =
          /** @type {number} */
          instruction[9];
          var rotateWithView =
          /** @type {boolean} */
          instruction[10];
          var rotation =
          /** @type {number} */
          instruction[11];
          var scale =
          /** @type {import("../../size.js").Size} */
          instruction[12];
          var width =
          /** @type {number} */
          instruction[13];
          var declutterImageWithText =
          /** @type {import("../canvas.js").DeclutterImageWithText} */
          instruction[14];

          if (!image && instruction.length >= 19) {
            // create label images
            text =
            /** @type {string} */
            instruction[18];
            textKey =
            /** @type {string} */
            instruction[19];
            strokeKey =
            /** @type {string} */
            instruction[20];
            fillKey =
            /** @type {string} */
            instruction[21];
            var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
            image = labelWithAnchor.label;
            instruction[3] = image;
            var textOffsetX =
            /** @type {number} */
            instruction[22];
            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
            instruction[4] = anchorX;
            var textOffsetY =
            /** @type {number} */
            instruction[23];
            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
            instruction[5] = anchorY;
            height = image.height;
            instruction[6] = height;
            width = image.width;
            instruction[13] = width;
          }

          var geometryWidths = void 0;

          if (instruction.length > 24) {
            geometryWidths =
            /** @type {number} */
            instruction[24];
          }

          var padding = void 0,
              backgroundFill = void 0,
              backgroundStroke = void 0;

          if (instruction.length > 16) {
            padding =
            /** @type {Array<number>} */
            instruction[15];
            backgroundFill =
            /** @type {boolean} */
            instruction[16];
            backgroundStroke =
            /** @type {boolean} */
            instruction[17];
          } else {
            padding = _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultPadding;
            backgroundFill = false;
            backgroundStroke = false;
          }

          if (rotateWithView && viewRotationFromTransform) {
            // Canvas is expected to be rotated to reverse view rotation.
            rotation += viewRotation;
          } else if (!rotateWithView && !viewRotationFromTransform) {
            // Canvas is not rotated, images need to be rotated back to be north-up.
            rotation -= viewRotation;
          }

          var widthIndex = 0;

          for (; d < dd; d += 2) {
            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
              continue;
            }

            var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);
            /** @type {ReplayImageOrLabelArgs} */

            var args = [context, contextScale, image, dimensions, opacity, backgroundFill ?
            /** @type {Array<*>} */
            lastFillInstruction : null, backgroundStroke ?
            /** @type {Array<*>} */
            lastStrokeInstruction : null];
            var imageArgs = void 0;
            var imageDeclutterBox = void 0;

            if (opt_declutterTree && declutterImageWithText) {
              var index = dd - d;

              if (!declutterImageWithText[index]) {
                // We now have the image for an image+text combination.
                declutterImageWithText[index] = args; // Don't render anything for now, wait for the text.

                continue;
              }

              imageArgs = declutterImageWithText[index];
              delete declutterImageWithText[index];
              imageDeclutterBox = getDeclutterBox(imageArgs);

              if (opt_declutterTree.collides(imageDeclutterBox)) {
                continue;
              }
            }

            if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
              continue;
            }

            if (imageArgs) {
              // We now have image and text for an image+text combination.
              if (opt_declutterTree) {
                opt_declutterTree.insert(imageDeclutterBox);
              } // Render the image before we render the text.


              this.replayImageOrLabel_.apply(this, imageArgs);
            }

            if (opt_declutterTree) {
              opt_declutterTree.insert(dimensions.declutterBox);
            }

            this.replayImageOrLabel_.apply(this, args);
          }

          ++i;
          break;

        case _Instruction_js__WEBPACK_IMPORTED_MODULE_7__["default"].DRAW_CHARS:
          var begin =
          /** @type {number} */
          instruction[1];
          var end =
          /** @type {number} */
          instruction[2];
          var baseline =
          /** @type {number} */
          instruction[3];
          var overflow =
          /** @type {number} */
          instruction[4];
          fillKey =
          /** @type {string} */
          instruction[5];
          var maxAngle =
          /** @type {number} */
          instruction[6];
          var measurePixelRatio =
          /** @type {number} */
          instruction[7];
          var offsetY =
          /** @type {number} */
          instruction[8];
          strokeKey =
          /** @type {string} */
          instruction[9];
          var strokeWidth =
          /** @type {number} */
          instruction[10];
          text =
          /** @type {string} */
          instruction[11];
          textKey =
          /** @type {string} */
          instruction[12];
          var pixelRatioScale = [
          /** @type {number} */
          instruction[13],
          /** @type {number} */
          instruction[13]];
          var textState = this.textStates[textKey];
          var font = textState.font;
          var textScale = [textState.scale[0] * measurePixelRatio, textState.scale[1] * measurePixelRatio];
          var cachedWidths = void 0;

          if (font in this.widths_) {
            cachedWidths = this.widths_[font];
          } else {
            cachedWidths = {};
            this.widths_[font] = cachedWidths;
          }

          var pathLength = (0,_geom_flat_length_js__WEBPACK_IMPORTED_MODULE_8__.lineStringLength)(pixelCoordinates, begin, end, 2);
          var textLength = Math.abs(textScale[0]) * (0,_canvas_js__WEBPACK_IMPORTED_MODULE_3__.measureAndCacheTextWidth)(font, text, cachedWidths);

          if (overflow || textLength <= pathLength) {
            var textAlign = this.textStates[textKey].textAlign;
            var startM = (pathLength - textLength) * _TextBuilder_js__WEBPACK_IMPORTED_MODULE_1__.TEXT_ALIGN[textAlign];
            var parts = (0,_geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_9__.drawTextOnPath)(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), _canvas_js__WEBPACK_IMPORTED_MODULE_3__.measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);

            drawChars: if (parts) {
              /** @type {Array<ReplayImageOrLabelArgs>} */
              var replayImageOrLabelArgs = [];
              var c = void 0,
                  cc = void 0,
                  chars = void 0,
                  label = void 0,
                  part = void 0;

              if (strokeKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk

                  chars =
                  /** @type {string} */
                  part[4];
                  label = this.createLabel(chars, textKey, '', strokeKey);
                  anchorX =
                  /** @type {number} */
                  part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                  var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultPadding, false, feature);

                  if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                    break drawChars;
                  }

                  replayImageOrLabelArgs.push([context, contextScale, label, dimensions, 1, null, null]);
                }
              }

              if (fillKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk

                  chars =
                  /** @type {string} */
                  part[4];
                  label = this.createLabel(chars, textKey, fillKey, '');
                  anchorX =
                  /** @type {number} */
                  part[2];
                  anchorY = baseline * label.height - offsetY;
                  var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultPadding, false, feature);

                  if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                    break drawChars;
                  }

                  replayImageOrLabelArgs.push([context, contextScale, label, dimensions, 1, null, null]);
                }
              }

              if (opt_declutterTree) {
                opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
              }

              for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {
                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);
              }
            }
          }

          ++i;
          break;

        case _Instruction_js__WEBPACK_IMPORTED_MODULE_7__["default"].END_GEOMETRY:
          if (opt_featureCallback !== undefined) {
            feature =
            /** @type {import("../../Feature.js").FeatureLike} */
            instruction[1];
            var result = opt_featureCallback(feature, currentGeometry);

            if (result) {
              return result;
            }
          }

          ++i;
          break;

        case _Instruction_js__WEBPACK_IMPORTED_MODULE_7__["default"].FILL:
          if (batchSize) {
            pendingFill++;
          } else {
            this.fill_(context);
          }

          ++i;
          break;

        case _Instruction_js__WEBPACK_IMPORTED_MODULE_7__["default"].MOVE_TO_LINE_TO:
          d =
          /** @type {number} */
          instruction[1];
          dd =
          /** @type {number} */
          instruction[2];
          x = pixelCoordinates[d];
          y = pixelCoordinates[d + 1];
          roundX = x + 0.5 | 0;
          roundY = y + 0.5 | 0;

          if (roundX !== prevX || roundY !== prevY) {
            context.moveTo(x, y);
            prevX = roundX;
            prevY = roundY;
          }

          for (d += 2; d < dd; d += 2) {
            x = pixelCoordinates[d];
            y = pixelCoordinates[d + 1];
            roundX = x + 0.5 | 0;
            roundY = y + 0.5 | 0;

            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
              context.lineTo(x, y);
              prevX = roundX;
              prevY = roundY;
            }
          }

          ++i;
          break;

        case _Instruction_js__WEBPACK_IMPORTED_MODULE_7__["default"].SET_FILL_STYLE:
          lastFillInstruction = instruction;
          this.alignFill_ = instruction[2];

          if (pendingFill) {
            this.fill_(context);
            pendingFill = 0;

            if (pendingStroke) {
              context.stroke();
              pendingStroke = 0;
            }
          }

          context.fillStyle =
          /** @type {import("../../colorlike.js").ColorLike} */
          instruction[1];
          ++i;
          break;

        case _Instruction_js__WEBPACK_IMPORTED_MODULE_7__["default"].SET_STROKE_STYLE:
          lastStrokeInstruction = instruction;

          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }

          this.setStrokeStyle_(context,
          /** @type {Array<*>} */
          instruction);
          ++i;
          break;

        case _Instruction_js__WEBPACK_IMPORTED_MODULE_7__["default"].STROKE:
          if (batchSize) {
            pendingStroke++;
          } else {
            context.stroke();
          }

          ++i;
          break;

        default:
          ++i; // consume the instruction anyway, to avoid an infinite loop

          break;
      }
    }

    if (pendingFill) {
      this.fill_(context);
    }

    if (pendingStroke) {
      context.stroke();
    }

    return undefined;
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [opt_declutterTree] Declutter tree.
   */


  Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree) {
    this.viewRotation_ = viewRotation;
    this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, opt_declutterTree);
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [opt_hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */


  Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {
    this.viewRotation_ = viewRotation;
    return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
  };

  return Executor;
}();

/* harmony default export */ __webpack_exports__["default"] = (Executor);

/***/ }),

/***/ "./build/wg/render/canvas/ExecutorGroup.js":
/*!*************************************************!*\
  !*** ./build/wg/render/canvas/ExecutorGroup.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPixelIndexArray": function() { return /* binding */ getPixelIndexArray; }
/* harmony export */ });
/* harmony import */ var _BuilderType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BuilderType.js */ "./build/wg/render/canvas/BuilderType.js");
/* harmony import */ var _Executor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Executor.js */ "./build/wg/render/canvas/Executor.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dom.js */ "./build/wg/dom.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../array.js */ "./build/wg/array.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./build/wg/geom/flat/transform.js");
/**
 * @module wg/render/canvas/ExecutorGroup
 */








/**
 * @const
 * @type {Array<import("./BuilderType.js").default>}
 */

var ORDER = [_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON, _BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CIRCLE, _BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].LINE_STRING, _BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE, _BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].TEXT, _BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT];

var ExecutorGroup =
/** @class */
function () {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("./BuilderType.js").default, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [opt_renderBuffer] Optional rendering buffer.
   */
  function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent_ = maxExtent;
    /**
     * @private
     * @type {boolean}
     */

    this.overlaps_ = overlaps;
    /**
     * @private
     * @type {number}
     */

    this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {number}
     */

    this.resolution_ = resolution;
    /**
     * @private
     * @type {number|undefined}
     */

    this.renderBuffer_ = opt_renderBuffer;
    /**
     * @private
     * @type {!Object<string, !Object<import("./BuilderType.js").default, import("./Executor").default>>}
     */

    this.executorsByZIndex_ = {};
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */

    this.hitDetectionContext_ = null;
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    this.hitDetectionTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.create)();
    this.createExecutors_(allInstructions);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */


  ExecutorGroup.prototype.clip = function (context, transform) {
    var flatClipCoords = this.getClipCoords(transform);
    context.beginPath();
    context.moveTo(flatClipCoords[0], flatClipCoords[1]);
    context.lineTo(flatClipCoords[2], flatClipCoords[3]);
    context.lineTo(flatClipCoords[4], flatClipCoords[5]);
    context.lineTo(flatClipCoords[6], flatClipCoords[7]);
    context.clip();
  };
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<import("./BuilderType.js").default, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   */


  ExecutorGroup.prototype.createExecutors_ = function (allInstructions) {
    for (var zIndex in allInstructions) {
      var executors = this.executorsByZIndex_[zIndex];

      if (executors === undefined) {
        executors = {};
        this.executorsByZIndex_[zIndex] = executors;
      }

      var instructionByZindex = allInstructions[zIndex];

      for (var builderType in instructionByZindex) {
        var instructions = instructionByZindex[builderType];
        executors[builderType] = new _Executor_js__WEBPACK_IMPORTED_MODULE_2__["default"](this.resolution_, this.pixelRatio_, this.overlaps_, instructions);
      }
    }
  };
  /**
   * @param {Array<import("./BuilderType.js").default>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */


  ExecutorGroup.prototype.hasExecutors = function (executors) {
    for (var zIndex in this.executorsByZIndex_) {
      var candidates = this.executorsByZIndex_[zIndex];

      for (var i = 0, ii = executors.length; i < ii; ++i) {
        if (executors[i] in candidates) {
          return true;
        }
      }
    }

    return false;
  };
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */


  ExecutorGroup.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
    hitTolerance = Math.round(hitTolerance);
    var contextSize = hitTolerance * 2 + 1;
    var transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.compose)(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
    var newContext = !this.hitDetectionContext_;

    if (newContext) {
      this.hitDetectionContext_ = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.createCanvasContext2D)(contextSize, contextSize);
    }

    var context = this.hitDetectionContext_;

    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
      context.canvas.width = contextSize;
      context.canvas.height = contextSize;
    } else if (!newContext) {
      context.clearRect(0, 0, contextSize, contextSize);
    }
    /**
     * @type {import("../../extent.js").Extent}
     */


    var hitExtent;

    if (this.renderBuffer_ !== undefined) {
      hitExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.createEmpty)();
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.extendCoordinate)(hitExtent, coordinate);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.buffer)(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
    }

    var indexes = getPixelIndexArray(hitTolerance);
    var builderType;
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @return {T|undefined} Callback result.
     */

    function featureCallback(feature, geometry) {
      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;

      for (var i_1 = 0, ii = indexes.length; i_1 < ii; i_1++) {
        if (imageData[indexes[i_1]] > 0) {
          if (!declutteredFeatures || builderType !== _BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE && builderType !== _BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].TEXT || declutteredFeatures.indexOf(feature) !== -1) {
            var idx = (indexes[i_1] - 3) / 4;
            var x = hitTolerance - idx % contextSize;
            var y = hitTolerance - (idx / contextSize | 0);
            var result_1 = callback(feature, geometry, x * x + y * y);

            if (result_1) {
              return result_1;
            }
          }

          context.clearRect(0, 0, contextSize, contextSize);
          break;
        }
      }

      return undefined;
    }
    /** @type {Array<number>} */


    var zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_5__.numberSafeCompareFunction);
    var i, j, executors, executor, result;

    for (i = zs.length - 1; i >= 0; --i) {
      var zIndexKey = zs[i].toString();
      executors = this.executorsByZIndex_[zIndexKey];

      for (j = ORDER.length - 1; j >= 0; --j) {
        builderType = ORDER[j];
        executor = executors[builderType];

        if (executor !== undefined) {
          result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);

          if (result) {
            return result;
          }
        }
      }
    }

    return undefined;
  };
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>} Clip coordinates.
   */


  ExecutorGroup.prototype.getClipCoords = function (transform) {
    var maxExtent = this.maxExtent_;

    if (!maxExtent) {
      return null;
    }

    var minX = maxExtent[0];
    var minY = maxExtent[1];
    var maxX = maxExtent[2];
    var maxY = maxExtent[3];
    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
    (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_6__.transform2D)(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
    return flatClipCoords;
  };
  /**
   * @return {boolean} Is empty.
   */


  ExecutorGroup.prototype.isEmpty = function () {
    return (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.isEmpty)(this.executorsByZIndex_);
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("./BuilderType.js").default>} [opt_builderTypes] Ordered replay types to replay.
   *     Default is {@link module:wg/render/replay~ORDER}
   * @param {import("rbush").default} [opt_declutterTree] Declutter tree.
   */


  ExecutorGroup.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterTree) {
    /** @type {Array<number>} */
    var zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_5__.numberSafeCompareFunction); // setup clipping so that the parts of over-simplified geometries are not
    // visible outside the current extent when panning

    if (this.maxExtent_) {
      context.save();
      this.clip(context, transform);
    }

    var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;
    var i, ii, j, jj, replays, replay;

    if (opt_declutterTree) {
      zs.reverse();
    }

    for (i = 0, ii = zs.length; i < ii; ++i) {
      var zIndexKey = zs[i].toString();
      replays = this.executorsByZIndex_[zIndexKey];

      for (j = 0, jj = builderTypes.length; j < jj; ++j) {
        var builderType = builderTypes[j];
        replay = replays[builderType];

        if (replay !== undefined) {
          replay.execute(context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree);
        }
      }
    }

    if (this.maxExtent_) {
      context.restore();
    }
  };

  return ExecutorGroup;
}();
/**
 * This cache is used to store arrays of indexes for calculated pixel circles
 * to increase performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object<number, Array<number>>}
 */


var circlePixelIndexArrayCache = {};
/**
 * This methods creates an array with indexes of all pixels within a circle,
 * ordered by how close they are to the center.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @return {Array<number>} An array with indexes within a circle.
 */

function getPixelIndexArray(radius) {
  if (circlePixelIndexArrayCache[radius] !== undefined) {
    return circlePixelIndexArrayCache[radius];
  }

  var size = radius * 2 + 1;
  var maxDistanceSq = radius * radius;
  var distances = new Array(maxDistanceSq + 1);

  for (var i = 0; i <= radius; ++i) {
    for (var j = 0; j <= radius; ++j) {
      var distanceSq = i * i + j * j;

      if (distanceSq > maxDistanceSq) {
        break;
      }

      var distance = distances[distanceSq];

      if (!distance) {
        distance = [];
        distances[distanceSq] = distance;
      }

      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);

      if (i > 0) {
        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
      }

      if (j > 0) {
        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);

        if (i > 0) {
          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
      }
    }
  }

  var pixelIndex = [];

  for (var i = 0, ii = distances.length; i < ii; ++i) {
    if (distances[i]) {
      pixelIndex.push.apply(pixelIndex, distances[i]);
    }
  }

  circlePixelIndexArrayCache[radius] = pixelIndex;
  return pixelIndex;
}
/* harmony default export */ __webpack_exports__["default"] = (ExecutorGroup);

/***/ }),

/***/ "./build/wg/render/canvas/ImageBuilder.js":
/*!************************************************!*\
  !*** ./build/wg/render/canvas/ImageBuilder.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Builder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Builder.js */ "./build/wg/render/canvas/Builder.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Instruction.js */ "./build/wg/render/canvas/Instruction.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/render/canvas/ImageBuilder
 */





var CanvasImageBuilder =
/** @class */
function (_super) {
  __extends(CanvasImageBuilder, _super);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */


  function CanvasImageBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */


    _this.hitDetectionImage_ = null;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */

    _this.image_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.imagePixelRatio_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.anchorX_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.anchorY_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.height_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.opacity_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.originX_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.originY_ = undefined;
    /**
     * @private
     * @type {boolean|undefined}
     */

    _this.rotateWithView_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.rotation_ = undefined;
    /**
     * @private
     * @type {import("../../size.js").Size|undefined}
     */

    _this.scale_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.width_ = undefined;
    /**
     * Data shared with a text builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */

    _this.declutterImageWithText_ = undefined;
    return _this;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasImageBuilder.prototype.drawPoint = function (pointGeometry, feature) {
    if (!this.image_) {
      return;
    }

    this.beginGeometry(pointGeometry, feature);
    var flatCoordinates = pointGeometry.getFlatCoordinates();
    var stride = pointGeometry.getStride();
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
    this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
    this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterImageWithText_]);
    this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
    this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterImageWithText_]);
    this.endGeometry(feature);
  };
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasImageBuilder.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
    if (!this.image_) {
      return;
    }

    this.beginGeometry(multiPointGeometry, feature);
    var flatCoordinates = multiPointGeometry.getFlatCoordinates();
    var stride = multiPointGeometry.getStride();
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
    this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
    this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterImageWithText_]);
    this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
    this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterImageWithText_]);
    this.endGeometry(feature);
  };
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */


  CanvasImageBuilder.prototype.finish = function () {
    this.reverseHitDetectionInstructions(); // FIXME this doesn't really protect us against further calls to draw*Geometry

    this.anchorX_ = undefined;
    this.anchorY_ = undefined;
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.imagePixelRatio_ = undefined;
    this.height_ = undefined;
    this.scale_ = undefined;
    this.opacity_ = undefined;
    this.originX_ = undefined;
    this.originY_ = undefined;
    this.rotateWithView_ = undefined;
    this.rotation_ = undefined;
    this.width_ = undefined;
    return _super.prototype.finish.call(this);
  };
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [opt_sharedData] Shared data.
   */


  CanvasImageBuilder.prototype.setImageStyle = function (imageStyle, opt_sharedData) {
    var anchor = imageStyle.getAnchor();
    var size = imageStyle.getSize();
    var hitDetectionImage = imageStyle.getHitDetectionImage();
    var image = imageStyle.getImage(this.pixelRatio);
    var origin = imageStyle.getOrigin();
    this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
    this.anchorX_ = anchor[0];
    this.anchorY_ = anchor[1];
    this.hitDetectionImage_ = hitDetectionImage;
    this.image_ = image;
    this.height_ = size[1];
    this.opacity_ = imageStyle.getOpacity();
    this.originX_ = origin[0] * this.imagePixelRatio_;
    this.originY_ = origin[1] * this.imagePixelRatio_;
    this.rotateWithView_ = imageStyle.getRotateWithView();
    this.rotation_ = imageStyle.getRotation();
    this.scale_ = imageStyle.getScaleArray();
    this.width_ = size[0];
    this.declutterImageWithText_ = opt_sharedData;
  };

  return CanvasImageBuilder;
}(_Builder_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CanvasImageBuilder);

/***/ }),

/***/ "./build/wg/render/canvas/Immediate.js":
/*!*********************************************!*\
  !*** ./build/wg/render/canvas/Immediate.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _VectorContext_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../VectorContext.js */ "./build/wg/render/VectorContext.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../colorlike.js */ "./build/wg/colorlike.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../canvas.js */ "./build/wg/render/canvas.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../array.js */ "./build/wg/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./build/wg/geom/flat/transform.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geom/SimpleGeometry.js */ "./build/wg/geom/SimpleGeometry.js");
/**
 * @module wg/render/canvas/Immediate
 */
// FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();










/**
 * @classdesc
 * A concrete subclass of {@link module:wg/render/VectorContext~VectorContext VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:wg/render/Event~RenderEvent RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */

var CanvasImmediateRenderer =
/** @class */
function (_super) {
  __extends(CanvasImmediateRenderer, _super);
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [opt_squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [opt_userTransform] Transform from user to view projection.
   */


  function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation, opt_squaredTolerance, opt_userTransform) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */


    _this.context_ = context;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    _this.extent_ = extent;
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.transform_ = transform;
    /**
     * @private
     * @type {number}
     */

    _this.viewRotation_ = viewRotation;
    /**
     * @private
     * @type {number}
     */

    _this.squaredTolerance_ = opt_squaredTolerance;
    /**
     * @private
     * @type {import("../../proj.js").TransformFunction}
     */

    _this.userTransform_ = opt_userTransform;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.contextFillState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.contextStrokeState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */

    _this.contextTextState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.fillState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.strokeState_ = null;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */

    _this.image_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.imageAnchorX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageAnchorY_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageHeight_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageOpacity_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageOriginX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageOriginY_ = 0;
    /**
     * @private
     * @type {boolean}
     */

    _this.imageRotateWithView_ = false;
    /**
     * @private
     * @type {number}
     */

    _this.imageRotation_ = 0;
    /**
     * @private
     * @type {import("../../size.js").Size}
     */

    _this.imageScale_ = [0, 0];
    /**
     * @private
     * @type {number}
     */

    _this.imageWidth_ = 0;
    /**
     * @private
     * @type {string}
     */

    _this.text_ = '';
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetY_ = 0;
    /**
     * @private
     * @type {boolean}
     */

    _this.textRotateWithView_ = false;
    /**
     * @private
     * @type {number}
     */

    _this.textRotation_ = 0;
    /**
     * @private
     * @type {import("../../size.js").Size}
     */

    _this.textScale_ = [0, 0];
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.textFillState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.textStrokeState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */

    _this.textState_ = null;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.pixelCoordinates_ = [];
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.tmpLocalTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.create)();
    return _this;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */


  CanvasImmediateRenderer.prototype.drawImages_ = function (flatCoordinates, offset, end, stride) {
    if (!this.image_) {
      return;
    }

    var pixelCoordinates = (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_1__.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
    var context = this.context_;
    var localTransform = this.tmpLocalTransform_;
    var alpha = context.globalAlpha;

    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha * this.imageOpacity_;
    }

    var rotation = this.imageRotation_;

    if (this.imageRotateWithView_) {
      rotation += this.viewRotation_;
    }

    for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
      var x = pixelCoordinates[i] - this.imageAnchorX_;
      var y = pixelCoordinates[i + 1] - this.imageAnchorY_;

      if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        var centerX = x + this.imageAnchorX_;
        var centerY = y + this.imageAnchorY_;
        (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.compose)(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
        context.setTransform.apply(context, localTransform);
        context.translate(centerX, centerY);
        context.scale(this.imageScale_[0], this.imageScale_[1]);
        context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
        context.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
      }
    }

    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha;
    }
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */


  CanvasImmediateRenderer.prototype.drawText_ = function (flatCoordinates, offset, end, stride) {
    if (!this.textState_ || this.text_ === '') {
      return;
    }

    if (this.textFillState_) {
      this.setContextFillState_(this.textFillState_);
    }

    if (this.textStrokeState_) {
      this.setContextStrokeState_(this.textStrokeState_);
    }

    this.setContextTextState_(this.textState_);
    var pixelCoordinates = (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_1__.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
    var context = this.context_;
    var rotation = this.textRotation_;

    if (this.textRotateWithView_) {
      rotation += this.viewRotation_;
    }

    for (; offset < end; offset += stride) {
      var x = pixelCoordinates[offset] + this.textOffsetX_;
      var y = pixelCoordinates[offset + 1] + this.textOffsetY_;

      if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
        var localTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.compose)(this.tmpLocalTransform_, x, y, 1, 1, rotation, -x, -y);
        context.setTransform.apply(context, localTransform);
        context.translate(x, y);
        context.scale(this.textScale_[0], this.textScale_[1]);

        if (this.textStrokeState_) {
          context.strokeText(this.text_, 0, 0);
        }

        if (this.textFillState_) {
          context.fillText(this.text_, 0, 0);
        }

        context.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        if (this.textStrokeState_) {
          context.strokeText(this.text_, x, y);
        }

        if (this.textFillState_) {
          context.fillText(this.text_, x, y);
        }
      }
    }
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */


  CanvasImmediateRenderer.prototype.moveToLineTo_ = function (flatCoordinates, offset, end, stride, close) {
    var context = this.context_;
    var pixelCoordinates = (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_1__.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
    context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
    var length = pixelCoordinates.length;

    if (close) {
      length -= 2;
    }

    for (var i = 2; i < length; i += 2) {
      context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
    }

    if (close) {
      context.closePath();
    }

    return end;
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */


  CanvasImmediateRenderer.prototype.drawRings_ = function (flatCoordinates, offset, ends, stride) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
    }

    return offset;
  };
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */


  CanvasImmediateRenderer.prototype.drawCircle = function (geometry) {
    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }

    if (this.fillState_ || this.strokeState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }

      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }

      var pixelCoordinates = (0,_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_3__.transformGeom2D)(geometry, this.transform_, this.pixelCoordinates_);
      var dx = pixelCoordinates[2] - pixelCoordinates[0];
      var dy = pixelCoordinates[3] - pixelCoordinates[1];
      var radius = Math.sqrt(dx * dx + dy * dy);
      var context = this.context_;
      context.beginPath();
      context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);

      if (this.fillState_) {
        context.fill();
      }

      if (this.strokeState_) {
        context.stroke();
      }
    }

    if (this.text_ !== '') {
      this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
  };
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */


  CanvasImmediateRenderer.prototype.setStyle = function (style) {
    this.setFillStrokeStyle(style.getFill(), style.getStroke());
    this.setImageStyle(style.getImage());
    this.setTextStyle(style.getText());
  };
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */


  CanvasImmediateRenderer.prototype.setTransform = function (transform) {
    this.transform_ = transform;
  };
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:wg/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */


  CanvasImmediateRenderer.prototype.drawGeometry = function (geometry) {
    var type = geometry.getType();

    switch (type) {
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINT:
        this.drawPoint(
        /** @type {import("../../geom/Point.js").default} */
        geometry);
        break;

      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].LINE_STRING:
        this.drawLineString(
        /** @type {import("../../geom/LineString.js").default} */
        geometry);
        break;

      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POLYGON:
        this.drawPolygon(
        /** @type {import("../../geom/Polygon.js").default} */
        geometry);
        break;

      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].MULTI_POINT:
        this.drawMultiPoint(
        /** @type {import("../../geom/MultiPoint.js").default} */
        geometry);
        break;

      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].MULTI_LINE_STRING:
        this.drawMultiLineString(
        /** @type {import("../../geom/MultiLineString.js").default} */
        geometry);
        break;

      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].MULTI_POLYGON:
        this.drawMultiPolygon(
        /** @type {import("../../geom/MultiPolygon.js").default} */
        geometry);
        break;

      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].GEOMETRY_COLLECTION:
        this.drawGeometryCollection(
        /** @type {import("../../geom/GeometryCollection.js").default} */
        geometry);
        break;

      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CIRCLE:
        this.drawCircle(
        /** @type {import("../../geom/Circle.js").default} */
        geometry);
        break;

      default:
    }
  };
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:wg/layer/Vector~VectorLayer VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */


  CanvasImmediateRenderer.prototype.drawFeature = function (feature, style) {
    var geometry = style.getGeometryFunction()(feature);

    if (!geometry || !(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }

    this.setStyle(style);
    this.drawGeometry(geometry);
  };
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */


  CanvasImmediateRenderer.prototype.drawGeometryCollection = function (geometry) {
    var geometries = geometry.getGeometriesArray();

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      this.drawGeometry(geometries[i]);
    }
  };
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */


  CanvasImmediateRenderer.prototype.drawPoint = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/Point.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();

    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }

    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */


  CanvasImmediateRenderer.prototype.drawMultiPoint = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/MultiPoint.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();

    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }

    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */


  CanvasImmediateRenderer.prototype.drawLineString = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/LineString.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }

    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      context.beginPath();
      this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
      context.stroke();
    }

    if (this.text_ !== '') {
      var flatMidpoint = geometry.getFlatMidpoint();
      this.drawText_(flatMidpoint, 0, 2, 2);
    }
  };
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */


  CanvasImmediateRenderer.prototype.drawMultiLineString = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/MultiLineString.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    var geometryExtent = geometry.getExtent();

    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(this.extent_, geometryExtent)) {
      return;
    }

    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      var offset = 0;
      var ends =
      /** @type {Array<number>} */
      geometry.getEnds();
      var stride = geometry.getStride();
      context.beginPath();

      for (var i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
      }

      context.stroke();
    }

    if (this.text_ !== '') {
      var flatMidpoints = geometry.getFlatMidpoints();
      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
    }
  };
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */


  CanvasImmediateRenderer.prototype.drawPolygon = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/Polygon.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }

    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }

      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }

      var context = this.context_;
      context.beginPath();
      this.drawRings_(geometry.getOrientedFlatCoordinates(), 0,
      /** @type {Array<number>} */
      geometry.getEnds(), geometry.getStride());

      if (this.fillState_) {
        context.fill();
      }

      if (this.strokeState_) {
        context.stroke();
      }
    }

    if (this.text_ !== '') {
      var flatInteriorPoint = geometry.getFlatInteriorPoint();
      this.drawText_(flatInteriorPoint, 0, 2, 2);
    }
  };
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */


  CanvasImmediateRenderer.prototype.drawMultiPolygon = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/MultiPolygon.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }

    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }

      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }

      var context = this.context_;
      var flatCoordinates = geometry.getOrientedFlatCoordinates();
      var offset = 0;
      var endss = geometry.getEndss();
      var stride = geometry.getStride();
      context.beginPath();

      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        offset = this.drawRings_(flatCoordinates, offset, ends, stride);
      }

      if (this.fillState_) {
        context.fill();
      }

      if (this.strokeState_) {
        context.stroke();
      }
    }

    if (this.text_ !== '') {
      var flatInteriorPoints = geometry.getFlatInteriorPoints();
      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
    }
  };
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */


  CanvasImmediateRenderer.prototype.setContextFillState_ = function (fillState) {
    var context = this.context_;
    var contextFillState = this.contextFillState_;

    if (!contextFillState) {
      context.fillStyle = fillState.fillStyle;
      this.contextFillState_ = {
        fillStyle: fillState.fillStyle
      };
    } else {
      if (contextFillState.fillStyle != fillState.fillStyle) {
        contextFillState.fillStyle = fillState.fillStyle;
        context.fillStyle = fillState.fillStyle;
      }
    }
  };
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */


  CanvasImmediateRenderer.prototype.setContextStrokeState_ = function (strokeState) {
    var context = this.context_;
    var contextStrokeState = this.contextStrokeState_;

    if (!contextStrokeState) {
      context.lineCap = strokeState.lineCap;

      if (context.setLineDash) {
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
      }

      context.lineJoin = strokeState.lineJoin;
      context.lineWidth = strokeState.lineWidth;
      context.miterLimit = strokeState.miterLimit;
      context.strokeStyle = strokeState.strokeStyle;
      this.contextStrokeState_ = {
        lineCap: strokeState.lineCap,
        lineDash: strokeState.lineDash,
        lineDashOffset: strokeState.lineDashOffset,
        lineJoin: strokeState.lineJoin,
        lineWidth: strokeState.lineWidth,
        miterLimit: strokeState.miterLimit,
        strokeStyle: strokeState.strokeStyle
      };
    } else {
      if (contextStrokeState.lineCap != strokeState.lineCap) {
        contextStrokeState.lineCap = strokeState.lineCap;
        context.lineCap = strokeState.lineCap;
      }

      if (context.setLineDash) {
        if (!(0,_array_js__WEBPACK_IMPORTED_MODULE_5__.equals)(contextStrokeState.lineDash, strokeState.lineDash)) {
          context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
        }

        if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
          contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
          context.lineDashOffset = strokeState.lineDashOffset;
        }
      }

      if (contextStrokeState.lineJoin != strokeState.lineJoin) {
        contextStrokeState.lineJoin = strokeState.lineJoin;
        context.lineJoin = strokeState.lineJoin;
      }

      if (contextStrokeState.lineWidth != strokeState.lineWidth) {
        contextStrokeState.lineWidth = strokeState.lineWidth;
        context.lineWidth = strokeState.lineWidth;
      }

      if (contextStrokeState.miterLimit != strokeState.miterLimit) {
        contextStrokeState.miterLimit = strokeState.miterLimit;
        context.miterLimit = strokeState.miterLimit;
      }

      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
        contextStrokeState.strokeStyle = strokeState.strokeStyle;
        context.strokeStyle = strokeState.strokeStyle;
      }
    }
  };
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */


  CanvasImmediateRenderer.prototype.setContextTextState_ = function (textState) {
    var context = this.context_;
    var contextTextState = this.contextTextState_;
    var textAlign = textState.textAlign ? textState.textAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultTextAlign;

    if (!contextTextState) {
      context.font = textState.font;
      context.textAlign =
      /** @type {CanvasTextAlign} */
      textAlign;
      context.textBaseline =
      /** @type {CanvasTextBaseline} */
      textState.textBaseline;
      this.contextTextState_ = {
        font: textState.font,
        textAlign: textAlign,
        textBaseline: textState.textBaseline
      };
    } else {
      if (contextTextState.font != textState.font) {
        contextTextState.font = textState.font;
        context.font = textState.font;
      }

      if (contextTextState.textAlign != textAlign) {
        contextTextState.textAlign =
        /** @type {CanvasTextAlign} */
        textAlign;
        context.textAlign =
        /** @type {CanvasTextAlign} */
        textAlign;
      }

      if (contextTextState.textBaseline != textState.textBaseline) {
        contextTextState.textBaseline =
        /** @type {CanvasTextBaseline} */
        textState.textBaseline;
        context.textBaseline =
        /** @type {CanvasTextBaseline} */
        textState.textBaseline;
      }
    }
  };
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */


  CanvasImmediateRenderer.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
    var _this = this;

    if (!fillStyle) {
      this.fillState_ = null;
    } else {
      var fillStyleColor = fillStyle.getColor();
      this.fillState_ = {
        fillStyle: (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_7__.asColorLike)(fillStyleColor ? fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultFillStyle)
      };
    }

    if (!strokeStyle) {
      this.strokeState_ = null;
    } else {
      var strokeStyleColor = strokeStyle.getColor();
      var strokeStyleLineCap = strokeStyle.getLineCap();
      var strokeStyleLineDash = strokeStyle.getLineDash();
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      var strokeStyleLineJoin = strokeStyle.getLineJoin();
      var strokeStyleWidth = strokeStyle.getWidth();
      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      var lineDash = strokeStyleLineDash ? strokeStyleLineDash : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultLineDash;
      this.strokeState_ = {
        lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultLineCap,
        lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map(function (n) {
          return n * _this.pixelRatio_;
        }),
        lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultLineDashOffset) * this.pixelRatio_,
        lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultLineJoin,
        lineWidth: (strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultLineWidth) * this.pixelRatio_,
        miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultMiterLimit,
        strokeStyle: (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_7__.asColorLike)(strokeStyleColor ? strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultStrokeStyle)
      };
    }
  };
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */


  CanvasImmediateRenderer.prototype.setImageStyle = function (imageStyle) {
    var imageSize;

    if (!imageStyle || !(imageSize = imageStyle.getSize())) {
      this.image_ = null;
      return;
    }

    var imageAnchor = imageStyle.getAnchor();
    var imageOrigin = imageStyle.getOrigin();
    this.image_ = imageStyle.getImage(this.pixelRatio_);
    this.imageAnchorX_ = imageAnchor[0] * this.pixelRatio_;
    this.imageAnchorY_ = imageAnchor[1] * this.pixelRatio_;
    this.imageHeight_ = imageSize[1] * this.pixelRatio_;
    this.imageOpacity_ = imageStyle.getOpacity();
    this.imageOriginX_ = imageOrigin[0];
    this.imageOriginY_ = imageOrigin[1];
    this.imageRotateWithView_ = imageStyle.getRotateWithView();
    this.imageRotation_ = imageStyle.getRotation();
    this.imageScale_ = imageStyle.getScaleArray();
    this.imageWidth_ = imageSize[0] * this.pixelRatio_;
  };
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */


  CanvasImmediateRenderer.prototype.setTextStyle = function (textStyle) {
    if (!textStyle) {
      this.text_ = '';
    } else {
      var textFillStyle = textStyle.getFill();

      if (!textFillStyle) {
        this.textFillState_ = null;
      } else {
        var textFillStyleColor = textFillStyle.getColor();
        this.textFillState_ = {
          fillStyle: (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_7__.asColorLike)(textFillStyleColor ? textFillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultFillStyle)
        };
      }

      var textStrokeStyle = textStyle.getStroke();

      if (!textStrokeStyle) {
        this.textStrokeState_ = null;
      } else {
        var textStrokeStyleColor = textStrokeStyle.getColor();
        var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
        var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
        var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
        var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
        var textStrokeStyleWidth = textStrokeStyle.getWidth();
        var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultLineCap,
          lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultLineDash,
          lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultLineDashOffset,
          lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultLineJoin,
          lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultLineWidth,
          miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultMiterLimit,
          strokeStyle: (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_7__.asColorLike)(textStrokeStyleColor ? textStrokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultStrokeStyle)
        };
      }

      var textFont = textStyle.getFont();
      var textOffsetX = textStyle.getOffsetX();
      var textOffsetY = textStyle.getOffsetY();
      var textRotateWithView = textStyle.getRotateWithView();
      var textRotation = textStyle.getRotation();
      var textScale = textStyle.getScaleArray();
      var textText = textStyle.getText();
      var textTextAlign = textStyle.getTextAlign();
      var textTextBaseline = textStyle.getTextBaseline();
      this.textState_ = {
        font: textFont !== undefined ? textFont : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultFont,
        textAlign: textTextAlign !== undefined ? textTextAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultTextAlign,
        textBaseline: textTextBaseline !== undefined ? textTextBaseline : _canvas_js__WEBPACK_IMPORTED_MODULE_6__.defaultTextBaseline
      };
      this.text_ = textText !== undefined ? Array.isArray(textText) ? textText.reduce(function (acc, t, i) {
        return acc += i % 2 ? ' ' : t;
      }, '') : textText : '';
      this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
      this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
      this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
      this.textRotation_ = textRotation !== undefined ? textRotation : 0;
      this.textScale_ = [this.pixelRatio_ * textScale[0], this.pixelRatio_ * textScale[1]];
    }
  };

  return CanvasImmediateRenderer;
}(_VectorContext_js__WEBPACK_IMPORTED_MODULE_8__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CanvasImmediateRenderer);

/***/ }),

/***/ "./build/wg/render/canvas/Instruction.js":
/*!***********************************************!*\
  !*** ./build/wg/render/canvas/Instruction.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fillInstruction": function() { return /* binding */ fillInstruction; },
/* harmony export */   "strokeInstruction": function() { return /* binding */ strokeInstruction; },
/* harmony export */   "beginPathInstruction": function() { return /* binding */ beginPathInstruction; },
/* harmony export */   "closePathInstruction": function() { return /* binding */ closePathInstruction; }
/* harmony export */ });
/**
 * @module wg/render/canvas/Instruction
 */

/**
 * @enum {number}
 */
var Instruction = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};
/**
 * @type {Array<Instruction>}
 */

var fillInstruction = [Instruction.FILL];
/**
 * @type {Array<Instruction>}
 */

var strokeInstruction = [Instruction.STROKE];
/**
 * @type {Array<Instruction>}
 */

var beginPathInstruction = [Instruction.BEGIN_PATH];
/**
 * @type {Array<Instruction>}
 */

var closePathInstruction = [Instruction.CLOSE_PATH];
/* harmony default export */ __webpack_exports__["default"] = (Instruction);

/***/ }),

/***/ "./build/wg/render/canvas/LineStringBuilder.js":
/*!*****************************************************!*\
  !*** ./build/wg/render/canvas/LineStringBuilder.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Builder.js */ "./build/wg/render/canvas/Builder.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Instruction.js */ "./build/wg/render/canvas/Instruction.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../canvas.js */ "./build/wg/render/canvas.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/render/canvas/LineStringBuilder
 */






var CanvasLineStringBuilder =
/** @class */
function (_super) {
  __extends(CanvasLineStringBuilder, _super);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */


  function CanvasLineStringBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */


  CanvasLineStringBuilder.prototype.drawFlatCoordinates_ = function (flatCoordinates, offset, end, stride) {
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
    var moveToLineToInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].MOVE_TO_LINE_TO, myBegin, myEnd];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);
    return end;
  };
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasLineStringBuilder.prototype.drawLineString = function (lineStringGeometry, feature) {
    var state = this.state;
    var strokeStyle = state.strokeStyle;
    var lineWidth = state.lineWidth;

    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }

    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(lineStringGeometry, feature);
    this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultLineDash, _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultLineDashOffset], _Instruction_js__WEBPACK_IMPORTED_MODULE_0__.beginPathInstruction);
    var flatCoordinates = lineStringGeometry.getFlatCoordinates();
    var stride = lineStringGeometry.getStride();
    this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.strokeInstruction);
    this.endGeometry(feature);
  };
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasLineStringBuilder.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
    var state = this.state;
    var strokeStyle = state.strokeStyle;
    var lineWidth = state.lineWidth;

    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }

    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(multiLineStringGeometry, feature);
    this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], _Instruction_js__WEBPACK_IMPORTED_MODULE_0__.beginPathInstruction);
    var ends = multiLineStringGeometry.getEnds();
    var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
    var stride = multiLineStringGeometry.getStride();
    var offset = 0;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.drawFlatCoordinates_(flatCoordinates, offset,
      /** @type {number} */
      ends[i], stride);
    }

    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.strokeInstruction);
    this.endGeometry(feature);
  };
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */


  CanvasLineStringBuilder.prototype.finish = function () {
    var state = this.state;

    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.strokeInstruction);
    }

    this.reverseHitDetectionInstructions();
    this.state = null;
    return _super.prototype.finish.call(this);
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */


  CanvasLineStringBuilder.prototype.applyStroke = function (state) {
    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.strokeInstruction);
      state.lastStroke = this.coordinates.length;
    }

    state.lastStroke = 0;

    _super.prototype.applyStroke.call(this, state);

    this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.beginPathInstruction);
  };

  return CanvasLineStringBuilder;
}(_Builder_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CanvasLineStringBuilder);

/***/ }),

/***/ "./build/wg/render/canvas/PolygonBuilder.js":
/*!**************************************************!*\
  !*** ./build/wg/render/canvas/PolygonBuilder.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Builder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Builder.js */ "./build/wg/render/canvas/Builder.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Instruction.js */ "./build/wg/render/canvas/Instruction.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../canvas.js */ "./build/wg/render/canvas.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../geom/flat/simplify.js */ "./build/wg/geom/flat/simplify.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/render/canvas/PolygonBuilder
 */







var CanvasPolygonBuilder =
/** @class */
function (_super) {
  __extends(CanvasPolygonBuilder, _super);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */


  function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */


  CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {
    var state = this.state;
    var fill = state.fillStyle !== undefined;
    var stroke = state.strokeStyle !== undefined;
    var numEnds = ends.length;
    this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.beginPathInstruction);
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.beginPathInstruction);

    for (var i = 0; i < numEnds; ++i) {
      var end = ends[i];
      var myBegin = this.coordinates.length;
      var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
      var moveToLineToInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].MOVE_TO_LINE_TO, myBegin, myEnd];
      this.instructions.push(moveToLineToInstruction);
      this.hitDetectionInstructions.push(moveToLineToInstruction);

      if (stroke) {
        // Performance optimization: only call closePath() when we have a stroke.
        // Otherwise the ring is closed already (see appendFlatLineCoordinates above).
        this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.closePathInstruction);
        this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.closePathInstruction);
      }

      offset = end;
    }

    if (fill) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.fillInstruction);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.fillInstruction);
    }

    if (stroke) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.strokeInstruction);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.strokeInstruction);
    }

    return offset;
  };
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   */


  CanvasPolygonBuilder.prototype.drawCircle = function (circleGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;

    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }

    this.setFillStrokeStyles_();
    this.beginGeometry(circleGeometry, feature);

    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].SET_FILL_STYLE, _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultFillStyle]);
    }

    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
    }

    var flatCoordinates = circleGeometry.getFlatCoordinates();
    var stride = circleGeometry.getStride();
    var myBegin = this.coordinates.length;
    this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
    var circleInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].CIRCLE, myBegin];
    this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.beginPathInstruction, circleInstruction);
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.beginPathInstruction, circleInstruction);

    if (state.fillStyle !== undefined) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.fillInstruction);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.fillInstruction);
    }

    if (state.strokeStyle !== undefined) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.strokeInstruction);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__.strokeInstruction);
    }

    this.endGeometry(feature);
  };
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasPolygonBuilder.prototype.drawPolygon = function (polygonGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;

    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }

    this.setFillStrokeStyles_();
    this.beginGeometry(polygonGeometry, feature);

    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].SET_FILL_STYLE, _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultFillStyle]);
    }

    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
    }

    var ends = polygonGeometry.getEnds();
    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
    var stride = polygonGeometry.getStride();
    this.drawFlatCoordinatess_(flatCoordinates, 0,
    /** @type {Array<number>} */
    ends, stride);
    this.endGeometry(feature);
  };
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasPolygonBuilder.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;

    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }

    this.setFillStrokeStyles_();
    this.beginGeometry(multiPolygonGeometry, feature);

    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].SET_FILL_STYLE, _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultFillStyle]);
    }

    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
    }

    var endss = multiPolygonGeometry.getEndss();
    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
    var stride = multiPolygonGeometry.getStride();
    var offset = 0;

    for (var i = 0, ii = endss.length; i < ii; ++i) {
      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
    }

    this.endGeometry(feature);
  };
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */


  CanvasPolygonBuilder.prototype.finish = function () {
    this.reverseHitDetectionInstructions();
    this.state = null; // We want to preserve topology when drawing polygons.  Polygons are
    // simplified using quantization and point elimination. However, we might
    // have received a mix of quantized and non-quantized geometries, so ensure
    // that all are quantized by quantizing all coordinates in the batch.

    var tolerance = this.tolerance;

    if (tolerance !== 0) {
      var coordinates = this.coordinates;

      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = (0,_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_2__.snap)(coordinates[i], tolerance);
      }
    }

    return _super.prototype.finish.call(this);
  };
  /**
   * @private
   */


  CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function () {
    var state = this.state;
    var fillStyle = state.fillStyle;

    if (fillStyle !== undefined) {
      this.updateFillStyle(state, this.createFill);
    }

    if (state.strokeStyle !== undefined) {
      this.updateStrokeStyle(state, this.applyStroke);
    }
  };

  return CanvasPolygonBuilder;
}(_Builder_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CanvasPolygonBuilder);

/***/ }),

/***/ "./build/wg/render/canvas/TextBuilder.js":
/*!***********************************************!*\
  !*** ./build/wg/render/canvas/TextBuilder.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TEXT_ALIGN": function() { return /* binding */ TEXT_ALIGN; }
/* harmony export */ });
/* harmony import */ var _Builder_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Builder.js */ "./build/wg/render/canvas/Builder.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Instruction.js */ "./build/wg/render/canvas/Instruction.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _style_TextPlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../style/TextPlacement.js */ "./build/wg/style/TextPlacement.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../colorlike.js */ "./build/wg/colorlike.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../canvas.js */ "./build/wg/render/canvas.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util.js */ "./build/wg/util.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geom/flat/straightchunk.js */ "./build/wg/geom/flat/straightchunk.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/render/canvas/TextBuilder
 */











/**
 * @const
 * @enum {number}
 */

var TEXT_ALIGN = {
  'left': 0,
  'end': 0,
  'center': 0.5,
  'right': 1,
  'start': 1,
  'top': 0,
  'middle': 0.5,
  'hanging': 0.2,
  'alphabetic': 0.8,
  'ideographic': 0.8,
  'bottom': 1
};

var CanvasTextBuilder =
/** @class */
function (_super) {
  __extends(CanvasTextBuilder, _super);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */


  function CanvasTextBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
    /**
     * @private
     * @type {Array<HTMLCanvasElement>}
     */


    _this.labels_ = null;
    /**
     * @private
     * @type {string|Array<string>}
     */

    _this.text_ = '';
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetY_ = 0;
    /**
     * @private
     * @type {boolean|undefined}
     */

    _this.textRotateWithView_ = undefined;
    /**
     * @private
     * @type {number}
     */

    _this.textRotation_ = 0;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.textFillState_ = null;
    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */

    _this.fillStates = {};
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.textStrokeState_ = null;
    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */

    _this.strokeStates = {};
    /**
     * @private
     * @type {import("../canvas.js").TextState}
     */

    _this.textState_ =
    /** @type {import("../canvas.js").TextState} */
    {};
    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */

    _this.textStates = {};
    /**
     * @private
     * @type {string}
     */

    _this.textKey_ = '';
    /**
     * @private
     * @type {string}
     */

    _this.fillKey_ = '';
    /**
     * @private
     * @type {string}
     */

    _this.strokeKey_ = '';
    /**
     * Data shared with an image builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */

    _this.declutterImageWithText_ = undefined;
    return _this;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */


  CanvasTextBuilder.prototype.finish = function () {
    var instructions = _super.prototype.finish.call(this);

    instructions.textStates = this.textStates;
    instructions.fillStates = this.fillStates;
    instructions.strokeStates = this.strokeStates;
    return instructions;
  };
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasTextBuilder.prototype.drawText = function (geometry, feature) {
    var fillState = this.textFillState_;
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;

    if (this.text_ === '' || !textState || !fillState && !strokeState) {
      return;
    }

    var coordinates = this.coordinates;
    var begin = coordinates.length;
    var geometryType = geometry.getType();
    var flatCoordinates = null;
    var stride = geometry.getStride();

    if (textState.placement === _style_TextPlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"].LINE && (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING || geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING || geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON || geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON)) {
      if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(this.getBufferedMaxExtent(), geometry.getExtent())) {
        return;
      }

      var ends = void 0;
      flatCoordinates = geometry.getFlatCoordinates();

      if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING) {
        ends = [flatCoordinates.length];
      } else if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING) {
        ends =
        /** @type {import("../../geom/MultiLineString.js").default} */
        geometry.getEnds();
      } else if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON) {
        ends =
        /** @type {import("../../geom/Polygon.js").default} */
        geometry.getEnds().slice(0, 1);
      } else if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON) {
        var endss =
        /** @type {import("../../geom/MultiPolygon.js").default} */
        geometry.getEndss();
        ends = [];

        for (var i = 0, ii = endss.length; i < ii; ++i) {
          ends.push(endss[i][0]);
        }
      }

      this.beginGeometry(geometry, feature);
      var textAlign = textState.textAlign;
      var flatOffset = 0;
      var flatEnd = void 0;

      for (var o = 0, oo = ends.length; o < oo; ++o) {
        if (textAlign == undefined) {
          var range = (0,_geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_3__.matchingChunk)(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
          flatOffset = range[0];
          flatEnd = range[1];
        } else {
          flatEnd = ends[o];
        }

        for (var i = flatOffset; i < flatEnd; i += stride) {
          coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
        }

        var end = coordinates.length;
        flatOffset = ends[o];
        this.drawChars_(begin, end);
        begin = end;
      }

      this.endGeometry(feature);
    } else {
      var geometryWidths = textState.overflow ? null : [];

      switch (geometryType) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT:
          flatCoordinates =
          /** @type {import("../../geom/MultiPoint.js").default} */
          geometry.getFlatCoordinates();
          break;

        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING:
          flatCoordinates =
          /** @type {import("../../geom/LineString.js").default} */
          geometry.getFlatMidpoint();
          break;

        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CIRCLE:
          flatCoordinates =
          /** @type {import("../../geom/Circle.js").default} */
          geometry.getCenter();
          break;

        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING:
          flatCoordinates =
          /** @type {import("../../geom/MultiLineString.js").default} */
          geometry.getFlatMidpoints();
          stride = 2;
          break;

        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON:
          flatCoordinates =
          /** @type {import("../../geom/Polygon.js").default} */
          geometry.getFlatInteriorPoint();

          if (!textState.overflow) {
            geometryWidths.push(flatCoordinates[2] / this.resolution);
          }

          stride = 3;
          break;

        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON:
          var interiorPoints =
          /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry.getFlatInteriorPoints();
          flatCoordinates = [];

          for (var i = 0, ii = interiorPoints.length; i < ii; i += 3) {
            if (!textState.overflow) {
              geometryWidths.push(interiorPoints[i + 2] / this.resolution);
            }

            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
          }

          if (flatCoordinates.length === 0) {
            return;
          }

          stride = 2;
          break;

        default:
      }

      var end = this.appendFlatPointCoordinates(flatCoordinates, stride);

      if (end === begin) {
        return;
      }

      if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
        var beg_1 = begin / 2;
        geometryWidths = geometryWidths.filter(function (w, i) {
          var keep = coordinates[(beg_1 + i) * 2] === flatCoordinates[i * stride] && coordinates[(beg_1 + i) * 2 + 1] === flatCoordinates[i * stride + 1];

          if (!keep) {
            --beg_1;
          }

          return keep;
        });
      }

      this.saveTextStates_();

      if (textState.backgroundFill || textState.backgroundStroke) {
        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);

        if (textState.backgroundFill) {
          this.updateFillStyle(this.state, this.createFill);
          this.hitDetectionInstructions.push(this.createFill(this.state));
        }

        if (textState.backgroundStroke) {
          this.updateStrokeStyle(this.state, this.applyStroke);
          this.hitDetectionInstructions.push(this.createStroke(this.state));
        }
      }

      this.beginGeometry(geometry, feature); // adjust padding for negative scale

      var padding = textState.padding;

      if (padding != _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
        var p0 = textState.padding[0];
        var p1 = textState.padding[1];
        var p2 = textState.padding[2];
        var p3 = textState.padding[3];

        if (textState.scale[0] < 0) {
          p1 = -p1;
          p3 = -p3;
        }

        if (textState.scale[1] < 0) {
          p0 = -p0;
          p2 = -p2;
        }

        padding = [p0, p1, p2, p3];
      } // The image is unknown at this stage so we pass null; it will be computed at render time.
      // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
      // render time.


      var pixelRatio_1 = this.pixelRatio;
      this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_5__["default"].DRAW_IMAGE, begin, end, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, this.declutterImageWithText_, padding == _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultPadding ? _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultPadding : padding.map(function (p) {
        return p * pixelRatio_1;
      }), !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);
      var scale = 1 / pixelRatio_1;
      this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_5__["default"].DRAW_IMAGE, begin, end, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [scale, scale], NaN, this.declutterImageWithText_, padding, !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);
      this.endGeometry(feature);
    }
  };
  /**
   * @private
   */


  CanvasTextBuilder.prototype.saveTextStates_ = function () {
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;
    var fillState = this.textFillState_;
    var strokeKey = this.strokeKey_;

    if (strokeState) {
      if (!(strokeKey in this.strokeStates)) {
        this.strokeStates[strokeKey] = {
          strokeStyle: strokeState.strokeStyle,
          lineCap: strokeState.lineCap,
          lineDashOffset: strokeState.lineDashOffset,
          lineWidth: strokeState.lineWidth,
          lineJoin: strokeState.lineJoin,
          miterLimit: strokeState.miterLimit,
          lineDash: strokeState.lineDash
        };
      }
    }

    var textKey = this.textKey_;

    if (!(textKey in this.textStates)) {
      this.textStates[textKey] = {
        font: textState.font,
        textAlign: textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultTextAlign,
        textBaseline: textState.textBaseline || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultTextBaseline,
        scale: textState.scale
      };
    }

    var fillKey = this.fillKey_;

    if (fillState) {
      if (!(fillKey in this.fillStates)) {
        this.fillStates[fillKey] = {
          fillStyle: fillState.fillStyle
        };
      }
    }
  };
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */


  CanvasTextBuilder.prototype.drawChars_ = function (begin, end) {
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;
    var strokeKey = this.strokeKey_;
    var textKey = this.textKey_;
    var fillKey = this.fillKey_;
    this.saveTextStates_();
    var pixelRatio = this.pixelRatio;
    var baseline = TEXT_ALIGN[textState.textBaseline];
    var offsetY = this.textOffsetY_ * pixelRatio;
    var text = this.text_;
    var strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
    this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_5__["default"].DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey, textState.maxAngle, pixelRatio, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);
    this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_5__["default"].DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey, textState.maxAngle, 1, offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio]);
  };
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [opt_sharedData] Shared data.
   */


  CanvasTextBuilder.prototype.setTextStyle = function (textStyle, opt_sharedData) {
    var textState, fillState, strokeState;

    if (!textStyle) {
      this.text_ = '';
    } else {
      var textFillStyle = textStyle.getFill();

      if (!textFillStyle) {
        fillState = null;
        this.textFillState_ = fillState;
      } else {
        fillState = this.textFillState_;

        if (!fillState) {
          fillState =
          /** @type {import("../canvas.js").FillState} */
          {};
          this.textFillState_ = fillState;
        }

        fillState.fillStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_6__.asColorLike)(textFillStyle.getColor() || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultFillStyle);
      }

      var textStrokeStyle = textStyle.getStroke();

      if (!textStrokeStyle) {
        strokeState = null;
        this.textStrokeState_ = strokeState;
      } else {
        strokeState = this.textStrokeState_;

        if (!strokeState) {
          strokeState =
          /** @type {import("../canvas.js").StrokeState} */
          {};
          this.textStrokeState_ = strokeState;
        }

        var lineDash = textStrokeStyle.getLineDash();
        var lineDashOffset = textStrokeStyle.getLineDashOffset();
        var lineWidth = textStrokeStyle.getWidth();
        var miterLimit = textStrokeStyle.getMiterLimit();
        strokeState.lineCap = textStrokeStyle.getLineCap() || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultLineCap;
        strokeState.lineDash = lineDash ? lineDash.slice() : _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultLineDash;
        strokeState.lineDashOffset = lineDashOffset === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultLineDashOffset : lineDashOffset;
        strokeState.lineJoin = textStrokeStyle.getLineJoin() || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultLineJoin;
        strokeState.lineWidth = lineWidth === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultLineWidth : lineWidth;
        strokeState.miterLimit = miterLimit === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultMiterLimit : miterLimit;
        strokeState.strokeStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_6__.asColorLike)(textStrokeStyle.getColor() || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultStrokeStyle);
      }

      textState = this.textState_;
      var font = textStyle.getFont() || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultFont;
      (0,_canvas_js__WEBPACK_IMPORTED_MODULE_4__.registerFont)(font);
      var textScale = textStyle.getScaleArray();
      textState.overflow = textStyle.getOverflow();
      textState.font = font;
      textState.maxAngle = textStyle.getMaxAngle();
      textState.placement = textStyle.getPlacement();
      textState.textAlign = textStyle.getTextAlign();
      textState.textBaseline = textStyle.getTextBaseline() || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultTextBaseline;
      textState.backgroundFill = textStyle.getBackgroundFill();
      textState.backgroundStroke = textStyle.getBackgroundStroke();
      textState.padding = textStyle.getPadding() || _canvas_js__WEBPACK_IMPORTED_MODULE_4__.defaultPadding;
      textState.scale = textScale === undefined ? [1, 1] : textScale;
      var textOffsetX = textStyle.getOffsetX();
      var textOffsetY = textStyle.getOffsetY();
      var textRotateWithView = textStyle.getRotateWithView();
      var textRotation = textStyle.getRotation();
      this.text_ = textStyle.getText() || '';
      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
      this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
      this.textRotation_ = textRotation === undefined ? 0 : textRotation;
      this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : (0,_util_js__WEBPACK_IMPORTED_MODULE_7__.getUid)(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';
      this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?') + (textState.textBaseline || '?');
      this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + (0,_util_js__WEBPACK_IMPORTED_MODULE_7__.getUid)(fillState.fillStyle) : '';
    }

    this.declutterImageWithText_ = opt_sharedData;
  };

  return CanvasTextBuilder;
}(_Builder_js__WEBPACK_IMPORTED_MODULE_8__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CanvasTextBuilder);

/***/ }),

/***/ "./build/wg/render/canvas/hitdetect.js":
/*!*********************************************!*\
  !*** ./build/wg/render/canvas/hitdetect.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HIT_DETECT_RESOLUTION": function() { return /* binding */ HIT_DETECT_RESOLUTION; },
/* harmony export */   "createHitDetectionImageData": function() { return /* binding */ createHitDetectionImageData; },
/* harmony export */   "hitDetect": function() { return /* binding */ hitDetect; }
/* harmony export */ });
/* harmony import */ var _Immediate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Immediate.js */ "./build/wg/render/canvas/Immediate.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _style_IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../style/IconAnchorUnits.js */ "./build/wg/style/IconAnchorUnits.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../style.js */ "./build/wg/style/Icon.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../math.js */ "./build/wg/math.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dom.js */ "./build/wg/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../array.js */ "./build/wg/array.js");
/**
 * @module wg/render/canvas/hitdetect
 */








var HIT_DETECT_RESOLUTION = 0.5;
/**
 * @param {import("../../size.js").Size} size Canvas size in css pixels.
 * @param {Array<import("../../transform.js").Transform>} transforms Transforms
 * for rendering features to all worlds of the viewport, from coordinates to css
 * pixels.
 * @param {Array<import("../../Feature.js").FeatureLike>} features
 * Features to consider for hit detection.
 * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
 * Layer style function.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {ImageData} Hit detection image data.
 */

function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {
  var width = size[0] * HIT_DETECT_RESOLUTION;
  var height = size[1] * HIT_DETECT_RESOLUTION;
  var context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasContext2D)(width, height);
  context.imageSmoothingEnabled = false;
  var canvas = context.canvas;
  var renderer = new _Immediate_js__WEBPACK_IMPORTED_MODULE_1__["default"](context, HIT_DETECT_RESOLUTION, extent, null, rotation);
  var featureCount = features.length; // Stretch hit detection index to use the whole available color range

  var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
  var featuresByZIndex = {};

  for (var i = 1; i <= featureCount; ++i) {
    var feature = features[i - 1];
    var featureStyleFunction = feature.getStyleFunction() || styleFunction;

    if (!styleFunction) {
      continue;
    }

    var styles = featureStyleFunction(feature, resolution);

    if (!styles) {
      continue;
    }

    if (!Array.isArray(styles)) {
      styles = [styles];
    }

    var index = i * indexFactor;
    var color = '#' + ('000000' + index.toString(16)).slice(-6);

    for (var j = 0, jj = styles.length; j < jj; ++j) {
      var originalStyle = styles[j];
      var geometry = originalStyle.getGeometryFunction()(feature);

      if (!geometry || !(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(extent, geometry.getExtent())) {
        continue;
      }

      var style = originalStyle.clone();
      var fill = style.getFill();

      if (fill) {
        fill.setColor(color);
      }

      var stroke = style.getStroke();

      if (stroke) {
        stroke.setColor(color);
        stroke.setLineDash(null);
      }

      style.setText(undefined);
      var image = originalStyle.getImage();

      if (image && image.getOpacity() !== 0) {
        var imgSize = image.getImageSize();

        if (!imgSize) {
          continue;
        }

        var imgContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasContext2D)(imgSize[0], imgSize[1], undefined, {
          alpha: false
        });
        var img = imgContext.canvas;
        imgContext.fillStyle = color;
        imgContext.fillRect(0, 0, img.width, img.height);
        style.setImage(new _style_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
          img: img,
          imgSize: imgSize,
          anchor: image.getAnchor(),
          anchorXUnits: _style_IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_4__["default"].PIXELS,
          anchorYUnits: _style_IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_4__["default"].PIXELS,
          offset: image.getOrigin(),
          opacity: 1,
          size: image.getSize(),
          scale: image.getScale(),
          rotation: image.getRotation(),
          rotateWithView: image.getRotateWithView()
        }));
      }

      var zIndex = style.getZIndex() || 0;
      var byGeometryType = featuresByZIndex[zIndex];

      if (!byGeometryType) {
        byGeometryType = {};
        featuresByZIndex[zIndex] = byGeometryType;
        byGeometryType[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON] = [];
        byGeometryType[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CIRCLE] = [];
        byGeometryType[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].LINE_STRING] = [];
        byGeometryType[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINT] = [];
      }

      byGeometryType[geometry.getType().replace('Multi', '')].push(geometry, style);
    }
  }

  var zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(_array_js__WEBPACK_IMPORTED_MODULE_6__.numberSafeCompareFunction);

  for (var i = 0, ii = zIndexKeys.length; i < ii; ++i) {
    var byGeometryType = featuresByZIndex[zIndexKeys[i]];

    for (var type in byGeometryType) {
      var geomAndStyle = byGeometryType[type];

      for (var j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
        renderer.setStyle(geomAndStyle[j + 1]);

        for (var k = 0, kk = transforms.length; k < kk; ++k) {
          renderer.setTransform(transforms[k]);
          renderer.drawGeometry(geomAndStyle[j]);
        }
      }
    }
  }

  return context.getImageData(0, 0, canvas.width, canvas.height);
}
/**
 * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
 * detection canvas in css pixels.
 * @param {Array<import("../../Feature").FeatureLike>} features Features. Has to
 * match the `features` array that was passed to `createHitDetectionImageData()`.
 * @param {ImageData} imageData Hit detection image data generated by
 * `createHitDetectionImageData()`.
 * @return {Array<import("../../Feature").FeatureLike>} features Features.
 */

function hitDetect(pixel, features, imageData) {
  var resultFeatures = [];

  if (imageData) {
    var x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
    var y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION); // The pixel coordinate is clamped down to the hit-detect canvas' size to account
    // for browsers returning coordinates slightly larger than the actual canvas size
    // due to a non-integer pixel ratio.

    var index = ((0,_math_js__WEBPACK_IMPORTED_MODULE_7__.clamp)(x, 0, imageData.width - 1) + (0,_math_js__WEBPACK_IMPORTED_MODULE_7__.clamp)(y, 0, imageData.height - 1) * imageData.width) * 4;
    var r = imageData.data[index];
    var g = imageData.data[index + 1];
    var b = imageData.data[index + 2];
    var i = b + 256 * (g + 256 * r);
    var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);

    if (i && i % indexFactor === 0) {
      resultFeatures.push(features[i / indexFactor - 1]);
    }
  }

  return resultFeatures;
}

/***/ }),

/***/ "./build/wg/renderer/Composite.js":
/*!****************************************!*\
  !*** ./build/wg/renderer/Composite.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Map.js */ "./build/wg/renderer/Map.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ObjectEventType.js */ "./build/wg/ObjectEventType.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../render/Event.js */ "./build/wg/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../render/EventType.js */ "./build/wg/render/EventType.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../source/State.js */ "./build/wg/source/State.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../css.js */ "./build/wg/css.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/canvas.js */ "./build/wg/render/canvas.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../layer/Layer.js */ "./build/wg/layer/Layer.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./build/wg/events.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dom.js */ "./build/wg/dom.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/renderer/Composite
 */












/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */

var CompositeMapRenderer =
/** @class */
function (_super) {
  __extends(CompositeMapRenderer, _super);
  /**
   * @param {import("../PluggableMap.js").default} map Map.
   */


  function CompositeMapRenderer(map) {
    var _this = _super.call(this, map) || this;
    /**
     * @type {import("../events.js").EventsKey}
     */


    _this.fontChangeListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_0__.listen)(_render_canvas_js__WEBPACK_IMPORTED_MODULE_1__.checkedFonts, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].PROPERTYCHANGE, map.redrawText.bind(map));
    /**
     * @private
     * @type {HTMLDivElement}
     */

    _this.element_ = document.createElement('div');
    var style = _this.element_.style;
    style.position = 'absolute';
    style.width = '100%';
    style.height = '100%';
    style.zIndex = '0';
    _this.element_.className = _css_js__WEBPACK_IMPORTED_MODULE_3__.CLASS_UNSELECTABLE + ' ol-layers';
    var container = map.getViewport();
    container.insertBefore(_this.element_, container.firstChild || null);
    /**
     * @private
     * @type {Array<HTMLElement>}
     */

    _this.children_ = [];
    /**
     * @private
     * @type {boolean}
     */

    _this.renderedVisible_ = true;
    return _this;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  CompositeMapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
    var map = this.getMap();

    if (map.hasListener(type)) {
      var event_1 = new _render_Event_js__WEBPACK_IMPORTED_MODULE_4__["default"](type, undefined, frameState);
      map.dispatchEvent(event_1);
    }
  };

  CompositeMapRenderer.prototype.disposeInternal = function () {
    (0,_events_js__WEBPACK_IMPORTED_MODULE_0__.unlistenByKey)(this.fontChangeListenerKey_);
    this.element_.parentNode.removeChild(this.element_);

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * Render.
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  CompositeMapRenderer.prototype.renderFrame = function (frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element_.style.display = 'none';
        this.renderedVisible_ = false;
      }

      return;
    }

    this.calculateMatrices2D(frameState);
    this.dispatchRenderEvent(_render_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].PRECOMPOSE, frameState);
    var layerStatesArray = frameState.layerStatesArray.sort(function (a, b) {
      return a.zIndex - b.zIndex;
    });
    var viewState = frameState.viewState;
    this.children_.length = 0;
    /**
     * @type {Array<import("../layer/BaseVector.js").default>}
     */

    var declutterLayers = [];
    var previousElement = null;

    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layerState = layerStatesArray[i];
      frameState.layerIndex = i;
      var layer = layerState.layer;
      var sourceState = layer.getSourceState();

      if (!(0,_layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__.inView)(layerState, viewState) || sourceState != _source_State_js__WEBPACK_IMPORTED_MODULE_7__["default"].READY && sourceState != _source_State_js__WEBPACK_IMPORTED_MODULE_7__["default"].UNDEFINED) {
        layer.unrender();
        continue;
      }

      var element = layer.render(frameState, previousElement);

      if (!element) {
        continue;
      }

      if (element !== previousElement) {
        this.children_.push(element);
        previousElement = element;
      }

      if ('getDeclutter' in layer) {
        declutterLayers.push(
        /** @type {import("../layer/BaseVector.js").default} */
        layer);
      }
    }

    for (var i = declutterLayers.length - 1; i >= 0; --i) {
      declutterLayers[i].renderDeclutter(frameState);
    }

    (0,_dom_js__WEBPACK_IMPORTED_MODULE_8__.replaceChildren)(this.element_, this.children_);
    this.dispatchRenderEvent(_render_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POSTCOMPOSE, frameState);

    if (!this.renderedVisible_) {
      this.element_.style.display = '';
      this.renderedVisible_ = true;
    }

    this.scheduleExpireIconCache(frameState);
  };
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../layer/Layer.js").default<import("../source/Source").default>, (Uint8ClampedArray|Uint8Array)): T} callback Layer
   *     callback.
   * @param {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @return {T|undefined} Callback result.
   * @template T
   */


  CompositeMapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
    var viewState = frameState.viewState;
    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;

    for (var i = numLayers - 1; i >= 0; --i) {
      var layerState = layerStates[i];
      var layer = layerState.layer;

      if (layer.hasRenderer() && (0,_layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__.inView)(layerState, viewState) && layerFilter(layer)) {
        var layerRenderer = layer.getRenderer();
        var data = layerRenderer.getDataAtPixel(pixel, frameState, hitTolerance);

        if (data) {
          var result = callback(layer, data);

          if (result) {
            return result;
          }
        }
      }
    }

    return undefined;
  };

  return CompositeMapRenderer;
}(_Map_js__WEBPACK_IMPORTED_MODULE_9__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CompositeMapRenderer);

/***/ }),

/***/ "./build/wg/renderer/Layer.js":
/*!************************************!*\
  !*** ./build/wg/renderer/Layer.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./build/wg/ImageState.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Observable.js */ "./build/wg/Observable.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../source/State.js */ "./build/wg/source/State.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/renderer/Layer
 */







/**
 * @template {import("../layer/Layer.js").default} LayerType
 */

var LayerRenderer =
/** @class */
function (_super) {
  __extends(LayerRenderer, _super);
  /**
   * @param {LayerType} layer Layer.
   */


  function LayerRenderer(layer) {
    var _this = _super.call(this) || this;
    /**
     * The renderer is initialized and ready to render.
     * @type {boolean}
     */


    _this.ready = true;
    /** @private */

    _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);
    /**
     * @protected
     * @type {LayerType}
     */

    _this.layer_ = layer;
    /**
     * @type {import("../render/canvas/ExecutorGroup").default}
     */

    _this.declutterExecutorGroup = null;
    return _this;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
   * an array of features.
   */


  LayerRenderer.prototype.getFeatures = function (pixel) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.abstract)();
  };
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */


  LayerRenderer.prototype.getData = function (pixel) {
    return null;
  };
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */


  LayerRenderer.prototype.prepareFrame = function (frameState) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.abstract)();
  };
  /**
   * Render the layer.
   * @abstract
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */


  LayerRenderer.prototype.renderFrame = function (frameState, target) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.abstract)();
  };
  /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */


  LayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {
    if (!tiles[zoom]) {
      tiles[zoom] = {};
    }

    tiles[zoom][tile.tileCoord.toString()] = tile;
    return undefined;
  };
  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */


  LayerRenderer.prototype.createLoadedTileFinder = function (source, projection, tiles) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       * @this {LayerRenderer}
       */
      function (zoom, tileRange) {
        var callback = this.loadedTileCallback.bind(this, tiles, zoom);
        return source.forEachLoadedTile(projection, zoom, tileRange, callback);
      }.bind(this)
    );
  };
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */


  LayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {
    return undefined;
  };
  /**
   * @abstract
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
   *    location, null will be returned.  If there is data, but pixel values cannot be
   *    returned, and empty array will be returned.
   */


  LayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
    return null;
  };
  /**
   * @return {LayerType} Layer.
   */


  LayerRenderer.prototype.getLayer = function () {
    return this.layer_;
  };
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */


  LayerRenderer.prototype.handleFontsChanged = function () {};
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */


  LayerRenderer.prototype.handleImageChange_ = function (event) {
    var image =
    /** @type {import("../Image.js").default} */
    event.target;

    if (image.getState() === _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      this.renderIfReadyAndVisible();
    }
  };
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../ImageBase.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */


  LayerRenderer.prototype.loadImage = function (image) {
    var imageState = image.getState();

    if (imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED && imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      image.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.boundHandleImageChange_);
    }

    if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      image.load();
      imageState = image.getState();
    }

    return imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
  };
  /**
   * @protected
   */


  LayerRenderer.prototype.renderIfReadyAndVisible = function () {
    var layer = this.getLayer();

    if (layer.getVisible() && layer.getSourceState() == _source_State_js__WEBPACK_IMPORTED_MODULE_3__["default"].READY) {
      layer.changed();
    }
  };
  /**
   * Clean up.
   */


  LayerRenderer.prototype.disposeInternal = function () {
    delete this.layer_;

    _super.prototype.disposeInternal.call(this);
  };

  return LayerRenderer;
}(_Observable_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (LayerRenderer);

/***/ }),

/***/ "./build/wg/renderer/Map.js":
/*!**********************************!*\
  !*** ./build/wg/renderer/Map.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Disposable.js */ "./build/wg/Disposable.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../style/IconImageCache.js */ "./build/wg/style/IconImageCache.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../layer/Layer.js */ "./build/wg/layer/Layer.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../coordinate.js */ "./build/wg/coordinate.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/renderer/Map
 */










/**
 * @typedef HitMatch
 * @property {import("../Feature.js").FeatureLike} feature Feature.
 * @property {import("../layer/Layer.js").default} layer Layer.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} distanceSq Squared distance.
 * @property {import("./vector.js").FeatureCallback<T>} callback Callback.
 * @template T
 */

/**
 * @abstract
 */

var MapRenderer =
/** @class */
function (_super) {
  __extends(MapRenderer, _super);
  /**
   * @param {import("../PluggableMap.js").default} map Map.
   */


  function MapRenderer(map) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */


    _this.map_ = map;
    return _this;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  MapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.abstract)();
  };
  /**
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @protected
   */


  MapRenderer.prototype.calculateMatrices2D = function (frameState) {
    var viewState = frameState.viewState;
    var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.compose)(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.makeInverse)(pixelToCoordinateTransform, coordinateToPixelTransform);
  };
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */


  MapRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
    var result;
    var viewState = frameState.viewState;
    /**
     * @param {boolean} managed Managed layer.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @return {T|undefined} Callback result.
     */

    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
      return callback.call(thisArg, feature, managed ? layer : null, geometry);
    }

    var projection = viewState.projection;
    var translatedCoordinate = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_2__.wrapX)(coordinate.slice(), projection);
    var offsets = [[0, 0]];

    if (projection.canWrapX() && checkWrapped) {
      var projectionExtent = projection.getExtent();
      var worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getWidth)(projectionExtent);
      offsets.push([-worldWidth, 0], [worldWidth, 0]);
    }

    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;
    var matches =
    /** @type {Array<HitMatch<T>>} */
    [];
    var tmpCoord = [];

    for (var i = 0; i < offsets.length; i++) {
      for (var j = numLayers - 1; j >= 0; --j) {
        var layerState = layerStates[j];
        var layer = layerState.layer;

        if (layer.hasRenderer() && (0,_layer_Layer_js__WEBPACK_IMPORTED_MODULE_4__.inView)(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
          var layerRenderer = layer.getRenderer();
          var source = layer.getSource();

          if (layerRenderer && source) {
            var coordinates = source.getWrapX() ? translatedCoordinate : coordinate;
            var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);
            tmpCoord[0] = coordinates[0] + offsets[i][0];
            tmpCoord[1] = coordinates[1] + offsets[i][1];
            result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, matches);
          }

          if (result) {
            return result;
          }
        }
      }
    }

    if (matches.length === 0) {
      return undefined;
    }

    var order = 1 / matches.length;
    matches.forEach(function (m, i) {
      return m.distanceSq += i * order;
    });
    matches.sort(function (a, b) {
      return a.distanceSq - b.distanceSq;
    });
    matches.some(function (m) {
      return result = m.callback(m.feature, m.layer, m.geometry);
    });
    return result;
  };
  /**
   * @abstract
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../layer/Layer.js").default<import("../source/Source").default>, (Uint8ClampedArray|Uint8Array)): T} callback Layer
   *     callback.
   * @param {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @return {T|undefined} Callback result.
   * @template T
   */


  MapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.abstract)();
  };
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */


  MapRenderer.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, _functions_js__WEBPACK_IMPORTED_MODULE_5__.TRUE, this, layerFilter, thisArg);
    return hasFeature !== undefined;
  };
  /**
   * @return {import("../PluggableMap.js").default} Map.
   */


  MapRenderer.prototype.getMap = function () {
    return this.map_;
  };
  /**
   * Render.
   * @abstract
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  MapRenderer.prototype.renderFrame = function (frameState) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.abstract)();
  };
  /**
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */


  MapRenderer.prototype.scheduleExpireIconCache = function (frameState) {
    if (_style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__.shared.canExpireCache()) {
      frameState.postRenderFunctions.push(expireIconCache);
    }
  };

  return MapRenderer;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
/**
 * @param {import("../PluggableMap.js").default} map Map.
 * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
 */


function expireIconCache(map, frameState) {
  _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__.shared.expire();
}

/* harmony default export */ __webpack_exports__["default"] = (MapRenderer);

/***/ }),

/***/ "./build/wg/renderer/canvas/ImageLayer.js":
/*!************************************************!*\
  !*** ./build/wg/renderer/canvas/ImageLayer.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Layer.js */ "./build/wg/renderer/canvas/Layer.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../ViewHint.js */ "./build/wg/ViewHint.js");
/* harmony import */ var _reproj_common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../reproj/common.js */ "./build/wg/reproj/common.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./common.js */ "./build/wg/renderer/canvas/common.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../proj.js */ "./build/wg/proj.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/renderer/canvas/ImageLayer
 */










/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */

var CanvasImageLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasImageLayerRenderer, _super);
  /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */


  function CanvasImageLayerRenderer(imageLayer) {
    var _this = _super.call(this, imageLayer) || this;
    /**
     * @protected
     * @type {?import("../../ImageBase.js").default}
     */


    _this.image_ = null;
    return _this;
  }
  /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */


  CanvasImageLayerRenderer.prototype.getImage = function () {
    return !this.image_ ? null : this.image_.getImage();
  };
  /**
   * Determine whether render should be called.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */


  CanvasImageLayerRenderer.prototype.prepareFrame = function (frameState) {
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var viewResolution = viewState.resolution;
    var imageSource = this.getLayer().getSource();
    var hints = frameState.viewHints;
    var renderedExtent = frameState.extent;

    if (layerState.extent !== undefined) {
      renderedExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getIntersection)(renderedExtent, (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, viewState.projection));
    }

    if (!hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].ANIMATING] && !hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERACTING] && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(renderedExtent)) {
      if (imageSource) {
        var projection = viewState.projection;

        if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_3__.ENABLE_RASTER_REPROJECTION) {
          var sourceProjection = imageSource.getProjection();

          if (sourceProjection) {
            projection = sourceProjection;
          }
        }

        var image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);

        if (image && this.loadImage(image)) {
          this.image_ = image;
        } else {
          this.image_ = null;
        }
      } else {
        this.image_ = null;
      }
    }

    return !!this.image_;
  };
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */


  CanvasImageLayerRenderer.prototype.getData = function (pixel) {
    var frameState = this.frameState;

    if (!frameState) {
      return null;
    }

    var layer = this.getLayer();
    var coordinate = (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
    var layerExtent = layer.getExtent();

    if (layerExtent) {
      if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsCoordinate)(layerExtent, coordinate)) {
        return null;
      }
    }

    var imageExtent = this.image_.getExtent();
    var img = this.image_.getImage();
    var imageMapWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(imageExtent);
    var col = Math.floor(img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth));

    if (col < 0 || col >= img.width) {
      return null;
    }

    var imageMapHeight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getHeight)(imageExtent);
    var row = Math.floor(img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight));

    if (row < 0 || row >= img.height) {
      return null;
    }

    return this.getImageData(img, col, row);
  };
  /**
   * Render the layer.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */


  CanvasImageLayerRenderer.prototype.renderFrame = function (frameState, target) {
    var image = this.image_;
    var imageExtent = image.getExtent();
    var imageResolution = image.getResolution();
    var imagePixelRatio = image.getPixelRatio();
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var viewCenter = viewState.center;
    var viewResolution = viewState.resolution;
    var size = frameState.size;
    var scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);
    var width = Math.round(size[0] * pixelRatio);
    var height = Math.round(size[1] * pixelRatio);
    var rotation = viewState.rotation;

    if (rotation) {
      var size_1 = Math.round(Math.sqrt(width * width + height * height));
      width = size_1;
      height = size_1;
    } // set forward and inverse pixel transforms


    (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.compose)(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.makeInverse)(this.inversePixelTransform, this.pixelTransform);
    var canvasTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.toString)(this.pixelTransform);
    this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));
    var context = this.context;
    var canvas = context.canvas;

    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    } // clipped rendering if layer extent is set


    var clipped = false;
    var render = true;

    if (layerState.extent) {
      var layerExtent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, viewState.projection);
      render = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.intersects)(layerExtent, frameState.extent);
      clipped = render && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsExtent)(layerExtent, frameState.extent);

      if (clipped) {
        this.clipUnrotated(context, frameState, layerExtent);
      }
    }

    var img = image.getImage();
    var transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.compose)(this.tempTransform, width / 2, height / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
    var dw = img.width * transform[0];
    var dh = img.height * transform[3];

    if (!this.getLayer().getSource().getInterpolate()) {
      (0,_obj_js__WEBPACK_IMPORTED_MODULE_5__.assign)(context, _common_js__WEBPACK_IMPORTED_MODULE_6__.IMAGE_SMOOTHING_DISABLED);
    }

    this.preRender(context, frameState);

    if (render && dw >= 0.5 && dh >= 0.5) {
      var dx = transform[4];
      var dy = transform[5];
      var opacity = layerState.opacity;
      var previousAlpha = void 0;

      if (opacity !== 1) {
        previousAlpha = context.globalAlpha;
        context.globalAlpha = opacity;
      }

      context.drawImage(img, 0, 0, +img.width, +img.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));

      if (opacity !== 1) {
        context.globalAlpha = previousAlpha;
      }
    }

    this.postRender(context, frameState);

    if (clipped) {
      context.restore();
    }

    (0,_obj_js__WEBPACK_IMPORTED_MODULE_5__.assign)(context, _common_js__WEBPACK_IMPORTED_MODULE_6__.IMAGE_SMOOTHING_ENABLED);

    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }

    return this.container;
  };

  return CanvasImageLayerRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_7__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CanvasImageLayerRenderer);

/***/ }),

/***/ "./build/wg/renderer/canvas/Layer.js":
/*!*******************************************!*\
  !*** ./build/wg/renderer/canvas/Layer.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Layer.js */ "./build/wg/renderer/Layer.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../render/Event.js */ "./build/wg/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../render/EventType.js */ "./build/wg/render/EventType.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../color.js */ "./build/wg/color.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dom.js */ "./build/wg/dom.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../array.js */ "./build/wg/array.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/renderer/canvas/Layer
 */










/**
 * @type {CanvasRenderingContext2D}
 */

var pixelContext = null;

function createPixelContext() {
  var canvas = document.createElement('canvas');
  canvas.width = 1;
  canvas.height = 1;
  pixelContext = canvas.getContext('2d');
}
/**
 * @abstract
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */


var CanvasLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasLayerRenderer, _super);
  /**
   * @param {LayerType} layer Layer.
   */


  function CanvasLayerRenderer(layer) {
    var _this = _super.call(this, layer) || this;
    /**
     * @protected
     * @type {HTMLElement}
     */


    _this.container = null;
    /**
     * @protected
     * @type {number}
     */

    _this.renderedResolution;
    /**
     * A temporary transform.  The values in this transform should only be used in a
     * function that sets the values.
     * @protected
     * @type {import("../../transform.js").Transform}
     */

    _this.tempTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.create)();
    /**
     * The transform for rendered pixels to viewport CSS pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */

    _this.pixelTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.create)();
    /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */

    _this.inversePixelTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.create)();
    /**
     * @type {CanvasRenderingContext2D}
     */

    _this.context = null;
    /**
     * @type {boolean}
     */

    _this.containerReused = false;
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */

    _this.pixelContext_ = null;
    /**
     * @protected
     * @type {import("../../PluggableMap.js").FrameState|null}
     */

    _this.frameState = null;
    return _this;
  }
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */


  CanvasLayerRenderer.prototype.getImageData = function (image, col, row) {
    if (!pixelContext) {
      createPixelContext();
    }

    pixelContext.clearRect(0, 0, 1, 1);
    var data;

    try {
      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
      data = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      return null;
    }

    return data;
  };
  /**
   * @param {import('../../PluggableMap.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */


  CanvasLayerRenderer.prototype.getBackground = function (frameState) {
    var layer = this.getLayer();
    var background = layer.getBackground();

    if (typeof background === 'function') {
      background = background(frameState.viewState.resolution);
    }

    return background || undefined;
  };
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {number} opacity Opacity.
   * @param {string} [opt_backgroundColor] Background color.
   */


  CanvasLayerRenderer.prototype.useContainer = function (target, transform, opacity, opt_backgroundColor) {
    var layerClassName = this.getLayer().getClassName();
    var container, context;

    if (target && target.className === layerClassName && target.style.opacity === '' && opacity === 1 && (!opt_backgroundColor || target.style.backgroundColor && (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.equals)((0,_color_js__WEBPACK_IMPORTED_MODULE_2__.asArray)(target.style.backgroundColor), (0,_color_js__WEBPACK_IMPORTED_MODULE_2__.asArray)(opt_backgroundColor)))) {
      var canvas = target.firstElementChild;

      if (canvas instanceof HTMLCanvasElement) {
        context = canvas.getContext('2d');
      }
    }

    if (context && context.canvas.style.transform === transform) {
      // Container of the previous layer renderer can be used.
      this.container = target;
      this.context = context;
      this.containerReused = true;
    } else if (this.containerReused) {
      // Previously reused container cannot be used any more.
      this.container = null;
      this.context = null;
      this.containerReused = false;
    }

    if (!this.container) {
      container = document.createElement('div');
      container.className = layerClassName;
      var style = container.style;
      style.position = 'absolute';
      style.width = '100%';
      style.height = '100%';

      if (opt_backgroundColor) {
        style.backgroundColor = opt_backgroundColor;
      }

      context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.createCanvasContext2D)();
      var canvas = context.canvas;
      container.appendChild(canvas);
      style = canvas.style;
      style.position = 'absolute';
      style.left = '0';
      style.transformOrigin = 'top left';
      this.container = container;
      this.context = context;
    }
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */


  CanvasLayerRenderer.prototype.clipUnrotated = function (context, frameState, extent) {
    var topLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.getTopLeft)(extent);
    var topRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.getTopRight)(extent);
    var bottomRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.getBottomRight)(extent);
    var bottomLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.getBottomLeft)(extent);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.apply)(frameState.coordinateToPixelTransform, topLeft);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.apply)(frameState.coordinateToPixelTransform, topRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.apply)(frameState.coordinateToPixelTransform, bottomRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.apply)(frameState.coordinateToPixelTransform, bottomLeft);
    var inverted = this.inversePixelTransform;
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.apply)(inverted, topLeft);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.apply)(inverted, topRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.apply)(inverted, bottomRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.apply)(inverted, bottomLeft);
    context.save();
    context.beginPath();
    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
    context.clip();
  };
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @private
   */


  CanvasLayerRenderer.prototype.dispatchRenderEvent_ = function (type, context, frameState) {
    var layer = this.getLayer();

    if (layer.hasListener(type)) {
      var event_1 = new _render_Event_js__WEBPACK_IMPORTED_MODULE_5__["default"](type, this.inversePixelTransform, frameState, context);
      layer.dispatchEvent(event_1);
    }
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */


  CanvasLayerRenderer.prototype.preRender = function (context, frameState) {
    this.frameState = frameState;
    this.dispatchRenderEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].PRERENDER, context, frameState);
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */


  CanvasLayerRenderer.prototype.postRender = function (context, frameState) {
    this.dispatchRenderEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POSTRENDER, context, frameState);
  };
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */


  CanvasLayerRenderer.prototype.getRenderTransform = function (center, resolution, rotation, pixelRatio, width, height, offsetX) {
    var dx1 = width / 2;
    var dy1 = height / 2;
    var sx = pixelRatio / resolution;
    var sy = -sx;
    var dx2 = -center[0] + offsetX;
    var dy2 = -center[1];
    return (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.compose)(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
  };
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @param {import("../../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
   *    location, null will be returned.  If there is data, but pixel values cannot be
   *    returned, and empty array will be returned.
   */


  CanvasLayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
    var renderPixel = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.apply)(this.inversePixelTransform, pixel.slice());
    var context = this.context;
    var layer = this.getLayer();
    var layerExtent = layer.getExtent();

    if (layerExtent) {
      var renderCoordinate = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
      /** get only data inside of the layer extent */

      if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.containsCoordinate)(layerExtent, renderCoordinate)) {
        return null;
      }
    }

    var x = Math.round(renderPixel[0]);
    var y = Math.round(renderPixel[1]);
    var pixelContext = this.pixelContext_;

    if (!pixelContext) {
      var pixelCanvas = document.createElement('canvas');
      pixelCanvas.width = 1;
      pixelCanvas.height = 1;
      pixelContext = pixelCanvas.getContext('2d');
      this.pixelContext_ = pixelContext;
    }

    pixelContext.clearRect(0, 0, 1, 1);
    var data;

    try {
      pixelContext.drawImage(context.canvas, x, y, 1, 1, 0, 0, 1, 1);
      data = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      if (err.name === 'SecurityError') {
        // tainted canvas, we assume there is data at the given pixel (although there might not be)
        this.pixelContext_ = null;
        return new Uint8Array();
      }

      return data;
    }

    if (data[3] === 0) {
      return null;
    }

    return data;
  };
  /**
   * Clean up.
   */


  CanvasLayerRenderer.prototype.disposeInternal = function () {
    delete this.frameState;

    _super.prototype.disposeInternal.call(this);
  };

  return CanvasLayerRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_7__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CanvasLayerRenderer);

/***/ }),

/***/ "./build/wg/renderer/canvas/TileLayer.js":
/*!***********************************************!*\
  !*** ./build/wg/renderer/canvas/TileLayer.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Layer.js */ "./build/wg/renderer/canvas/Layer.js");
/* harmony import */ var _ImageTile_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../ImageTile.js */ "./build/wg/ImageTile.js");
/* harmony import */ var _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../reproj/Tile.js */ "./build/wg/reproj/Tile.js");
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../TileRange.js */ "./build/wg/TileRange.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../TileState.js */ "./build/wg/TileState.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./common.js */ "./build/wg/renderer/canvas/common.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../css.js */ "./build/wg/css.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util.js */ "./build/wg/util.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../array.js */ "./build/wg/array.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../size.js */ "./build/wg/size.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/renderer/canvas/TileLayer
 */
















/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 * @template {import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default} [LayerType=import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default]
 * @extends {CanvasLayerRenderer<LayerType>}
 */

var CanvasTileLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasTileLayerRenderer, _super);
  /**
   * @param {LayerType} tileLayer Tile layer.
   */


  function CanvasTileLayerRenderer(tileLayer) {
    var _this = _super.call(this, tileLayer) || this;
    /**
     * Rendered extent has changed since the previous `renderFrame()` call
     * @type {boolean}
     */


    _this.extentChanged = true;
    /**
     * @private
     * @type {?import("../../extent.js").Extent}
     */

    _this.renderedExtent_ = null;
    /**
     * @protected
     * @type {number}
     */

    _this.renderedPixelRatio;
    /**
     * @protected
     * @type {import("../../proj/Projection.js").default}
     */

    _this.renderedProjection = null;
    /**
     * @protected
     * @type {number}
     */

    _this.renderedRevision;
    /**
     * @protected
     * @type {!Array<import("../../Tile.js").default>}
     */

    _this.renderedTiles = [];
    /**
     * @private
     * @type {boolean}
     */

    _this.newTiles_ = false;
    /**
     * @protected
     * @type {import("../../extent.js").Extent}
     */

    _this.tmpExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createEmpty)();
    /**
     * @private
     * @type {import("../../TileRange.js").default}
     */

    _this.tmpTileRange_ = new _TileRange_js__WEBPACK_IMPORTED_MODULE_2__["default"](0, 0, 0, 0);
    return _this;
  }
  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */


  CanvasTileLayerRenderer.prototype.isDrawableTile = function (tile) {
    var tileLayer = this.getLayer();
    var tileState = tile.getState();
    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED || tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].EMPTY || tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR && !useInterimTilesOnError;
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */


  CanvasTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {
    var pixelRatio = frameState.pixelRatio;
    var projection = frameState.viewState.projection;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getSource();
    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);

    if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR) {
      if (!tileLayer.getUseInterimTilesOnError()) {
        // When useInterimTilesOnError is false, we consider the error tile as loaded.
        tile.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED);
      } else if (tileLayer.getPreload() > 0) {
        // Preloaded tiles for lower resolutions might have finished loading.
        this.newTiles_ = true;
      }
    }

    if (!this.isDrawableTile(tile)) {
      tile = tile.getInterimTile();
    }

    return tile;
  };
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */


  CanvasTileLayerRenderer.prototype.getData = function (pixel) {
    var frameState = this.frameState;

    if (!frameState) {
      return null;
    }

    var layer = this.getLayer();
    var coordinate = (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
    var layerExtent = layer.getExtent();

    if (layerExtent) {
      if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsCoordinate)(layerExtent, coordinate)) {
        return null;
      }
    }

    var pixelRatio = frameState.pixelRatio;
    var projection = frameState.viewState.projection;
    var viewState = frameState.viewState;
    var source = layer.getRenderSource();
    var tileGrid = source.getTileGridForProjection(viewState.projection);
    var tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);

    for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
      var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      var tile = source.getTile(z, tileCoord[1], tileCoord[2], pixelRatio, projection);

      if (!(tile instanceof _ImageTile_js__WEBPACK_IMPORTED_MODULE_5__["default"] || tile instanceof _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_6__["default"])) {
        return null;
      }

      if (tile.getState() !== _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED) {
        continue;
      }

      var tileOrigin = tileGrid.getOrigin(z);
      var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_7__.toSize)(tileGrid.getTileSize(z));
      var tileResolution = tileGrid.getResolution(z);
      var col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));
      var row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));
      return this.getImageData(tile.getImage(), col, row);
    }

    return null;
  };
  /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */


  CanvasTileLayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {
    if (this.isDrawableTile(tile)) {
      return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);
    }

    return false;
  };
  /**
   * Determine whether render should be called.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */


  CanvasTileLayerRenderer.prototype.prepareFrame = function (frameState) {
    return !!this.getLayer().getSource();
  };
  /**
   * Render the layer.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */


  CanvasTileLayerRenderer.prototype.renderFrame = function (frameState, target) {
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var viewResolution = viewState.resolution;
    var viewCenter = viewState.center;
    var rotation = viewState.rotation;
    var pixelRatio = frameState.pixelRatio;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getSource();
    var sourceRevision = tileSource.getRevision();
    var tileGrid = tileSource.getTileGridForProjection(projection);
    var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    var tileResolution = tileGrid.getResolution(z);
    var extent = frameState.extent;
    var layerExtent = layerState.extent && (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, projection);

    if (layerExtent) {
      extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getIntersection)(extent, (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, projection));
    }

    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio); // desired dimensions of the canvas in pixels

    var width = Math.round(frameState.size[0] * tilePixelRatio);
    var height = Math.round(frameState.size[1] * tilePixelRatio);

    if (rotation) {
      var size = Math.round(Math.sqrt(width * width + height * height));
      width = size;
      height = size;
    }

    var dx = tileResolution * width / 2 / tilePixelRatio;
    var dy = tileResolution * height / 2 / tilePixelRatio;
    var canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];
    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
    /**
     * @type {Object<number, Object<string, import("../../Tile.js").default>>}
     */

    var tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};
    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
    var tmpExtent = this.tmpExtent;
    var tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;

    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
        var tile = this.getTile(z, x, y, frameState);

        if (this.isDrawableTile(tile)) {
          var uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(this);

          if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            var inTransition = tile.inTransition(uid);

            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
              this.newTiles_ = true;
            }
          }

          if (tile.getAlpha(uid, frameState.time) === 1) {
            // don't look for alt tiles if alpha is 1
            continue;
          }
        }

        var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
        var covered = false;

        if (childTileRange) {
          covered = findLoadedTiles(z + 1, childTileRange);
        }

        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);
        }
      }
    }

    var canvasScale = tileResolution / viewResolution; // set forward and inverse pixel transforms

    (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.compose)(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);
    var canvasTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.toString)(this.pixelTransform);
    this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));
    var context = this.context;
    var canvas = context.canvas;
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.makeInverse)(this.inversePixelTransform, this.pixelTransform); // set scale transform for calculating tile positions on the canvas

    (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.compose)(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);

    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }

    if (layerExtent) {
      this.clipUnrotated(context, frameState, layerExtent);
    }

    if (!tileSource.getInterpolate()) {
      (0,_obj_js__WEBPACK_IMPORTED_MODULE_9__.assign)(context, _common_js__WEBPACK_IMPORTED_MODULE_10__.IMAGE_SMOOTHING_DISABLED);
    }

    this.preRender(context, frameState);
    this.renderedTiles.length = 0;
    /** @type {Array<number>} */

    var zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_11__.numberSafeCompareFunction);
    var clips, clipZs, currentClip;

    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {
      zs = zs.reverse();
    } else {
      clips = [];
      clipZs = [];
    }

    for (var i = zs.length - 1; i >= 0; --i) {
      var currentZ = zs[i];
      var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
      var currentResolution = tileGrid.getResolution(currentZ);
      var currentScale = currentResolution / tileResolution;
      var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;
      var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;
      var originTileCoord = tileGrid.getTileCoordForCoordAndZ((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getTopLeft)(canvasExtent), currentZ);
      var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      var origin_1 = (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.apply)(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);
      var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
      var tilesToDraw = tilesToDrawByZ[currentZ];

      for (var tileCoordKey in tilesToDraw) {
        var tile =
        /** @type {import("../../ImageTile.js").default} */
        tilesToDraw[tileCoordKey];
        var tileCoord = tile.tileCoord; // Calculate integer positions and sizes so that tiles align

        var xIndex = originTileCoord[1] - tileCoord[1];
        var nextX = Math.round(origin_1[0] - (xIndex - 1) * dx_1);
        var yIndex = originTileCoord[2] - tileCoord[2];
        var nextY = Math.round(origin_1[1] - (yIndex - 1) * dy_1);
        var x = Math.round(origin_1[0] - xIndex * dx_1);
        var y = Math.round(origin_1[1] - yIndex * dy_1);
        var w = nextX - x;
        var h = nextY - y;
        var transition = z === currentZ;
        var inTransition = transition && tile.getAlpha((0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(this), frameState.time) !== 1;
        var contextSaved = false;

        if (!inTransition) {
          if (clips) {
            // Clip mask for regions in this tile that already filled by a higher z tile
            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];

            for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {
              if (z !== currentZ && currentZ < clipZs[i_1]) {
                var clip = clips[i_1];

                if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.intersects)([x, y, x + w, y + h], [clip[0], clip[3], clip[4], clip[7]])) {
                  if (!contextSaved) {
                    context.save();
                    contextSaved = true;
                  }

                  context.beginPath(); // counter-clockwise (outer ring) for current tile

                  context.moveTo(currentClip[0], currentClip[1]);
                  context.lineTo(currentClip[2], currentClip[3]);
                  context.lineTo(currentClip[4], currentClip[5]);
                  context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher z tile

                  context.moveTo(clip[6], clip[7]);
                  context.lineTo(clip[4], clip[5]);
                  context.lineTo(clip[2], clip[3]);
                  context.lineTo(clip[0], clip[1]);
                  context.clip();
                }
              }
            }

            clips.push(currentClip);
            clipZs.push(currentZ);
          } else {
            context.clearRect(x, y, w, h);
          }
        }

        this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition);

        if (clips && !inTransition) {
          if (contextSaved) {
            context.restore();
          }

          this.renderedTiles.unshift(tile);
        } else {
          this.renderedTiles.push(tile);
        }

        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
      }
    }

    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution;
    this.extentChanged = !this.renderedExtent_ || !(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.equals)(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;
    this.renderedProjection = projection;
    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
    this.scheduleExpireCache(frameState, tileSource);
    this.postRender(context, frameState);

    if (layerState.extent) {
      context.restore();
    }

    (0,_obj_js__WEBPACK_IMPORTED_MODULE_9__.assign)(context, _common_js__WEBPACK_IMPORTED_MODULE_10__.IMAGE_SMOOTHING_ENABLED);

    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }

    var opacity = (0,_css_js__WEBPACK_IMPORTED_MODULE_12__.cssOpacity)(layerState.opacity);
    var container = this.container;

    if (opacity !== container.style.opacity) {
      container.style.opacity = opacity;
    }

    return this.container;
  };
  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */


  CanvasTileLayerRenderer.prototype.drawTileImage = function (tile, frameState, x, y, w, h, gutter, transition) {
    var image = this.getTileImage(tile);

    if (!image) {
      return;
    }

    var uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(this);
    var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
    var alphaChanged = alpha !== this.context.globalAlpha;

    if (alphaChanged) {
      this.context.save();
      this.context.globalAlpha = alpha;
    }

    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);

    if (alphaChanged) {
      this.context.restore();
    }

    if (alpha !== 1) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  };
  /**
   * @return {HTMLCanvasElement} Image
   */


  CanvasTileLayerRenderer.prototype.getImage = function () {
    var context = this.context;
    return context ? context.canvas : null;
  };
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */


  CanvasTileLayerRenderer.prototype.getTileImage = function (tile) {
    return tile.getImage();
  };
  /**
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */


  CanvasTileLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      /**
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @param {import("../../PluggableMap.js").default} map Map.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       */
      var postRenderFunction = function (tileSource, map, frameState) {
        var tileSourceKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(tileSource);

        if (tileSourceKey in frameState.usedTiles) {
          tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
        }
      }.bind(null, tileSource);

      frameState.postRenderFunctions.push(
      /** @type {import("../../PluggableMap.js").PostRenderFunction} */
      postRenderFunction);
    }
  };
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */


  CanvasTileLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, tile) {
    // FIXME should we use tilesToDrawByZ instead?
    var tileSourceKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(tileSource);

    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }

    usedTiles[tileSourceKey][tile.getKey()] = true;
  };
  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [opt_tileCallback] Tile callback.
   * @protected
   */


  CanvasTileLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {
    var tileSourceKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(tileSource);

    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }

    var wantedTiles = frameState.wantedTiles[tileSourceKey];
    var tileQueue = frameState.tileQueue;
    var minZoom = tileGrid.getMinZoom();
    var tileCount = 0;
    var tile, tileRange, tileResolution, x, y, z;

    for (z = minZoom; z <= currentZ; ++z) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
      tileResolution = tileGrid.getResolution(z);

      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (currentZ - z <= preload) {
            ++tileCount;
            tile = tileSource.getTile(z, x, y, pixelRatio, projection);

            if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].IDLE) {
              wantedTiles[tile.getKey()] = true;

              if (!tileQueue.isKeyQueued(tile.getKey())) {
                tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
              }
            }

            if (opt_tileCallback !== undefined) {
              opt_tileCallback(tile);
            }
          } else {
            tileSource.useTile(z, x, y, projection);
          }
        }
      }
    }

    tileSource.updateCacheSize(tileCount, projection);
  };

  return CanvasTileLayerRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_13__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CanvasTileLayerRenderer);

/***/ }),

/***/ "./build/wg/renderer/canvas/VectorImageLayer.js":
/*!******************************************************!*\
  !*** ./build/wg/renderer/canvas/VectorImageLayer.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ImageLayer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ImageLayer.js */ "./build/wg/renderer/canvas/ImageLayer.js");
/* harmony import */ var _VectorLayer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VectorLayer.js */ "./build/wg/renderer/canvas/VectorLayer.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../ImageCanvas.js */ "./build/wg/ImageCanvas.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../ImageState.js */ "./build/wg/ImageState.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/rbush.min.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../ViewHint.js */ "./build/wg/ViewHint.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/renderer/canvas/VectorImageLayer
 */












/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */

var CanvasVectorImageLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasVectorImageLayerRenderer, _super);
  /**
   * @param {import("../../layer/VectorImage.js").default} layer Vector image layer.
   */


  function CanvasVectorImageLayerRenderer(layer) {
    var _this = _super.call(this, layer) || this;
    /**
     * @private
     * @type {import("./VectorLayer.js").default}
     */


    _this.vectorRenderer_ = new _VectorLayer_js__WEBPACK_IMPORTED_MODULE_1__["default"](layer);
    /**
     * @private
     * @type {number}
     */

    _this.layerImageRatio_ = layer.getImageRatio();
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.coordinateToVectorPixelTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.renderedPixelToCoordinateTransform_ = null;
    return _this;
  }
  /**
   * Clean up.
   */


  CanvasVectorImageLayerRenderer.prototype.disposeInternal = function () {
    this.vectorRenderer_.dispose();

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
   */


  CanvasVectorImageLayerRenderer.prototype.getFeatures = function (pixel) {
    if (!this.vectorRenderer_) {
      return new Promise(function (resolve) {
        return resolve([]);
      });
    }

    var vectorPixel = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(this.coordinateToVectorPixelTransform_, (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(this.renderedPixelToCoordinateTransform_, pixel.slice()));
    return this.vectorRenderer_.getFeatures(vectorPixel);
  };
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */


  CanvasVectorImageLayerRenderer.prototype.handleFontsChanged = function () {
    this.vectorRenderer_.handleFontsChanged();
  };
  /**
   * Determine whether render should be called.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */


  CanvasVectorImageLayerRenderer.prototype.prepareFrame = function (frameState) {
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var viewResolution = viewState.resolution;
    var hints = frameState.viewHints;
    var vectorRenderer = this.vectorRenderer_;
    var renderedExtent = frameState.extent;

    if (this.layerImageRatio_ !== 1) {
      renderedExtent = renderedExtent.slice(0);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.scaleFromCenter)(renderedExtent, this.layerImageRatio_);
    }

    var width = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getWidth)(renderedExtent) / viewResolution;
    var height = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getHeight)(renderedExtent) / viewResolution;

    if (!hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_4__["default"].ANIMATING] && !hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_4__["default"].INTERACTING] && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.isEmpty)(renderedExtent)) {
      vectorRenderer.useContainer(null, null, 1);
      var context = vectorRenderer.context;
      var imageFrameState_1 =
      /** @type {import("../../PluggableMap.js").FrameState} */
      (0,_obj_js__WEBPACK_IMPORTED_MODULE_5__.assign)({}, frameState, {
        declutterTree: new rbush__WEBPACK_IMPORTED_MODULE_0__(9),
        extent: renderedExtent,
        size: [width, height],
        viewState:
        /** @type {import("../../View.js").State} */
        (0,_obj_js__WEBPACK_IMPORTED_MODULE_5__.assign)({}, frameState.viewState, {
          rotation: 0
        })
      });
      var emptyImage_1 = true;
      var image_1 = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_6__["default"](renderedExtent, viewResolution, pixelRatio, context.canvas, function (callback) {
        if (vectorRenderer.prepareFrame(imageFrameState_1) && vectorRenderer.replayGroupChanged) {
          vectorRenderer.clipping = false;

          if (vectorRenderer.renderFrame(imageFrameState_1, null)) {
            vectorRenderer.renderDeclutter(imageFrameState_1);
            emptyImage_1 = false;
          }

          callback();
        }
      });
      image_1.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, function () {
        if (image_1.getState() !== _ImageState_js__WEBPACK_IMPORTED_MODULE_8__["default"].LOADED) {
          return;
        }

        this.image_ = emptyImage_1 ? null : image_1;
        var imageResolution = image_1.getResolution();
        var imagePixelRatio = image_1.getPixelRatio();
        var renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
        this.renderedResolution = renderedResolution;
        this.coordinateToVectorPixelTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.compose)(this.coordinateToVectorPixelTransform_, width / 2, height / 2, 1 / renderedResolution, -1 / renderedResolution, 0, -viewState.center[0], -viewState.center[1]);
      }.bind(this));
      image_1.load();
    }

    if (this.image_) {
      this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();
    }

    return !!this.image_;
  };
  /**
   */


  CanvasVectorImageLayerRenderer.prototype.preRender = function () {};
  /**
   */


  CanvasVectorImageLayerRenderer.prototype.postRender = function () {};
  /**
   */


  CanvasVectorImageLayerRenderer.prototype.renderDeclutter = function () {};
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */


  CanvasVectorImageLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {
    if (this.vectorRenderer_) {
      return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches);
    } else {
      return _super.prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback, matches);
    }
  };

  return CanvasVectorImageLayerRenderer;
}(_ImageLayer_js__WEBPACK_IMPORTED_MODULE_9__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CanvasVectorImageLayerRenderer);

/***/ }),

/***/ "./build/wg/renderer/canvas/VectorLayer.js":
/*!*************************************************!*\
  !*** ./build/wg/renderer/canvas/VectorLayer.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _render_canvas_BuilderGroup_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../render/canvas/BuilderGroup.js */ "./build/wg/render/canvas/BuilderGroup.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Layer.js */ "./build/wg/renderer/canvas/Layer.js");
/* harmony import */ var _render_canvas_ExecutorGroup_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../render/canvas/ExecutorGroup.js */ "./build/wg/render/canvas/ExecutorGroup.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../ViewHint.js */ "./build/wg/ViewHint.js");
/* harmony import */ var _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../render/canvas/hitdetect.js */ "./build/wg/render/canvas/hitdetect.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../css.js */ "./build/wg/css.js");
/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../vector.js */ "./build/wg/renderer/vector.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../array.js */ "./build/wg/array.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util.js */ "./build/wg/util.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../coordinate.js */ "./build/wg/coordinate.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/renderer/canvas/VectorLayer
 */















/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */

var CanvasVectorLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasVectorLayerRenderer, _super);
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */


  function CanvasVectorLayerRenderer(vectorLayer) {
    var _this = _super.call(this, vectorLayer) || this;
    /** @private */


    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
    /**
     * @type {boolean}
     */

    _this.animatingOrInteracting_;
    /**
     * @private
     * @type {boolean}
     */

    _this.dirty_ = false;
    /**
     * @type {ImageData}
     */

    _this.hitDetectionImageData_ = null;
    /**
     * @type {Array<import("../../Feature.js").default>}
     */

    _this.renderedFeatures_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.renderedRevision_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.renderedResolution_ = NaN;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    _this.renderedExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createEmpty)();
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    _this.wrappedRenderedExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createEmpty)();
    /**
     * @private
     * @type {number}
     */

    _this.renderedRotation_;
    /**
     * @private
     * @type {import("../../coordinate").Coordinate}
     */

    _this.renderedCenter_ = null;
    /**
     * @private
     * @type {import("../../proj/Projection").default}
     */

    _this.renderedProjection_ = null;
    /**
     * @private
     * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
     */

    _this.renderedRenderOrder_ = null;
    /**
     * @private
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */

    _this.replayGroup_ = null;
    /**
     * A new replay group had to be created by `prepareFrame()`
     * @type {boolean}
     */

    _this.replayGroupChanged = true;
    /**
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */

    _this.declutterExecutorGroup = null;
    /**
     * Clipping to be performed by `renderFrame()`
     * @type {boolean}
     */

    _this.clipping = true;
    return _this;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("rbush").default} [opt_declutterTree] Declutter tree.
   */


  CanvasVectorLayerRenderer.prototype.renderWorlds = function (executorGroup, frameState, opt_declutterTree) {
    var extent = frameState.extent;
    var viewState = frameState.viewState;
    var center = viewState.center;
    var resolution = viewState.resolution;
    var projection = viewState.projection;
    var rotation = viewState.rotation;
    var projectionExtent = projection.getExtent();
    var vectorSource = this.getLayer().getSource();
    var pixelRatio = frameState.pixelRatio;
    var viewHints = frameState.viewHints;
    var snapToPixel = !(viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].ANIMATING] || viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERACTING]);
    var context = this.context;
    var width = Math.round(frameState.size[0] * pixelRatio);
    var height = Math.round(frameState.size[1] * pixelRatio);
    var multiWorld = vectorSource.getWrapX() && projection.canWrapX();
    var worldWidth = multiWorld ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(projectionExtent) : null;
    var endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
    var world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;

    do {
      var transform = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);
      executorGroup.execute(context, 1, transform, rotation, snapToPixel, undefined, opt_declutterTree);
    } while (++world < endWorld);
  };
  /**
   * Render declutter items for this layer
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   */


  CanvasVectorLayerRenderer.prototype.renderDeclutter = function (frameState) {
    if (this.declutterExecutorGroup) {
      this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);
    }
  };
  /**
   * Render the layer.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */


  CanvasVectorLayerRenderer.prototype.renderFrame = function (frameState, target) {
    var pixelRatio = frameState.pixelRatio;
    var layerState = frameState.layerStatesArray[frameState.layerIndex]; // set forward and inverse pixel transforms

    (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.makeScale)(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.makeInverse)(this.inversePixelTransform, this.pixelTransform);
    var canvasTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.toString)(this.pixelTransform);
    this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));
    var context = this.context;
    var canvas = context.canvas;
    var replayGroup = this.replayGroup_;
    var declutterExecutorGroup = this.declutterExecutorGroup;

    if ((!replayGroup || replayGroup.isEmpty()) && (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())) {
      return null;
    } // resize and clear


    var width = Math.round(frameState.size[0] * pixelRatio);
    var height = Math.round(frameState.size[1] * pixelRatio);

    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;

      if (canvas.style.transform !== canvasTransform) {
        canvas.style.transform = canvasTransform;
      }
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }

    this.preRender(context, frameState);
    var viewState = frameState.viewState;
    var projection = viewState.projection; // clipped rendering if layer extent is set

    var clipped = false;
    var render = true;

    if (layerState.extent && this.clipping) {
      var layerExtent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, projection);
      render = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.intersects)(layerExtent, frameState.extent);
      clipped = render && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsExtent)(layerExtent, frameState.extent);

      if (clipped) {
        this.clipUnrotated(context, frameState, layerExtent);
      }
    }

    if (render) {
      this.renderWorlds(replayGroup, frameState);
    }

    if (clipped) {
      context.restore();
    }

    this.postRender(context, frameState);
    var opacity = (0,_css_js__WEBPACK_IMPORTED_MODULE_4__.cssOpacity)(layerState.opacity);
    var container = this.container;

    if (opacity !== container.style.opacity) {
      container.style.opacity = opacity;
    }

    if (this.renderedRotation_ !== viewState.rotation) {
      this.renderedRotation_ = viewState.rotation;
      this.hitDetectionImageData_ = null;
    }

    return this.container;
  };
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
   */


  CanvasVectorLayerRenderer.prototype.getFeatures = function (pixel) {
    return new Promise(
    /**
     * @param {function(Array<import("../../Feature").default|import("../../render/Feature").default>): void} resolve Resolver function.
     * @this {CanvasVectorLayerRenderer}
     */
    function (resolve) {
      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        var size = [this.context.canvas.width, this.context.canvas.height];
        (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.apply)(this.pixelTransform, size);
        var center = this.renderedCenter_;
        var resolution = this.renderedResolution_;
        var rotation = this.renderedRotation_;
        var projection = this.renderedProjection_;
        var extent = this.wrappedRenderedExtent_;
        var layer = this.getLayer();
        var transforms = [];
        var width = size[0] * _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_5__.HIT_DETECT_RESOLUTION;
        var height = size[1] * _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_5__.HIT_DETECT_RESOLUTION;
        transforms.push(this.getRenderTransform(center, resolution, rotation, _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_5__.HIT_DETECT_RESOLUTION, width, height, 0).slice());
        var source = layer.getSource();
        var projectionExtent = projection.getExtent();

        if (source.getWrapX() && projection.canWrapX() && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsExtent)(projectionExtent, extent)) {
          var startX = extent[0];
          var worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(projectionExtent);
          var world = 0;
          var offsetX = void 0;

          while (startX < projectionExtent[0]) {
            --world;
            offsetX = worldWidth * world;
            transforms.push(this.getRenderTransform(center, resolution, rotation, _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_5__.HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
            startX += worldWidth;
          }

          world = 0;
          startX = extent[2];

          while (startX > projectionExtent[2]) {
            ++world;
            offsetX = worldWidth * world;
            transforms.push(this.getRenderTransform(center, resolution, rotation, _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_5__.HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
            startX -= worldWidth;
          }
        }

        this.hitDetectionImageData_ = (0,_render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_5__.createHitDetectionImageData)(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
      }

      resolve((0,_render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_5__.hitDetect)(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
    }.bind(this));
  };
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */


  CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {
    var _this = this;

    if (!this.replayGroup_) {
      return undefined;
    }

    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    var layer = this.getLayer();
    /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */

    var features = {};
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {number} distanceSq The squared distance to the click position
     * @return {T|undefined} Callback result.
     */

    var featureCallback = function featureCallback(feature, geometry, distanceSq) {
      var key = (0,_util_js__WEBPACK_IMPORTED_MODULE_6__.getUid)(feature);
      var match = features[key];

      if (!match) {
        if (distanceSq === 0) {
          features[key] = true;
          return callback(feature, layer, geometry);
        }

        matches.push(features[key] = {
          feature: feature,
          layer: layer,
          geometry: geometry,
          distanceSq: distanceSq,
          callback: callback
        });
      } else if (match !== true && distanceSq < match.distanceSq) {
        if (distanceSq === 0) {
          features[key] = true;
          matches.splice(matches.lastIndexOf(match), 1);
          return callback(feature, layer, geometry);
        }

        match.geometry = geometry;
        match.distanceSq = distanceSq;
      }

      return undefined;
    };

    var result;
    var executorGroups = [this.replayGroup_];

    if (this.declutterExecutorGroup) {
      executorGroups.push(this.declutterExecutorGroup);
    }

    executorGroups.some(function (executorGroup) {
      return result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === _this.declutterExecutorGroup && frameState.declutterTree ? frameState.declutterTree.all().map(function (item) {
        return item.value;
      }) : null);
    });
    return result;
  };
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */


  CanvasVectorLayerRenderer.prototype.handleFontsChanged = function () {
    var layer = this.getLayer();

    if (layer.getVisible() && this.replayGroup_) {
      layer.changed();
    }
  };
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */


  CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function (event) {
    this.renderIfReadyAndVisible();
  };
  /**
   * Determine whether render should be called.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */


  CanvasVectorLayerRenderer.prototype.prepareFrame = function (frameState) {
    var vectorLayer = this.getLayer();
    var vectorSource = vectorLayer.getSource();

    if (!vectorSource) {
      return false;
    }

    var animating = frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].ANIMATING];
    var interacting = frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERACTING];
    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

    if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
      this.animatingOrInteracting_ = true;
      return true;
    }

    this.animatingOrInteracting_ = false;
    var frameStateExtent = frameState.extent;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var resolution = viewState.resolution;
    var pixelRatio = frameState.pixelRatio;
    var vectorLayerRevision = vectorLayer.getRevision();
    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

    if (vectorLayerRenderOrder === undefined) {
      vectorLayerRenderOrder = _vector_js__WEBPACK_IMPORTED_MODULE_7__.defaultOrder;
    }

    var center = viewState.center.slice();
    var extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.buffer)(frameStateExtent, vectorLayerRenderBuffer * resolution);
    var renderedExtent = extent.slice();
    var loadExtents = [extent.slice()];
    var projectionExtent = projection.getExtent();

    if (vectorSource.getWrapX() && projection.canWrapX() && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsExtent)(projectionExtent, frameState.extent)) {
      // For the replay group, we need an extent that intersects the real world
      // (-180° to +180°). To support geometries in a coordinate range from -540°
      // to +540°, we add at least 1 world width on each side of the projection
      // extent. If the viewport is wider than the world, we need to add half of
      // the viewport width to make sure we cover the whole viewport.
      var worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(projectionExtent);
      var gutter = Math.max((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(extent) / 2, worldWidth);
      extent[0] = projectionExtent[0] - gutter;
      extent[2] = projectionExtent[2] + gutter;
      (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_8__.wrapX)(center, projection);
      var loadExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.wrapX)(loadExtents[0], projection); // If the extent crosses the date line, we load data for both edges of the worlds

      if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
        loadExtents.push([loadExtent[0] + worldWidth, loadExtent[1], loadExtent[2] + worldWidth, loadExtent[3]]);
      } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
        loadExtents.push([loadExtent[0] - worldWidth, loadExtent[1], loadExtent[2] - worldWidth, loadExtent[3]]);
      }
    }

    if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsExtent)(this.wrappedRenderedExtent_, extent)) {
      if (!(0,_array_js__WEBPACK_IMPORTED_MODULE_9__.equals)(this.renderedExtent_, renderedExtent)) {
        this.hitDetectionImageData_ = null;
        this.renderedExtent_ = renderedExtent;
      }

      this.renderedCenter_ = center;
      this.replayGroupChanged = false;
      return true;
    }

    this.replayGroup_ = null;
    this.dirty_ = false;
    var replayGroup = new _render_canvas_BuilderGroup_js__WEBPACK_IMPORTED_MODULE_10__["default"]((0,_vector_js__WEBPACK_IMPORTED_MODULE_7__.getTolerance)(resolution, pixelRatio), extent, resolution, pixelRatio);
    var declutterBuilderGroup;

    if (this.getLayer().getDeclutter()) {
      declutterBuilderGroup = new _render_canvas_BuilderGroup_js__WEBPACK_IMPORTED_MODULE_10__["default"]((0,_vector_js__WEBPACK_IMPORTED_MODULE_7__.getTolerance)(resolution, pixelRatio), extent, resolution, pixelRatio);
    }

    var userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();
    var userTransform;

    if (userProjection) {
      for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
        var extent_1 = loadExtents[i];
        var userExtent_1 = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)(extent_1, projection);
        vectorSource.loadFeatures(userExtent_1, (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserResolution)(resolution, projection), userProjection);
      }

      userTransform = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransformFromProjections)(userProjection, projection);
    } else {
      for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
        vectorSource.loadFeatures(loadExtents[i], resolution, projection);
      }
    }

    var squaredTolerance = (0,_vector_js__WEBPACK_IMPORTED_MODULE_7__.getSquaredTolerance)(resolution, pixelRatio);

    var render =
    /**
     * @param {import("../../Feature.js").default} feature Feature.
     * @this {CanvasVectorLayerRenderer}
     */
    function (feature) {
      var styles;
      var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();

      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }

      if (styles) {
        var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);
        this.dirty_ = this.dirty_ || dirty;
      }
    }.bind(this);

    var userExtent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)(extent, projection);
    /** @type {Array<import("../../Feature.js").default>} */

    var features = vectorSource.getFeaturesInExtent(userExtent);

    if (vectorLayerRenderOrder) {
      features.sort(vectorLayerRenderOrder);
    }

    for (var i = 0, ii = features.length; i < ii; ++i) {
      render(features[i]);
    }

    this.renderedFeatures_ = features;
    var replayGroupInstructions = replayGroup.finish();
    var executorGroup = new _render_canvas_ExecutorGroup_js__WEBPACK_IMPORTED_MODULE_11__["default"](extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());

    if (declutterBuilderGroup) {
      this.declutterExecutorGroup = new _render_canvas_ExecutorGroup_js__WEBPACK_IMPORTED_MODULE_11__["default"](extent, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());
    }

    this.renderedResolution_ = resolution;
    this.renderedRevision_ = vectorLayerRevision;
    this.renderedRenderOrder_ = vectorLayerRenderOrder;
    this.renderedExtent_ = renderedExtent;
    this.wrappedRenderedExtent_ = extent;
    this.renderedCenter_ = center;
    this.renderedProjection_ = projection;
    this.replayGroup_ = executorGroup;
    this.hitDetectionImageData_ = null;
    this.replayGroupChanged = true;
    return true;
  };
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [opt_transform] Transform from user to view projection.
   * @param {import("../../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
   * @return {boolean} `true` if an image is loading.
   */


  CanvasVectorLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, builderGroup, opt_transform, opt_declutterBuilderGroup) {
    if (!styles) {
      return false;
    }

    var loading = false;

    if (Array.isArray(styles)) {
      for (var i = 0, ii = styles.length; i < ii; ++i) {
        loading = (0,_vector_js__WEBPACK_IMPORTED_MODULE_7__.renderFeature)(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup) || loading;
      }
    } else {
      loading = (0,_vector_js__WEBPACK_IMPORTED_MODULE_7__.renderFeature)(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup);
    }

    return loading;
  };

  return CanvasVectorLayerRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_12__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CanvasVectorLayerRenderer);

/***/ }),

/***/ "./build/wg/renderer/canvas/VectorTileLayer.js":
/*!*****************************************************!*\
  !*** ./build/wg/renderer/canvas/VectorTileLayer.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _render_canvas_BuilderGroup_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../render/canvas/BuilderGroup.js */ "./build/wg/render/canvas/BuilderGroup.js");
/* harmony import */ var _render_canvas_ExecutorGroup_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../render/canvas/ExecutorGroup.js */ "./build/wg/render/canvas/ExecutorGroup.js");
/* harmony import */ var _TileLayer_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./TileLayer.js */ "./build/wg/renderer/canvas/TileLayer.js");
/* harmony import */ var _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../render/canvas/BuilderType.js */ "./build/wg/render/canvas/BuilderType.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../TileState.js */ "./build/wg/TileState.js");
/* harmony import */ var _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../layer/VectorTileRenderType.js */ "./build/wg/layer/VectorTileRenderType.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ViewHint.js */ "./build/wg/ViewHint.js");
/* harmony import */ var _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../render/canvas/hitdetect.js */ "./build/wg/render/canvas/hitdetect.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../vector.js */ "./build/wg/renderer/vector.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util.js */ "./build/wg/util.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../size.js */ "./build/wg/size.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../coordinate.js */ "./build/wg/coordinate.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/renderer/canvas/VectorTileLayer
 */
















/**
 * @type {!Object<string, Array<import("../../render/canvas/BuilderType.js").default>>}
 */

var IMAGE_REPLAYS = {
  'image': [_render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON, _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CIRCLE, _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].LINE_STRING, _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE, _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].TEXT],
  'hybrid': [_render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON, _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].LINE_STRING],
  'vector': []
};
/**
 * @type {!Object<string, Array<import("../../render/canvas/BuilderType.js").default>>}
 */

var VECTOR_REPLAYS = {
  'hybrid': [_render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE, _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].TEXT, _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT],
  'vector': [_render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON, _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CIRCLE, _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].LINE_STRING, _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE, _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].TEXT, _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT]
};
/**
 * @classdesc
 * Canvas renderer for vector tile layers.
 * @api
 * @extends {CanvasTileLayerRenderer<import("../../layer/VectorTile.js").default>}
 */

var CanvasVectorTileLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasVectorTileLayerRenderer, _super);
  /**
   * @param {import("../../layer/VectorTile.js").default} layer VectorTile layer.
   */


  function CanvasVectorTileLayerRenderer(layer) {
    var _this = _super.call(this, layer) || this;
    /** @private */


    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
    /**
     * @private
     * @type {boolean}
     */

    _this.dirty_ = false;
    /**
     * @private
     * @type {number}
     */

    _this.renderedLayerRevision_;
    /**
     * @private
     * @type {import("../../transform").Transform}
     */

    _this.renderedPixelToCoordinateTransform_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.renderedRotation_;
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.tmpTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.create)();
    return _this;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection").default} projection Projection.
   * @return {boolean|undefined} Tile needs to be rendered.
   */


  CanvasVectorTileLayerRenderer.prototype.prepareTile = function (tile, pixelRatio, projection) {
    var render;
    var state = tile.getState();

    if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED || state === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
      this.updateExecutorGroup_(tile, pixelRatio, projection);

      if (this.tileImageNeedsRender_(tile)) {
        render = true;
      }
    }

    return render;
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */


  CanvasVectorTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var resolution = viewState.resolution;
    var projection = viewState.projection;
    var layer = this.getLayer();
    var tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);
    var viewHints = frameState.viewHints;
    var hifi = !(viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].ANIMATING] || viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].INTERACTING]);

    if (hifi || !tile.wantedResolution) {
      tile.wantedResolution = resolution;
    }

    var render = this.prepareTile(tile, pixelRatio, projection);

    if (render && (hifi || Date.now() - frameState.time < 8) && layer.getRenderMode() !== _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_4__["default"].VECTOR) {
      this.renderTileImage_(tile, frameState);
    }

    return _super.prototype.getTile.call(this, z, x, y, frameState);
  };
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */


  CanvasVectorTileLayerRenderer.prototype.isDrawableTile = function (tile) {
    var layer = this.getLayer();
    return _super.prototype.isDrawableTile.call(this, tile) && (layer.getRenderMode() === _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_4__["default"].VECTOR ? (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(layer) in tile.executorGroups : tile.hasContext(layer));
  };
  /**
   * @inheritDoc
   */


  CanvasVectorTileLayerRenderer.prototype.getTileImage = function (tile) {
    return tile.getImage(this.getLayer());
  };
  /**
   * Determine whether render should be called.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */


  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function (frameState) {
    var layerRevision = this.getLayer().getRevision();

    if (this.renderedLayerRevision_ != layerRevision) {
      this.renderedTiles.length = 0;
    }

    this.renderedLayerRevision_ = layerRevision;
    return _super.prototype.prepareFrame.call(this, frameState);
  };
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */


  CanvasVectorTileLayerRenderer.prototype.updateExecutorGroup_ = function (tile, pixelRatio, projection) {
    var layer =
    /** @type {import("../../layer/VectorTile.js").default} */
    this.getLayer();
    var revision = layer.getRevision();
    var renderOrder = layer.getRenderOrder() || null;
    var resolution = tile.wantedResolution;
    var builderState = tile.getReplayState(layer);

    if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder) {
      return;
    }

    var source = layer.getSource();
    var declutter = layer.getDeclutter();
    var sourceTileGrid = source.getTileGrid();
    var tileGrid = source.getTileGridForProjection(projection);
    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
    var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);
    var layerUid = (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(layer);
    delete tile.hitDetectionImageData[layerUid];
    tile.executorGroups[layerUid] = [];

    if (declutter) {
      tile.declutterExecutorGroups[layerUid] = [];
    }

    var _loop_1 = function _loop_1(t, tt) {
      var sourceTile = sourceTiles[t];

      if (sourceTile.getState() != _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
        return "continue";
      }

      var sourceTileCoord = sourceTile.tileCoord;
      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
      var sharedExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.getIntersection)(tileExtent, sourceTileExtent);
      var builderExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.buffer)(sharedExtent, layer.getRenderBuffer() * resolution, this_1.tmpExtent);
      var bufferedExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.equals)(sourceTileExtent, sharedExtent) ? null : builderExtent;
      builderState.dirty = false;
      var builderGroup = new _render_canvas_BuilderGroup_js__WEBPACK_IMPORTED_MODULE_7__["default"](0, builderExtent, resolution, pixelRatio);
      var declutterBuilderGroup = declutter ? new _render_canvas_BuilderGroup_js__WEBPACK_IMPORTED_MODULE_7__["default"](0, sharedExtent, resolution, pixelRatio) : undefined;
      var squaredTolerance = (0,_vector_js__WEBPACK_IMPORTED_MODULE_8__.getSquaredTolerance)(resolution, pixelRatio);
      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @this {CanvasVectorTileLayerRenderer}
       */

      var render = function render(feature) {
        var styles;
        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();

        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }

        if (styles) {
          var dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup);
          this.dirty_ = this.dirty_ || dirty;
          builderState.dirty = builderState.dirty || dirty;
        }
      };

      var features = sourceTile.getFeatures();

      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {
        features.sort(renderOrder);
      }

      for (var i = 0, ii = features.length; i < ii; ++i) {
        var feature = features[i];

        if (!bufferedExtent || (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.intersects)(bufferedExtent, feature.getGeometry().getExtent())) {
          render.call(this_1, feature);
        }
      }

      var executorGroupInstructions = builderGroup.finish(); // no need to clip when the render tile is covered by a single source tile

      var replayExtent = layer.getRenderMode() !== _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_4__["default"].VECTOR && declutter && sourceTiles.length === 1 ? null : sharedExtent;
      var renderingReplayGroup = new _render_canvas_ExecutorGroup_js__WEBPACK_IMPORTED_MODULE_9__["default"](replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());
      tile.executorGroups[layerUid].push(renderingReplayGroup);

      if (declutterBuilderGroup) {
        var declutterExecutorGroup = new _render_canvas_ExecutorGroup_js__WEBPACK_IMPORTED_MODULE_9__["default"](null, resolution, pixelRatio, source.getOverlaps(), declutterBuilderGroup.finish(), layer.getRenderBuffer());
        tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);
      }
    };

    var this_1 = this;

    for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {
      _loop_1(t, tt);
    }

    builderState.renderedRevision = revision;
    builderState.renderedRenderOrder = renderOrder;
    builderState.renderedResolution = resolution;
  };
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */


  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {
    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;
    var layer = this.getLayer();
    var source = layer.getSource();
    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    var hitExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.boundingExtent)([coordinate]);
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.buffer)(hitExtent, resolution * hitTolerance, hitExtent);
    /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */

    var features = {};
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {number} distanceSq The squared distance to the click position.
     * @return {T|undefined} Callback result.
     */

    var featureCallback = function featureCallback(feature, geometry, distanceSq) {
      var key = feature.getId();

      if (key === undefined) {
        key = (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(feature);
      }

      var match = features[key];

      if (!match) {
        if (distanceSq === 0) {
          features[key] = true;
          return callback(feature, layer, geometry);
        }

        matches.push(features[key] = {
          feature: feature,
          layer: layer,
          geometry: geometry,
          distanceSq: distanceSq,
          callback: callback
        });
      } else if (match !== true && distanceSq < match.distanceSq) {
        if (distanceSq === 0) {
          features[key] = true;
          matches.splice(matches.lastIndexOf(match), 1);
          return callback(feature, layer, geometry);
        }

        match.geometry = geometry;
        match.distanceSq = distanceSq;
      }

      return undefined;
    };

    var renderedTiles =
    /** @type {Array<import("../../VectorRenderTile.js").default>} */
    this.renderedTiles;
    var found;

    var _loop_2 = function _loop_2(i, ii) {
      var tile = renderedTiles[i];
      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);

      if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.intersects)(tileExtent, hitExtent)) {
        return "continue";
      }

      var layerUid = (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(layer);
      var executorGroups = [tile.executorGroups[layerUid]];
      var declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];

      if (declutterExecutorGroups) {
        executorGroups.push(declutterExecutorGroups);
      }

      executorGroups.some(function (executorGroups) {
        var declutteredFeatures = executorGroups === declutterExecutorGroups ? frameState.declutterTree.all().map(function (item) {
          return item.value;
        }) : null;

        for (var t = 0, tt = executorGroups.length; t < tt; ++t) {
          var executorGroup = executorGroups[t];
          found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);

          if (found) {
            return true;
          }
        }
      });
    };

    for (var i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {
      _loop_2(i, ii);
    }

    return found;
  };
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
   */


  CanvasVectorTileLayerRenderer.prototype.getFeatures = function (pixel) {
    return new Promise(function (resolve, reject) {
      var layer =
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer();
      var layerUid = (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(layer);
      var source = layer.getSource();
      var projection = this.renderedProjection;
      var projectionExtent = projection.getExtent();
      var resolution = this.renderedResolution;
      var tileGrid = source.getTileGridForProjection(projection);
      var coordinate = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.apply)(this.renderedPixelToCoordinateTransform_, pixel.slice());
      var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);
      var tile;

      for (var i = 0, ii = this.renderedTiles.length; i < ii; ++i) {
        if (tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()) {
          tile = this.renderedTiles[i];

          if (tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
            var extent_1 = tileGrid.getTileCoordExtent(tile.tileCoord);

            if (source.getWrapX() && projection.canWrapX() && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.containsExtent)(projectionExtent, extent_1)) {
              (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_10__.wrapX)(coordinate, projection);
            }

            break;
          }

          tile = undefined;
        }
      }

      if (!tile || tile.loadingSourceTiles > 0) {
        resolve([]);
        return;
      }

      var extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
      var corner = (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.getTopLeft)(extent);
      var tilePixel = [(coordinate[0] - corner[0]) / resolution, (corner[1] - coordinate[1]) / resolution];
      var features = tile.getSourceTiles().reduce(function (accumulator, sourceTile) {
        return accumulator.concat(sourceTile.getFeatures());
      }, []);
      var hitDetectionImageData = tile.hitDetectionImageData[layerUid];

      if (!hitDetectionImageData && !this.animatingOrInteracting_) {
        var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_11__.toSize)(tileGrid.getTileSize(tileGrid.getZForResolution(resolution)));
        var rotation = this.renderedRotation_;
        var transforms = [this.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_12__.HIT_DETECT_RESOLUTION, tileSize[0] * _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_12__.HIT_DETECT_RESOLUTION, tileSize[1] * _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_12__.HIT_DETECT_RESOLUTION, 0)];
        hitDetectionImageData = (0,_render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_12__.createHitDetectionImageData)(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);
        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;
      }

      resolve((0,_render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_12__.hitDetect)(tilePixel, features, hitDetectionImageData));
    }.bind(this));
  };
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */


  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged = function () {
    var layer = this.getLayer();

    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {
      layer.changed();
    }
  };
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */


  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function (event) {
    this.renderIfReadyAndVisible();
  };
  /**
   * Render declutter items for this layer
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   */


  CanvasVectorTileLayerRenderer.prototype.renderDeclutter = function (frameState) {
    var context = this.context;
    var alpha = context.globalAlpha;
    context.globalAlpha = this.getLayer().getOpacity();
    var viewHints = frameState.viewHints;
    var hifi = !(viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].ANIMATING] || viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].INTERACTING]);
    var tiles =
    /** @type {Array<import("../../VectorRenderTile.js").default>} */
    this.renderedTiles;

    for (var i = 0, ii = tiles.length; i < ii; ++i) {
      var tile = tiles[i];
      var declutterExecutorGroups = tile.declutterExecutorGroups[(0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(this.getLayer())];

      if (declutterExecutorGroups) {
        for (var j = declutterExecutorGroups.length - 1; j >= 0; --j) {
          declutterExecutorGroups[j].execute(this.context, 1, this.getTileRenderTransform(tile, frameState), frameState.viewState.rotation, hifi, undefined, frameState.declutterTree);
        }
      }
    }

    context.globalAlpha = alpha;
  };

  CanvasVectorTileLayerRenderer.prototype.getTileRenderTransform = function (tile, frameState) {
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var center = viewState.center;
    var resolution = viewState.resolution;
    var rotation = viewState.rotation;
    var size = frameState.size;
    var width = Math.round(size[0] * pixelRatio);
    var height = Math.round(size[1] * pixelRatio);
    var source = this.getLayer().getSource();
    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    var tileCoord = tile.tileCoord;
    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
    var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];
    var transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.multiply)((0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.scale)(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));
    return transform;
  };
  /**
   * Render the layer.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */


  CanvasVectorTileLayerRenderer.prototype.renderFrame = function (frameState, target) {
    var viewHints = frameState.viewHints;
    var hifi = !(viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].ANIMATING] || viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].INTERACTING]);

    _super.prototype.renderFrame.call(this, frameState, target);

    this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();
    this.renderedRotation_ = frameState.viewState.rotation;
    var layer =
    /** @type {import("../../layer/VectorTile.js").default} */
    this.getLayer();
    var renderMode = layer.getRenderMode();
    var context = this.context;
    var alpha = context.globalAlpha;
    context.globalAlpha = layer.getOpacity();
    var replayTypes = VECTOR_REPLAYS[renderMode];
    var viewState = frameState.viewState;
    var rotation = viewState.rotation;
    var tileSource = layer.getSource();
    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    var z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);
    var tiles = this.renderedTiles;
    var clips = [];
    var clipZs = [];

    for (var i = tiles.length - 1; i >= 0; --i) {
      var tile =
      /** @type {import("../../VectorRenderTile.js").default} */
      tiles[i];
      var executorGroups = tile.executorGroups[(0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(layer)].filter(function (group) {
        return group.hasExecutors(replayTypes);
      });

      if (executorGroups.length === 0) {
        continue;
      }

      var transform = this.getTileRenderTransform(tile, frameState);
      var currentZ = tile.tileCoord[0];
      var contextSaved = false; // Clip mask for regions in this tile that already filled by a higher z tile

      var currentClip = executorGroups[0].getClipCoords(transform);

      for (var j = 0, jj = clips.length; j < jj; ++j) {
        if (z !== currentZ && currentZ < clipZs[j]) {
          var clip = clips[j];

          if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.intersects)([currentClip[0], currentClip[3], currentClip[4], currentClip[7]], [clip[0], clip[3], clip[4], clip[7]])) {
            if (!contextSaved) {
              context.save();
              contextSaved = true;
            }

            context.beginPath(); // counter-clockwise (outer ring) for current tile

            context.moveTo(currentClip[0], currentClip[1]);
            context.lineTo(currentClip[2], currentClip[3]);
            context.lineTo(currentClip[4], currentClip[5]);
            context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher z tile

            context.moveTo(clip[6], clip[7]);
            context.lineTo(clip[4], clip[5]);
            context.lineTo(clip[2], clip[3]);
            context.lineTo(clip[0], clip[1]);
            context.clip();
          }
        }
      }

      clips.push(currentClip);
      clipZs.push(currentZ);

      for (var t = 0, tt = executorGroups.length; t < tt; ++t) {
        var executorGroup = executorGroups[t];
        executorGroup.execute(context, 1, transform, rotation, hifi, replayTypes);
      }

      if (contextSaved) {
        context.restore();
      }
    }

    context.globalAlpha = alpha;
    return this.container;
  };
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder group for decluttering.
   * @return {boolean} `true` if an image is loading.
   */


  CanvasVectorTileLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, builderGroup, opt_declutterBuilderGroup) {
    if (!styles) {
      return false;
    }

    var loading = false;

    if (Array.isArray(styles)) {
      for (var i = 0, ii = styles.length; i < ii; ++i) {
        loading = (0,_vector_js__WEBPACK_IMPORTED_MODULE_8__.renderFeature)(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, undefined, opt_declutterBuilderGroup) || loading;
      }
    } else {
      loading = (0,_vector_js__WEBPACK_IMPORTED_MODULE_8__.renderFeature)(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, undefined, opt_declutterBuilderGroup);
    }

    return loading;
  };
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} A new tile image was rendered.
   * @private
   */


  CanvasVectorTileLayerRenderer.prototype.tileImageNeedsRender_ = function (tile) {
    var layer =
    /** @type {import("../../layer/VectorTile.js").default} */
    this.getLayer();

    if (layer.getRenderMode() === _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_4__["default"].VECTOR) {
      return false;
    }

    var replayState = tile.getReplayState(layer);
    var revision = layer.getRevision();
    var resolution = tile.wantedResolution;
    return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision;
  };
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {import("../../PluggableMap").FrameState} frameState Frame state.
   * @private
   */


  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function (tile, frameState) {
    var layer =
    /** @type {import("../../layer/VectorTile.js").default} */
    this.getLayer();
    var replayState = tile.getReplayState(layer);
    var revision = layer.getRevision();
    var executorGroups = tile.executorGroups[(0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(layer)];
    replayState.renderedTileRevision = revision;
    var tileCoord = tile.wrappedTileCoord;
    var z = tileCoord[0];
    var source = layer.getSource();
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var tileGrid = source.getTileGridForProjection(projection);
    var tileResolution = tileGrid.getResolution(tile.tileCoord[0]);
    var renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;
    var resolution = tileGrid.getResolution(z);
    var context = tile.getContext(layer); // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles

    pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));
    var size = source.getTilePixelSize(z, pixelRatio, projection);
    context.canvas.width = size[0];
    context.canvas.height = size[1];
    var renderScale = pixelRatio / renderPixelRatio;

    if (renderScale !== 1) {
      var canvasTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.reset)(this.tmpTransform_);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.scale)(canvasTransform, renderScale, renderScale);
      context.setTransform.apply(context, canvasTransform);
    }

    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
    var pixelScale = renderPixelRatio / resolution;
    var transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.reset)(this.tmpTransform_);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.scale)(transform, pixelScale, -pixelScale);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.translate)(transform, -tileExtent[0], -tileExtent[3]);

    for (var i = 0, ii = executorGroups.length; i < ii; ++i) {
      var executorGroup = executorGroups[i];
      executorGroup.execute(context, renderScale, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);
    }

    replayState.renderedTileResolution = tile.wantedResolution;
  };

  return CanvasVectorTileLayerRenderer;
}(_TileLayer_js__WEBPACK_IMPORTED_MODULE_13__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CanvasVectorTileLayerRenderer);

/***/ }),

/***/ "./build/wg/renderer/canvas/common.js":
/*!********************************************!*\
  !*** ./build/wg/renderer/canvas/common.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IMAGE_SMOOTHING_DISABLED": function() { return /* binding */ IMAGE_SMOOTHING_DISABLED; },
/* harmony export */   "IMAGE_SMOOTHING_ENABLED": function() { return /* binding */ IMAGE_SMOOTHING_ENABLED; }
/* harmony export */ });
/**
 * @module wg/renderer/canvas/common
 */

/**
 * Context options to disable image smoothing.
 * @type {Object}
 */
var IMAGE_SMOOTHING_DISABLED = {
  imageSmoothingEnabled: false,
  msImageSmoothingEnabled: false
};
/**
 * Context options to enable image smoothing.
 * @type {Object}
 */

var IMAGE_SMOOTHING_ENABLED = {
  imageSmoothingEnabled: true,
  msImageSmoothingEnabled: true
};

/***/ }),

/***/ "./build/wg/renderer/vector.js":
/*!*************************************!*\
  !*** ./build/wg/renderer/vector.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultOrder": function() { return /* binding */ defaultOrder; },
/* harmony export */   "getSquaredTolerance": function() { return /* binding */ getSquaredTolerance; },
/* harmony export */   "getTolerance": function() { return /* binding */ getTolerance; },
/* harmony export */   "renderFeature": function() { return /* binding */ renderFeature; }
/* harmony export */ });
/* harmony import */ var _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/canvas/BuilderType.js */ "./build/wg/render/canvas/BuilderType.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageState.js */ "./build/wg/ImageState.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/**
 * @module wg/renderer/vector
 */




/**
 * Feature callback. The callback will be called with three arguments. The first
 * argument is one {@link module:wg/Feature~Feature feature} or {@link module:wg/render/Feature~RenderFeature render feature}
 * at the pixel, the second is the {@link module:wg/layer/Layer~Layer layer} of the feature and will be null for
 * unmanaged layers. The third is the {@link module:wg/geom/SimpleGeometry~SimpleGeometry} of the feature. For features
 * with a GeometryCollection geometry, it will be the first detected geometry from the collection.
 * @template T
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default<import("../source/Source").default>, import("../geom/SimpleGeometry.js").default): T} FeatureCallback
 */

/**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */

var SIMPLIFY_TOLERANCE = 0.5;
/**
 * @const
 * @type {Object<import("../geom/GeometryType.js").default,
 *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
 *                         import("../style/Style.js").default, Object): void>}
 */

var GEOMETRY_RENDERERS = {
  'Point': renderPointGeometry,
  'LineString': renderLineStringGeometry,
  'Polygon': renderPolygonGeometry,
  'MultiPoint': renderMultiPointGeometry,
  'MultiLineString': renderMultiLineStringGeometry,
  'MultiPolygon': renderMultiPolygonGeometry,
  'GeometryCollection': renderGeometryCollectionGeometry,
  'Circle': renderCircleGeometry
};
/**
 * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
 * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
 * @return {number} Order.
 */

function defaultOrder(feature1, feature2) {
  return parseInt((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getUid)(feature1), 10) - parseInt((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getUid)(feature2), 10);
}
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */

function getSquaredTolerance(resolution, pixelRatio) {
  var tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */

function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
 * @param {import("../geom/Circle.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */

function renderCircleGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (fillStyle || strokeStyle) {
    var circleReplay = builderGroup.getBuilder(style.getZIndex(), _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CIRCLE);
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(import("../events/Event.js").default): void} listener Listener function.
 * @param {import("../proj.js").TransformFunction} [opt_transform] Transform from user to view projection.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 * @return {boolean} `true` if style is loading.
 */


function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform, opt_declutterBuilderGroup) {
  var loading = false;
  var imageStyle = style.getImage();

  if (imageStyle) {
    var imageState = imageStyle.getImageState();

    if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED || imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
      imageStyle.unlistenImageChange(listener);
    } else {
      if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
        imageStyle.load();
      }

      imageState = imageStyle.getImageState();
      imageStyle.listenImageChange(listener);
      loading = true;
    }
  }

  renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup);
  return loading;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */

function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {
  var geometry = style.getGeometryFunction()(feature);

  if (!geometry) {
    return;
  }

  var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);
  var renderer = style.getRenderer();

  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature);
  } else {
    var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(replayGroup, simplifiedGeometry, style, feature, opt_declutterBuilderGroup);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */


function renderGeometry(replayGroup, geometry, style, feature) {
  if (geometry.getType() == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].GEOMETRY_COLLECTION) {
    var geometries =
    /** @type {import("../geom/GeometryCollection.js").default} */
    geometry.getGeometries();

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style, feature);
    }

    return;
  }

  var replay = replayGroup.getBuilder(style.getZIndex(), _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].DEFAULT);
  replay.drawCustom(
  /** @type {import("../geom/SimpleGeometry.js").default} */
  geometry, feature, style.getRenderer(), style.getHitDetectionRenderer());
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */


function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(replayGroup, geometries[i], style, feature, opt_declutterBuilderGroup);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */


function renderLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var strokeStyle = style.getStroke();

  if (strokeStyle) {
    var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */


function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var strokeStyle = style.getStroke();

  if (strokeStyle) {
    var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */


function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (strokeStyle || fillStyle) {
    var polygonReplay = builderGroup.getBuilder(style.getZIndex(), _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */


function renderPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var imageStyle = style.getImage();
  var textStyle = style.getText();
  /** @type {import("../render/canvas.js").DeclutterImageWithText} */

  var declutterImageWithText;

  if (opt_declutterBuilderGroup) {
    builderGroup = opt_declutterBuilderGroup;
    declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {} : undefined;
  }

  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
      return;
    }

    var imageReplay = builderGroup.getBuilder(style.getZIndex(), _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].IMAGE);
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawPoint(geometry, feature);
  }

  if (textStyle && textStyle.getText()) {
    var textReplay = builderGroup.getBuilder(style.getZIndex(), _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].TEXT);
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */


function renderMultiPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var imageStyle = style.getImage();
  var textStyle = style.getText();
  /** @type {import("../render/canvas.js").DeclutterImageWithText} */

  var declutterImageWithText;

  if (opt_declutterBuilderGroup) {
    builderGroup = opt_declutterBuilderGroup;
    declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {} : undefined;
  }

  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
      return;
    }

    var imageReplay = builderGroup.getBuilder(style.getZIndex(), _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].IMAGE);
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawMultiPoint(geometry, feature);
  }

  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].TEXT);
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */


function renderPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (fillStyle || strokeStyle) {
    var polygonReplay = builderGroup.getBuilder(style.getZIndex(), _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _render_canvas_BuilderType_js__WEBPACK_IMPORTED_MODULE_1__["default"].TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}

/***/ }),

/***/ "./build/wg/renderer/webgl/Layer.js":
/*!******************************************!*\
  !*** ./build/wg/renderer/webgl/Layer.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebGLWorkerMessageType": function() { return /* binding */ WebGLWorkerMessageType; },
/* harmony export */   "writePointFeatureToBuffers": function() { return /* binding */ writePointFeatureToBuffers; },
/* harmony export */   "getBlankImageData": function() { return /* binding */ getBlankImageData; },
/* harmony export */   "colorEncodeId": function() { return /* binding */ colorEncodeId; },
/* harmony export */   "colorDecodeId": function() { return /* binding */ colorDecodeId; }
/* harmony export */ });
/* harmony import */ var _layer_Property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layer/Property.js */ "./build/wg/layer/Property.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Layer.js */ "./build/wg/renderer/Layer.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../render/Event.js */ "./build/wg/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../render/EventType.js */ "./build/wg/render/EventType.js");
/* harmony import */ var _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../webgl/Helper.js */ "./build/wg/webgl/Helper.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/renderer/webgl/Layer
 */









/**
 * @enum {string}
 */

var WebGLWorkerMessageType = {
  GENERATE_BUFFERS: 'GENERATE_BUFFERS'
};
/**
 * @typedef {Object} WebGLWorkerGenerateBuffersMessage
 * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.
 * When the buffers are generated, the worked will send a message of the same type to the main thread, with
 * the generated buffers in it.
 * Note that any addition properties present in the message *will* be sent back to the main thread.
 * @property {WebGLWorkerMessageType} type Message type
 * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.
 * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).
 * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).
 * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.
 */

/**
 * @typedef {Object} PostProcessesOptions
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas that will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
 */

/**
 * @typedef {Object} Options
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process steps
 * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions
 */

/**
 * @classdesc
 * Base WebGL renderer class.
 * Holds all logic related to data manipulation & some common rendering logic
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */

var WebGLLayerRenderer =
/** @class */
function (_super) {
  __extends(WebGLLayerRenderer, _super);
  /**
   * @param {LayerType} layer Layer.
   * @param {Options} [opt_options] Options.
   */


  function WebGLLayerRenderer(layer, opt_options) {
    var _this = _super.call(this, layer) || this;

    var options = opt_options || {};
    /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform is only
     * set before dispatching rendering events.
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.inversePixelTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.create)();
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */

    _this.pixelContext_ = null;
    /**
     * @private
     */

    _this.postProcesses_ = options.postProcesses;
    /**
     * @private
     */

    _this.uniforms_ = options.uniforms;
    /**
     * @type {WebGLHelper}
     * @protected
     */

    _this.helper;
    layer.addChangeListener(_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAP, _this.removeHelper.bind(_this));
    _this.dispatchPreComposeEvent = _this.dispatchPreComposeEvent.bind(_this);
    _this.dispatchPostComposeEvent = _this.dispatchPostComposeEvent.bind(_this);
    return _this;
  }
  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */


  WebGLLayerRenderer.prototype.dispatchPreComposeEvent = function (context, frameState) {
    var layer = this.getLayer();

    if (layer.hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].PRECOMPOSE)) {
      var event_1 = new _render_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"](_render_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].PRECOMPOSE, undefined, frameState, context);
      layer.dispatchEvent(event_1);
    }
  };
  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */


  WebGLLayerRenderer.prototype.dispatchPostComposeEvent = function (context, frameState) {
    var layer = this.getLayer();

    if (layer.hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POSTCOMPOSE)) {
      var event_2 = new _render_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"](_render_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POSTCOMPOSE, undefined, frameState, context);
      layer.dispatchEvent(event_2);
    }
  };
  /**
   * Reset options (only handles uniforms).
   * @param {Options} options Options.
   */


  WebGLLayerRenderer.prototype.reset = function (options) {
    this.uniforms_ = options.uniforms;

    if (this.helper) {
      this.helper.setUniforms(this.uniforms_);
    }
  };
  /**
   * @protected
   */


  WebGLLayerRenderer.prototype.removeHelper = function () {
    if (this.helper) {
      this.helper.dispose();
      delete this.helper;
    }
  };
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */


  WebGLLayerRenderer.prototype.prepareFrame = function (frameState) {
    if (this.getLayer().getRenderSource()) {
      var incrementGroup = true;
      var groupNumber = -1;
      var className = void 0;

      for (var i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {
        var layer = frameState.layerStatesArray[i].layer;
        var renderer = layer.getRenderer();

        if (!(renderer instanceof WebGLLayerRenderer)) {
          incrementGroup = true;
          continue;
        }

        var layerClassName = layer.getClassName();

        if (incrementGroup || layerClassName !== className) {
          groupNumber += 1;
          incrementGroup = false;
        }

        className = layerClassName;

        if (renderer === this) {
          break;
        }
      }

      var canvasCacheKey = 'map/' + frameState.mapId + '/group/' + groupNumber;

      if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {
        this.removeHelper();
        this.helper = new _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
          postProcesses: this.postProcesses_,
          uniforms: this.uniforms_,
          canvasCacheKey: canvasCacheKey
        });

        if (className) {
          this.helper.getCanvas().className = className;
        }

        this.afterHelperCreated();
      }
    }

    return this.prepareFrameInternal(frameState);
  };
  /**
   * @protected
   */


  WebGLLayerRenderer.prototype.afterHelperCreated = function () {};
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @protected
   */


  WebGLLayerRenderer.prototype.prepareFrameInternal = function (frameState) {
    return true;
  };
  /**
   * Clean up.
   */


  WebGLLayerRenderer.prototype.disposeInternal = function () {
    this.removeHelper();

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @private
   */


  WebGLLayerRenderer.prototype.dispatchRenderEvent_ = function (type, context, frameState) {
    var layer = this.getLayer();

    if (layer.hasListener(type)) {
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.compose)(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);
      var event_3 = new _render_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"](type, this.inversePixelTransform_, frameState, context);
      layer.dispatchEvent(event_3);
    }
  };
  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */


  WebGLLayerRenderer.prototype.preRender = function (context, frameState) {
    this.dispatchRenderEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].PRERENDER, context, frameState);
  };
  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */


  WebGLLayerRenderer.prototype.postRender = function (context, frameState) {
    this.dispatchRenderEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POSTRENDER, context, frameState);
  };
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @param {import("../../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
   *    location, null will be returned.  If there is data, but pixel values cannot be
   *    returned, and empty array will be returned.
   */


  WebGLLayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
    var renderPixel = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.apply)([frameState.pixelRatio, 0, 0, frameState.pixelRatio, 0, 0], pixel.slice());
    var gl = this.helper.getGL();

    if (!gl) {
      return null;
    }

    var layer = this.getLayer();
    var layerExtent = layer.getExtent();

    if (layerExtent) {
      var renderCoordinate = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
      /** get only data inside of the layer extent */

      if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.containsCoordinate)(layerExtent, renderCoordinate)) {
        return null;
      }
    }

    var attributes = gl.getContextAttributes();

    if (!attributes || !attributes.preserveDrawingBuffer) {
      // we assume there is data at the given pixel (although there might not be)
      return new Uint8Array();
    }

    var x = Math.round(renderPixel[0]);
    var y = Math.round(renderPixel[1]);
    var pixelContext = this.pixelContext_;

    if (!pixelContext) {
      var pixelCanvas = document.createElement('canvas');
      pixelCanvas.width = 1;
      pixelCanvas.height = 1;
      pixelContext = pixelCanvas.getContext('2d');
      this.pixelContext_ = pixelContext;
    }

    pixelContext.clearRect(0, 0, 1, 1);
    var data;

    try {
      pixelContext.drawImage(gl.canvas, x, y, 1, 1, 0, 0, 1, 1);
      data = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      return data;
    }

    if (data[3] === 0) {
      return null;
    }

    return data;
  };

  return WebGLLayerRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_6__["default"]);

var tmpArray_ = [];
var bufferPositions_ = {
  vertexPosition: 0,
  indexPosition: 0
};

function writePointVertex(buffer, pos, x, y, index) {
  buffer[pos + 0] = x;
  buffer[pos + 1] = y;
  buffer[pos + 2] = index;
}
/**
 * An object holding positions both in an index and a vertex buffer.
 * @typedef {Object} BufferPositions
 * @property {number} vertexPosition Position in the vertex buffer
 * @property {number} indexPosition Position in the index buffer
 */

/**
 * Pushes a quad (two triangles) based on a point geometry
 * @param {Float32Array} instructions Array of render instructions for points.
 * @param {number} elementIndex Index from which render instructions will be read.
 * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.
 * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.
 * @param {number} customAttributesCount Amount of custom attributes for each element.
 * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.
 * @return {BufferPositions} New buffer positions where to write next
 * @property {number} vertexPosition New position in the vertex buffer where future writes should start.
 * @property {number} indexPosition New position in the index buffer where future writes should start.
 * @private
 */


function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {
  // This is for x, y and index
  var baseVertexAttrsCount = 3;
  var baseInstructionsCount = 2;
  var stride = baseVertexAttrsCount + customAttributesCount;
  var x = instructions[elementIndex + 0];
  var y = instructions[elementIndex + 1]; // read custom numerical attributes on the feature

  var customAttrs = tmpArray_;
  customAttrs.length = customAttributesCount;

  for (var i = 0; i < customAttrs.length; i++) {
    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];
  }

  var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;
  var iPos = bufferPositions ? bufferPositions.indexPosition : 0;
  var baseIndex = vPos / stride; // push vertices for each of the four quad corners (first standard then custom attributes)

  writePointVertex(vertexBuffer, vPos, x, y, 0);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  writePointVertex(vertexBuffer, vPos, x, y, 1);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  writePointVertex(vertexBuffer, vPos, x, y, 2);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  writePointVertex(vertexBuffer, vPos, x, y, 3);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  indexBuffer[iPos++] = baseIndex;
  indexBuffer[iPos++] = baseIndex + 1;
  indexBuffer[iPos++] = baseIndex + 3;
  indexBuffer[iPos++] = baseIndex + 1;
  indexBuffer[iPos++] = baseIndex + 2;
  indexBuffer[iPos++] = baseIndex + 3;
  bufferPositions_.vertexPosition = vPos;
  bufferPositions_.indexPosition = iPos;
  return bufferPositions_;
}
/**
 * Returns a texture of 1x1 pixel, white
 * @private
 * @return {ImageData} Image data.
 */

function getBlankImageData() {
  var canvas = document.createElement('canvas');
  var image = canvas.getContext('2d').createImageData(1, 1);
  image.data[0] = 255;
  image.data[1] = 255;
  image.data[2] = 255;
  image.data[3] = 255;
  return image;
}
/**
 * Generates a color array based on a numerical id
 * Note: the range for each component is 0 to 1 with 256 steps
 * @param {number} id Id
 * @param {Array<number>} [opt_array] Reusable array
 * @return {Array<number>} Color array containing the encoded id
 */

function colorEncodeId(id, opt_array) {
  var array = opt_array || [];
  var radix = 256;
  var divide = radix - 1;
  array[0] = Math.floor(id / radix / radix / radix) / divide;
  array[1] = Math.floor(id / radix / radix) % radix / divide;
  array[2] = Math.floor(id / radix) % radix / divide;
  array[3] = id % radix / divide;
  return array;
}
/**
 * Reads an id from a color-encoded array
 * Note: the expected range for each component is 0 to 1 with 256 steps.
 * @param {Array<number>} color Color array containing the encoded id
 * @return {number} Decoded id
 */

function colorDecodeId(color) {
  var id = 0;
  var radix = 256;
  var mult = radix - 1;
  id += Math.round(color[0] * radix * radix * radix * mult);
  id += Math.round(color[1] * radix * radix * mult);
  id += Math.round(color[2] * radix * mult);
  id += Math.round(color[3] * mult);
  return id;
}
/* harmony default export */ __webpack_exports__["default"] = (WebGLLayerRenderer);

/***/ }),

/***/ "./build/wg/renderer/webgl/PointsLayer.js":
/*!************************************************!*\
  !*** ./build/wg/renderer/webgl/PointsLayer.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _layer_BaseVector_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../layer/BaseVector.js */ "./build/wg/layer/BaseVector.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../source/VectorEventType.js */ "./build/wg/source/VectorEventType.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../ViewHint.js */ "./build/wg/ViewHint.js");
/* harmony import */ var _webgl_Buffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../webgl/Buffer.js */ "./build/wg/webgl/Buffer.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Layer.js */ "./build/wg/renderer/webgl/Layer.js");
/* harmony import */ var _webgl_RenderTarget_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../webgl/RenderTarget.js */ "./build/wg/webgl/RenderTarget.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../webgl.js */ "./build/wg/webgl.js");
/* harmony import */ var _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/Helper.js */ "./build/wg/webgl/Helper.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _worker_webgl_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../worker/webgl.js */ "./build/wg/worker/webgl.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util.js */ "./build/wg/util.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../events.js */ "./build/wg/events.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/renderer/webgl/PointsLayer
 */

















/**
 * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different
 * for each feature.
 * @property {string} name Attribute name.
 * @property {function(import("../../Feature").default, Object<string, *>):number} callback This callback computes the numerical value of the
 * attribute for a given feature (properties are available as 2nd arg for quicker access).
 */

/**
 * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize
 * rebuildBuffers by accessing these objects quicker.
 * @property {import("../../Feature").default} feature Feature
 * @property {Object<string, *>} properties Feature properties
 * @property {import("../../geom").Geometry} geometry Feature geometry
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='wg-layer'] A CSS class name to set to the canvas element.
 * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then
 * passed to the GPU. The `name` property of each attribute will serve as its identifier:
 *  * In the vertex shader as an `attribute` by prefixing it with `a_`
 *  * In the fragment shader as a `varying` by prefixing it with `v_`
 * Please note that these can only be numerical values.
 * @property {string} vertexShader Vertex shader source, mandatory.
 * @property {string} fragmentShader Fragment shader source, mandatory.
 * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.
 * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process steps
 * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.
 * @property {Array<import("./Layer").PostProcessesOptions>} [postProcesses] Post-processes definitions
 */

/**
 * @classdesc
 * WebGL vector renderer optimized for points.
 * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU
 * every time the vector source changes.
 *
 * You need to provide vertex and fragment shaders for rendering. This can be done using
 * {@link module:wg/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute
 * containing the screen-space projected center of the quad, as well as a `a_index` attribute
 * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).
 *
 * To include variable attributes in the shaders, you need to declare them using the `attributes` property of
 * the options object like so:
 * ```js
 * new WebGLPointsLayerRenderer(layer, {
 *   attributes: [
 *     {
 *       name: 'size',
 *       callback: function(feature) {
 *         // compute something with the feature
 *       }
 *     },
 *     {
 *       name: 'weight',
 *       callback: function(feature) {
 *         // compute something with the feature
 *       }
 *     },
 *   ],
 *   vertexShader:
 *     // shader using attribute a_weight and a_size
 *   fragmentShader:
 *     // shader using varying v_weight and v_size
 * ```
 *
 * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`
 * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain
 * the final color that will have to be output for hit detection to work.
 *
 * The following uniform is used for the main texture: `u_texture`.
 * The following uniform is used for the layer opacity: `u_opacity`.
 *
 * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.
 *
 * Points are rendered as quads with the following structure:
 *
 * ```
 *   (u0, v1)      (u1, v1)
 *  [3]----------[2]
 *   |`           |
 *   |  `         |
 *   |    `       |
 *   |      `     |
 *   |        `   |
 *   |          ` |
 *  [0]----------[1]
 *   (u0, v0)      (u1, v0)
 *  ```
 *
 * This uses {@link module:wg/webgl/Helper~WebGLHelper} internally.
 *
 * @api
 */

var WebGLPointsLayerRenderer =
/** @class */
function (_super) {
  __extends(WebGLPointsLayerRenderer, _super);
  /**
   * @param {import("../../layer/Layer.js").default} layer Layer.
   * @param {Options} options Options.
   */


  function WebGLPointsLayerRenderer(layer, options) {
    var _this = this;

    var uniforms = options.uniforms || {};
    var projectionMatrixTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.create)();
    uniforms[_webgl_Helper_js__WEBPACK_IMPORTED_MODULE_1__.DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;
    _this = _super.call(this, layer, {
      uniforms: uniforms,
      postProcesses: options.postProcesses
    }) || this;
    _this.ready = false;
    _this.sourceRevision_ = -1;
    _this.verticesBuffer_ = new _webgl_Buffer_js__WEBPACK_IMPORTED_MODULE_2__["default"](_webgl_js__WEBPACK_IMPORTED_MODULE_3__.ARRAY_BUFFER, _webgl_js__WEBPACK_IMPORTED_MODULE_3__.DYNAMIC_DRAW);
    _this.hitVerticesBuffer_ = new _webgl_Buffer_js__WEBPACK_IMPORTED_MODULE_2__["default"](_webgl_js__WEBPACK_IMPORTED_MODULE_3__.ARRAY_BUFFER, _webgl_js__WEBPACK_IMPORTED_MODULE_3__.DYNAMIC_DRAW);
    _this.indicesBuffer_ = new _webgl_Buffer_js__WEBPACK_IMPORTED_MODULE_2__["default"](_webgl_js__WEBPACK_IMPORTED_MODULE_3__.ELEMENT_ARRAY_BUFFER, _webgl_js__WEBPACK_IMPORTED_MODULE_3__.DYNAMIC_DRAW);
    /**
     * @private
     */

    _this.vertexShader_ = options.vertexShader;
    /**
     * @private
     */

    _this.fragmentShader_ = options.fragmentShader;
    /**
     * @type {WebGLProgram}
     * @private
     */

    _this.program_;
    /**
     * @type {boolean}
     * @private
     */

    _this.hitDetectionEnabled_ = options.hitFragmentShader && options.hitVertexShader ? true : false;
    /**
     * @private
     */

    _this.hitVertexShader_ = options.hitVertexShader;
    /**
     * @private
     */

    _this.hitFragmentShader_ = options.hitFragmentShader;
    /**
     * @type {WebGLProgram}
     * @private
     */

    _this.hitProgram_;
    var customAttributes = options.attributes ? options.attributes.map(function (attribute) {
      return {
        name: 'a_' + attribute.name,
        size: 1,
        type: _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_1__.AttributeType.FLOAT
      };
    }) : [];
    /**
     * A list of attributes used by the renderer. By default only the position and
     * index of the vertex (0 to 3) are required.
     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
     */

    _this.attributes = [{
      name: 'a_position',
      size: 2,
      type: _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_1__.AttributeType.FLOAT
    }, {
      name: 'a_index',
      size: 1,
      type: _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_1__.AttributeType.FLOAT
    }].concat(customAttributes);
    /**
     * A list of attributes used for hit detection.
     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
     */

    _this.hitDetectionAttributes = [{
      name: 'a_position',
      size: 2,
      type: _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_1__.AttributeType.FLOAT
    }, {
      name: 'a_index',
      size: 1,
      type: _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_1__.AttributeType.FLOAT
    }, {
      name: 'a_hitColor',
      size: 4,
      type: _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_1__.AttributeType.FLOAT
    }, {
      name: 'a_featureUid',
      size: 1,
      type: _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_1__.AttributeType.FLOAT
    }].concat(customAttributes);
    _this.customAttributes = options.attributes ? options.attributes : [];
    _this.previousExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.createEmpty)();
    /**
     * This transform is updated on every frame and is the composition of:
     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)
     * - current world->screen transform
     * @type {import("../../transform.js").Transform}
     * @private
     */

    _this.currentTransform_ = projectionMatrixTransform;
    /**
     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space
     * @type {import("../../transform.js").Transform}
     * @private
     */

    _this.renderTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.create)();
    /**
     * @type {import("../../transform.js").Transform}
     * @private
     */

    _this.invertRenderTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.create)();
    /**
     * @type {Float32Array}
     * @private
     */

    _this.renderInstructions_ = new Float32Array(0);
    /**
     * These instructions are used for hit detection
     * @type {Float32Array}
     * @private
     */

    _this.hitRenderInstructions_ = new Float32Array(0);
    /**
     * @type {WebGLRenderTarget}
     * @private
     */

    _this.hitRenderTarget_;
    /**
     * Keep track of latest message sent to worker
     * @type {number}
     * @private
     */

    _this.generateBuffersRun_ = 0;
    _this.worker_ = (0,_worker_webgl_js__WEBPACK_IMPORTED_MODULE_5__.create)();

    _this.worker_.addEventListener('message',
    /**
     * @param {*} event Event.
     * @this {WebGLPointsLayerRenderer}
     */
    function (event) {
      var received = event.data;

      if (received.type === _Layer_js__WEBPACK_IMPORTED_MODULE_6__.WebGLWorkerMessageType.GENERATE_BUFFERS) {
        var projectionTransform = received.projectionTransform;

        if (received.hitDetection) {
          this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);
          this.helper.flushBufferData(this.hitVerticesBuffer_);
        } else {
          this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);
          this.helper.flushBufferData(this.verticesBuffer_);
        }

        this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);
        this.helper.flushBufferData(this.indicesBuffer_);
        this.renderTransform_ = projectionTransform;
        (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.makeInverse)(this.invertRenderTransform_, this.renderTransform_);

        if (received.hitDetection) {
          this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);
        } else {
          this.renderInstructions_ = new Float32Array(event.data.renderInstructions);

          if (received.generateBuffersRun === this.generateBuffersRun_) {
            this.ready = true;
          }
        }

        this.getLayer().changed();
      }
    }.bind(_this));
    /**
     * This object will be updated when the source changes. Key is uid.
     * @type {Object<string, FeatureCacheItem>}
     * @private
     */


    _this.featureCache_ = {};
    /**
     * Amount of features in the cache.
     * @type {number}
     * @private
     */

    _this.featureCount_ = 0;

    var source = _this.getLayer().getSource();

    _this.sourceListenKeys_ = [(0,_events_js__WEBPACK_IMPORTED_MODULE_7__.listen)(source, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].ADDFEATURE, _this.handleSourceFeatureAdded_, _this), (0,_events_js__WEBPACK_IMPORTED_MODULE_7__.listen)(source, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this), (0,_events_js__WEBPACK_IMPORTED_MODULE_7__.listen)(source, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this), (0,_events_js__WEBPACK_IMPORTED_MODULE_7__.listen)(source, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].CLEAR, _this.handleSourceFeatureClear_, _this)];
    source.forEachFeature(function (feature) {
      this.featureCache_[(0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(feature)] = {
        feature: feature,
        properties: feature.getProperties(),
        geometry: feature.getGeometry()
      };
      this.featureCount_++;
    }.bind(_this));
    return _this;
  }

  WebGLPointsLayerRenderer.prototype.afterHelperCreated = function () {
    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);

    if (this.hitDetectionEnabled_) {
      this.hitProgram_ = this.helper.getProgram(this.hitFragmentShader_, this.hitVertexShader_);
      this.hitRenderTarget_ = new _webgl_RenderTarget_js__WEBPACK_IMPORTED_MODULE_10__["default"](this.helper);
    }
  };
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */


  WebGLPointsLayerRenderer.prototype.handleSourceFeatureAdded_ = function (event) {
    var feature = event.feature;
    this.featureCache_[(0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(feature)] = {
      feature: feature,
      properties: feature.getProperties(),
      geometry: feature.getGeometry()
    };
    this.featureCount_++;
  };
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */


  WebGLPointsLayerRenderer.prototype.handleSourceFeatureChanged_ = function (event) {
    var feature = event.feature;
    this.featureCache_[(0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(feature)] = {
      feature: feature,
      properties: feature.getProperties(),
      geometry: feature.getGeometry()
    };
  };
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */


  WebGLPointsLayerRenderer.prototype.handleSourceFeatureDelete_ = function (event) {
    var feature = event.feature;
    delete this.featureCache_[(0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(feature)];
    this.featureCount_--;
  };
  /**
   * @private
   */


  WebGLPointsLayerRenderer.prototype.handleSourceFeatureClear_ = function () {
    this.featureCache_ = {};
    this.featureCount_ = 0;
  };
  /**
   * Render the layer.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {HTMLElement} The rendered element.
   */


  WebGLPointsLayerRenderer.prototype.renderFrame = function (frameState) {
    var gl = this.helper.getGL();
    this.preRender(gl, frameState);
    var renderCount = this.indicesBuffer_.getSize();
    this.helper.drawElements(0, renderCount);
    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
    var canvas = this.helper.getCanvas();

    if (this.hitDetectionEnabled_) {
      this.renderHitDetection(frameState);
      this.hitRenderTarget_.clearCachedData();
    }

    this.postRender(gl, frameState);
    return canvas;
  };
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */


  WebGLPointsLayerRenderer.prototype.prepareFrameInternal = function (frameState) {
    var layer = this.getLayer();
    var vectorSource = layer.getSource();
    var viewState = frameState.viewState;
    var viewNotMoving = !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_11__["default"].ANIMATING] && !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_11__["default"].INTERACTING];
    var extentChanged = !(0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.equals)(this.previousExtent_, frameState.extent);
    var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();

    if (sourceChanged) {
      this.sourceRevision_ = vectorSource.getRevision();
    }

    if (viewNotMoving && (extentChanged || sourceChanged)) {
      var projection = viewState.projection;
      var resolution = viewState.resolution;
      var renderBuffer = layer instanceof _layer_BaseVector_js__WEBPACK_IMPORTED_MODULE_12__["default"] ? layer.getRenderBuffer() : 0;
      var extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.buffer)(frameState.extent, renderBuffer * resolution);
      vectorSource.loadFeatures(extent, resolution, projection);
      this.rebuildBuffers_(frameState);
      this.previousExtent_ = frameState.extent.slice();
    } // apply the current projection transform with the invert of the one used to fill buffers


    this.helper.makeProjectionTransform(frameState, this.currentTransform_);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.multiply)(this.currentTransform_, this.invertRenderTransform_);
    this.helper.useProgram(this.program_);
    this.helper.prepareDraw(frameState); // write new data

    this.helper.bindBuffer(this.verticesBuffer_);
    this.helper.bindBuffer(this.indicesBuffer_);
    this.helper.enableAttributes(this.attributes);
    return true;
  };
  /**
   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much
   * @param {import("../../PluggableMap").FrameState} frameState Frame state.
   * @private
   */


  WebGLPointsLayerRenderer.prototype.rebuildBuffers_ = function (frameState) {
    // saves the projection transform for the current frame state
    var projectionTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.create)();
    this.helper.makeProjectionTransform(frameState, projectionTransform); // here we anticipate the amount of render instructions that we well generate
    // this can be done since we know that for normal render we only have x, y as base instructions,
    // and x, y, r, g, b, a and featureUid for hit render instructions
    // and we also know the amount of custom attributes to append to these

    var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;

    if (!this.renderInstructions_ || this.renderInstructions_.length !== totalInstructionsCount) {
      this.renderInstructions_ = new Float32Array(totalInstructionsCount);
    }

    if (this.hitDetectionEnabled_) {
      var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;

      if (!this.hitRenderInstructions_ || this.hitRenderInstructions_.length !== totalHitInstructionsCount) {
        this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);
      }
    } // loop on features to fill the buffer


    var featureCache, geometry;
    var tmpCoords = [];
    var tmpColor = [];
    var renderIndex = 0;
    var hitIndex = 0;
    var hitColor;

    for (var featureUid in this.featureCache_) {
      featureCache = this.featureCache_[featureUid];
      geometry =
      /** @type {import("../../geom").Point} */
      featureCache.geometry;

      if (!geometry || geometry.getType() !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POINT) {
        continue;
      }

      tmpCoords[0] = geometry.getFlatCoordinates()[0];
      tmpCoords[1] = geometry.getFlatCoordinates()[1];
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.apply)(projectionTransform, tmpCoords);
      hitColor = (0,_Layer_js__WEBPACK_IMPORTED_MODULE_6__.colorEncodeId)(hitIndex + 6, tmpColor);
      this.renderInstructions_[renderIndex++] = tmpCoords[0];
      this.renderInstructions_[renderIndex++] = tmpCoords[1]; // for hit detection, the feature uid is saved in the opacity value
      // and the index of the opacity value is encoded in the color values

      if (this.hitDetectionEnabled_) {
        this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];
        this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];
        this.hitRenderInstructions_[hitIndex++] = hitColor[0];
        this.hitRenderInstructions_[hitIndex++] = hitColor[1];
        this.hitRenderInstructions_[hitIndex++] = hitColor[2];
        this.hitRenderInstructions_[hitIndex++] = hitColor[3];
        this.hitRenderInstructions_[hitIndex++] = Number(featureUid);
      } // pushing custom attributes


      var value = void 0;

      for (var j = 0; j < this.customAttributes.length; j++) {
        value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);
        this.renderInstructions_[renderIndex++] = value;

        if (this.hitDetectionEnabled_) {
          this.hitRenderInstructions_[hitIndex++] = value;
        }
      }
    }
    /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */


    var message = {
      type: _Layer_js__WEBPACK_IMPORTED_MODULE_6__.WebGLWorkerMessageType.GENERATE_BUFFERS,
      renderInstructions: this.renderInstructions_.buffer,
      customAttributesCount: this.customAttributes.length
    }; // additional properties will be sent back as-is by the worker

    message['projectionTransform'] = projectionTransform;
    message['generateBuffersRun'] = ++this.generateBuffersRun_;
    this.ready = false;
    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);
    this.renderInstructions_ = null;
    /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */

    if (this.hitDetectionEnabled_) {
      var hitMessage = {
        type: _Layer_js__WEBPACK_IMPORTED_MODULE_6__.WebGLWorkerMessageType.GENERATE_BUFFERS,
        renderInstructions: this.hitRenderInstructions_.buffer,
        customAttributesCount: 5 + this.customAttributes.length
      };
      hitMessage['projectionTransform'] = projectionTransform;
      hitMessage['hitDetection'] = true;
      this.worker_.postMessage(hitMessage, [this.hitRenderInstructions_.buffer]);
      this.hitRenderInstructions_ = null;
    }
  };
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */


  WebGLPointsLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_14__.assert)(this.hitDetectionEnabled_, 66);

    if (!this.hitRenderInstructions_) {
      return undefined;
    }

    var pixel = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.apply)(frameState.coordinateToPixelTransform, coordinate.slice());
    var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);
    var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];
    var index = (0,_Layer_js__WEBPACK_IMPORTED_MODULE_6__.colorDecodeId)(color);
    var opacity = this.hitRenderInstructions_[index];
    var uid = Math.floor(opacity).toString();
    var source = this.getLayer().getSource();
    var feature = source.getFeatureByUid(uid);

    if (feature) {
      return callback(feature, this.getLayer(), null);
    }

    return undefined;
  };
  /**
   * Render the hit detection data to the corresponding render target
   * @param {import("../../PluggableMap.js").FrameState} frameState current frame state
   */


  WebGLPointsLayerRenderer.prototype.renderHitDetection = function (frameState) {
    // skip render entirely if vertex buffers not ready/generated yet
    if (!this.hitVerticesBuffer_.getSize()) {
      return;
    }

    this.hitRenderTarget_.setSize([Math.floor(frameState.size[0] / 2), Math.floor(frameState.size[1] / 2)]);
    this.helper.useProgram(this.hitProgram_);
    this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);
    this.helper.bindBuffer(this.hitVerticesBuffer_);
    this.helper.bindBuffer(this.indicesBuffer_);
    this.helper.enableAttributes(this.hitDetectionAttributes);
    var renderCount = this.indicesBuffer_.getSize();
    this.helper.drawElements(0, renderCount);
  };
  /**
   * Clean up.
   */


  WebGLPointsLayerRenderer.prototype.disposeInternal = function () {
    this.worker_.terminate();
    this.layer_ = null;
    this.sourceListenKeys_.forEach(function (key) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_7__.unlistenByKey)(key);
    });
    this.sourceListenKeys_ = null;

    _super.prototype.disposeInternal.call(this);
  };

  return WebGLPointsLayerRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_6__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (WebGLPointsLayerRenderer);

/***/ }),

/***/ "./build/wg/renderer/webgl/TileLayer.js":
/*!**********************************************!*\
  !*** ./build/wg/renderer/webgl/TileLayer.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Uniforms": function() { return /* binding */ Uniforms; },
/* harmony export */   "Attributes": function() { return /* binding */ Attributes; }
/* harmony export */ });
/* harmony import */ var _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../structs/LRUCache.js */ "./build/wg/structs/LRUCache.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../source/State.js */ "./build/wg/source/State.js");
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../TileRange.js */ "./build/wg/TileRange.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../TileState.js */ "./build/wg/TileState.js");
/* harmony import */ var _webgl_TileTexture_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../webgl/TileTexture.js */ "./build/wg/webgl/TileTexture.js");
/* harmony import */ var _webgl_Buffer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../webgl/Buffer.js */ "./build/wg/webgl/Buffer.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Layer.js */ "./build/wg/renderer/webgl/Layer.js");
/* harmony import */ var _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/Helper.js */ "./build/wg/webgl/Helper.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../webgl.js */ "./build/wg/webgl.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _vec_mat4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../vec/mat4.js */ "./build/wg/vec/mat4.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tilecoord.js */ "./build/wg/tilecoord.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../util.js */ "./build/wg/util.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../array.js */ "./build/wg/array.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../size.js */ "./build/wg/size.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/renderer/webgl/TileLayer
 */



















var Uniforms = {
  TILE_TEXTURE_ARRAY: 'u_tileTextures',
  TILE_TRANSFORM: 'u_tileTransform',
  TRANSITION_ALPHA: 'u_transitionAlpha',
  DEPTH: 'u_depth',
  TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',
  TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',
  TEXTURE_RESOLUTION: 'u_textureResolution',
  TEXTURE_ORIGIN_X: 'u_textureOriginX',
  TEXTURE_ORIGIN_Y: 'u_textureOriginY',
  RENDER_EXTENT: 'u_renderExtent',
  RESOLUTION: 'u_resolution',
  ZOOM: 'u_zoom'
};
var Attributes = {
  TEXTURE_COORD: 'a_textureCoord'
};
/**
 * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
 */

var attributeDescriptions = [{
  name: Attributes.TEXTURE_COORD,
  size: 2,
  type: _webgl_Helper_js__WEBPACK_IMPORTED_MODULE_1__.AttributeType.FLOAT
}];
/**
 * @type {Object<string, boolean>}
 */

var empty = {};
/**
 * Transform a zoom level into a depth value ranging from -1 to 1.
 * @param {number} z A zoom level.
 * @return {number} A depth value.
 */

function depthForZ(z) {
  return 2 * (1 - 1 / (z + 1)) - 1;
}
/**
 * Add a tile texture to the lookup.
 * @param {Object<number, Array<import("../../webgl/TileTexture.js").default>>} tileTexturesByZ Lookup of
 * tile textures by zoom level.
 * @param {import("../../webgl/TileTexture.js").default} tileTexture A tile texture.
 * @param {number} z The zoom level.
 */


function addTileTextureToLookup(tileTexturesByZ, tileTexture, z) {
  if (!(z in tileTexturesByZ)) {
    tileTexturesByZ[z] = [];
  }

  tileTexturesByZ[z].push(tileTexture);
}
/**
 * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
 * @param {import("../../extent.js").Extent} extent The frame extent.
 * @return {import("../../extent.js").Extent} Frame extent intersected with layer extents.
 */


function getRenderExtent(frameState, extent) {
  var layerState = frameState.layerStatesArray[frameState.layerIndex];

  if (layerState.extent) {
    extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(extent, (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, frameState.viewState.projection));
  }

  var source =
  /** @type {import("../../source/Tile.js").default} */
  layerState.layer.getRenderSource();

  if (!source.getWrapX()) {
    var gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();

    if (gridExtent) {
      extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(extent, gridExtent);
    }
  }

  return extent;
}

function getCacheKey(source, tileCoord) {
  return "".concat(source.getKey(), ",").concat((0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_3__.getKey)(tileCoord));
}
/**
 * @typedef {Object} Options
 * @property {string} vertexShader Vertex shader source.
 * @property {string} fragmentShader Fragment shader source.
 * @property {Object<string, import("../../webgl/Helper").UniformValue>} [uniforms] Additional uniforms
 * made available to shaders.
 * @property {Array<import("../../webgl/PaletteTexture.js").default>} [paletteTextures] Palette textures.
 * @property {number} [cacheSize=512] The texture cache size.
 */

/**
 * @typedef {import("../../layer/WebGLTile.js").default} LayerType
 */

/**
 * @classdesc
 * WebGL renderer for tile layers.
 * @extends {WebGLLayerRenderer<LayerType>}
 * @api
 */


var WebGLTileLayerRenderer =
/** @class */
function (_super) {
  __extends(WebGLTileLayerRenderer, _super);
  /**
   * @param {LayerType} tileLayer Tile layer.
   * @param {Options} options Options.
   */


  function WebGLTileLayerRenderer(tileLayer, options) {
    var _this = _super.call(this, tileLayer, {
      uniforms: options.uniforms
    }) || this;
    /**
     * The last call to `renderFrame` was completed with all tiles loaded
     * @type {boolean}
     */


    _this.renderComplete = false;
    /**
     * This transform converts texture coordinates to screen coordinates.
     * @type {import("../../transform.js").Transform}
     * @private
     */

    _this.tileTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.create)();
    /**
     * @type {Array<number>}
     * @private
     */

    _this.tempMat4_ = (0,_vec_mat4_js__WEBPACK_IMPORTED_MODULE_5__.create)();
    /**
     * @type {import("../../TileRange.js").default}
     * @private
     */

    _this.tempTileRange_ = new _TileRange_js__WEBPACK_IMPORTED_MODULE_6__["default"](0, 0, 0, 0);
    /**
     * @type {import("../../tilecoord.js").TileCoord}
     * @private
     */

    _this.tempTileCoord_ = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_3__.createOrUpdate)(0, 0, 0);
    /**
     * @type {import("../../size.js").Size}
     * @private
     */

    _this.tempSize_ = [0, 0];
    /**
     * @type {WebGLProgram}
     * @private
     */

    _this.program_;
    /**
     * @private
     */

    _this.vertexShader_ = options.vertexShader;
    /**
     * @private
     */

    _this.fragmentShader_ = options.fragmentShader;
    /**
     * Tiles are rendered as a quad with the following structure:
     *
     *  [P3]---------[P2]
     *   |`           |
     *   |  `     B   |
     *   |    `       |
     *   |      `     |
     *   |   A    `   |
     *   |          ` |
     *  [P0]---------[P1]
     *
     * Triangle A: P0, P1, P3
     * Triangle B: P1, P2, P3
     *
     * @private
     */

    _this.indices_ = new _webgl_Buffer_js__WEBPACK_IMPORTED_MODULE_7__["default"](_webgl_js__WEBPACK_IMPORTED_MODULE_8__.ELEMENT_ARRAY_BUFFER, _webgl_js__WEBPACK_IMPORTED_MODULE_8__.STATIC_DRAW);

    _this.indices_.fromArray([0, 1, 3, 1, 2, 3]);

    var cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;
    /**
     * @type {import("../../structs/LRUCache.js").default<import("../../webgl/TileTexture.js").default>}
     * @private
     */

    _this.tileTextureCache_ = new _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_9__["default"](cacheSize);
    /**
     * @type {Array<import("../../webgl/PaletteTexture.js").default>}
     * @private
     */

    _this.paletteTextures_ = options.paletteTextures || [];
    /**
     * @private
     * @type {import("../../PluggableMap.js").FrameState|null}
     */

    _this.frameState_ = null;
    return _this;
  }
  /**
   * @param {Options} options Options.
   */


  WebGLTileLayerRenderer.prototype.reset = function (options) {
    _super.prototype.reset.call(this, {
      uniforms: options.uniforms
    });

    this.vertexShader_ = options.vertexShader;
    this.fragmentShader_ = options.fragmentShader;
    this.paletteTextures_ = options.paletteTextures || [];

    if (this.helper) {
      this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
    }
  };

  WebGLTileLayerRenderer.prototype.afterHelperCreated = function () {
    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
    this.helper.flushBufferData(this.indices_);
  };
  /**
   * @param {import("../../webgl/TileTexture").TileType} tile Tile.
   * @return {boolean} Tile is drawable.
   * @private
   */


  WebGLTileLayerRenderer.prototype.isDrawableTile_ = function (tile) {
    var tileLayer = this.getLayer();
    var tileState = tile.getState();
    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_10__["default"].LOADED || tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_10__["default"].EMPTY || tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_10__["default"].ERROR && !useInterimTilesOnError;
  };
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */


  WebGLTileLayerRenderer.prototype.prepareFrameInternal = function (frameState) {
    var layer = this.getLayer();
    var source = layer.getRenderSource();

    if (!source) {
      return false;
    }

    if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(getRenderExtent(frameState, frameState.extent))) {
      return false;
    }

    return source.getState() === _source_State_js__WEBPACK_IMPORTED_MODULE_11__["default"].READY;
  };
  /**
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent The extent to be rendered.
   * @param {number} initialZ The zoom level.
   * @param {Object<number, Array<TileTexture>>} tileTexturesByZ The zoom level.
   */


  WebGLTileLayerRenderer.prototype.enqueueTiles = function (frameState, extent, initialZ, tileTexturesByZ) {
    var viewState = frameState.viewState;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getRenderSource();
    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    var tilePixelRatio = tileSource.getTilePixelRatio(frameState.pixelRatio);
    var gutter = tileSource.getGutterForProjection(viewState.projection);
    var tileSourceKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_12__.getUid)(tileSource);

    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }

    var wantedTiles = frameState.wantedTiles[tileSourceKey];
    var tileTextureCache = this.tileTextureCache_;
    var minZ = Math.max(initialZ - tileLayer.getPreload(), tileGrid.getMinZoom(), tileLayer.getMinZoom());

    for (var z = initialZ; z >= minZ; --z) {
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);
      var tileResolution = tileGrid.getResolution(z);

      for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
          var tileCoord = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_3__.createOrUpdate)(z, x, y, this.tempTileCoord_);
          var cacheKey = getCacheKey(tileSource, tileCoord);
          /** @type {TileTexture} */

          var tileTexture = void 0;
          /** @type {import("../../webgl/TileTexture").TileType} */

          var tile = void 0;

          if (tileTextureCache.containsKey(cacheKey)) {
            tileTexture = tileTextureCache.get(cacheKey);
            tile = tileTexture.tile;
          }

          if (!tileTexture || tileTexture.tile.key !== tileSource.getKey()) {
            tile = tileSource.getTile(z, x, y, frameState.pixelRatio, viewState.projection);

            if (!tileTexture) {
              tileTexture = new _webgl_TileTexture_js__WEBPACK_IMPORTED_MODULE_13__["default"]({
                tile: tile,
                grid: tileGrid,
                helper: this.helper,
                tilePixelRatio: tilePixelRatio,
                gutter: gutter
              });
              tileTextureCache.set(cacheKey, tileTexture);
            } else {
              if (this.isDrawableTile_(tile)) {
                tileTexture.setTile(tile);
              } else {
                var interimTile =
                /** @type {import("../../webgl/TileTexture").TileType} */
                tile.getInterimTile();
                tileTexture.setTile(interimTile);
              }
            }
          }

          addTileTextureToLookup(tileTexturesByZ, tileTexture, z);
          var tileQueueKey = tile.getKey();
          wantedTiles[tileQueueKey] = true;

          if (tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_10__["default"].IDLE) {
            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {
              frameState.tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tileCoord), tileResolution]);
            }
          }
        }
      }
    }
  };
  /**
   * Render the layer.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {HTMLElement} The rendered element.
   */


  WebGLTileLayerRenderer.prototype.renderFrame = function (frameState) {
    this.frameState_ = frameState;
    this.renderComplete = true;
    var gl = this.helper.getGL();
    this.preRender(gl, frameState);
    var viewState = frameState.viewState;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getRenderSource();
    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    var extent = getRenderExtent(frameState, frameState.extent);
    var z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);
    /**
     * @type {Object<number, Array<import("../../webgl/TileTexture.js").default>>}
     */

    var tileTexturesByZ = {};

    if (frameState.nextExtent) {
      var targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);
      var nextExtent = getRenderExtent(frameState, frameState.nextExtent);
      this.enqueueTiles(frameState, nextExtent, targetZ, tileTexturesByZ);
    }

    this.enqueueTiles(frameState, extent, z, tileTexturesByZ);
    /**
     * A lookup of alpha values for tiles at the target rendering resolution
     * for tiles that are in transition.  If a tile coord key is absent from
     * this lookup, the tile should be rendered at alpha 1.
     * @type {Object<string, number>}
     */

    var alphaLookup = {};
    var uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_12__.getUid)(this);
    var time = frameState.time;
    var blend = false; // look for cached tiles to use if a target tile is not ready

    var tileTextures = tileTexturesByZ[z];

    for (var i = 0, ii = tileTextures.length; i < ii; ++i) {
      var tileTexture = tileTextures[i];
      var tile = tileTexture.tile;
      var tileCoord = tile.tileCoord;

      if (tileTexture.loaded) {
        var alpha = tile.getAlpha(uid, time);

        if (alpha === 1) {
          // no need to look for alt tiles
          tile.endTransition(uid);
          continue;
        }

        blend = true;
        var tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_3__.getKey)(tileCoord);
        alphaLookup[tileCoordKey] = alpha;
      }

      this.renderComplete = false; // first look for child tiles (at z + 1)

      var coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tileTexturesByZ);

      if (coveredByChildren) {
        continue;
      } // next look for parent tiles


      var minZoom = tileGrid.getMinZoom();

      for (var parentZ = z - 1; parentZ >= minZoom; --parentZ) {
        var coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileTexturesByZ);

        if (coveredByParent) {
          break;
        }
      }
    }

    this.helper.useProgram(this.program_);
    this.helper.prepareDraw(frameState, !blend);
    var zs = Object.keys(tileTexturesByZ).map(Number).sort(_array_js__WEBPACK_IMPORTED_MODULE_14__.numberSafeCompareFunction);
    var centerX = viewState.center[0];
    var centerY = viewState.center[1];

    for (var j = 0, jj = zs.length; j < jj; ++j) {
      var tileZ = zs[j];
      var tileResolution = tileGrid.getResolution(tileZ);
      var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_15__.toSize)(tileGrid.getTileSize(tileZ), this.tempSize_);
      var tileOrigin = tileGrid.getOrigin(tileZ);
      var centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);
      var centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);
      var tileScale = viewState.resolution / tileResolution;
      var depth = depthForZ(tileZ);
      var tileTextures_1 = tileTexturesByZ[tileZ];

      for (var i = 0, ii = tileTextures_1.length; i < ii; ++i) {
        var tileTexture = tileTextures_1[i];

        if (!tileTexture.loaded) {
          continue;
        }

        var tile = tileTexture.tile;
        var tileCoord = tile.tileCoord;
        var tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_3__.getKey)(tileCoord);
        var tileCenterI = tileCoord[1];
        var tileCenterJ = tileCoord[2];
        (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.compose)(this.tileTransform_, 0, 0, 2 / (frameState.size[0] * tileScale / tileSize[0]), -2 / (frameState.size[1] * tileScale / tileSize[1]), viewState.rotation, -(centerI - tileCenterI), -(centerJ - tileCenterJ));
        this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, (0,_vec_mat4_js__WEBPACK_IMPORTED_MODULE_5__.fromTransform)(this.tempMat4_, this.tileTransform_));
        this.helper.bindBuffer(tileTexture.coords);
        this.helper.bindBuffer(this.indices_);
        this.helper.enableAttributes(attributeDescriptions);
        var textureSlot = 0;

        while (textureSlot < tileTexture.textures.length) {
          var textureProperty = 'TEXTURE' + textureSlot;
          var uniformName = "".concat(Uniforms.TILE_TEXTURE_ARRAY, "[").concat(textureSlot, "]");
          gl.activeTexture(gl[textureProperty]);
          gl.bindTexture(gl.TEXTURE_2D, tileTexture.textures[textureSlot]);
          gl.uniform1i(this.helper.getUniformLocation(uniformName), textureSlot);
          ++textureSlot;
        }

        for (var paletteIndex = 0; paletteIndex < this.paletteTextures_.length; ++paletteIndex) {
          var paletteTexture = this.paletteTextures_[paletteIndex];
          gl.activeTexture(gl['TEXTURE' + textureSlot]);
          var texture = paletteTexture.getTexture(gl);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.uniform1i(this.helper.getUniformLocation(paletteTexture.name), textureSlot);
          ++textureSlot;
        }

        var alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;

        if (alpha < 1) {
          frameState.animate = true;
        }

        this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);
        this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileSize[0]);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileSize[1]);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_RESOLUTION, tileResolution);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_X, tileOrigin[0] + tileCenterI * tileSize[0] * tileResolution);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_Y, tileOrigin[1] - tileCenterJ * tileSize[1] * tileResolution);
        this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, extent);
        this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);
        this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);
        this.helper.drawElements(0, this.indices_.getSize());
      }
    }

    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
    var canvas = this.helper.getCanvas();
    var tileTextureCache = this.tileTextureCache_;

    while (tileTextureCache.canExpireCache()) {
      var tileTexture = tileTextureCache.pop();
      tileTexture.dispose();
    } // TODO: let the renderers manage their own cache instead of managing the source cache

    /**
     * Here we unconditionally expire the source cache since the renderer maintains
     * its own cache.
     * @param {import("../../PluggableMap.js").default} map Map.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     */


    var postRenderFunction = function postRenderFunction(map, frameState) {
      tileSource.expireCache(frameState.viewState.projection, empty);
    };

    frameState.postRenderFunctions.push(postRenderFunction);
    this.postRender(gl, frameState);
    return canvas;
  };
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.
   */


  WebGLTileLayerRenderer.prototype.getData = function (pixel) {
    var gl = this.helper.getGL();

    if (!gl) {
      return null;
    }

    var frameState = this.frameState_;

    if (!frameState) {
      return null;
    }

    var layer = this.getLayer();
    var coordinate = (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
    var viewState = frameState.viewState;
    var layerExtent = layer.getExtent();

    if (layerExtent) {
      if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsCoordinate)((0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerExtent, viewState.projection), coordinate)) {
        return null;
      }
    }

    var source = layer.getRenderSource();
    var tileGrid = source.getTileGridForProjection(viewState.projection);

    if (!source.getWrapX()) {
      var gridExtent = tileGrid.getExtent();

      if (gridExtent) {
        if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsCoordinate)(gridExtent, coordinate)) {
          return null;
        }
      }
    }

    var tileTextureCache = this.tileTextureCache_;

    for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
      var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      var cacheKey = getCacheKey(source, tileCoord);

      if (!tileTextureCache.containsKey(cacheKey)) {
        continue;
      }

      var tileTexture = tileTextureCache.get(cacheKey);

      if (!tileTexture.loaded) {
        continue;
      }

      var tileOrigin = tileGrid.getOrigin(z);
      var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_15__.toSize)(tileGrid.getTileSize(z));
      var tileResolution = tileGrid.getResolution(z);
      var col = (coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0];
      var row = (tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1];
      return tileTexture.getPixelData(col, row);
    }

    return null;
  };
  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {number} altZ The alternate zoom level.
   * @param {Object<number, Array<import("../../webgl/TileTexture.js").default>>} tileTexturesByZ Lookup of
   * tile textures by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */


  WebGLTileLayerRenderer.prototype.findAltTiles_ = function (tileGrid, tileCoord, altZ, tileTexturesByZ) {
    var tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);

    if (!tileRange) {
      return false;
    }

    var covered = true;
    var tileTextureCache = this.tileTextureCache_;
    var source = this.getLayer().getRenderSource();

    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
        var cacheKey = getCacheKey(source, [altZ, x, y]);
        var loaded = false;

        if (tileTextureCache.containsKey(cacheKey)) {
          var tileTexture = tileTextureCache.get(cacheKey);

          if (tileTexture.loaded) {
            addTileTextureToLookup(tileTexturesByZ, tileTexture, altZ);
            loaded = true;
          }
        }

        if (!loaded) {
          covered = false;
        }
      }
    }

    return covered;
  };

  WebGLTileLayerRenderer.prototype.removeHelper = function () {
    if (this.helper) {
      var tileTextureCache = this.tileTextureCache_;
      tileTextureCache.forEach(function (tileTexture) {
        return tileTexture.dispose();
      });
      tileTextureCache.clear();
    }

    _super.prototype.removeHelper.call(this);
  };
  /**
   * Clean up.
   */


  WebGLTileLayerRenderer.prototype.disposeInternal = function () {
    var helper = this.helper;

    if (helper) {
      var gl = helper.getGL();
      gl.deleteProgram(this.program_);
      delete this.program_;
      helper.deleteBuffer(this.indices_);
    }

    _super.prototype.disposeInternal.call(this);

    delete this.indices_;
    delete this.tileTextureCache_;
    delete this.frameState_;
  };

  return WebGLTileLayerRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_16__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (WebGLTileLayerRenderer);

/***/ }),

/***/ "./build/wg/reproj.js":
/*!****************************!*\
  !*** ./build/wg/reproj.js ***!
  \****************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calculateSourceResolution": function() { return /* binding */ calculateSourceResolution; },
/* harmony export */   "calculateSourceExtentResolution": function() { return /* binding */ calculateSourceExtentResolution; },
/* harmony export */   "render": function() { return /* binding */ render; }
/* harmony export */ });
/* harmony import */ var _renderer_canvas_common_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderer/canvas/common.js */ "./build/wg/renderer/canvas/common.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./obj.js */ "./build/wg/obj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent.js */ "./build/wg/extent.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom.js */ "./build/wg/dom.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./build/wg/proj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./math.js */ "./build/wg/math.js");
/**
 * @module wg/reproj
 */






var brokenDiagonalRendering_;
/**
 * This draws a small triangle into a canvas by setting the triangle as the clip region
 * and then drawing a (too large) rectangle
 *
 * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle
 * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.
 * @param {number} v1 The y-coordinate of the second point.
 * @param {number} u2 The x-coordinate of the third point.
 * @param {number} v2 The y-coordinate of the third point.
 */

function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}
/**
 * Given the data from getImageData, see if the right values appear at the provided offset.
 * Returns true if either the color or transparency is off
 *
 * @param {Uint8ClampedArray} data The data returned from getImageData
 * @param {number} offset The pixel offset from the start of data.
 * @return {boolean} true if the diagonal rendering is broken
 */


function verifyBrokenDiagonalRendering(data, offset) {
  // the values ought to be close to the rgba(210, 0, 0, 0.75)
  return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;
}
/**
 * Determines if the current browser configuration can render triangular clip regions correctly.
 * This value is cached so the function is only expensive the first time called.
 * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976
 * IE also doesn't. Chrome works, and everything seems to work on OSX and Android. This function caches the
 * result. I suppose that it is conceivably possible that a browser might flip modes while the app is
 * running, but lets hope not.
 *
 * @return {boolean} true if the Diagonal Rendering is broken.
 */


function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === undefined) {
    var ctx = document.createElement('canvas').getContext('2d');
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    var data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
  }

  return brokenDiagonalRendering_;
}
/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */


function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  var sourceCenter = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.transform)(targetCenter, targetProj, sourceProj); // calculate the ideal resolution of the source data

  var sourceResolution = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getPointResolution)(targetProj, targetResolution, targetCenter);
  var targetMetersPerUnit = targetProj.getMetersPerUnit();

  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }

  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();

  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  } // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.


  var sourceExtent = sourceProj.getExtent();

  if (!sourceExtent || (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsCoordinate)(sourceExtent, sourceCenter)) {
    var compensationFactor = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getPointResolution)(sourceProj, sourceResolution, sourceCenter) / sourceResolution;

    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }

  return sourceResolution;
}
/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./extent.js").Extent} targetExtent Target extent
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */

function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  var targetCenter = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getCenter)(targetExtent);
  var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);

  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.forEachCorner)(targetExtent, function (corner) {
      sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }

  return sourceResolution;
}
/**
 * @typedef {Object} ImageExtent
 * @property {import("./extent.js").Extent} extent Extent.
 * @property {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
 */

/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {import("./extent.js").Extent} targetExtent Target extent.
 * @param {import("./reproj/Triangulation.js").default} triangulation Calculated triangulation.
 * @param {Array<ImageExtent>} sources Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean} [opt_renderEdges] Render reprojection edges.
 * @param {object} [opt_interpolate] Use linear interpolation when resampling.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */

function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges, opt_interpolate) {
  var context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.createCanvasContext2D)(Math.round(pixelRatio * width), Math.round(pixelRatio * height));

  if (!opt_interpolate) {
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.assign)(context, _renderer_canvas_common_js__WEBPACK_IMPORTED_MODULE_4__.IMAGE_SMOOTHING_DISABLED);
  }

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);

  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }

  context.globalCompositeOperation = 'lighter';
  var sourceDataExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createEmpty)();
  sources.forEach(function (src, i, arr) {
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.extend)(sourceDataExtent, src.extent);
  });
  var canvasWidthInUnits = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(sourceDataExtent);
  var canvasHeightInUnits = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getHeight)(sourceDataExtent);
  var stitchContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.createCanvasContext2D)(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));

  if (!opt_interpolate) {
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.assign)(stitchContext, _renderer_canvas_common_js__WEBPACK_IMPORTED_MODULE_4__.IMAGE_SMOOTHING_DISABLED);
  }

  var stitchScale = pixelRatio / sourceResolution;
  sources.forEach(function (src, i, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);
    var srcWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(src.extent);
    var srcHeight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getHeight)(src.extent); // This test should never fail -- but it does. Need to find a fix the upstream condition

    if (src.image.width > 0 && src.image.height > 0) {
      stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
    }
  });
  var targetTopLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getTopLeft)(targetExtent);
  triangulation.getTriangles().forEach(function (triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    var source = triangle.source;
    var target = triangle.target;
    var x0 = source[0][0],
        y0 = source[0][1];
    var x1 = source[1][0],
        y1 = source[1][1];
    var x2 = source[2][0],
        y2 = source[2][1]; // Make sure that everything is on pixel boundaries

    var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
    var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
    var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution); // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.

    var sourceNumericalShiftX = x0;
    var sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];
    var affineCoefs = (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.solveLinearSystem)(augmentedMatrix);

    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();

    if (isBrokenDiagonalRendering() || !opt_interpolate) {
      // Make sure that all lines are horizontal or vertical
      context.moveTo(u1, v1); // This is the diagonal line. Do it in 4 steps

      var steps = 4;
      var ud = u0 - u1;
      var vd = v0 - v1;

      for (var step = 0; step < steps; step++) {
        // Go horizontally
        context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound(step * vd / (steps - 1))); // Go vertically

        if (step != steps - 1) {
          context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound((step + 1) * vd / (steps - 1)));
        }
      } // We are almost at u0r, v0r


      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }

    context.clip();
    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });

  if (opt_renderEdges) {
    context.save();
    context.globalCompositeOperation = 'source-over';
    context.strokeStyle = 'black';
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function (triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }

  return context.canvas;
}

/***/ }),

/***/ "./build/wg/reproj/Image.js":
/*!**********************************!*\
  !*** ./build/wg/reproj/Image.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./build/wg/reproj/common.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _ImageBase_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../ImageBase.js */ "./build/wg/ImageBase.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ImageState.js */ "./build/wg/ImageState.js");
/* harmony import */ var _Triangulation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Triangulation.js */ "./build/wg/reproj/Triangulation.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../reproj.js */ "./build/wg/reproj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events.js */ "./build/wg/events.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/reproj/Image
 */










/**
 * @typedef {function(import("../extent.js").Extent, number, number) : import("../ImageBase.js").default} FunctionType
 */

/**
 * @classdesc
 * Class encapsulating single reprojected image.
 * See {@link module:wg/source/Image~ImageSource}.
 */

var ReprojImage =
/** @class */
function (_super) {
  __extends(ReprojImage, _super);
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent.
   * @param {number} targetResolution Target resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {FunctionType} getImageFunction
   *     Function returning source images (extent, resolution, pixelRatio).
   * @param {boolean} interpolate Use linear interpolation when resampling.
   */


  function ReprojImage(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction, interpolate) {
    var _this = this;

    var maxSourceExtent = sourceProj.getExtent();
    var maxTargetExtent = targetProj.getExtent();
    var limitedTargetExtent = maxTargetExtent ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;
    var targetCenter = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.getCenter)(limitedTargetExtent);
    var sourceResolution = (0,_reproj_js__WEBPACK_IMPORTED_MODULE_1__.calculateSourceResolution)(sourceProj, targetProj, targetCenter, targetResolution);
    var errorThresholdInPixels = _common_js__WEBPACK_IMPORTED_MODULE_2__.ERROR_THRESHOLD;
    var triangulation = new _Triangulation_js__WEBPACK_IMPORTED_MODULE_3__["default"](sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
    var sourceExtent = triangulation.calculateSourceExtent();
    var sourceImage = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
    var state = sourceImage ? _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE : _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].EMPTY;
    var sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;
    _this = _super.call(this, targetExtent, targetResolution, sourcePixelRatio, state) || this;
    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */

    _this.targetProj_ = targetProj;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    _this.maxSourceExtent_ = maxSourceExtent;
    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */

    _this.triangulation_ = triangulation;
    /**
     * @private
     * @type {number}
     */

    _this.targetResolution_ = targetResolution;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    _this.targetExtent_ = targetExtent;
    /**
     * @private
     * @type {import("../ImageBase.js").default}
     */

    _this.sourceImage_ = sourceImage;
    /**
     * @private
     * @type {number}
     */

    _this.sourcePixelRatio_ = sourcePixelRatio;
    /**
     * @private
     * @type {boolean}
     */

    _this.interpolate_ = interpolate;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.canvas_ = null;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */

    _this.sourceListenerKey_ = null;
    return _this;
  }
  /**
   * Clean up.
   */


  ReprojImage.prototype.disposeInternal = function () {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADING) {
      this.unlistenSource_();
    }

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * @return {HTMLCanvasElement} Image.
   */


  ReprojImage.prototype.getImage = function () {
    return this.canvas_;
  };
  /**
   * @return {import("../proj/Projection.js").default} Projection.
   */


  ReprojImage.prototype.getProjection = function () {
    return this.targetProj_;
  };
  /**
   * @private
   */


  ReprojImage.prototype.reproject_ = function () {
    var sourceState = this.sourceImage_.getState();

    if (sourceState == _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED) {
      var width = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.getWidth)(this.targetExtent_) / this.targetResolution_;
      var height = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = (0,_reproj_js__WEBPACK_IMPORTED_MODULE_1__.render)(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [{
        extent: this.sourceImage_.getExtent(),
        image: this.sourceImage_.getImage()
      }], 0, undefined, this.interpolate_);
    }

    this.state = sourceState;
    this.changed();
  };
  /**
   * Load not yet loaded URI.
   */


  ReprojImage.prototype.load = function () {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE) {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADING;
      this.changed();
      var sourceState = this.sourceImage_.getState();

      if (sourceState == _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED || sourceState == _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR) {
        this.reproject_();
      } else {
        this.sourceListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_5__.listen)(this.sourceImage_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, function (e) {
          var sourceState = this.sourceImage_.getState();

          if (sourceState == _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED || sourceState == _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR) {
            this.unlistenSource_();
            this.reproject_();
          }
        }, this);
        this.sourceImage_.load();
      }
    }
  };
  /**
   * @private
   */


  ReprojImage.prototype.unlistenSource_ = function () {
    (0,_events_js__WEBPACK_IMPORTED_MODULE_5__.unlistenByKey)(
    /** @type {!import("../events.js").EventsKey} */
    this.sourceListenerKey_);
    this.sourceListenerKey_ = null;
  };

  return ReprojImage;
}(_ImageBase_js__WEBPACK_IMPORTED_MODULE_7__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (ReprojImage);

/***/ }),

/***/ "./build/wg/reproj/Tile.js":
/*!*********************************!*\
  !*** ./build/wg/reproj/Tile.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common.js */ "./build/wg/reproj/common.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Tile.js */ "./build/wg/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../TileState.js */ "./build/wg/TileState.js");
/* harmony import */ var _Triangulation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Triangulation.js */ "./build/wg/reproj/Triangulation.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../reproj.js */ "./build/wg/reproj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./build/wg/events.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/reproj/Tile
 */











/**
 * @typedef {function(number, number, number, number) : import("../Tile.js").default} FunctionType
 */

/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:wg/source/TileImage~TileImage}.
 *
 */

var ReprojTile =
/** @class */
function (_super) {
  __extends(ReprojTile, _super);
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [opt_errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [opt_renderEdges] Render reprojection edges.
   * @param {boolean} [opt_interpolate] Use linear interpolation when resampling.
   */


  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_interpolate) {
    var _this = _super.call(this, tileCoord, _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE, {
      interpolate: !!opt_interpolate
    }) || this;
    /**
     * @private
     * @type {boolean}
     */


    _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {number}
     */

    _this.gutter_ = gutter;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.canvas_ = null;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */

    _this.sourceTileGrid_ = sourceTileGrid;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */

    _this.targetTileGrid_ = targetTileGrid;
    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */

    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
    /**
     * @private
     * @type {!Array<import("../Tile.js").default>}
     */

    _this.sourceTiles_ = [];
    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */

    _this.sourcesListenerKeys_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.sourceZ_ = 0;
    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);

    var maxTargetExtent = _this.targetTileGrid_.getExtent();

    var maxSourceExtent = _this.sourceTileGrid_.getExtent();

    var limitedTargetExtent = maxTargetExtent ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;

    if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getArea)(limitedTargetExtent) === 0) {
      // Tile is completely outside range -> EMPTY
      // TODO: is it actually correct that the source even creates the tile ?
      _this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].EMPTY;
      return _this;
    }

    var sourceProjExtent = sourceProj.getExtent();

    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getIntersection)(maxSourceExtent, sourceProjExtent);
      }
    }

    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);
    var sourceResolution = (0,_reproj_js__WEBPACK_IMPORTED_MODULE_2__.calculateSourceExtentResolution)(sourceProj, targetProj, limitedTargetExtent, targetResolution);

    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      // invalid sourceResolution -> EMPTY
      // probably edges of the projections when no extent is defined
      _this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].EMPTY;
      return _this;
    }

    var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : _common_js__WEBPACK_IMPORTED_MODULE_3__.ERROR_THRESHOLD;
    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */

    _this.triangulation_ = new _Triangulation_js__WEBPACK_IMPORTED_MODULE_4__["default"](sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);

    if (_this.triangulation_.getTriangles().length === 0) {
      // no valid triangles -> EMPTY
      _this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].EMPTY;
      return _this;
    }

    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);

    var sourceExtent = _this.triangulation_.calculateSourceExtent();

    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.clamp)(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
        sourceExtent[3] = (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.clamp)(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
      } else {
        sourceExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getIntersection)(sourceExtent, maxSourceExtent);
      }
    }

    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getArea)(sourceExtent)) {
      _this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].EMPTY;
    } else {
      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);

      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);

          if (tile) {
            _this.sourceTiles_.push(tile);
          }
        }
      }

      if (_this.sourceTiles_.length === 0) {
        _this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].EMPTY;
      }
    }

    return _this;
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */


  ReprojTile.prototype.getImage = function () {
    return this.canvas_;
  };
  /**
   * @private
   */


  ReprojTile.prototype.reproject_ = function () {
    var sources = [];
    this.sourceTiles_.forEach(function (tile, i, arr) {
      if (tile && tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED) {
        sources.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
          image: tile.getImage()
        });
      }
    }.bind(this));
    this.sourceTiles_.length = 0;

    if (sources.length === 0) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR;
    } else {
      var z = this.wrappedTileCoord_[0];
      var size = this.targetTileGrid_.getTileSize(z);
      var width = typeof size === 'number' ? size : size[0];
      var height = typeof size === 'number' ? size : size[1];
      var targetResolution = this.targetTileGrid_.getResolution(z);
      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
      var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
      this.canvas_ = (0,_reproj_js__WEBPACK_IMPORTED_MODULE_2__.render)(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED;
    }

    this.changed();
  };
  /**
   * Load not yet loaded URI.
   */


  ReprojTile.prototype.load = function () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADING;
      this.changed();
      var leftToLoad_1 = 0;
      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach(function (tile, i, arr) {
        var state = tile.getState();

        if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE || state == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADING) {
          leftToLoad_1++;
          var sourceListenKey_1 = (0,_events_js__WEBPACK_IMPORTED_MODULE_6__.listen)(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, function (e) {
            var state = tile.getState();

            if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED || state == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR || state == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].EMPTY) {
              (0,_events_js__WEBPACK_IMPORTED_MODULE_6__.unlistenByKey)(sourceListenKey_1);
              leftToLoad_1--;

              if (leftToLoad_1 === 0) {
                this.unlistenSources_();
                this.reproject_();
              }
            }
          }, this);
          this.sourcesListenerKeys_.push(sourceListenKey_1);
        }
      }.bind(this));

      if (leftToLoad_1 === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      } else {
        this.sourceTiles_.forEach(function (tile, i, arr) {
          var state = tile.getState();

          if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE) {
            tile.load();
          }
        });
      }
    }
  };
  /**
   * @private
   */


  ReprojTile.prototype.unlistenSources_ = function () {
    this.sourcesListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__.unlistenByKey);
    this.sourcesListenerKeys_ = null;
  };

  return ReprojTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_8__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (ReprojTile);

/***/ }),

/***/ "./build/wg/reproj/Triangulation.js":
/*!******************************************!*\
  !*** ./build/wg/reproj/Triangulation.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
/**
 * @module wg/reproj/Triangulation
 */



/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array<import("../coordinate.js").Coordinate>} source Source.
 * @property {Array<import("../coordinate.js").Coordinate>} target Target.
 */

/**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */

var MAX_SUBDIVISION = 10;
/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */

var MAX_TRIANGLE_WIDTH = 0.25;
/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */

var Triangulation =
/** @class */
function () {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} opt_destinationResolution The (optional) resolution of the destination.
   */
  function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {
    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */
    this.sourceProj_ = sourceProj;
    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */

    this.targetProj_ = targetProj;
    /** @type {!Object<string, import("../coordinate.js").Coordinate>} */

    var transformInvCache = {};
    var transformInv = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(this.targetProj_, this.sourceProj_);
    /**
     * @param {import("../coordinate.js").Coordinate} c A coordinate.
     * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
     * @private
     */

    this.transformInv_ = function (c) {
      var key = c[0] + '/' + c[1];

      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c);
      }

      return transformInvCache[key];
    };
    /**
     * @type {import("../extent.js").Extent}
     * @private
     */


    this.maxSourceExtent_ = maxSourceExtent;
    /**
     * @type {number}
     * @private
     */

    this.errorThresholdSquared_ = errorThreshold * errorThreshold;
    /**
     * @type {Array<Triangle>}
     * @private
     */

    this.triangles_ = [];
    /**
     * Indicates that the triangulation crosses edge of the source projection.
     * @type {boolean}
     * @private
     */

    this.wrapsXInSource_ = false;
    /**
     * @type {boolean}
     * @private
     */

    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(maxSourceExtent) == (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(this.sourceProj_.getExtent());
    /**
     * @type {?number}
     * @private
     */

    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(this.sourceProj_.getExtent()) : null;
    /**
     * @type {?number}
     * @private
     */

    this.targetWorldWidth_ = this.targetProj_.getExtent() ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(this.targetProj_.getExtent()) : null;
    var destinationTopLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getTopLeft)(targetExtent);
    var destinationTopRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getTopRight)(targetExtent);
    var destinationBottomRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getBottomRight)(targetExtent);
    var destinationBottomLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getBottomLeft)(targetExtent);
    var sourceTopLeft = this.transformInv_(destinationTopLeft);
    var sourceTopRight = this.transformInv_(destinationTopRight);
    var sourceBottomRight = this.transformInv_(destinationBottomRight);
    var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
    /*
     * The maxSubdivision controls how many splittings of the target area can
     * be done. The idea here is to do a linear mapping of the target areas
     * but the actual overal reprojection (can be) extremely non-linear. The
     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256
     * tile size. However this function is also called to remap canvas rendered
     * layers which can be much larger. This calculation increases the maxSubdivision
     * value by the right factor so that each 256x256 pixel area has
     * MAX_SUBDIVISION divisions.
     */

    var maxSubdivision = MAX_SUBDIVISION + (opt_destinationResolution ? Math.max(0, Math.ceil((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.log2)((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getArea)(targetExtent) / (opt_destinationResolution * opt_destinationResolution * 256 * 256)))) : 0);
    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);

    if (this.wrapsXInSource_) {
      var leftBound_1 = Infinity;
      this.triangles_.forEach(function (triangle, i, arr) {
        leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
      }); // Shift triangles to be as close to `leftBound` as possible
      // (if the distance is more than `worldWidth / 2` it can be closer.

      this.triangles_.forEach(function (triangle) {
        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound_1 > this.sourceWorldWidth_ / 2) {
          var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];

          if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }

          if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }

          if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          } // Rarely (if the extent contains both the dateline and prime meridian)
          // the shift can in turn break some triangles.
          // Detect this here and don't shift in such cases.


          var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
          var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);

          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      }.bind(this));
    }

    transformInvCache = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */


  Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {
    this.triangles_.push({
      source: [aSrc, bSrc, cSrc],
      target: [a, b, c]
    });
  };
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */


  Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
    var sourceQuadExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.boundingExtent)([aSrc, bSrc, cSrc, dSrc]);
    var sourceCoverageX = this.sourceWorldWidth_ ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(sourceQuadExtent) / this.sourceWorldWidth_ : null;
    var sourceWorldWidth =
    /** @type {number} */
    this.sourceWorldWidth_; // when the quad is wrapped in the source projection
    // it covers most of the projection extent, but not fully

    var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
    var needsSubdivision = false;

    if (maxSubdivision > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        var targetQuadExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.boundingExtent)([a, b, c, d]);
        var targetCoverageX = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(targetQuadExtent) / this.targetWorldWidth_;
        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }

      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
    }

    if (!needsSubdivision && this.maxSourceExtent_) {
      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
        if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.intersects)(sourceQuadExtent, this.maxSourceExtent_)) {
          // whole quad outside source projection extent -> ignore
          return;
        }
      }
    }

    var isNotFinite = 0;

    if (!needsSubdivision) {
      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
        if (maxSubdivision > 0) {
          needsSubdivision = true;
        } else {
          // It might be the case that only 1 of the points is infinite. In this case
          // we can draw a single triangle with the other three points
          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);

          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
            return;
          }
        }
      }
    }

    if (maxSubdivision > 0) {
      if (!needsSubdivision) {
        var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
        var centerSrc = this.transformInv_(center);
        var dx = void 0;

        if (wrapsX) {
          var centerSrcEstimX = ((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.modulo)(aSrc[0], sourceWorldWidth) + (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.modulo)(cSrc[0], sourceWorldWidth)) / 2;
          dx = centerSrcEstimX - (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.modulo)(centerSrc[0], sourceWorldWidth);
        } else {
          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
        }

        var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
        var centerSrcErrorSquared = dx * dx + dy * dy;
        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
      }

      if (needsSubdivision) {
        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
          // split horizontally (top & bottom)
          var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
          var bcSrc = this.transformInv_(bc);
          var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
          var daSrc = this.transformInv_(da);
          this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
          this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
        } else {
          // split vertically (left & right)
          var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
          var abSrc = this.transformInv_(ab);
          var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
          var cdSrc = this.transformInv_(cd);
          this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
          this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
        }

        return;
      }
    }

    if (wrapsX) {
      if (!this.canWrapXInSource_) {
        return;
      }

      this.wrapsXInSource_ = true;
    } // Exactly zero or one of *Src is not finite
    // The triangles must have the diagonal line as the first side
    // This is to allow easy code in reproj.s to make it straight for broken
    // browsers that can't handle diagonal clipping


    if ((isNotFinite & 0xb) == 0) {
      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
    }

    if ((isNotFinite & 0xe) == 0) {
      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
    }

    if (isNotFinite) {
      // Try the other two triangles
      if ((isNotFinite & 0xd) == 0) {
        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
      }

      if ((isNotFinite & 0x7) == 0) {
        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
      }
    }
  };
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */


  Triangulation.prototype.calculateSourceExtent = function () {
    var extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createEmpty)();
    this.triangles_.forEach(function (triangle, i, arr) {
      var src = triangle.source;
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.extendCoordinate)(extent, src[0]);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.extendCoordinate)(extent, src[1]);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.extendCoordinate)(extent, src[2]);
    });
    return extent;
  };
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */


  Triangulation.prototype.getTriangles = function () {
    return this.triangles_;
  };

  return Triangulation;
}();

/* harmony default export */ __webpack_exports__["default"] = (Triangulation);

/***/ }),

/***/ "./build/wg/reproj/common.js":
/*!***********************************!*\
  !*** ./build/wg/reproj/common.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ERROR_THRESHOLD": function() { return /* binding */ ERROR_THRESHOLD; },
/* harmony export */   "ENABLE_RASTER_REPROJECTION": function() { return /* binding */ ENABLE_RASTER_REPROJECTION; }
/* harmony export */ });
/**
 * @module wg/reproj/common
 */

/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
var ERROR_THRESHOLD = 0.5;
/**
 * Enable automatic reprojection of raster sources. Default is `true`.
 * TODO: decide if we want to expose this as a build flag or remove it
 * @type {boolean}
 */

var ENABLE_RASTER_REPROJECTION = true;

/***/ }),

/***/ "./build/wg/resolutionconstraint.js":
/*!******************************************!*\
  !*** ./build/wg/resolutionconstraint.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSnapToResolutions": function() { return /* binding */ createSnapToResolutions; },
/* harmony export */   "createSnapToPower": function() { return /* binding */ createSnapToPower; },
/* harmony export */   "createMinMaxResolution": function() { return /* binding */ createMinMaxResolution; }
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./build/wg/math.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extent.js */ "./build/wg/extent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "./build/wg/array.js");
/**
 * @module wg/resolutionconstraint
 */



/**
 * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
 */

/**
 * Returns a modified resolution taking into account the viewport size and maximum
 * allowed extent.
 * @param {number} resolution Resolution
 * @param {import("./extent.js").Extent} maxExtent Maximum allowed extent.
 * @param {import("./size.js").Size} viewportSize Viewport size.
 * @param {boolean} showFullExtent Whether to show the full extent.
 * @return {number} Capped resolution.
 */

function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  var xResolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.getWidth)(maxExtent) / viewportSize[0];
  var yResolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(maxExtent) / viewportSize[1];

  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }

  return Math.min(resolution, Math.min(xResolution, yResolution));
}
/**
 * Returns a modified resolution to be between maxResolution and minResolution while
 * still allowing the value to be slightly out of bounds.
 * Note: the computation is based on the logarithm function (ln):
 *  - at 1, ln(x) is 0
 *  - above 1, ln(x) keeps increasing but at a much slower pace than x
 * The final result is clamped to prevent getting too far away from bounds.
 * @param {number} resolution Resolution.
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @return {number} Smoothed resolution.
 */


function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  var result = Math.min(resolution, maxResolution);
  var ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;

  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }

  return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(result, minResolution / 2, maxResolution * 2);
}
/**
 * @param {Array<number>} resolutions Resolutions.
 * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [opt_maxExtent] Maximum allowed extent.
 * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */


function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, opt_isMoving) {
      if (resolution !== undefined) {
        var maxResolution = resolutions[0];
        var minResolution = resolutions[resolutions.length - 1];
        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution; // during interacting or animating, allow intermediary values

        if (opt_isMoving) {
          var smooth = opt_smooth !== undefined ? opt_smooth : true;

          if (!smooth) {
            return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(resolution, minResolution, cappedMaxRes);
          }

          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }

        var capped = Math.min(cappedMaxRes, resolution);
        var z = Math.floor((0,_array_js__WEBPACK_IMPORTED_MODULE_2__.linearFindNearest)(resolutions, capped, direction));

        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }

        return resolutions[z];
      } else {
        return undefined;
      }
    }
  );
}
/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number} [opt_minResolution] Minimum resolution.
 * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [opt_maxExtent] Maximum allowed extent.
 * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */

function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, opt_isMoving) {
      if (resolution !== undefined) {
        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
        var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0; // during interacting or animating, allow intermediary values

        if (opt_isMoving) {
          var smooth = opt_smooth !== undefined ? opt_smooth : true;

          if (!smooth) {
            return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(resolution, minResolution, cappedMaxRes);
          }

          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }

        var tolerance = 1e-9;
        var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
        var offset = -direction * (0.5 - tolerance) + 0.5;
        var capped = Math.min(cappedMaxRes, resolution);
        var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
        var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        var newResolution = maxResolution / Math.pow(power, zoomLevel);
        return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(newResolution, minResolution, cappedMaxRes);
      } else {
        return undefined;
      }
    }
  );
}
/**
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [opt_maxExtent] Maximum allowed extent.
 * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */

function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, opt_isMoving) {
      if (resolution !== undefined) {
        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
        var smooth = opt_smooth !== undefined ? opt_smooth : true;

        if (!smooth || !opt_isMoving) {
          return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(resolution, minResolution, cappedMaxRes);
        }

        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
      } else {
        return undefined;
      }
    }
  );
}

/***/ }),

/***/ "./build/wg/rotationconstraint.js":
/*!****************************************!*\
  !*** ./build/wg/rotationconstraint.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "disable": function() { return /* binding */ disable; },
/* harmony export */   "none": function() { return /* binding */ none; },
/* harmony export */   "createSnapToN": function() { return /* binding */ createSnapToN; },
/* harmony export */   "createSnapToZero": function() { return /* binding */ createSnapToZero; }
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./build/wg/math.js");
/**
 * @module wg/rotationconstraint
 */

/**
 * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
 */

/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */

function disable(rotation) {
  if (rotation !== undefined) {
    return 0;
  } else {
    return undefined;
  }
}
/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */

function none(rotation) {
  if (rotation !== undefined) {
    return rotation;
  } else {
    return undefined;
  }
}
/**
 * @param {number} n N.
 * @return {Type} Rotation constraint.
 */

function createSnapToN(n) {
  var theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, opt_isMoving) {
      if (opt_isMoving) {
        return rotation;
      }

      if (rotation !== undefined) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      } else {
        return undefined;
      }
    }
  );
}
/**
 * @param {number} [opt_tolerance] Tolerance.
 * @return {Type} Rotation constraint.
 */

function createSnapToZero(opt_tolerance) {
  var tolerance = opt_tolerance || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, opt_isMoving) {
      if (opt_isMoving) {
        return rotation;
      }

      if (rotation !== undefined) {
        if (Math.abs(rotation) <= tolerance) {
          return 0;
        } else {
          return rotation;
        }
      } else {
        return undefined;
      }
    }
  );
}

/***/ }),

/***/ "./build/wg/size.js":
/*!**************************!*\
  !*** ./build/wg/size.js ***!
  \**************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buffer": function() { return /* binding */ buffer; },
/* harmony export */   "hasArea": function() { return /* binding */ hasArea; },
/* harmony export */   "scale": function() { return /* binding */ scale; },
/* harmony export */   "toSize": function() { return /* binding */ toSize; }
/* harmony export */ });
/**
 * @module wg/size
 */

/**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */

/**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size} [opt_size] Optional reusable size array.
 * @return {Size} The buffered size.
 */
function buffer(size, num, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }

  opt_size[0] = size[0] + 2 * num;
  opt_size[1] = size[1] + 2 * num;
  return opt_size;
}
/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */

function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}
/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size} [opt_size] Optional reusable size array.
 * @return {Size} The scaled size.
 */

function scale(size, ratio, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }

  opt_size[0] = size[0] * ratio + 0.5 | 0;
  opt_size[1] = size[1] * ratio + 0.5 | 0;
  return opt_size;
}
/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size} [opt_size] Optional reusable size array.
 * @return {Size} Size.
 * @api
 */

function toSize(size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === undefined) {
      opt_size = [size, size];
    } else {
      opt_size[0] = size;
      opt_size[1] = size;
    }

    return opt_size;
  }
}

/***/ }),

/***/ "./build/wg/source.js":
/*!****************************!*\
  !*** ./build/wg/source.js ***!
  \****************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BingMaps": function() { return /* reexport safe */ _source_BingMaps_js__WEBPACK_IMPORTED_MODULE_0__["default"]; },
/* harmony export */   "CartoDB": function() { return /* reexport safe */ _source_CartoDB_js__WEBPACK_IMPORTED_MODULE_1__["default"]; },
/* harmony export */   "Cluster": function() { return /* reexport safe */ _source_Cluster_js__WEBPACK_IMPORTED_MODULE_2__["default"]; },
/* harmony export */   "DataTile": function() { return /* reexport safe */ _source_DataTile_js__WEBPACK_IMPORTED_MODULE_3__["default"]; },
/* harmony export */   "GeoTIFF": function() { return /* reexport safe */ _source_GeoTIFF_js__WEBPACK_IMPORTED_MODULE_4__["default"]; },
/* harmony export */   "IIIF": function() { return /* reexport safe */ _source_IIIF_js__WEBPACK_IMPORTED_MODULE_5__["default"]; },
/* harmony export */   "Image": function() { return /* reexport safe */ _source_Image_js__WEBPACK_IMPORTED_MODULE_6__["default"]; },
/* harmony export */   "ImageArcGISRest": function() { return /* reexport safe */ _source_ImageArcGISRest_js__WEBPACK_IMPORTED_MODULE_7__["default"]; },
/* harmony export */   "ImageCanvas": function() { return /* reexport safe */ _source_ImageCanvas_js__WEBPACK_IMPORTED_MODULE_8__["default"]; },
/* harmony export */   "ImageMapGuide": function() { return /* reexport safe */ _source_ImageMapGuide_js__WEBPACK_IMPORTED_MODULE_9__["default"]; },
/* harmony export */   "ImageStatic": function() { return /* reexport safe */ _source_ImageStatic_js__WEBPACK_IMPORTED_MODULE_10__["default"]; },
/* harmony export */   "ImageWMS": function() { return /* reexport safe */ _source_ImageWMS_js__WEBPACK_IMPORTED_MODULE_11__["default"]; },
/* harmony export */   "OSM": function() { return /* reexport safe */ _source_OSM_js__WEBPACK_IMPORTED_MODULE_12__["default"]; },
/* harmony export */   "Raster": function() { return /* reexport safe */ _source_Raster_js__WEBPACK_IMPORTED_MODULE_13__["default"]; },
/* harmony export */   "Source": function() { return /* reexport safe */ _source_Source_js__WEBPACK_IMPORTED_MODULE_14__["default"]; },
/* harmony export */   "Stamen": function() { return /* reexport safe */ _source_Stamen_js__WEBPACK_IMPORTED_MODULE_15__["default"]; },
/* harmony export */   "Tile": function() { return /* reexport safe */ _source_Tile_js__WEBPACK_IMPORTED_MODULE_16__["default"]; },
/* harmony export */   "TileArcGISRest": function() { return /* reexport safe */ _source_TileArcGISRest_js__WEBPACK_IMPORTED_MODULE_17__["default"]; },
/* harmony export */   "TileDebug": function() { return /* reexport safe */ _source_TileDebug_js__WEBPACK_IMPORTED_MODULE_18__["default"]; },
/* harmony export */   "TileImage": function() { return /* reexport safe */ _source_TileImage_js__WEBPACK_IMPORTED_MODULE_19__["default"]; },
/* harmony export */   "TileJSON": function() { return /* reexport safe */ _source_TileJSON_js__WEBPACK_IMPORTED_MODULE_20__["default"]; },
/* harmony export */   "TileWMS": function() { return /* reexport safe */ _source_TileWMS_js__WEBPACK_IMPORTED_MODULE_21__["default"]; },
/* harmony export */   "UrlTile": function() { return /* reexport safe */ _source_UrlTile_js__WEBPACK_IMPORTED_MODULE_22__["default"]; },
/* harmony export */   "UTFGrid": function() { return /* reexport safe */ _source_UTFGrid_js__WEBPACK_IMPORTED_MODULE_23__["default"]; },
/* harmony export */   "Vector": function() { return /* reexport safe */ _source_Vector_js__WEBPACK_IMPORTED_MODULE_24__["default"]; },
/* harmony export */   "VectorTile": function() { return /* reexport safe */ _source_VectorTile_js__WEBPACK_IMPORTED_MODULE_25__["default"]; },
/* harmony export */   "WMTS": function() { return /* reexport safe */ _source_WMTS_js__WEBPACK_IMPORTED_MODULE_26__["default"]; },
/* harmony export */   "XYZ": function() { return /* reexport safe */ _source_XYZ_js__WEBPACK_IMPORTED_MODULE_27__["default"]; },
/* harmony export */   "Zoomify": function() { return /* reexport safe */ _source_Zoomify_js__WEBPACK_IMPORTED_MODULE_28__["default"]; },
/* harmony export */   "sourcesFromTileGrid": function() { return /* binding */ sourcesFromTileGrid; }
/* harmony export */ });
/* harmony import */ var _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./structs/LRUCache.js */ "./build/wg/structs/LRUCache.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./extent.js */ "./build/wg/extent.js");
/* harmony import */ var _source_BingMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./source/BingMaps.js */ "./build/wg/source/BingMaps.js");
/* harmony import */ var _source_CartoDB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./source/CartoDB.js */ "./build/wg/source/CartoDB.js");
/* harmony import */ var _source_Cluster_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./source/Cluster.js */ "./build/wg/source/Cluster.js");
/* harmony import */ var _source_DataTile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./source/DataTile.js */ "./build/wg/source/DataTile.js");
/* harmony import */ var _source_GeoTIFF_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./source/GeoTIFF.js */ "./build/wg/source/GeoTIFF.js");
/* harmony import */ var _source_IIIF_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./source/IIIF.js */ "./build/wg/source/IIIF.js");
/* harmony import */ var _source_Image_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./source/Image.js */ "./build/wg/source/Image.js");
/* harmony import */ var _source_ImageArcGISRest_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./source/ImageArcGISRest.js */ "./build/wg/source/ImageArcGISRest.js");
/* harmony import */ var _source_ImageCanvas_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./source/ImageCanvas.js */ "./build/wg/source/ImageCanvas.js");
/* harmony import */ var _source_ImageMapGuide_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./source/ImageMapGuide.js */ "./build/wg/source/ImageMapGuide.js");
/* harmony import */ var _source_ImageStatic_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./source/ImageStatic.js */ "./build/wg/source/ImageStatic.js");
/* harmony import */ var _source_ImageWMS_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./source/ImageWMS.js */ "./build/wg/source/ImageWMS.js");
/* harmony import */ var _source_OSM_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./source/OSM.js */ "./build/wg/source/OSM.js");
/* harmony import */ var _source_Raster_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./source/Raster.js */ "./build/wg/source/Raster.js");
/* harmony import */ var _source_Source_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./source/Source.js */ "./build/wg/source/Source.js");
/* harmony import */ var _source_Stamen_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./source/Stamen.js */ "./build/wg/source/Stamen.js");
/* harmony import */ var _source_Tile_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./source/Tile.js */ "./build/wg/source/Tile.js");
/* harmony import */ var _source_TileArcGISRest_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./source/TileArcGISRest.js */ "./build/wg/source/TileArcGISRest.js");
/* harmony import */ var _source_TileDebug_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./source/TileDebug.js */ "./build/wg/source/TileDebug.js");
/* harmony import */ var _source_TileImage_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./source/TileImage.js */ "./build/wg/source/TileImage.js");
/* harmony import */ var _source_TileJSON_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./source/TileJSON.js */ "./build/wg/source/TileJSON.js");
/* harmony import */ var _source_TileWMS_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./source/TileWMS.js */ "./build/wg/source/TileWMS.js");
/* harmony import */ var _source_UrlTile_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./source/UrlTile.js */ "./build/wg/source/UrlTile.js");
/* harmony import */ var _source_UTFGrid_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./source/UTFGrid.js */ "./build/wg/source/UTFGrid.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./source/Vector.js */ "./build/wg/source/Vector.js");
/* harmony import */ var _source_VectorTile_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./source/VectorTile.js */ "./build/wg/source/VectorTile.js");
/* harmony import */ var _source_WMTS_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./source/WMTS.js */ "./build/wg/source/WMTS.js");
/* harmony import */ var _source_XYZ_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./source/XYZ.js */ "./build/wg/source/XYZ.js");
/* harmony import */ var _source_Zoomify_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./source/Zoomify.js */ "./build/wg/source/Zoomify.js");
/**
 * @module wg/source
 */































/**
 * Creates a sources function from a tile grid. This function can be used as value for the
 * `sources` property of the {@link module:wg/layer/Layer~Layer} subclasses that support it.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @param {function(import("./tilecoord.js").TileCoord): import("./source/Source.js").default} factory Source factory.
 * This function takes a {@link module:wg/tilecoord~TileCoord} as argument and is expected to return a
 * {@link module:wg/source/Source~Source}. **Note**: The returned sources should have a tile grid with
 * a limited set of resolutions, matching the resolution range of a single zoom level of the pyramid
 * `tileGrid` that `createFromTileGrid` was called with.
 * @return {function(import("./extent.js").Extent, number): Array<import("./source/Source.js").default>} Sources function.
 * @api
 */

function sourcesFromTileGrid(tileGrid, factory) {
  var sourceCache = new _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_29__["default"](32);
  var tileGridExtent = tileGrid.getExtent();
  return function (extent, resolution) {
    sourceCache.expireCache();

    if (tileGridExtent) {
      extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_30__.getIntersection)(tileGridExtent, extent);
    }

    var z = tileGrid.getZForResolution(resolution);
    var wantedSources = [];
    tileGrid.forEachTileCoord(extent, z, function (tileCoord) {
      var key = tileCoord.toString();

      if (!sourceCache.containsKey(key)) {
        var source = factory(tileCoord);
        sourceCache.set(key, source);
      }

      wantedSources.push(sourceCache.get(key));
    });
    return wantedSources;
  };
}

/***/ }),

/***/ "./build/wg/source/BingMaps.js":
/*!*************************************!*\
  !*** ./build/wg/source/BingMaps.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "quadKey": function() { return /* binding */ quadKey; }
/* harmony export */ });
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./State.js */ "./build/wg/source/State.js");
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TileImage.js */ "./build/wg/source/TileImage.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tileurlfunction.js */ "./build/wg/tileurlfunction.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tilecoord.js */ "./build/wg/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tilegrid.js */ "./build/wg/tilegrid.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _net_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../net.js */ "./build/wg/net.js");
/**
 * @module wg/source/BingMaps
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();









/**
 * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coord.
 * @return {string} Quad key.
 */

function quadKey(tileCoord) {
  var z = tileCoord[0];
  var digits = new Array(z);
  var mask = 1 << z - 1;
  var i, charCode;

  for (i = 0; i < z; ++i) {
    // 48 is charCode for 0 - '0'.charCodeAt(0)
    charCode = 48;

    if (tileCoord[1] & mask) {
      charCode += 1;
    }

    if (tileCoord[2] & mask) {
      charCode += 2;
    }

    digits[i] = String.fromCharCode(charCode);
    mask >>= 1;
  }

  return digits.join('');
}
/**
 * The attribution containing a link to the Microsoft® Bing™ Maps Platform APIs’
 * Terms Of Use.
 * @const
 * @type {string}
 */

var TOS_ATTRIBUTION = '<a class="wg-attribution-bing-tos" ' + 'href="https://www.microsoft.com/maps/product/terms.html" target="_blank">' + 'Terms of Use</a>';
/**
 * @typedef {Object} Options
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {boolean} [hidpi=false] If `true` hidpi tiles will be requested.
 * @property {string} [culture='en-us'] Culture code.
 * @property {string} key Bing Maps API key. Get yours at https://www.bingmapsportal.com/.
 * @property {string} imagerySet Type of imagery.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {number} [maxZoom=21] Max zoom. Default is what's advertized by the BingMaps service.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @typedef {Object} BingMapsImageryMetadataResponse
 * @property {number} statusCode The response status code
 * @property {string} statusDescription The response status description
 * @property {string} authenticationResultCode The authentication result code
 * @property {Array<ResourceSet>} resourceSets The array of resource sets
 */

/**
 * @typedef {Object} ResourceSet
 * @property {Array<Resource>} resources Resources.
 */

/**
 * @typedef {Object} Resource
 * @property {number} imageHeight The image height
 * @property {number} imageWidth The image width
 * @property {number} zoomMin The minimum zoom level
 * @property {number} zoomMax The maximum zoom level
 * @property {string} imageUrl The image URL
 * @property {Array<string>} imageUrlSubdomains The image URL subdomains for rotation
 * @property {Array<ImageryProvider>} [imageryProviders] The array of ImageryProviders
 */

/**
 * @typedef {Object} ImageryProvider
 * @property {Array<CoverageArea>} coverageAreas The coverage areas
 * @property {string} [attribution] The attribution
 */

/**
 * @typedef {Object} CoverageArea
 * @property {number} zoomMin The minimum zoom
 * @property {number} zoomMax The maximum zoom
 * @property {Array<number>} bbox The coverage bounding box
 */

/**
 * @classdesc
 * Layer source for Bing Maps tile data.
 * @api
 */

var BingMaps =
/** @class */
function (_super) {
  __extends(BingMaps, _super);
  /**
   * @param {Options} options Bing Maps options.
   */


  function BingMaps(options) {
    var _this = this;

    var hidpi = options.hidpi !== undefined ? options.hidpi : false;
    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    _this = _super.call(this, {
      cacheSize: options.cacheSize,
      crossOrigin: 'anonymous',
      interpolate: interpolate,
      opaque: true,
      projection: (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:3857'),
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: _State_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: hidpi ? 2 : 1,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    }) || this;
    /**
     * @private
     * @type {boolean}
     */

    _this.hidpi_ = hidpi;
    /**
     * @private
     * @type {string}
     */

    _this.culture_ = options.culture !== undefined ? options.culture : 'en-us';
    /**
     * @private
     * @type {number}
     */

    _this.maxZoom_ = options.maxZoom !== undefined ? options.maxZoom : -1;
    /**
     * @private
     * @type {string}
     */

    _this.apiKey_ = options.key;
    /**
     * @private
     * @type {string}
     */

    _this.imagerySet_ = options.imagerySet;
    var url = 'https://dev.virtualearth.net/REST/v1/Imagery/Metadata/' + _this.imagerySet_ + '?uriScheme=https&include=ImageryProviders&key=' + _this.apiKey_ + '&c=' + _this.culture_;
    (0,_net_js__WEBPACK_IMPORTED_MODULE_2__.jsonp)(url, _this.handleImageryMetadataResponse.bind(_this), undefined, 'jsonp');
    return _this;
  }
  /**
   * Get the api key used for this source.
   *
   * @return {string} The api key.
   * @api
   */


  BingMaps.prototype.getApiKey = function () {
    return this.apiKey_;
  };
  /**
   * Get the imagery set associated with this source.
   *
   * @return {string} The imagery set.
   * @api
   */


  BingMaps.prototype.getImagerySet = function () {
    return this.imagerySet_;
  };
  /**
   * @param {BingMapsImageryMetadataResponse} response Response.
   */


  BingMaps.prototype.handleImageryMetadataResponse = function (response) {
    if (response.statusCode != 200 || response.statusDescription != 'OK' || response.authenticationResultCode != 'ValidCredentials' || response.resourceSets.length != 1 || response.resourceSets[0].resources.length != 1) {
      this.setState(_State_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR);
      return;
    }

    var resource = response.resourceSets[0].resources[0];
    var maxZoom = this.maxZoom_ == -1 ? resource.zoomMax : this.maxZoom_;
    var sourceProjection = this.getProjection();
    var extent = (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_3__.extentFromProjection)(sourceProjection);
    var scale = this.hidpi_ ? 2 : 1;
    var tileSize = resource.imageWidth == resource.imageHeight ? resource.imageWidth / scale : [resource.imageWidth / scale, resource.imageHeight / scale];
    var tileGrid = (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_3__.createXYZ)({
      extent: extent,
      minZoom: resource.zoomMin,
      maxZoom: maxZoom,
      tileSize: tileSize
    });
    this.tileGrid = tileGrid;
    var culture = this.culture_;
    var hidpi = this.hidpi_;
    this.tileUrlFunction = (0,_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_4__.createFromTileUrlFunctions)(resource.imageUrlSubdomains.map(function (subdomain) {
      /** @type {import('../tilecoord.js').TileCoord} */
      var quadKeyTileCoord = [0, 0, 0];
      var imageUrl = resource.imageUrl.replace('{subdomain}', subdomain).replace('{culture}', culture);
      return (
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        function (tileCoord, pixelRatio, projection) {
          if (!tileCoord) {
            return undefined;
          } else {
            (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_5__.createOrUpdate)(tileCoord[0], tileCoord[1], tileCoord[2], quadKeyTileCoord);
            var url = imageUrl;

            if (hidpi) {
              url += '&dpi=d1&device=mobile';
            }

            return url.replace('{quadkey}', quadKey(quadKeyTileCoord));
          }
        }
      );
    }));

    if (resource.imageryProviders) {
      var transform_1 = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransformFromProjections)((0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:4326'), this.getProjection());
      this.setAttributions(function (frameState) {
        var attributions = [];
        var viewState = frameState.viewState;
        var tileGrid = this.getTileGrid();
        var z = tileGrid.getZForResolution(viewState.resolution, this.zDirection);
        var tileCoord = tileGrid.getTileCoordForCoordAndZ(viewState.center, z);
        var zoom = tileCoord[0];
        resource.imageryProviders.map(function (imageryProvider) {
          var intersecting = false;
          var coverageAreas = imageryProvider.coverageAreas;

          for (var i = 0, ii = coverageAreas.length; i < ii; ++i) {
            var coverageArea = coverageAreas[i];

            if (zoom >= coverageArea.zoomMin && zoom <= coverageArea.zoomMax) {
              var bbox = coverageArea.bbox;
              var epsg4326Extent = [bbox[1], bbox[0], bbox[3], bbox[2]];
              var extent_1 = (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.applyTransform)(epsg4326Extent, transform_1);

              if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.intersects)(extent_1, frameState.extent)) {
                intersecting = true;
                break;
              }
            }
          }

          if (intersecting) {
            attributions.push(imageryProvider.attribution);
          }
        });
        attributions.push(TOS_ATTRIBUTION);
        return attributions;
      }.bind(this));
    }

    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_1__["default"].READY);
  };

  return BingMaps;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_7__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (BingMaps);

/***/ }),

/***/ "./build/wg/source/CartoDB.js":
/*!************************************!*\
  !*** ./build/wg/source/CartoDB.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./State.js */ "./build/wg/source/State.js");
/* harmony import */ var _XYZ_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./XYZ.js */ "./build/wg/source/XYZ.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/**
 * @module wg/source/CartoDB
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();




/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [maxZoom=18] Max zoom.
 * @property {number} [minZoom] Minimum zoom.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {Object} [config] If using anonymous maps, the CartoDB config to use. See
 * https://carto.com/developers/maps-api/guides/anonymous-maps/
 * for more detail.
 * If using named maps, a key-value lookup with the template parameters.
 * See https://carto.com/developers/maps-api/guides/named-maps/
 * for more detail.
 * @property {string} [map] If using named maps, this will be the name of the template to load.
 * See https://carto.com/developers/maps-api/guides/named-maps/
 * for more detail.
 * @property {string} [account] Username as used to access public Carto dashboard at https://{username}.carto.com/.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @typedef {Object} CartoDBLayerInfo
 * @property {string} layergroupid The layer group ID
 * @property {{https: string}} cdn_url The CDN URL
 */

/**
 * @classdesc
 * Layer source for the CartoDB Maps API.
 * @api
 */

var CartoDB =
/** @class */
function (_super) {
  __extends(CartoDB, _super);
  /**
   * @param {Options} options CartoDB options.
   */


  function CartoDB(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 18,
      minZoom: options.minZoom,
      projection: options.projection,
      transition: options.transition,
      wrapX: options.wrapX,
      zDirection: options.zDirection
    }) || this;
    /**
     * @type {string}
     * @private
     */


    _this.account_ = options.account;
    /**
     * @type {string}
     * @private
     */

    _this.mapId_ = options.map || '';
    /**
     * @type {!Object}
     * @private
     */

    _this.config_ = options.config || {};
    /**
     * @type {!Object<string, CartoDBLayerInfo>}
     * @private
     */

    _this.templateCache_ = {};

    _this.initializeMap_();

    return _this;
  }
  /**
   * Returns the current config.
   * @return {!Object} The current configuration.
   * @api
   */


  CartoDB.prototype.getConfig = function () {
    return this.config_;
  };
  /**
   * Updates the carto db config.
   * @param {Object} config a key-value lookup. Values will replace current values
   *     in the config.
   * @api
   */


  CartoDB.prototype.updateConfig = function (config) {
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.assign)(this.config_, config);
    this.initializeMap_();
  };
  /**
   * Sets the CartoDB config
   * @param {Object} config In the case of anonymous maps, a CartoDB configuration
   *     object.
   * If using named maps, a key-value lookup with the template parameters.
   * @api
   */


  CartoDB.prototype.setConfig = function (config) {
    this.config_ = config || {};
    this.initializeMap_();
  };
  /**
   * Issue a request to initialize the CartoDB map.
   * @private
   */


  CartoDB.prototype.initializeMap_ = function () {
    var paramHash = JSON.stringify(this.config_);

    if (this.templateCache_[paramHash]) {
      this.applyTemplate_(this.templateCache_[paramHash]);
      return;
    }

    var mapUrl = 'https://' + this.account_ + '.carto.com/api/v1/map';

    if (this.mapId_) {
      mapUrl += '/named/' + this.mapId_;
    }

    var client = new XMLHttpRequest();
    client.addEventListener('load', this.handleInitResponse_.bind(this, paramHash));
    client.addEventListener('error', this.handleInitError_.bind(this));
    client.open('POST', mapUrl);
    client.setRequestHeader('Content-type', 'application/json');
    client.send(JSON.stringify(this.config_));
  };
  /**
   * Handle map initialization response.
   * @param {string} paramHash a hash representing the parameter set that was used
   *     for the request
   * @param {Event} event Event.
   * @private
   */


  CartoDB.prototype.handleInitResponse_ = function (paramHash, event) {
    var client =
    /** @type {XMLHttpRequest} */
    event.target; // status will be 0 for file:// urls

    if (!client.status || client.status >= 200 && client.status < 300) {
      var response = void 0;

      try {
        response =
        /** @type {CartoDBLayerInfo} */
        JSON.parse(client.responseText);
      } catch (err) {
        this.setState(_State_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR);
        return;
      }

      this.applyTemplate_(response);
      this.templateCache_[paramHash] = response;
      this.setState(_State_js__WEBPACK_IMPORTED_MODULE_1__["default"].READY);
    } else {
      this.setState(_State_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR);
    }
  };
  /**
   * @private
   * @param {Event} event Event.
   */


  CartoDB.prototype.handleInitError_ = function (event) {
    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR);
  };
  /**
   * Apply the new tile urls returned by carto db
   * @param {CartoDBLayerInfo} data Result of carto db call.
   * @private
   */


  CartoDB.prototype.applyTemplate_ = function (data) {
    var tilesUrl = 'https://' + data.cdn_url.https + '/' + this.account_ + '/api/v1/map/' + data.layergroupid + '/{z}/{x}/{y}.png';
    this.setUrl(tilesUrl);
  };

  return CartoDB;
}(_XYZ_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CartoDB);

/***/ }),

/***/ "./build/wg/source/Cluster.js":
/*!************************************!*\
  !*** ./build/wg/source/Cluster.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Feature.js */ "./build/wg/Feature.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/Point.js */ "./build/wg/geom/Point.js");
/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Vector.js */ "./build/wg/source/Vector.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../coordinate.js */ "./build/wg/coordinate.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/**
 * @module wg/source/Cluster
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();










/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [distance=20] Distance in pixels within which features will
 * be clustered together.
 * @property {number} [minDistance=0] Minimum distance in pixels between clusters.
 * Will be capped at the configured distance.
 * By default no minimum distance is guaranteed. This config can be used to avoid
 * overlapping icons. As a tradoff, the cluster feature's position will no longer be
 * the center of all its features.
 * @property {function(Feature):Point} [geometryFunction]
 * Function that takes an {@link module:wg/Feature~Feature} as argument and returns an
 * {@link module:wg/geom/Point~Point} as cluster calculation point for the feature. When a
 * feature should not be considered for clustering, the function should return
 * `null`. The default, which works when the underlying source contains point
 * features only, is
 * ```js
 * function(feature) {
 *   return feature.getGeometry();
 * }
 * ```
 * See {@link module:wg/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster
 * calculation point for polygons.
 * @property {function(Point, Array<Feature>):Feature} [createCluster]
 * Function that takes the cluster's center {@link module:wg/geom/Point~Point} and an array
 * of {@link module:wg/Feature~Feature} included in this cluster. Must return a
 * {@link module:wg/Feature~Feature} that will be used to render. Default implementation is:
 * ```js
 * function(point, features) {
 *   return new Feature({
 *     geometry: point,
 *     features: features
 *   });
 * }
 * ```
 * @property {VectorSource} [source=null] Source.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */

/**
 * @classdesc
 * Layer source to cluster vector data. Works out of the box with point
 * geometries. For other geometry types, or if not all geometries should be
 * considered for clustering, a custom `geometryFunction` can be defined.
 *
 * If the instance is disposed without also disposing the underlying
 * source `setSource(null)` has to be called to remove the listener reference
 * from the wrapped source.
 * @api
 */

var Cluster =
/** @class */
function (_super) {
  __extends(Cluster, _super);
  /**
   * @param {Options} options Cluster options.
   */


  function Cluster(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      wrapX: options.wrapX
    }) || this;
    /**
     * @type {number|undefined}
     * @protected
     */


    _this.resolution = undefined;
    /**
     * @type {number}
     * @protected
     */

    _this.distance = options.distance !== undefined ? options.distance : 20;
    /**
     * @type {number}
     * @protected
     */

    _this.minDistance = options.minDistance || 0;
    /**
     * @type {number}
     * @protected
     */

    _this.interpolationRatio = 0;
    /**
     * @type {Array<Feature>}
     * @protected
     */

    _this.features = [];
    /**
     * @param {Feature} feature Feature.
     * @return {Point} Cluster calculation point.
     * @protected
     */

    _this.geometryFunction = options.geometryFunction || function (feature) {
      var geometry =
      /** @type {Point} */
      feature.getGeometry();
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(geometry.getType() == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT, 10); // The default `geometryFunction` can only handle `Point` geometries

      return geometry;
    };
    /**
     * @type {function(Point, Array<Feature>):Feature}
     * @private
     */


    _this.createCustomCluster_ = options.createCluster;
    /**
     * @type {VectorSource|null}
     * @protected
     */

    _this.source = null;
    /**
     * @private
     */

    _this.boundRefresh_ = _this.refresh.bind(_this);

    _this.updateDistance(_this.distance, _this.minDistance);

    _this.setSource(options.source || null);

    return _this;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [opt_fast] Skip dispatching of {@link module:wg/source/VectorEventType~VectorEventType#removefeature} events.
   * @api
   */


  Cluster.prototype.clear = function (opt_fast) {
    this.features.length = 0;

    _super.prototype.clear.call(this, opt_fast);
  };
  /**
   * Get the distance in pixels between clusters.
   * @return {number} Distance.
   * @api
   */


  Cluster.prototype.getDistance = function () {
    return this.distance;
  };
  /**
   * Get a reference to the wrapped source.
   * @return {VectorSource|null} Source.
   * @api
   */


  Cluster.prototype.getSource = function () {
    return this.source;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */


  Cluster.prototype.loadFeatures = function (extent, resolution, projection) {
    this.source.loadFeatures(extent, resolution, projection);

    if (resolution !== this.resolution) {
      this.resolution = resolution;
      this.refresh();
    }
  };
  /**
   * Set the distance within which features will be clusterd together.
   * @param {number} distance The distance in pixels.
   * @api
   */


  Cluster.prototype.setDistance = function (distance) {
    this.updateDistance(distance, this.minDistance);
  };
  /**
   * Set the minimum distance between clusters. Will be capped at the
   * configured distance.
   * @param {number} minDistance The minimum distance in pixels.
   * @api
   */


  Cluster.prototype.setMinDistance = function (minDistance) {
    this.updateDistance(this.distance, minDistance);
  };
  /**
   * The configured minimum distance between clusters.
   * @return {number} The minimum distance in pixels.
   * @api
   */


  Cluster.prototype.getMinDistance = function () {
    return this.minDistance;
  };
  /**
   * Replace the wrapped source.
   * @param {VectorSource|null} source The new source for this instance.
   * @api
   */


  Cluster.prototype.setSource = function (source) {
    if (this.source) {
      this.source.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.boundRefresh_);
    }

    this.source = source;

    if (source) {
      source.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.boundRefresh_);
    }

    this.refresh();
  };
  /**
   * Handle the source changing.
   */


  Cluster.prototype.refresh = function () {
    this.clear();
    this.cluster();
    this.addFeatures(this.features);
  };
  /**
   * Update the distances and refresh the source if necessary.
   * @param {number} distance The new distance.
   * @param {number} minDistance The new minimum distance.
   */


  Cluster.prototype.updateDistance = function (distance, minDistance) {
    var ratio = distance === 0 ? 0 : Math.min(minDistance, distance) / distance;
    var changed = distance !== this.distance || this.interpolationRatio !== ratio;
    this.distance = distance;
    this.minDistance = minDistance;
    this.interpolationRatio = ratio;

    if (changed) {
      this.refresh();
    }
  };
  /**
   * @protected
   */


  Cluster.prototype.cluster = function () {
    if (this.resolution === undefined || !this.source) {
      return;
    }

    var extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.createEmpty)();
    var mapDistance = this.distance * this.resolution;
    var features = this.source.getFeatures();
    /** @type {Object<string, true>} */

    var clustered = {};

    for (var i = 0, ii = features.length; i < ii; i++) {
      var feature = features[i];

      if (!((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.getUid)(feature) in clustered)) {
        var geometry = this.geometryFunction(feature);

        if (geometry) {
          var coordinates = geometry.getCoordinates();
          (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.createOrUpdateFromCoordinate)(coordinates, extent);
          (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.buffer)(extent, mapDistance, extent);
          var neighbors = this.source.getFeaturesInExtent(extent).filter(function (neighbor) {
            var uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.getUid)(neighbor);

            if (uid in clustered) {
              return false;
            }

            clustered[uid] = true;
            return true;
          });
          this.features.push(this.createCluster(neighbors, extent));
        }
      }
    }
  };
  /**
   * @param {Array<Feature>} features Features
   * @param {import("../extent.js").Extent} extent The searched extent for these features.
   * @return {Feature} The cluster feature.
   * @protected
   */


  Cluster.prototype.createCluster = function (features, extent) {
    var centroid = [0, 0];

    for (var i = features.length - 1; i >= 0; --i) {
      var geometry_1 = this.geometryFunction(features[i]);

      if (geometry_1) {
        (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_5__.add)(centroid, geometry_1.getCoordinates());
      } else {
        features.splice(i, 1);
      }
    }

    (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_5__.scale)(centroid, 1 / features.length);
    var searchCenter = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getCenter)(extent);
    var ratio = this.interpolationRatio;
    var geometry = new _geom_Point_js__WEBPACK_IMPORTED_MODULE_6__["default"]([centroid[0] * (1 - ratio) + searchCenter[0] * ratio, centroid[1] * (1 - ratio) + searchCenter[1] * ratio]);

    if (this.createCustomCluster_) {
      return this.createCustomCluster_(geometry, features);
    } else {
      return new _Feature_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
        geometry: geometry,
        features: features
      });
    }
  };

  return Cluster;
}(_Vector_js__WEBPACK_IMPORTED_MODULE_8__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Cluster);

/***/ }),

/***/ "./build/wg/source/DataTile.js":
/*!*************************************!*\
  !*** ./build/wg/source/DataTile.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DataTile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DataTile.js */ "./build/wg/DataTile.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _TileEventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TileEventType.js */ "./build/wg/source/TileEventType.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Tile.js */ "./build/wg/source/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../TileState.js */ "./build/wg/TileState.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tilegrid.js */ "./build/wg/tilegrid.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tilecoord.js */ "./build/wg/tilecoord.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/source/DataTile
 */












/**
 * Data tile loading function.  The function is called with z, x, and y tile coordinates and
 * returns {@link import("../DataTile.js").Data data} for a tile or a promise for the same.
 * @typedef {function(number, number, number) : (import("../DataTile.js").Data|Promise<import("../DataTile.js").Data>)} Loader
 */

/**
 * @typedef {Object} Options
 * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.
 * Returns {@link import("../DataTile.js").Data data} for a tile or a promise for the same.
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The pixel width and height of the tiles.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Tile projection.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("./State.js").default} [state] The source state.
 * @property {number} [tilePixelRatio] Tile pixel ratio.
 * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.
 * @property {number} [transition] Transition time when fading in new tiles (in miliseconds).
 * @property {number} [bandCount=4] Number of bands represented in the data.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @classdesc
 * A source for typed array data tiles.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */

var DataTileSource =
/** @class */
function (_super) {
  __extends(DataTileSource, _super);
  /**
   * @param {Options} options Image tile options.
   */


  function DataTileSource(options) {
    var _this = this;

    var projection = options.projection === undefined ? 'EPSG:3857' : options.projection;
    var tileGrid = options.tileGrid;

    if (tileGrid === undefined && projection) {
      tileGrid = (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_0__.createXYZ)({
        extent: (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_0__.extentFromProjection)(projection),
        maxResolution: options.maxResolution,
        maxZoom: options.maxZoom,
        minZoom: options.minZoom,
        tileSize: options.tileSize
      });
    }

    _this = _super.call(this, {
      cacheSize: 0.1,
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: projection,
      tileGrid: tileGrid,
      opaque: options.opaque,
      state: options.state,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate
    }) || this;
    /**
     * @private
     * @type {!Object<string, boolean>}
     */

    _this.tileLoadingKeys_ = {};
    /**
     * @private
     */

    _this.loader_ = options.loader;
    _this.handleTileChange_ = _this.handleTileChange_.bind(_this);
    /**
     * @type {number}
     */

    _this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined

    return _this;
  }
  /**
   * @param {Loader} loader The data loader.
   * @protected
   */


  DataTileSource.prototype.setLoader = function (loader) {
    this.loader_ = loader;
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!DataTile} Tile.
   */


  DataTileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {
    var tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__.getKeyZXY)(z, x, y);

    if (this.tileCache.containsKey(tileCoordKey)) {
      return this.tileCache.get(tileCoordKey);
    }

    var sourceLoader = this.loader_;

    function loader() {
      return (0,_functions_js__WEBPACK_IMPORTED_MODULE_2__.toPromise)(function () {
        return sourceLoader(z, x, y);
      });
    }

    var tile = new _DataTile_js__WEBPACK_IMPORTED_MODULE_3__["default"]((0,_obj_js__WEBPACK_IMPORTED_MODULE_4__.assign)({
      tileCoord: [z, x, y],
      loader: loader
    }, this.tileOptions));
    tile.key = this.getKey();
    tile.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CHANGE, this.handleTileChange_);
    this.tileCache.set(tileCoordKey, tile);
    return tile;
  };
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   */


  DataTileSource.prototype.handleTileChange_ = function (event) {
    var tile =
    /** @type {import("../Tile.js").default} */
    event.target;
    var uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_6__.getUid)(tile);
    var tileState = tile.getState();
    var type;

    if (tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_7__["default"].LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = _TileEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_7__["default"].ERROR ? _TileEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].TILELOADERROR : tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_7__["default"].LOADED ? _TileEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].TILELOADEND : undefined;
    }

    if (type) {
      this.dispatchEvent(new _Tile_js__WEBPACK_IMPORTED_MODULE_9__.TileSourceEvent(type, tile));
    }
  };

  return DataTileSource;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_9__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (DataTileSource);

/***/ }),

/***/ "./build/wg/source/GeoTIFF.js":
/*!************************************!*\
  !*** ./build/wg/source/GeoTIFF.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DataTile_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./DataTile.js */ "./build/wg/source/DataTile.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./State.js */ "./build/wg/source/State.js");
/* harmony import */ var _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tilegrid/TileGrid.js */ "./build/wg/tilegrid/TileGrid.js");
/* harmony import */ var geotiff__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! geotiff */ "./node_modules/geotiff/dist-module/pool.js");
/* harmony import */ var geotiff__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! geotiff */ "./node_modules/geotiff/dist-module/geotiff.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../size.js */ "./build/wg/size.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj/Units.js */ "./build/wg/proj/Units.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/source/GeoTIFF
 */











/**
 * @typedef {Object} SourceInfo
 * @property {string} url URL for the source GeoTIFF.
 * @property {Array<string>} [overviews] List of any overview URLs.
 * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on
 * the configured min and max.  If not provided and raster statistics are available, those will be used instead.
 * If neither are available, the minimum for the data type will be used.  To disable this behavior, set
 * the `normalize` option to `false` in the constructor.
 * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on
 * the configured min and max.  If not provided and raster statistics are available, those will be used instead.
 * If neither are available, the maximum for the data type will be used.  To disable this behavior, set
 * the `normalize` option to `false` in the constructor.
 * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).
 * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata
 * will include information about nodata values, so you should only need to set this property if
 * you find that it is not already extracted from the metadata.
 * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will
 * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the
 * near-infrared band, configure `bands: [4]`.
 */

/**
 * @typedef {Object} GeoKeys
 * @property {number} GTModelTypeGeoKey Model type.
 * @property {number} GTRasterTypeGeoKey Raster type.
 * @property {number} GeogAngularUnitsGeoKey Angular units.
 * @property {number} GeogInvFlatteningGeoKey Inverse flattening.
 * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.
 * @property {number} GeographicTypeGeoKey Geographic coordinate system code.
 * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.
 * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.
 */

/**
 * @typedef {import("geotiff").GeoTIFF} GeoTIFF
 */

/**
 * @typedef {import("geotiff").MultiGeoTIFF} MultiGeoTIFF
 */

/**
 * @typedef {Object} GDALMetadata
 * @property {string} STATISTICS_MINIMUM The minimum value (as a string).
 * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).
 */

var STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';
var STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';
/**
 * @typedef {import("geotiff").GeoTIFFImage} GeoTIFFImage
 */

var workerPool;

function getWorkerPool() {
  if (!workerPool) {
    workerPool = new geotiff__WEBPACK_IMPORTED_MODULE_1__["default"]();
  }

  return workerPool;
}
/**
 * Get the bounding box of an image.  If the image does not have an affine transform,
 * the pixel bounds are returned.
 * @param {GeoTIFFImage} image The image.
 * @return {Array<number>} The image bounding box.
 */


function getBoundingBox(image) {
  try {
    return image.getBoundingBox();
  } catch (_) {
    var fileDirectory = image.fileDirectory;
    return [0, 0, fileDirectory.ImageWidth, fileDirectory.ImageLength];
  }
}
/**
 * Get the origin of an image.  If the image does not have an affine transform,
 * the top-left corner of the pixel bounds is returned.
 * @param {GeoTIFFImage} image The image.
 * @return {Array<number>} The image origin.
 */


function getOrigin(image) {
  try {
    return image.getOrigin().slice(0, 2);
  } catch (_) {
    return [0, image.fileDirectory.ImageLength];
  }
}
/**
 * Get the resolution of an image.  If the image does not have an affine transform,
 * the width of the image is compared with the reference image.
 * @param {GeoTIFFImage} image The image.
 * @param {GeoTIFFImage} referenceImage The reference image.
 * @return {number} The image resolution.
 */


function getResolution(image, referenceImage) {
  try {
    return image.getResolution(referenceImage)[0];
  } catch (_) {
    return referenceImage.fileDirectory.ImageWidth / image.fileDirectory.ImageWidth;
  }
}
/**
 * @param {GeoTIFFImage} image A GeoTIFF.
 * @return {import("../proj/Projection.js").default} The image projection.
 */


function getProjection(image) {
  var geoKeys = image.geoKeys;

  if (!geoKeys) {
    return null;
  }

  if (geoKeys.ProjectedCSTypeGeoKey) {
    var code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;
    var projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(code);

    if (!projection) {
      var units = (0,_proj_Units_js__WEBPACK_IMPORTED_MODULE_2__.fromCode)(geoKeys.ProjLinearUnitsGeoKey);

      if (units) {
        projection = new _proj_js__WEBPACK_IMPORTED_MODULE_0__.Projection({
          code: code,
          units: units
        });
      }
    }

    return projection;
  }

  if (geoKeys.GeographicTypeGeoKey) {
    var code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;
    var projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(code);

    if (!projection) {
      var units = (0,_proj_Units_js__WEBPACK_IMPORTED_MODULE_2__.fromCode)(geoKeys.GeogAngularUnitsGeoKey);

      if (units) {
        projection = new _proj_js__WEBPACK_IMPORTED_MODULE_0__.Projection({
          code: code,
          units: units
        });
      }
    }

    return projection;
  }

  return null;
}
/**
 * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.
 * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.
 */


function getImagesForTIFF(tiff) {
  return tiff.getImageCount().then(function (count) {
    var requests = new Array(count);

    for (var i = 0; i < count; ++i) {
      requests[i] = tiff.getImage(i);
    }

    return Promise.all(requests);
  });
}
/**
 * @param {SourceInfo} source The GeoTIFF source.
 * @param {object} options Options for the GeoTIFF source.
 * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.
 */


function getImagesForSource(source, options) {
  var request;

  if (source.overviews) {
    request = (0,geotiff__WEBPACK_IMPORTED_MODULE_3__.fromUrls)(source.url, source.overviews, options);
  } else {
    request = (0,geotiff__WEBPACK_IMPORTED_MODULE_3__.fromUrl)(source.url, options);
  }

  return request.then(getImagesForTIFF);
}
/**
 * @param {number|Array<number>|Array<Array<number>>} expected Expected value.
 * @param {number|Array<number>|Array<Array<number>>} got Actual value.
 * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.
 * @param {string} message The error message.
 * @param {function(Error):void} rejector A function to be called with any error.
 */


function assertEqual(expected, got, tolerance, message, rejector) {
  if (Array.isArray(expected)) {
    var length_1 = expected.length;

    if (!Array.isArray(got) || length_1 != got.length) {
      var error = new Error(message);
      rejector(error);
      throw error;
    }

    for (var i = 0; i < length_1; ++i) {
      assertEqual(expected[i], got[i], tolerance, message, rejector);
    }

    return;
  }

  got =
  /** @type {number} */
  got;

  if (Math.abs(expected - got) > tolerance * expected) {
    throw new Error(message);
  }
}
/**
 * @param {Array} array The data array.
 * @return {number} The minimum value.
 */


function getMinForDataType(array) {
  if (array instanceof Int8Array) {
    return -128;
  }

  if (array instanceof Int16Array) {
    return -32768;
  }

  if (array instanceof Int32Array) {
    return -2147483648;
  }

  if (array instanceof Float32Array) {
    return 1.2e-38;
  }

  return 0;
}
/**
 * @param {Array} array The data array.
 * @return {number} The maximum value.
 */


function getMaxForDataType(array) {
  if (array instanceof Int8Array) {
    return 127;
  }

  if (array instanceof Uint8Array) {
    return 255;
  }

  if (array instanceof Uint8ClampedArray) {
    return 255;
  }

  if (array instanceof Int16Array) {
    return 32767;
  }

  if (array instanceof Uint16Array) {
    return 65535;
  }

  if (array instanceof Int32Array) {
    return 2147483647;
  }

  if (array instanceof Uint32Array) {
    return 4294967295;
  }

  if (array instanceof Float32Array) {
    return 3.4e38;
  }

  return 255;
}
/**
 * @typedef {Object} GeoTIFFSourceOptions
 * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.
 * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.
 * @property {string} [credentials] How credentials shall be handled. See
 * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values
 * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.
 * By default only a single range is used.
 * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is
 * requested. Only use this when you know the source image to be small enough to fit in memory.
 * @property {number} [blockSize=65536] The block size to use.
 * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.
 */

/**
 * @typedef {Object} Options
 * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.
 * Multiple sources can be combined when their resolution sets are equal after applying a scale.
 * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and
 * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,
 * use the {@link import("./GeoTIFF.js").SourceInfo bands} property. If, for example, you specify two
 * sources, one with 3 bands and {@link import("./GeoTIFF.js").SourceInfo nodata} configured, and
 * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha
 * band from the first source, and 1 band from the second source.
 * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.
 * @property {boolean} [convertToRGB = false] By default, bands from the sources are read as-is. When
 * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will
 * convert other color spaces (YCbCr, CMYK) to RGB.
 * @property {boolean} [normalize=true] By default, the source data is normalized to values between
 * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.
 * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option
 * to `false` will make it so any `min` and `max` properties on sources are ignored.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.
 */

/**
 * @classdesc
 * A source for working with GeoTIFF data.
 * @api
 */


var GeoTIFFSource =
/** @class */
function (_super) {
  __extends(GeoTIFFSource, _super);
  /**
   * @param {Options} options Data tile options.
   */


  function GeoTIFFSource(options) {
    var _this = _super.call(this, {
      state: _State_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADING,
      tileGrid: null,
      projection: null,
      opaque: options.opaque,
      transition: options.transition,
      interpolate: options.interpolate !== false,
      wrapX: options.wrapX
    }) || this;
    /**
     * @type {Array<SourceInfo>}
     * @private
     */


    _this.sourceInfo_ = options.sources;
    var numSources = _this.sourceInfo_.length;
    /**
     * @type {object}
     * @private
     */

    _this.sourceOptions_ = options.sourceOptions;
    /**
     * @type {Array<Array<GeoTIFFImage>>}
     * @private
     */

    _this.sourceImagery_ = new Array(numSources);
    /**
     * @type {Array<number>}
     * @private
     */

    _this.resolutionFactors_ = new Array(numSources);
    /**
     * @type {Array<number>}
     * @private
     */

    _this.samplesPerPixel_;
    /**
     * @type {Array<Array<number>>}
     * @private
     */

    _this.nodataValues_;
    /**
     * @type {Array<Array<GDALMetadata>>}
     * @private
     */

    _this.metadata_;
    /**
     * @type {boolean}
     * @private
     */

    _this.normalize_ = options.normalize !== false;
    /**
     * @type {boolean}
     * @private
     */

    _this.addAlpha_ = false;
    /**
     * @type {Error}
     * @private
     */

    _this.error_ = null;
    /**
     * @type {'readRasters' | 'readRGB'}
     */

    _this.readMethod_ = options.convertToRGB ? 'readRGB' : 'readRasters';

    _this.setKey(_this.sourceInfo_.map(function (source) {
      return source.url;
    }).join(','));

    var self = _this;
    var requests = new Array(numSources);

    for (var i = 0; i < numSources; ++i) {
      requests[i] = getImagesForSource(_this.sourceInfo_[i], _this.sourceOptions_);
    }

    Promise.all(requests).then(function (sources) {
      self.configure_(sources);
    }).catch(function (error) {
      console.error(error); // eslint-disable-line no-console

      self.error_ = error;
      self.setState(_State_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR);
    });
    return _this;
  }
  /**
   * @return {Error} A source loading error. When the source state is `error`, use this function
   * to get more information about the error. To debug a faulty configuration, you may want to use
   * a listener like
   * ```js
   * geotiffSource.on('change', () => {
   *   if (geotiffSource.getState() === 'error') {
   *     console.error(geotiffSource.getError());
   *   }
   * });
   * ```
   */


  GeoTIFFSource.prototype.getError = function () {
    return this.error_;
  };
  /**
   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF
   * must have the same internal tiled structure.
   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images
   * from a single GeoTIFF.
   * @private
   */


  GeoTIFFSource.prototype.configure_ = function (sources) {
    var extent;
    var origin;
    var tileSizes;
    var resolutions;
    var samplesPerPixel = new Array(sources.length);
    var nodataValues = new Array(sources.length);
    var metadata = new Array(sources.length);
    var minZoom = 0;
    var sourceCount = sources.length;

    var _loop_1 = function _loop_1(sourceIndex) {
      var images = sources[sourceIndex];
      var imageCount = images.length;
      var sourceExtent = void 0;
      var sourceOrigin = void 0;
      var sourceTileSizes = new Array(imageCount);
      var sourceResolutions = new Array(imageCount);
      nodataValues[sourceIndex] = new Array(imageCount);
      metadata[sourceIndex] = new Array(imageCount);

      for (var imageIndex = 0; imageIndex < imageCount; ++imageIndex) {
        var image = images[imageIndex];
        var nodataValue = image.getGDALNoData();
        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);
        nodataValues[sourceIndex][imageIndex] = nodataValue === null ? NaN : nodataValue;
        var wantedSamples = this_1.sourceInfo_[sourceIndex].bands;
        samplesPerPixel[sourceIndex] = wantedSamples ? wantedSamples.length : image.getSamplesPerPixel();
        var level = imageCount - (imageIndex + 1);

        if (!sourceExtent) {
          sourceExtent = getBoundingBox(image);
        }

        if (!sourceOrigin) {
          sourceOrigin = getOrigin(image);
        }

        sourceResolutions[level] = getResolution(image, images[0]);
        sourceTileSizes[level] = [image.getTileWidth(), image.getTileHeight()];
      }

      if (!extent) {
        extent = sourceExtent;
      } else {
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getIntersection)(extent, sourceExtent, extent);
      }

      if (!origin) {
        origin = sourceOrigin;
      } else {
        var message = "Origin mismatch for source ".concat(sourceIndex, ", got [").concat(sourceOrigin, "] but expected [").concat(origin, "]");
        assertEqual(origin, sourceOrigin, 0, message, this_1.viewRejector);
      }

      if (!resolutions) {
        resolutions = sourceResolutions;
        this_1.resolutionFactors_[sourceIndex] = 1;
      } else {
        if (resolutions.length - minZoom > sourceResolutions.length) {
          minZoom = resolutions.length - sourceResolutions.length;
        }

        var resolutionFactor_1 = resolutions[resolutions.length - 1] / sourceResolutions[sourceResolutions.length - 1];
        this_1.resolutionFactors_[sourceIndex] = resolutionFactor_1;
        var scaledSourceResolutions = sourceResolutions.map(function (resolution) {
          return resolution *= resolutionFactor_1;
        });
        var message = "Resolution mismatch for source ".concat(sourceIndex, ", got [").concat(scaledSourceResolutions, "] but expected [").concat(resolutions, "]");
        assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 0.02, message, this_1.viewRejector);
      }

      if (!tileSizes) {
        tileSizes = sourceTileSizes;
      } else {
        assertEqual(tileSizes.slice(minZoom, tileSizes.length), sourceTileSizes, 0, "Tile size mismatch for source ".concat(sourceIndex), this_1.viewRejector);
      }

      this_1.sourceImagery_[sourceIndex] = images.reverse();
    };

    var this_1 = this;

    for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
      _loop_1(sourceIndex);
    }

    for (var i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {
      var sourceImagery = this.sourceImagery_[i];

      while (sourceImagery.length < resolutions.length) {
        sourceImagery.unshift(undefined);
      }
    }

    if (!this.getProjection()) {
      var firstSource = sources[0];

      for (var i = firstSource.length - 1; i >= 0; --i) {
        var image = firstSource[i];
        var projection = getProjection(image);

        if (projection) {
          this.projection = projection;
          break;
        }
      }
    }

    this.samplesPerPixel_ = samplesPerPixel;
    this.nodataValues_ = nodataValues;
    this.metadata_ = metadata; // decide if we need to add an alpha band to handle nodata

    outer: for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
      // option 1: source is configured with a nodata value
      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {
        this.addAlpha_ = true;
        break;
      }

      var values = nodataValues[sourceIndex]; // option 2: check image metadata for limited bands

      var bands = this.sourceInfo_[sourceIndex].bands;

      if (bands) {
        for (var i = 0; i < bands.length; ++i) {
          if (!isNaN(values[bands[i] - 1])) {
            this.addAlpha_ = true;
            break outer;
          }
        }

        continue;
      } // option 3: check image metadata for all bands


      for (var imageIndex = 0; imageIndex < values.length; ++imageIndex) {
        if (!isNaN(values[imageIndex])) {
          this.addAlpha_ = true;
          break outer;
        }
      }
    }

    var additionalBands = this.addAlpha_ ? 1 : 0;
    this.bandCount = samplesPerPixel.reduce(function (accumulator, value) {
      accumulator += value;
      return accumulator;
    }, 0) + additionalBands;
    var tileGrid = new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
      extent: extent,
      minZoom: minZoom,
      origin: origin,
      resolutions: resolutions,
      tileSizes: tileSizes
    });
    this.tileGrid = tileGrid;
    this.setLoader(this.loadTile_.bind(this));
    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_4__["default"].READY);
    this.viewResolver({
      projection: this.projection,
      resolutions: resolutions,
      center: (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)((0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getCenter)(extent), this.projection),
      extent: (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)(extent, this.projection),
      zoom: 0
    });
  };

  GeoTIFFSource.prototype.loadTile_ = function (z, x, y) {
    var size = (0,_size_js__WEBPACK_IMPORTED_MODULE_7__.toSize)(this.tileGrid.getTileSize(z));
    var sourceCount = this.sourceImagery_.length;
    var requests = new Array(sourceCount);
    var addAlpha = this.addAlpha_;
    var bandCount = this.bandCount;
    var samplesPerPixel = this.samplesPerPixel_;
    var nodataValues = this.nodataValues_;
    var sourceInfo = this.sourceInfo_;

    var _loop_2 = function _loop_2(sourceIndex) {
      var source = sourceInfo[sourceIndex];
      var resolutionFactor = this_2.resolutionFactors_[sourceIndex];
      var pixelBounds = [Math.round(x * (size[0] * resolutionFactor)), Math.round(y * (size[1] * resolutionFactor)), Math.round((x + 1) * (size[0] * resolutionFactor)), Math.round((y + 1) * (size[1] * resolutionFactor))];
      var image = this_2.sourceImagery_[sourceIndex][z];
      var samples = void 0;

      if (source.bands) {
        samples = source.bands.map(function (bandNumber) {
          return bandNumber - 1;
        });
      }
      /** @type {number|Array<number>} */


      var fillValue = void 0;

      if (!isNaN(source.nodata)) {
        fillValue = source.nodata;
      } else {
        if (!samples) {
          fillValue = nodataValues[sourceIndex];
        } else {
          fillValue = samples.map(function (sampleIndex) {
            return nodataValues[sourceIndex][sampleIndex];
          });
        }
      }

      requests[sourceIndex] = image[this_2.readMethod_]({
        window: pixelBounds,
        width: size[0],
        height: size[1],
        samples: samples,
        fillValue: fillValue,
        pool: getWorkerPool(),
        interleave: false
      });
    };

    var this_2 = this;

    for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
      _loop_2(sourceIndex);
    }

    var pixelCount = size[0] * size[1];
    var dataLength = pixelCount * bandCount;
    var normalize = this.normalize_;
    var metadata = this.metadata_;
    return Promise.all(requests).then(function (sourceSamples) {
      /** @type {Uint8Array|Float32Array} */
      var data;

      if (normalize) {
        data = new Uint8Array(dataLength);
      } else {
        data = new Float32Array(dataLength);
      }

      var dataIndex = 0;

      for (var pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {
        var transparent = addAlpha;

        for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
          var source = sourceInfo[sourceIndex];
          var min = source.min;
          var max = source.max;
          var gain = void 0,
              bias = void 0;

          if (normalize) {
            var stats = metadata[sourceIndex][0];

            if (min === undefined) {
              if (stats && STATISTICS_MINIMUM in stats) {
                min = parseFloat(stats[STATISTICS_MINIMUM]);
              } else {
                min = getMinForDataType(sourceSamples[sourceIndex][0]);
              }
            }

            if (max === undefined) {
              if (stats && STATISTICS_MAXIMUM in stats) {
                max = parseFloat(stats[STATISTICS_MAXIMUM]);
              } else {
                max = getMaxForDataType(sourceSamples[sourceIndex][0]);
              }
            }

            gain = 255 / (max - min);
            bias = -min * gain;
          }

          for (var sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex]; ++sampleIndex) {
            var sourceValue = sourceSamples[sourceIndex][sampleIndex][pixelIndex];
            var value = void 0;

            if (normalize) {
              value = (0,_math_js__WEBPACK_IMPORTED_MODULE_8__.clamp)(gain * sourceValue + bias, 0, 255);
            } else {
              value = sourceValue;
            }

            if (!addAlpha) {
              data[dataIndex] = value;
            } else {
              var nodata = source.nodata;

              if (nodata === undefined) {
                var bandIndex = void 0;

                if (source.bands) {
                  bandIndex = source.bands[sampleIndex] - 1;
                } else {
                  bandIndex = sampleIndex;
                }

                nodata = nodataValues[sourceIndex][bandIndex];
              }

              if (sourceValue !== nodata) {
                transparent = false;
                data[dataIndex] = value;
              }
            }

            dataIndex++;
          }
        }

        if (addAlpha) {
          if (!transparent) {
            data[dataIndex] = 255;
          }

          dataIndex++;
        }
      }

      return data;
    });
  };

  return GeoTIFFSource;
}(_DataTile_js__WEBPACK_IMPORTED_MODULE_9__["default"]);
/**
 * Get a promise for view properties based on the source.  Use the result of this function
 * as the `view` option in a map constructor.
 *
 *     const source = new GeoTIFF(options);
 *
 *     const map = new Map({
 *       target: 'map',
 *       layers: [
 *         new TileLayer({
 *           source: source,
 *         }),
 *       ],
 *       view: source.getView(),
 *     });
 *
 * @function
 * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
 * @api
 *
 */


GeoTIFFSource.prototype.getView;
/* harmony default export */ __webpack_exports__["default"] = (GeoTIFFSource);

/***/ }),

/***/ "./build/wg/source/IIIF.js":
/*!*********************************!*\
  !*** ./build/wg/source/IIIF.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tilegrid/TileGrid.js */ "./build/wg/tilegrid/TileGrid.js");
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TileImage.js */ "./build/wg/source/TileImage.js");
/* harmony import */ var _Zoomify_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Zoomify.js */ "./build/wg/source/Zoomify.js");
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tilegrid/common.js */ "./build/wg/tilegrid/common.js");
/* harmony import */ var _format_IIIFInfo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../format/IIIFInfo.js */ "./build/wg/format/IIIFInfo.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../size.js */ "./build/wg/size.js");
/**
 * @module wg/source/IIIF
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();










/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Size of the cache.
 * @property {null|string} [crossOrigin] The value for the crossOrigin option of the request.
 * @property {import("../extent.js").Extent} [extent=[0, -height, width, 0]] The extent.
 * @property {string} [format='jpg'] Requested image format.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {string} [quality] Requested IIIF image quality. Default is 'native'
 * for version 1, 'default' for versions 2 and 3.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {Array<number>} [resolutions] Supported resolutions as given in IIIF 'scaleFactors'
 * @property {import("../size.js").Size} size Size of the image [width, height].
 * @property {Array<import("../size.js").Size>} [sizes] Supported scaled image sizes.
 * Content of the IIIF info.json 'sizes' property, but as array of Size objects.
 * @property {import("./State.js").default} [state] Source state.
 * @property {Array<string>} [supports=[]] Supported IIIF region and size calculation
 * features.
 * @property {number} [tilePixelRatio] Tile pixel ratio.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Same tile size is used for all zoom levels. If tile size is a number,
 * a square tile is assumed. If the IIIF image service supports arbitrary
 * tiling (sizeByH, sizeByW, sizeByWh or sizeByPct as well as regionByPx or regionByPct
 * are supported), the default tilesize is 256.
 * @property {number} [transition] Transition.
 * @property {string} [url] Base URL of the IIIF Image service.
 * This should be the same as the IIIF Image ID.
 * @property {import("../format/IIIFInfo.js").Versions} [version=Versions.VERSION2] Service's IIIF Image API version.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

function formatPercentage(percentage) {
  return percentage.toLocaleString('en', {
    maximumFractionDigits: 10
  });
}
/**
 * @classdesc
 * Layer source for IIIF Image API services.
 * @api
 */


var IIIF =
/** @class */
function (_super) {
  __extends(IIIF, _super);
  /**
   * @param {Options} [opt_options] Tile source options. Use {@link import("../format/IIIFInfo.js").IIIFInfo}
   * to parse Image API service information responses into constructor options.
   * @api
   */


  function IIIF(opt_options) {
    var _this = this;
    /**
     * @type {Partial<Options>}
     */


    var options = opt_options || {};
    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    var baseUrl = options.url || '';
    baseUrl = baseUrl + (baseUrl.lastIndexOf('/') === baseUrl.length - 1 || baseUrl === '' ? '' : '/');
    var version = options.version || _format_IIIFInfo_js__WEBPACK_IMPORTED_MODULE_0__.Versions.VERSION2;
    var sizes = options.sizes || [];
    var size = options.size;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(size != undefined && Array.isArray(size) && size.length == 2 && !isNaN(size[0]) && size[0] > 0 && !isNaN(size[1]) && size[1] > 0, 60);
    var width = size[0];
    var height = size[1];
    var tileSize = options.tileSize;
    var tilePixelRatio = options.tilePixelRatio || 1;
    var format = options.format || 'jpg';
    var quality = options.quality || (options.version == _format_IIIFInfo_js__WEBPACK_IMPORTED_MODULE_0__.Versions.VERSION1 ? 'native' : 'default');
    var resolutions = options.resolutions || [];
    var supports = options.supports || [];
    var extent = options.extent || [0, -height, width, 0];
    var supportsListedSizes = sizes != undefined && Array.isArray(sizes) && sizes.length > 0;
    var supportsListedTiles = tileSize !== undefined && (typeof tileSize === 'number' && Number.isInteger(tileSize) && tileSize > 0 || Array.isArray(tileSize) && tileSize.length > 0);
    var supportsArbitraryTiling = supports != undefined && Array.isArray(supports) && ((0,_array_js__WEBPACK_IMPORTED_MODULE_2__.includes)(supports, 'regionByPx') || (0,_array_js__WEBPACK_IMPORTED_MODULE_2__.includes)(supports, 'regionByPct')) && ((0,_array_js__WEBPACK_IMPORTED_MODULE_2__.includes)(supports, 'sizeByWh') || (0,_array_js__WEBPACK_IMPORTED_MODULE_2__.includes)(supports, 'sizeByH') || (0,_array_js__WEBPACK_IMPORTED_MODULE_2__.includes)(supports, 'sizeByW') || (0,_array_js__WEBPACK_IMPORTED_MODULE_2__.includes)(supports, 'sizeByPct'));
    var tileWidth, tileHeight, maxZoom;
    resolutions.sort(function (a, b) {
      return b - a;
    });

    if (supportsListedTiles || supportsArbitraryTiling) {
      if (tileSize != undefined) {
        if (typeof tileSize === 'number' && Number.isInteger(tileSize) && tileSize > 0) {
          tileWidth = tileSize;
          tileHeight = tileSize;
        } else if (Array.isArray(tileSize) && tileSize.length > 0) {
          if (tileSize.length == 1 || tileSize[1] == undefined && Number.isInteger(tileSize[0])) {
            tileWidth = tileSize[0];
            tileHeight = tileSize[0];
          }

          if (tileSize.length == 2) {
            if (Number.isInteger(tileSize[0]) && Number.isInteger(tileSize[1])) {
              tileWidth = tileSize[0];
              tileHeight = tileSize[1];
            } else if (tileSize[0] == undefined && Number.isInteger(tileSize[1])) {
              tileWidth = tileSize[1];
              tileHeight = tileSize[1];
            }
          }
        }
      }

      if (tileWidth === undefined || tileHeight === undefined) {
        tileWidth = _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_TILE_SIZE;
        tileHeight = _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_TILE_SIZE;
      }

      if (resolutions.length == 0) {
        maxZoom = Math.max(Math.ceil(Math.log(width / tileWidth) / Math.LN2), Math.ceil(Math.log(height / tileHeight) / Math.LN2));

        for (var i = maxZoom; i >= 0; i--) {
          resolutions.push(Math.pow(2, i));
        }
      } else {
        var maxScaleFactor = Math.max.apply(Math, resolutions); // TODO maxScaleFactor might not be a power to 2

        maxZoom = Math.round(Math.log(maxScaleFactor) / Math.LN2);
      }
    } else {
      // No tile support.
      tileWidth = width;
      tileHeight = height;
      resolutions = [];

      if (supportsListedSizes) {
        /*
         * 'sizes' provided. Use full region in different resolutions. Every
         * resolution has only one tile.
         */
        sizes.sort(function (a, b) {
          return a[0] - b[0];
        });
        maxZoom = -1;
        var ignoredSizesIndex = [];

        for (var i = 0; i < sizes.length; i++) {
          var resolution = width / sizes[i][0];

          if (resolutions.length > 0 && resolutions[resolutions.length - 1] == resolution) {
            ignoredSizesIndex.push(i);
            continue;
          }

          resolutions.push(resolution);
          maxZoom++;
        }

        if (ignoredSizesIndex.length > 0) {
          for (var i = 0; i < ignoredSizesIndex.length; i++) {
            sizes.splice(ignoredSizesIndex[i] - i, 1);
          }
        }
      } else {
        // No useful image information at all. Try pseudo tile with full image.
        resolutions.push(1);
        sizes.push([width, height]);
        maxZoom = 0;
      }
    }

    var tileGrid = new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
      tileSize: [tileWidth, tileHeight],
      extent: extent,
      origin: (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getTopLeft)(extent),
      resolutions: resolutions
    });

    var tileUrlFunction = function tileUrlFunction(tileCoord, pixelRatio, projection) {
      var regionParam, sizeParam;
      var zoom = tileCoord[0];

      if (zoom > maxZoom) {
        return;
      }

      var tileX = tileCoord[1],
          tileY = tileCoord[2],
          scale = resolutions[zoom];

      if (tileX === undefined || tileY === undefined || scale === undefined || tileX < 0 || Math.ceil(width / scale / tileWidth) <= tileX || tileY < 0 || Math.ceil(height / scale / tileHeight) <= tileY) {
        return;
      }

      if (supportsArbitraryTiling || supportsListedTiles) {
        var regionX = tileX * tileWidth * scale,
            regionY = tileY * tileHeight * scale;
        var regionW = tileWidth * scale,
            regionH = tileHeight * scale,
            sizeW = tileWidth,
            sizeH = tileHeight;

        if (regionX + regionW > width) {
          regionW = width - regionX;
        }

        if (regionY + regionH > height) {
          regionH = height - regionY;
        }

        if (regionX + tileWidth * scale > width) {
          sizeW = Math.floor((width - regionX + scale - 1) / scale);
        }

        if (regionY + tileHeight * scale > height) {
          sizeH = Math.floor((height - regionY + scale - 1) / scale);
        }

        if (regionX == 0 && regionW == width && regionY == 0 && regionH == height) {
          // canonical full image region parameter is 'full', not 'x,y,w,h'
          regionParam = 'full';
        } else if (!supportsArbitraryTiling || (0,_array_js__WEBPACK_IMPORTED_MODULE_2__.includes)(supports, 'regionByPx')) {
          regionParam = regionX + ',' + regionY + ',' + regionW + ',' + regionH;
        } else if ((0,_array_js__WEBPACK_IMPORTED_MODULE_2__.includes)(supports, 'regionByPct')) {
          var pctX = formatPercentage(regionX / width * 100),
              pctY = formatPercentage(regionY / height * 100),
              pctW = formatPercentage(regionW / width * 100),
              pctH = formatPercentage(regionH / height * 100);
          regionParam = 'pct:' + pctX + ',' + pctY + ',' + pctW + ',' + pctH;
        }

        if (version == _format_IIIFInfo_js__WEBPACK_IMPORTED_MODULE_0__.Versions.VERSION3 && (!supportsArbitraryTiling || (0,_array_js__WEBPACK_IMPORTED_MODULE_2__.includes)(supports, 'sizeByWh'))) {
          sizeParam = sizeW + ',' + sizeH;
        } else if (!supportsArbitraryTiling || (0,_array_js__WEBPACK_IMPORTED_MODULE_2__.includes)(supports, 'sizeByW')) {
          sizeParam = sizeW + ',';
        } else if ((0,_array_js__WEBPACK_IMPORTED_MODULE_2__.includes)(supports, 'sizeByH')) {
          sizeParam = ',' + sizeH;
        } else if ((0,_array_js__WEBPACK_IMPORTED_MODULE_2__.includes)(supports, 'sizeByWh')) {
          sizeParam = sizeW + ',' + sizeH;
        } else if ((0,_array_js__WEBPACK_IMPORTED_MODULE_2__.includes)(supports, 'sizeByPct')) {
          sizeParam = 'pct:' + formatPercentage(100 / scale);
        }
      } else {
        regionParam = 'full';

        if (supportsListedSizes) {
          var regionWidth = sizes[zoom][0],
              regionHeight = sizes[zoom][1];

          if (version == _format_IIIFInfo_js__WEBPACK_IMPORTED_MODULE_0__.Versions.VERSION3) {
            if (regionWidth == width && regionHeight == height) {
              sizeParam = 'max';
            } else {
              sizeParam = regionWidth + ',' + regionHeight;
            }
          } else {
            if (regionWidth == width) {
              sizeParam = 'full';
            } else {
              sizeParam = regionWidth + ',';
            }
          }
        } else {
          sizeParam = version == _format_IIIFInfo_js__WEBPACK_IMPORTED_MODULE_0__.Versions.VERSION3 ? 'max' : 'full';
        }
      }

      return baseUrl + regionParam + '/' + sizeParam + '/0/' + quality + '.' + format;
    };

    var IiifTileClass = _Zoomify_js__WEBPACK_IMPORTED_MODULE_6__.CustomTile.bind(null, (0,_size_js__WEBPACK_IMPORTED_MODULE_7__.toSize)(tileSize || 256).map(function (size) {
      return size * tilePixelRatio;
    }));
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: interpolate,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: options.state,
      tileClass: IiifTileClass,
      tileGrid: tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: tileUrlFunction,
      transition: options.transition
    }) || this;
    /**
     * @type {number|import("../array.js").NearestDirectionFunction}
     */

    _this.zDirection = options.zDirection;
    return _this;
  }

  return IIIF;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_8__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (IIIF);

/***/ }),

/***/ "./build/wg/source/Image.js":
/*!**********************************!*\
  !*** ./build/wg/source/Image.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImageSourceEventType": function() { return /* binding */ ImageSourceEventType; },
/* harmony export */   "ImageSourceEvent": function() { return /* binding */ ImageSourceEvent; },
/* harmony export */   "defaultImageLoadFunction": function() { return /* binding */ defaultImageLoadFunction; }
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../ImageState.js */ "./build/wg/ImageState.js");
/* harmony import */ var _reproj_Image_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../reproj/Image.js */ "./build/wg/reproj/Image.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Source.js */ "./build/wg/source/Source.js");
/* harmony import */ var _reproj_common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../reproj/common.js */ "./build/wg/reproj/common.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/source/Image
 */











/**
 * @enum {string}
 */

var ImageSourceEventType = {
  /**
   * Triggered when an image starts loading.
   * @event module:wg/source/Image.ImageSourceEvent#imageloadstart
   * @api
   */
  IMAGELOADSTART: 'imageloadstart',

  /**
   * Triggered when an image finishes loading.
   * @event module:wg/source/Image.ImageSourceEvent#imageloadend
   * @api
   */
  IMAGELOADEND: 'imageloadend',

  /**
   * Triggered if image loading results in an error.
   * @event module:wg/source/Image.ImageSourceEvent#imageloaderror
   * @api
   */
  IMAGELOADERROR: 'imageloaderror'
};
/**
 * @typedef {'imageloadend'|'imageloaderror'|'imageloadstart'} ImageSourceEventTypes
 */

/**
 * @classdesc
 * Events emitted by {@link module:wg/source/Image~ImageSource} instances are instances of this
 * type.
 */

var ImageSourceEvent =
/** @class */
function (_super) {
  __extends(ImageSourceEvent, _super);
  /**
   * @param {string} type Type.
   * @param {import("../Image.js").default} image The image.
   */


  function ImageSourceEvent(type, image) {
    var _this = _super.call(this, type) || this;
    /**
     * The image related to the event.
     * @type {import("../Image.js").default}
     * @api
     */


    _this.image = image;
    return _this;
  }

  return ImageSourceEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<ImageSourceEventTypes, ImageSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types
 *     |ImageSourceEventTypes, Return>} ImageSourceOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {Array<number>} [resolutions] Resolutions.
 * @property {import("./State.js").default} [state] State.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing a single image.
 * @abstract
 * @fires module:wg/source/Image.ImageSourceEvent
 * @api
 */

var ImageSource =
/** @class */
function (_super) {
  __extends(ImageSource, _super);
  /**
   * @param {Options} options Single image source options.
   */


  function ImageSource(options) {
    var _this = this;

    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    _this = _super.call(this, {
      attributions: options.attributions,
      projection: options.projection,
      state: options.state,
      interpolate: interpolate
    }) || this;
    /***
     * @type {ImageSourceOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {ImageSourceOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {ImageSourceOnSignature<void>}
     */

    _this.un;
    /**
     * @private
     * @type {Array<number>|null}
     */

    _this.resolutions_ = options.resolutions !== undefined ? options.resolutions : null;
    /**
     * @private
     * @type {import("../reproj/Image.js").default}
     */

    _this.reprojectedImage_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.reprojectedRevision_ = 0;
    return _this;
  }
  /**
   * @return {Array<number>|null} Resolutions.
   */


  ImageSource.prototype.getResolutions = function () {
    return this.resolutions_;
  };
  /**
   * @protected
   * @param {number} resolution Resolution.
   * @return {number} Resolution.
   */


  ImageSource.prototype.findNearestResolution = function (resolution) {
    if (this.resolutions_) {
      var idx = (0,_array_js__WEBPACK_IMPORTED_MODULE_2__.linearFindNearest)(this.resolutions_, resolution, 0);
      resolution = this.resolutions_[idx];
    }

    return resolution;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   */


  ImageSource.prototype.getImage = function (extent, resolution, pixelRatio, projection) {
    var sourceProjection = this.getProjection();

    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_3__.ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(sourceProjection, projection)) {
      if (sourceProjection) {
        projection = sourceProjection;
      }

      return this.getImageInternal(extent, resolution, pixelRatio, projection);
    } else {
      if (this.reprojectedImage_) {
        if (this.reprojectedRevision_ == this.getRevision() && (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(this.reprojectedImage_.getProjection(), projection) && this.reprojectedImage_.getResolution() == resolution && (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.equals)(this.reprojectedImage_.getExtent(), extent)) {
          return this.reprojectedImage_;
        }

        this.reprojectedImage_.dispose();
        this.reprojectedImage_ = null;
      }

      this.reprojectedImage_ = new _reproj_Image_js__WEBPACK_IMPORTED_MODULE_5__["default"](sourceProjection, projection, extent, resolution, pixelRatio, function (extent, resolution, pixelRatio) {
        return this.getImageInternal(extent, resolution, pixelRatio, sourceProjection);
      }.bind(this), this.getInterpolate());
      this.reprojectedRevision_ = this.getRevision();
      return this.reprojectedImage_;
    }
  };
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   * @protected
   */


  ImageSource.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_6__.abstract)();
  };
  /**
   * Handle image change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */


  ImageSource.prototype.handleImageChange = function (event) {
    var image =
    /** @type {import("../Image.js").default} */
    event.target;
    var type;

    switch (image.getState()) {
      case _ImageState_js__WEBPACK_IMPORTED_MODULE_7__["default"].LOADING:
        this.loading = true;
        type = ImageSourceEventType.IMAGELOADSTART;
        break;

      case _ImageState_js__WEBPACK_IMPORTED_MODULE_7__["default"].LOADED:
        this.loading = false;
        type = ImageSourceEventType.IMAGELOADEND;
        break;

      case _ImageState_js__WEBPACK_IMPORTED_MODULE_7__["default"].ERROR:
        this.loading = false;
        type = ImageSourceEventType.IMAGELOADERROR;
        break;

      default:
        return;
    }

    if (this.hasListener(type)) {
      this.dispatchEvent(new ImageSourceEvent(type, image));
    }
  };

  return ImageSource;
}(_Source_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
/**
 * Default image load function for image sources that use import("../Image.js").Image image
 * instances.
 * @param {import("../Image.js").default} image Image.
 * @param {string} src Source.
 */


function defaultImageLoadFunction(image, src) {
  /** @type {HTMLImageElement|HTMLVideoElement} */
  image.getImage().src = src;
}
/* harmony default export */ __webpack_exports__["default"] = (ImageSource);

/***/ }),

/***/ "./build/wg/source/ImageArcGISRest.js":
/*!********************************************!*\
  !*** ./build/wg/source/ImageArcGISRest.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Image.js */ "./build/wg/source/Image.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Image.js */ "./build/wg/Image.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../uri.js */ "./build/wg/uri.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/**
 * @module wg/source/ImageArcGISRest
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();








/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting the image from
 * the remote server.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given
 * a URL.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service
 * defaults will be used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is
 * `IMAGE` by default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`, and `IMAGESR`
 * will be set dynamically. Set `LAYERS` to override the default service layer visibility. See
 * https://developers.arcgis.com/rest/services-reference/export-map.htm
 * for further reference.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * The projection code must contain a numeric end portion separated by :
 * or the entire code must form a valid ArcGIS SpatialReference definition.
 * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport,
 * `2` means twice the size of the map viewport, and so on.
 * @property {Array<number>} [resolutions] Resolutions. If specified, requests will be made for
 * these resolutions only.
 * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The url
 * should include /MapServer or /ImageServer.
 */

/**
 * @classdesc
 * Source for data from ArcGIS Rest services providing single, untiled images.
 * Useful when underlying map service has labels.
 *
 * If underlying map service is not using labels,
 * take advantage of ol image caching and use
 * {@link module:wg/source/TileArcGISRest~TileArcGISRest} data source.
 *
 * @fires module:wg/source/Image.ImageSourceEvent
 * @api
 */

var ImageArcGISRest =
/** @class */
function (_super) {
  __extends(ImageArcGISRest, _super);
  /**
   * @param {Options} [opt_options] Image ArcGIS Rest Options.
   */


  function ImageArcGISRest(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    _this = _super.call(this, {
      attributions: options.attributions,
      interpolate: interpolate,
      projection: options.projection,
      resolutions: options.resolutions
    }) || this;
    /**
     * @private
     * @type {?string}
     */

    _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
    /**
     * @private
     * @type {boolean}
     */

    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
    /**
     * @private
     * @type {string|undefined}
     */

    _this.url_ = options.url;
    /**
     * @private
     * @type {import("../Image.js").LoadFunction}
     */

    _this.imageLoadFunction_ = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _Image_js__WEBPACK_IMPORTED_MODULE_0__.defaultImageLoadFunction;
    /**
     * @private
     * @type {!Object}
     */

    _this.params_ = options.params || {};
    /**
     * @private
     * @type {import("../Image.js").default}
     */

    _this.image_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.imageSize_ = [0, 0];
    /**
     * @private
     * @type {number}
     */

    _this.renderedRevision_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;
    return _this;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */


  ImageArcGISRest.prototype.getParams = function () {
    return this.params_;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */


  ImageArcGISRest.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
    if (this.url_ === undefined) {
      return null;
    }

    resolution = this.findNearestResolution(resolution);
    pixelRatio = this.hidpi_ ? pixelRatio : 1;
    var image = this.image_;

    if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsExtent)(image.getExtent(), extent)) {
      return image;
    }

    var params = {
      'F': 'image',
      'FORMAT': 'PNG32',
      'TRANSPARENT': true
    };
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_2__.assign)(params, this.params_);
    extent = extent.slice();
    var centerX = (extent[0] + extent[2]) / 2;
    var centerY = (extent[1] + extent[3]) / 2;

    if (this.ratio_ != 1) {
      var halfWidth = this.ratio_ * (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(extent) / 2;
      var halfHeight = this.ratio_ * (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getHeight)(extent) / 2;
      extent[0] = centerX - halfWidth;
      extent[1] = centerY - halfHeight;
      extent[2] = centerX + halfWidth;
      extent[3] = centerY + halfHeight;
    }

    var imageResolution = resolution / pixelRatio; // Compute an integer width and height.

    var width = Math.ceil((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(extent) / imageResolution);
    var height = Math.ceil((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getHeight)(extent) / imageResolution); // Modify the extent to match the integer width and height.

    extent[0] = centerX - imageResolution * width / 2;
    extent[2] = centerX + imageResolution * width / 2;
    extent[1] = centerY - imageResolution * height / 2;
    extent[3] = centerY + imageResolution * height / 2;
    this.imageSize_[0] = width;
    this.imageSize_[1] = height;
    var url = this.getRequestUrl_(extent, this.imageSize_, pixelRatio, projection, params);
    this.image_ = new _Image_js__WEBPACK_IMPORTED_MODULE_3__["default"](extent, resolution, pixelRatio, url, this.crossOrigin_, this.imageLoadFunction_);
    this.renderedRevision_ = this.getRevision();
    this.image_.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE, this.handleImageChange.bind(this));
    return this.image_;
  };
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */


  ImageArcGISRest.prototype.getImageLoadFunction = function () {
    return this.imageLoadFunction_;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../size.js").Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string} Request URL.
   * @private
   */


  ImageArcGISRest.prototype.getRequestUrl_ = function (extent, size, pixelRatio, projection, params) {
    // ArcGIS Server only wants the numeric portion of the projection ID.
    // (if there is no numeric portion the entire projection code must
    // form a valid ArcGIS SpatialReference definition).
    var srid = projection.getCode().split(/:(?=\d+$)/).pop();
    params['SIZE'] = size[0] + ',' + size[1];
    params['BBOX'] = extent.join(',');
    params['BBOXSR'] = srid;
    params['IMAGESR'] = srid;
    params['DPI'] = Math.round(90 * pixelRatio);
    var url = this.url_;
    var modifiedUrl = url.replace(/MapServer\/?$/, 'MapServer/export').replace(/ImageServer\/?$/, 'ImageServer/exportImage');

    if (modifiedUrl == url) {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_5__.assert)(false, 50); // `options.featureTypes` should be an Array
    }

    return (0,_uri_js__WEBPACK_IMPORTED_MODULE_6__.appendParams)(modifiedUrl, params);
  };
  /**
   * Return the URL used for this ArcGIS source.
   * @return {string|undefined} URL.
   * @api
   */


  ImageArcGISRest.prototype.getUrl = function () {
    return this.url_;
  };
  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */


  ImageArcGISRest.prototype.setImageLoadFunction = function (imageLoadFunction) {
    this.image_ = null;
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  };
  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */


  ImageArcGISRest.prototype.setUrl = function (url) {
    if (url != this.url_) {
      this.url_ = url;
      this.image_ = null;
      this.changed();
    }
  };
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */


  ImageArcGISRest.prototype.updateParams = function (params) {
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_2__.assign)(this.params_, params);
    this.image_ = null;
    this.changed();
  };

  return ImageArcGISRest;
}(_Image_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (ImageArcGISRest);

/***/ }),

/***/ "./build/wg/source/ImageCanvas.js":
/*!****************************************!*\
  !*** ./build/wg/source/ImageCanvas.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageCanvas.js */ "./build/wg/ImageCanvas.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Image.js */ "./build/wg/source/Image.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/**
 * @module wg/source/ImageCanvas
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();




/**
 * A function returning the canvas element (`{HTMLCanvasElement}`)
 * used by the source as an image. The arguments passed to the function are:
 * {@link module:wg/extent~Extent} the image extent, `{number}` the image resolution,
 * `{number}` the pixel ratio of the map, {@link module:wg/size~Size} the image size,
 * and {@link module:wg/proj/Projection~Projection} the image projection. The canvas returned by
 * this function is cached by the source. The this keyword inside the function
 * references the {@link module:wg/source/ImageCanvas~ImageCanvasSource}.
 *
 * @typedef {function(this:import("../ImageCanvas.js").default, import("../extent.js").Extent, number,
 *     number, import("../size.js").Size, import("../proj/Projection.js").default): HTMLCanvasElement} FunctionType
 */

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {FunctionType} [canvasFunction] Canvas function.
 * The function returning the canvas element used by the source
 * as an image. The arguments passed to the function are: {@link import("../extent.js").Extent} the
 * image extent, `{number}` the image resolution, `{number}` the pixel ratio of the map,
 * {@link import("../size.js").Size} the image size, and {@link import("../proj/Projection.js").default} the image
 * projection. The canvas returned by this function is cached by the source. If
 * the value returned by the function is later changed then
 * `changed` should be called on the source for the source to
 * invalidate the current cached image. See: {@link module:wg/Observable~Observable#changed}
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [ratio=1.5] Ratio. 1 means canvases are the size of the map viewport, 2 means twice the
 * width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {Array<number>} [resolutions] Resolutions.
 * If specified, new canvases will be created for these resolutions
 * @property {import("./State.js").default} [state] Source state.
 */

/**
 * @classdesc
 * Base class for image sources where a canvas element is the image.
 * @api
 */

var ImageCanvasSource =
/** @class */
function (_super) {
  __extends(ImageCanvasSource, _super);
  /**
   * @param {Options} [opt_options] ImageCanvas options.
   */


  function ImageCanvasSource(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    _this = _super.call(this, {
      attributions: options.attributions,
      interpolate: interpolate,
      projection: options.projection,
      resolutions: options.resolutions,
      state: options.state
    }) || this;
    /**
     * @private
     * @type {FunctionType}
     */

    _this.canvasFunction_ = options.canvasFunction;
    /**
     * @private
     * @type {import("../ImageCanvas.js").default}
     */

    _this.canvas_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.renderedRevision_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;
    return _this;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageCanvas.js").default} Single image.
   */


  ImageCanvasSource.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
    resolution = this.findNearestResolution(resolution);
    var canvas = this.canvas_;

    if (canvas && this.renderedRevision_ == this.getRevision() && canvas.getResolution() == resolution && canvas.getPixelRatio() == pixelRatio && (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.containsExtent)(canvas.getExtent(), extent)) {
      return canvas;
    }

    extent = extent.slice();
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.scaleFromCenter)(extent, this.ratio_);
    var width = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.getWidth)(extent) / resolution;
    var height = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(extent) / resolution;
    var size = [width * pixelRatio, height * pixelRatio];
    var canvasElement = this.canvasFunction_.call(this, extent, resolution, pixelRatio, size, projection);

    if (canvasElement) {
      canvas = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_1__["default"](extent, resolution, pixelRatio, canvasElement);
    }

    this.canvas_ = canvas;
    this.renderedRevision_ = this.getRevision();
    return canvas;
  };

  return ImageCanvasSource;
}(_Image_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (ImageCanvasSource);

/***/ }),

/***/ "./build/wg/source/ImageMapGuide.js":
/*!******************************************!*\
  !*** ./build/wg/source/ImageMapGuide.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Image.js */ "./build/wg/source/Image.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Image.js */ "./build/wg/Image.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../uri.js */ "./build/wg/uri.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/**
 * @module wg/source/ImageMapGuide
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();







/**
 * @typedef {Object} Options
 * @property {string} [url] The mapagent url.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {number} [displayDpi=96] The display resolution.
 * @property {number} [metersPerUnit=1] The meters-per-unit value.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {boolean} [useOverlay] If `true`, will use `GETDYNAMICMAPOVERLAYIMAGE`.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [ratio=1] Ratio. `1` means image requests are the size of the map viewport, `2` means
 * twice the width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {Array<number>} [resolutions] Resolutions.
 * If specified, requests will be made for these resolutions only.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object} [params] Additional parameters.
 */

/**
 * @classdesc
 * Source for images from Mapguide servers
 *
 * @fires module:wg/source/Image.ImageSourceEvent
 * @api
 */

var ImageMapGuide =
/** @class */
function (_super) {
  __extends(ImageMapGuide, _super);
  /**
   * @param {Options} options ImageMapGuide options.
   */


  function ImageMapGuide(options) {
    var _this = this;

    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    _this = _super.call(this, {
      interpolate: interpolate,
      projection: options.projection,
      resolutions: options.resolutions
    }) || this;
    /**
     * @private
     * @type {?string}
     */

    _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
    /**
     * @private
     * @type {number}
     */

    _this.displayDpi_ = options.displayDpi !== undefined ? options.displayDpi : 96;
    /**
     * @private
     * @type {!Object}
     */

    _this.params_ = options.params || {};
    /**
     * @private
     * @type {string|undefined}
     */

    _this.url_ = options.url;
    /**
     * @private
     * @type {import("../Image.js").LoadFunction}
     */

    _this.imageLoadFunction_ = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _Image_js__WEBPACK_IMPORTED_MODULE_0__.defaultImageLoadFunction;
    /**
     * @private
     * @type {boolean}
     */

    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
    /**
     * @private
     * @type {number}
     */

    _this.metersPerUnit_ = options.metersPerUnit !== undefined ? options.metersPerUnit : 1;
    /**
     * @private
     * @type {number}
     */

    _this.ratio_ = options.ratio !== undefined ? options.ratio : 1;
    /**
     * @private
     * @type {boolean}
     */

    _this.useOverlay_ = options.useOverlay !== undefined ? options.useOverlay : false;
    /**
     * @private
     * @type {import("../Image.js").default}
     */

    _this.image_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.renderedRevision_ = 0;
    return _this;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */


  ImageMapGuide.prototype.getParams = function () {
    return this.params_;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */


  ImageMapGuide.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
    resolution = this.findNearestResolution(resolution);
    pixelRatio = this.hidpi_ ? pixelRatio : 1;
    var image = this.image_;

    if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsExtent)(image.getExtent(), extent)) {
      return image;
    }

    if (this.ratio_ != 1) {
      extent = extent.slice();
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.scaleFromCenter)(extent, this.ratio_);
    }

    var width = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(extent) / resolution;
    var height = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getHeight)(extent) / resolution;
    var size = [width * pixelRatio, height * pixelRatio];

    if (this.url_ !== undefined) {
      var imageUrl = this.getUrl(this.url_, this.params_, extent, size, projection);
      image = new _Image_js__WEBPACK_IMPORTED_MODULE_2__["default"](extent, resolution, pixelRatio, imageUrl, this.crossOrigin_, this.imageLoadFunction_);
      image.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.handleImageChange.bind(this));
    } else {
      image = null;
    }

    this.image_ = image;
    this.renderedRevision_ = this.getRevision();
    return image;
  };
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */


  ImageMapGuide.prototype.getImageLoadFunction = function () {
    return this.imageLoadFunction_;
  };
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */


  ImageMapGuide.prototype.updateParams = function (params) {
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_4__.assign)(this.params_, params);
    this.changed();
  };
  /**
   * @param {string} baseUrl The mapagent url.
   * @param {Object<string, string|number>} params Request parameters.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../size.js").Size} size Size.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string} The mapagent map image request URL.
   */


  ImageMapGuide.prototype.getUrl = function (baseUrl, params, extent, size, projection) {
    var scale = getScale(extent, size, this.metersPerUnit_, this.displayDpi_);
    var center = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getCenter)(extent);
    var baseParams = {
      'OPERATION': this.useOverlay_ ? 'GETDYNAMICMAPOVERLAYIMAGE' : 'GETMAPIMAGE',
      'VERSION': '2.0.0',
      'LOCALE': 'en',
      'CLIENTAGENT': 'wg/source/ImageMapGuide source',
      'CLIP': '1',
      'SETDISPLAYDPI': this.displayDpi_,
      'SETDISPLAYWIDTH': Math.round(size[0]),
      'SETDISPLAYHEIGHT': Math.round(size[1]),
      'SETVIEWSCALE': scale,
      'SETVIEWCENTERX': center[0],
      'SETVIEWCENTERY': center[1]
    };
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_4__.assign)(baseParams, params);
    return (0,_uri_js__WEBPACK_IMPORTED_MODULE_5__.appendParams)(baseUrl, baseParams);
  };
  /**
   * Set the image load function of the MapGuide source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */


  ImageMapGuide.prototype.setImageLoadFunction = function (imageLoadFunction) {
    this.image_ = null;
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  };

  return ImageMapGuide;
}(_Image_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
/**
 * @param {import("../extent.js").Extent} extent The map extents.
 * @param {import("../size.js").Size} size The viewport size.
 * @param {number} metersPerUnit The meters-per-unit value.
 * @param {number} dpi The display resolution.
 * @return {number} The computed map scale.
 */


function getScale(extent, size, metersPerUnit, dpi) {
  var mcsW = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(extent);
  var mcsH = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getHeight)(extent);
  var devW = size[0];
  var devH = size[1];
  var mpp = 0.0254 / dpi;

  if (devH * mcsW > devW * mcsH) {
    return mcsW * metersPerUnit / (devW * mpp); // width limited
  } else {
    return mcsH * metersPerUnit / (devH * mpp); // height limited
  }
}

/* harmony default export */ __webpack_exports__["default"] = (ImageMapGuide);

/***/ }),

/***/ "./build/wg/source/ImageStatic.js":
/*!****************************************!*\
  !*** ./build/wg/source/ImageStatic.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Image.js */ "./build/wg/source/Image.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ImageState.js */ "./build/wg/ImageState.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Image.js */ "./build/wg/Image.js");
/* harmony import */ var _renderer_canvas_common_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../renderer/canvas/common.js */ "./build/wg/renderer/canvas/common.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom.js */ "./build/wg/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/**
 * @module wg/source/ImageStatic
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();










/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {import("../extent.js").Extent} [imageExtent] Extent of the image in map coordinates.
 * This is the [left, bottom, right, top] map coordinates of your image.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("../size.js").Size} [imageSize] Size of the image in pixels. Usually the image size is auto-detected, so this
 * only needs to be set if auto-detection fails for some reason.
 * @property {string} url Image URL.
 */

/**
 * @classdesc
 * A layer source for displaying a single, static image.
 * @api
 */

var Static =
/** @class */
function (_super) {
  __extends(Static, _super);
  /**
   * @param {Options} options ImageStatic options.
   */


  function Static(options) {
    var _this = this;

    var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
    var
    /** @type {import("../Image.js").LoadFunction} */
    imageLoadFunction = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _Image_js__WEBPACK_IMPORTED_MODULE_1__.defaultImageLoadFunction;
    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    _this = _super.call(this, {
      attributions: options.attributions,
      interpolate: interpolate,
      projection: (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.projection)
    }) || this;
    /**
     * @private
     * @type {string}
     */

    _this.url_ = options.url;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    _this.imageExtent_ = options.imageExtent;
    /**
     * @private
     * @type {import("../Image.js").default}
     */

    _this.image_ = new _Image_js__WEBPACK_IMPORTED_MODULE_2__["default"](_this.imageExtent_, undefined, 1, _this.url_, crossOrigin, imageLoadFunction);
    /**
     * @private
     * @type {import("../size.js").Size|null}
     */

    _this.imageSize_ = options.imageSize ? options.imageSize : null;

    _this.image_.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, _this.handleImageChange.bind(_this));

    return _this;
  }
  /**
   * Returns the image extent
   * @return {import("../extent.js").Extent} image extent.
   * @api
   */


  Static.prototype.getImageExtent = function () {
    return this.imageExtent_;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */


  Static.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
    if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.intersects)(extent, this.image_.getExtent())) {
      return this.image_;
    }

    return null;
  };
  /**
   * Return the URL used for this image source.
   * @return {string} URL.
   * @api
   */


  Static.prototype.getUrl = function () {
    return this.url_;
  };
  /**
   * @param {import("../events/Event.js").default} evt Event.
   */


  Static.prototype.handleImageChange = function (evt) {
    if (this.image_.getState() == _ImageState_js__WEBPACK_IMPORTED_MODULE_5__["default"].LOADED) {
      var imageExtent = this.image_.getExtent();
      var image = this.image_.getImage();
      var imageWidth = void 0,
          imageHeight = void 0;

      if (this.imageSize_) {
        imageWidth = this.imageSize_[0];
        imageHeight = this.imageSize_[1];
      } else {
        imageWidth = image.width;
        imageHeight = image.height;
      }

      var extentWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.getWidth)(imageExtent);
      var extentHeight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.getHeight)(imageExtent);
      var xResolution = extentWidth / imageWidth;
      var yResolution = extentHeight / imageHeight;
      var targetWidth = imageWidth;
      var targetHeight = imageHeight;

      if (xResolution > yResolution) {
        targetWidth = Math.round(extentWidth / yResolution);
      } else {
        targetHeight = Math.round(extentHeight / xResolution);
      }

      if (targetWidth !== imageWidth || targetHeight !== imageHeight) {
        var context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_6__.createCanvasContext2D)(targetWidth, targetHeight);

        if (!this.getInterpolate()) {
          (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.assign)(context, _renderer_canvas_common_js__WEBPACK_IMPORTED_MODULE_8__.IMAGE_SMOOTHING_DISABLED);
        }

        var canvas = context.canvas;
        context.drawImage(image, 0, 0, imageWidth, imageHeight, 0, 0, canvas.width, canvas.height);
        this.image_.setImage(canvas);
      }
    }

    _super.prototype.handleImageChange.call(this, evt);
  };

  return Static;
}(_Image_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Static);

/***/ }),

/***/ "./build/wg/source/ImageWMS.js":
/*!*************************************!*\
  !*** ./build/wg/source/ImageWMS.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common.js */ "./build/wg/source/common.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Image.js */ "./build/wg/source/Image.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Image.js */ "./build/wg/Image.js");
/* harmony import */ var _WMSServerType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./WMSServerType.js */ "./build/wg/source/WMSServerType.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../uri.js */ "./build/wg/uri.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../reproj.js */ "./build/wg/reproj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../string.js */ "./build/wg/string.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/**
 * @module wg/source/ImageWMS
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();














/**
 * Number of decimal digits to consider in integer values when rounding.
 * @type {number}
 */

var DECIMALS = 4;
/**
 * @const
 * @type {import("../size.js").Size}
 */

var GETFEATUREINFO_IMAGE_SIZE = [101, 101];
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("./WMSServerType.js").default|string} [serverType] The type of
 * the remote WMS server: `mapserver`, `geoserver` or `qgis`. Only needed if `hidpi` is `true`.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object<string,*>} params WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
 * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport, `2` means
 * twice the width and height of the map viewport, and so on. Must be `1` or
 * higher.
 * @property {Array<number>} [resolutions] Resolutions.
 * If specified, requests will be made for these resolutions only.
 * @property {string} url WMS service URL.
 */

/**
 * @classdesc
 * Source for WMS servers providing single, untiled images.
 *
 * @fires module:wg/source/Image.ImageSourceEvent
 * @api
 */

var ImageWMS =
/** @class */
function (_super) {
  __extends(ImageWMS, _super);
  /**
   * @param {Options} [opt_options] ImageWMS options.
   */


  function ImageWMS(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    _this = _super.call(this, {
      attributions: options.attributions,
      interpolate: interpolate,
      projection: options.projection,
      resolutions: options.resolutions
    }) || this;
    /**
     * @private
     * @type {?string}
     */

    _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
    /**
     * @private
     * @type {string|undefined}
     */

    _this.url_ = options.url;
    /**
     * @private
     * @type {import("../Image.js").LoadFunction}
     */

    _this.imageLoadFunction_ = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _Image_js__WEBPACK_IMPORTED_MODULE_1__.defaultImageLoadFunction;
    /**
     * @private
     * @type {!Object}
     */

    _this.params_ = options.params || {};
    /**
     * @private
     * @type {boolean}
     */

    _this.v13_ = true;

    _this.updateV13_();
    /**
     * @private
     * @type {import("./WMSServerType.js").default|undefined}
     */


    _this.serverType_ =
    /** @type {import("./WMSServerType.js").default|undefined} */
    options.serverType;
    /**
     * @private
     * @type {boolean}
     */

    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
    /**
     * @private
     * @type {import("../Image.js").default}
     */

    _this.image_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.imageSize_ = [0, 0];
    /**
     * @private
     * @type {number}
     */

    _this.renderedRevision_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;
    return _this;
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */


  ImageWMS.prototype.getFeatureInfoUrl = function (coordinate, resolution, projection, params) {
    if (this.url_ === undefined) {
      return undefined;
    }

    var projectionObj = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection);
    var sourceProjectionObj = this.getProjection();

    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      resolution = (0,_reproj_js__WEBPACK_IMPORTED_MODULE_2__.calculateSourceResolution)(sourceProjectionObj, projectionObj, coordinate, resolution);
      coordinate = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.transform)(coordinate, projectionObj, sourceProjectionObj);
    }

    var extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getForViewAndSize)(coordinate, resolution, 0, GETFEATUREINFO_IMAGE_SIZE);
    var baseParams = {
      'SERVICE': 'WMS',
      'VERSION': _common_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_WMS_VERSION,
      'REQUEST': 'GetFeatureInfo',
      'FORMAT': 'image/png',
      'TRANSPARENT': true,
      'QUERY_LAYERS': this.params_['LAYERS']
    };
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_5__.assign)(baseParams, this.params_, params);
    var x = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)((coordinate[0] - extent[0]) / resolution, DECIMALS);
    var y = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)((extent[3] - coordinate[1]) / resolution, DECIMALS);
    baseParams[this.v13_ ? 'I' : 'X'] = x;
    baseParams[this.v13_ ? 'J' : 'Y'] = y;
    return this.getRequestUrl_(extent, GETFEATUREINFO_IMAGE_SIZE, 1, sourceProjectionObj || projectionObj, baseParams);
  };
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */


  ImageWMS.prototype.getLegendUrl = function (resolution, params) {
    if (this.url_ === undefined) {
      return undefined;
    }

    var baseParams = {
      'SERVICE': 'WMS',
      'VERSION': _common_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_WMS_VERSION,
      'REQUEST': 'GetLegendGraphic',
      'FORMAT': 'image/png'
    };

    if (params === undefined || params['LAYER'] === undefined) {
      var layers = this.params_.LAYERS;
      var isSingleLayer = !Array.isArray(layers) || layers.length === 1;

      if (!isSingleLayer) {
        return undefined;
      }

      baseParams['LAYER'] = layers;
    }

    if (resolution !== undefined) {
      var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
      var pixelSize = 0.00028;
      baseParams['SCALE'] = resolution * mpu / pixelSize;
    }

    (0,_obj_js__WEBPACK_IMPORTED_MODULE_5__.assign)(baseParams, params);
    return (0,_uri_js__WEBPACK_IMPORTED_MODULE_7__.appendParams)(
    /** @type {string} */
    this.url_, baseParams);
  };
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */


  ImageWMS.prototype.getParams = function () {
    return this.params_;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */


  ImageWMS.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
    if (this.url_ === undefined) {
      return null;
    }

    resolution = this.findNearestResolution(resolution);

    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {
      pixelRatio = 1;
    }

    var imageResolution = resolution / pixelRatio;
    var center = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getCenter)(extent);
    var viewWidth = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)((0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getWidth)(extent) / imageResolution, DECIMALS);
    var viewHeight = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)((0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getHeight)(extent) / imageResolution, DECIMALS);
    var viewExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getForViewAndSize)(center, imageResolution, 0, [viewWidth, viewHeight]);
    var requestWidth = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(this.ratio_ * (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getWidth)(extent) / imageResolution, DECIMALS);
    var requestHeight = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(this.ratio_ * (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getHeight)(extent) / imageResolution, DECIMALS);
    var requestExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getForViewAndSize)(center, imageResolution, 0, [requestWidth, requestHeight]);
    var image = this.image_;

    if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.containsExtent)(image.getExtent(), viewExtent)) {
      return image;
    }

    var params = {
      'SERVICE': 'WMS',
      'VERSION': _common_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_WMS_VERSION,
      'REQUEST': 'GetMap',
      'FORMAT': 'image/png',
      'TRANSPARENT': true
    };
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_5__.assign)(params, this.params_);
    this.imageSize_[0] = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.round)((0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getWidth)(requestExtent) / imageResolution, DECIMALS);
    this.imageSize_[1] = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.round)((0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getHeight)(requestExtent) / imageResolution, DECIMALS);
    var url = this.getRequestUrl_(requestExtent, this.imageSize_, pixelRatio, projection, params);
    this.image_ = new _Image_js__WEBPACK_IMPORTED_MODULE_8__["default"](requestExtent, resolution, pixelRatio, url, this.crossOrigin_, this.imageLoadFunction_);
    this.renderedRevision_ = this.getRevision();
    this.image_.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CHANGE, this.handleImageChange.bind(this));
    return this.image_;
  };
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */


  ImageWMS.prototype.getImageLoadFunction = function () {
    return this.imageLoadFunction_;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../size.js").Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string} Request URL.
   * @private
   */


  ImageWMS.prototype.getRequestUrl_ = function (extent, size, pixelRatio, projection, params) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_10__.assert)(this.url_ !== undefined, 9); // `url` must be configured or set using `#setUrl()`

    params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();

    if (!('STYLES' in this.params_)) {
      params['STYLES'] = '';
    }

    if (pixelRatio != 1) {
      switch (this.serverType_) {
        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_11__["default"].GEOSERVER:
          var dpi = 90 * pixelRatio + 0.5 | 0;

          if ('FORMAT_OPTIONS' in params) {
            params['FORMAT_OPTIONS'] += ';dpi:' + dpi;
          } else {
            params['FORMAT_OPTIONS'] = 'dpi:' + dpi;
          }

          break;

        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_11__["default"].MAPSERVER:
          params['MAP_RESOLUTION'] = 90 * pixelRatio;
          break;

        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_11__["default"].CARMENTA_SERVER:
        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_11__["default"].QGIS:
          params['DPI'] = 90 * pixelRatio;
          break;

        default:
          (0,_asserts_js__WEBPACK_IMPORTED_MODULE_10__.assert)(false, 8); // Unknown `serverType` configured

          break;
      }
    }

    params['WIDTH'] = size[0];
    params['HEIGHT'] = size[1];
    var axisOrientation = projection.getAxisOrientation();
    var bbox;

    if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {
      bbox = [extent[1], extent[0], extent[3], extent[2]];
    } else {
      bbox = extent;
    }

    params['BBOX'] = bbox.join(',');
    return (0,_uri_js__WEBPACK_IMPORTED_MODULE_7__.appendParams)(
    /** @type {string} */
    this.url_, params);
  };
  /**
   * Return the URL used for this WMS source.
   * @return {string|undefined} URL.
   * @api
   */


  ImageWMS.prototype.getUrl = function () {
    return this.url_;
  };
  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */


  ImageWMS.prototype.setImageLoadFunction = function (imageLoadFunction) {
    this.image_ = null;
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  };
  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */


  ImageWMS.prototype.setUrl = function (url) {
    if (url != this.url_) {
      this.url_ = url;
      this.image_ = null;
      this.changed();
    }
  };
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */


  ImageWMS.prototype.updateParams = function (params) {
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_5__.assign)(this.params_, params);
    this.updateV13_();
    this.image_ = null;
    this.changed();
  };
  /**
   * @private
   */


  ImageWMS.prototype.updateV13_ = function () {
    var version = this.params_['VERSION'] || _common_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_WMS_VERSION;
    this.v13_ = (0,_string_js__WEBPACK_IMPORTED_MODULE_12__.compareVersions)(version, '1.3') >= 0;
  };

  return ImageWMS;
}(_Image_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (ImageWMS);

/***/ }),

/***/ "./build/wg/source/OGCMapTile.js":
/*!***************************************!*\
  !*** ./build/wg/source/OGCMapTile.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./State.js */ "./build/wg/source/State.js");
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileImage.js */ "./build/wg/source/TileImage.js");
/* harmony import */ var _ogcTileUtil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ogcTileUtil.js */ "./build/wg/source/ogcTileUtil.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/source/OGCMapTile
 */





/**
 * @typedef {Object} Options
 * @property {string} url URL to the OGC Map Tileset endpoint.
 * @property {Object} [context] A lookup of values to use in the tile URL template.  The `{tileMatrix}`
 * (zoom level), `{tileRow}`, and `{tileCol}` variables in the URL will always be provided by the source.
 * @property {string} [mediaType] The content type for the tiles (e.g. "image/png").  If not provided,
 * the source will try to find a link with rel="item" that uses a supported image type.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. By default, the projection
 * will be derived from the `crs` of the `tileMatrixSet`.  You can override this by supplying
 * a projection to the constructor.
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Tile cache size. The default depends on the screen size. Will be ignored if too small.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(tile, src) {
 *   tile.getImage().src = src;
 * };
 * ```
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */

/**
 * @classdesc
 * Layer source for map tiles from an [OGC API - Tiles](https://ogcapi.ogc.org/tiles/) service that provides "map" type tiles.
 * The service must conform to at least the core (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/core)
 * and tileset (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/tileset) conformance classes.
 */

var OGCMapTile =
/** @class */
function (_super) {
  __extends(OGCMapTile, _super);
  /**
   * @param {Options} options OGC map tile options.
   */


  function OGCMapTile(options) {
    var _this = this;

    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: interpolate,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: _State_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADING,
      tileLoadFunction: options.tileLoadFunction,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition
    }) || this;
    var sourceInfo = {
      url: options.url,
      projection: _this.getProjection(),
      mediaType: options.mediaType,
      context: options.context || null
    };
    (0,_ogcTileUtil_js__WEBPACK_IMPORTED_MODULE_1__.getTileSetInfo)(sourceInfo).then(_this.handleTileSetInfo_.bind(_this)).catch(_this.handleError_.bind(_this));
    return _this;
  }
  /**
   * @param {import("./ogcTileUtil.js").TileSetInfo} tileSetInfo Tile set info.
   * @private
   */


  OGCMapTile.prototype.handleTileSetInfo_ = function (tileSetInfo) {
    this.tileGrid = tileSetInfo.grid;
    this.setTileUrlFunction(tileSetInfo.urlFunction, tileSetInfo.urlTemplate);
    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_0__["default"].READY);
  };
  /**
   * @private
   * @param {Error} error The error.
   */


  OGCMapTile.prototype.handleError_ = function (error) {
    console.error(error); // eslint-disable-line no-console

    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR);
  };

  return OGCMapTile;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (OGCMapTile);

/***/ }),

/***/ "./build/wg/source/OGCVectorTile.js":
/*!******************************************!*\
  !*** ./build/wg/source/OGCVectorTile.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./State.js */ "./build/wg/source/State.js");
/* harmony import */ var _VectorTile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VectorTile.js */ "./build/wg/source/VectorTile.js");
/* harmony import */ var _ogcTileUtil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ogcTileUtil.js */ "./build/wg/source/ogcTileUtil.js");
/**
 * @module wg/source/OGCVectorTile
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();




/**
 * @typedef {Object} Options
 * @property {string} url URL to the OGC Vector Tileset endpoint.
 * @property {Object} [context] A lookup of values to use in the tile URL template.  The `{tileMatrix}`
 * (zoom level), `{tileRow}`, and `{tileCol}` variables in the URL will always be provided by the source.
 * @property {import("../format/Feature.js").default} format Feature parser for tiles.
 * @property {string} [mediaType] The content type for the tiles (e.g. "application/vnd.mapbox-vector-tile").  If not provided,
 * the source will try to find a link with rel="item" that uses a vector type supported by the configured format.
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.
 * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this
 * to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.
 * @property {typeof import("../VectorTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:wg/VectorTile~VectorTile}.
 * @property {number} [transition] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When set to `true`, tiles will be wrapped horizontally to
 * render multiple worlds.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=1]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for map tiles from an [OGC API - Tiles](https://ogcapi.ogc.org/tiles/) service that provides "vector" type tiles.
 * The service must conform to at least the core (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/core)
 * and tileset (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/tileset) conformance classes.
 *
 * Vector tile sets may come in a variety of formats (e.g. GeoJSON, MVT).  The `format` option is used to determine
 * which of the advertised media types is used.  If you need to force the use of a particular media type, you can
 * provide the `mediaType` option.
 */

var OGCVectorTile =
/** @class */
function (_super) {
  __extends(OGCVectorTile, _super);
  /**
   * @param {Options} options OGC vector tile options.
   */


  function OGCVectorTile(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      format: options.format,
      overlaps: options.overlaps,
      projection: options.projection,
      tileClass: options.tileClass,
      transition: options.transition,
      wrapX: options.wrapX,
      zDirection: options.zDirection,
      state: _State_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADING
    }) || this;

    var sourceInfo = {
      url: options.url,
      projection: _this.getProjection(),
      mediaType: options.mediaType,
      supportedMediaTypes: options.format.supportedMediaTypes,
      context: options.context || null
    };
    (0,_ogcTileUtil_js__WEBPACK_IMPORTED_MODULE_1__.getTileSetInfo)(sourceInfo).then(_this.handleTileSetInfo_.bind(_this)).catch(_this.handleError_.bind(_this));
    return _this;
  }
  /**
   * @param {import("./ogcTileUtil.js").TileSetInfo} tileSetInfo Tile set info.
   * @private
   */


  OGCVectorTile.prototype.handleTileSetInfo_ = function (tileSetInfo) {
    this.tileGrid = tileSetInfo.grid;
    this.setTileUrlFunction(tileSetInfo.urlFunction, tileSetInfo.urlTemplate);
    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_0__["default"].READY);
  };
  /**
   * @private
   * @param {Error} error The error.
   */


  OGCVectorTile.prototype.handleError_ = function (error) {
    console.error(error); // eslint-disable-line no-console

    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR);
  };

  return OGCVectorTile;
}(_VectorTile_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (OGCVectorTile);

/***/ }),

/***/ "./build/wg/source/OSM.js":
/*!********************************!*\
  !*** ./build/wg/source/OSM.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ATTRIBUTION": function() { return /* binding */ ATTRIBUTION; }
/* harmony export */ });
/* harmony import */ var _XYZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./XYZ.js */ "./build/wg/source/XYZ.js");
/**
 * @module wg/source/OSM
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();


/**
 * The attribution containing a link to the OpenStreetMap Copyright and License
 * page.
 * @const
 * @type {string}
 * @api
 */

var ATTRIBUTION = '&#169; ' + '<a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> ' + 'contributors.';
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {number} [maxZoom=19] Max zoom.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
 * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 * @api
 */

var OSM =
/** @class */
function (_super) {
  __extends(OSM, _super);
  /**
   * @param {Options} [opt_options] Open Street Map options.
   */


  function OSM(opt_options) {
    var options = opt_options || {};
    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    var attributions;

    if (options.attributions !== undefined) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }

    var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';
    var url = options.url !== undefined ? options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';
    return _super.call(this, {
      attributions: attributions,
      attributionsCollapsible: false,
      cacheSize: options.cacheSize,
      crossOrigin: crossOrigin,
      interpolate: interpolate,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
      opaque: options.opaque !== undefined ? options.opaque : true,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url: url,
      wrapX: options.wrapX,
      zDirection: options.zDirection
    }) || this;
  }

  return OSM;
}(_XYZ_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (OSM);

/***/ }),

/***/ "./build/wg/source/Raster.js":
/*!***********************************!*\
  !*** ./build/wg/source/Raster.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "newImageData": function() { return /* binding */ newImageData; },
/* harmony export */   "Processor": function() { return /* binding */ Processor; },
/* harmony export */   "RasterSourceEvent": function() { return /* binding */ RasterSourceEvent; }
/* harmony export */ });
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./build/wg/Disposable.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../ImageCanvas.js */ "./build/wg/ImageCanvas.js");
/* harmony import */ var _layer_Image_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../layer/Image.js */ "./build/wg/layer/Image.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Image.js */ "./build/wg/source/Image.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Source.js */ "./build/wg/source/Source.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./State.js */ "./build/wg/source/State.js");
/* harmony import */ var _layer_Tile_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../layer/Tile.js */ "./build/wg/layer/Tile.js");
/* harmony import */ var _TileQueue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../TileQueue.js */ "./build/wg/TileQueue.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Tile.js */ "./build/wg/source/Tile.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../dom.js */ "./build/wg/dom.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/source/Raster
 */


















var hasImageData = true;

try {
  new ImageData(10, 10);
} catch (_) {
  hasImageData = false;
}
/** @type {CanvasRenderingContext2D} */


var context;
/**
 * @param {Uint8ClampedArray} data Image data.
 * @param {number} width Number of columns.
 * @param {number} height Number of rows.
 * @return {ImageData} Image data.
 */

function newImageData(data, width, height) {
  if (hasImageData) {
    return new ImageData(data, width, height);
  }

  if (!context) {
    context = document.createElement('canvas').getContext('2d');
  }

  var imageData = context.createImageData(width, height);
  imageData.data.set(data);
  return imageData;
}
/**
 * @typedef {Object} MinionData
 * @property {Array<ArrayBuffer>} buffers Array of buffers.
 * @property {Object} meta Operation metadata.
 * @property {boolean} imageOps The operation is an image operation.
 * @property {number} width The width of the image.
 * @property {number} height The height of the image.
 */

/* istanbul ignore next */

/**
 * Create a function for running operations.  This function is serialized for
 * use in a worker.
 * @param {function(Array, Object):*} operation The operation.
 * @return {function(MinionData):ArrayBuffer} A function that takes an object with
 * buffers, meta, imageOps, width, and height properties and returns an array
 * buffer.
 */

function createMinion(operation) {
  var workerHasImageData = true;

  try {
    new ImageData(10, 10);
  } catch (_) {
    workerHasImageData = false;
  }

  function newWorkerImageData(data, width, height) {
    if (workerHasImageData) {
      return new ImageData(data, width, height);
    } else {
      return {
        data: data,
        width: width,
        height: height
      };
    }
  }

  return function (data) {
    // bracket notation for minification support
    var buffers = data['buffers'];
    var meta = data['meta'];
    var imageOps = data['imageOps'];
    var width = data['width'];
    var height = data['height'];
    var numBuffers = buffers.length;
    var numBytes = buffers[0].byteLength;

    if (imageOps) {
      var images = new Array(numBuffers);

      for (var b = 0; b < numBuffers; ++b) {
        images[b] = newWorkerImageData(new Uint8ClampedArray(buffers[b]), width, height);
      }

      var output_1 = operation(images, meta).data;
      return output_1.buffer;
    }

    var output = new Uint8ClampedArray(numBytes);
    var arrays = new Array(numBuffers);
    var pixels = new Array(numBuffers);

    for (var b = 0; b < numBuffers; ++b) {
      arrays[b] = new Uint8ClampedArray(buffers[b]);
      pixels[b] = [0, 0, 0, 0];
    }

    for (var i = 0; i < numBytes; i += 4) {
      for (var j = 0; j < numBuffers; ++j) {
        var array = arrays[j];
        pixels[j][0] = array[i];
        pixels[j][1] = array[i + 1];
        pixels[j][2] = array[i + 2];
        pixels[j][3] = array[i + 3];
      }

      var pixel = operation(pixels, meta);
      output[i] = pixel[0];
      output[i + 1] = pixel[1];
      output[i + 2] = pixel[2];
      output[i + 3] = pixel[3];
    }

    return output.buffer;
  };
}
/**
 * Create a worker for running operations.
 * @param {ProcessorOptions} config Processor options.
 * @param {function(MessageEvent): void} onMessage Called with a message event.
 * @return {Worker} The worker.
 */


function createWorker(config, onMessage) {
  var lib = Object.keys(config.lib || {}).map(function (name) {
    return 'var ' + name + ' = ' + config.lib[name].toString() + ';';
  });
  var lines = lib.concat(['var __minion__ = (' + createMinion.toString() + ')(', config.operation.toString(), ');', 'self.addEventListener("message", function(event) {', '  var buffer = __minion__(event.data);', '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);', '});']);
  var worker = new Worker(typeof Blob === 'undefined' ? 'data:text/javascript;base64,' + Buffer.from(lines.join('\n'), 'binary').toString('base64') : URL.createObjectURL(new Blob(lines, {
    type: 'text/javascript'
  })));
  worker.addEventListener('message', onMessage);
  return worker;
}
/**
 * @typedef {Object} FauxMessageEvent
 * @property {Object} data Message data.
 */

/**
 * Create a faux worker for running operations.
 * @param {ProcessorOptions} config Configuration.
 * @param {function(FauxMessageEvent): void} onMessage Called with a message event.
 * @return {Object} The faux worker.
 */


function createFauxWorker(config, onMessage) {
  var minion = createMinion(config.operation);
  var terminated = false;
  return {
    postMessage: function postMessage(data) {
      setTimeout(function () {
        if (terminated) {
          return;
        }

        onMessage({
          data: {
            buffer: minion(data),
            meta: data['meta']
          }
        });
      }, 0);
    },
    terminate: function terminate() {
      terminated = true;
    }
  };
}
/**
 * @typedef {function(Error, ImageData, (Object|Array<Object>)): void} JobCallback
 */

/**
 * @typedef {Object} Job
 * @property {Object} meta Job metadata.
 * @property {Array<ImageData>} inputs Array of input data.
 * @property {JobCallback} callback Called when the job is complete.
 */

/**
 * @typedef {Object} ProcessorOptions
 * @property {number} threads Number of workers to spawn.
 * @property {Operation} operation The operation.
 * @property {Object<string, Function>} [lib] Functions that will be made available to operations run in a worker.
 * @property {number} queue The number of queued jobs to allow.
 * @property {boolean} [imageOps=false] Pass all the image data to the operation instead of a single pixel.
 */

/**
 * @classdesc
 * A processor runs pixel or image operations in workers.
 */


var Processor =
/** @class */
function (_super) {
  __extends(Processor, _super);
  /**
   * @param {ProcessorOptions} config Configuration.
   */


  function Processor(config) {
    var _this = _super.call(this) || this;

    _this._imageOps = !!config.imageOps;
    var threads;

    if (config.threads === 0) {
      threads = 0;
    } else if (_this._imageOps) {
      threads = 1;
    } else {
      threads = config.threads || 1;
    }
    /**
     * @type {Array<Worker>}
     */


    var workers = new Array(threads);

    if (threads) {
      for (var i = 0; i < threads; ++i) {
        workers[i] = createWorker(config, _this._onWorkerMessage.bind(_this, i));
      }
    } else {
      workers[0] = createFauxWorker(config, _this._onWorkerMessage.bind(_this, 0));
    }

    _this._workers = workers;
    /**
     * @type {Array<Job>}
     * @private
     */

    _this._queue = [];
    _this._maxQueueLength = config.queue || Infinity;
    _this._running = 0;
    /**
     * @type {Object<number, any>}
     * @private
     */

    _this._dataLookup = {};
    /**
     * @type {Job}
     * @private
     */

    _this._job = null;
    return _this;
  }
  /**
   * Run operation on input data.
   * @param {Array<ImageData>} inputs Array of image data.
   * @param {Object} meta A user data object.  This is passed to all operations
   *     and must be serializable.
   * @param {function(Error, ImageData, Object): void} callback Called when work
   *     completes.  The first argument is any error.  The second is the ImageData
   *     generated by operations.  The third is the user data object.
   */


  Processor.prototype.process = function (inputs, meta, callback) {
    this._enqueue({
      inputs: inputs,
      meta: meta,
      callback: callback
    });

    this._dispatch();
  };
  /**
   * Add a job to the queue.
   * @param {Job} job The job.
   */


  Processor.prototype._enqueue = function (job) {
    this._queue.push(job);

    while (this._queue.length > this._maxQueueLength) {
      this._queue.shift().callback(null, null);
    }
  };
  /**
   * Dispatch a job.
   */


  Processor.prototype._dispatch = function () {
    if (this._running || this._queue.length === 0) {
      return;
    }

    var job = this._queue.shift();

    this._job = job;
    var width = job.inputs[0].width;
    var height = job.inputs[0].height;
    var buffers = job.inputs.map(function (input) {
      return input.data.buffer;
    });
    var threads = this._workers.length;
    this._running = threads;

    if (threads === 1) {
      this._workers[0].postMessage({
        buffers: buffers,
        meta: job.meta,
        imageOps: this._imageOps,
        width: width,
        height: height
      }, buffers);

      return;
    }

    var length = job.inputs[0].data.length;
    var segmentLength = 4 * Math.ceil(length / 4 / threads);

    for (var i = 0; i < threads; ++i) {
      var offset = i * segmentLength;
      var slices = [];

      for (var j = 0, jj = buffers.length; j < jj; ++j) {
        slices.push(buffers[j].slice(offset, offset + segmentLength));
      }

      this._workers[i].postMessage({
        buffers: slices,
        meta: job.meta,
        imageOps: this._imageOps,
        width: width,
        height: height
      }, slices);
    }
  };
  /**
   * Handle messages from the worker.
   * @param {number} index The worker index.
   * @param {MessageEvent} event The message event.
   */


  Processor.prototype._onWorkerMessage = function (index, event) {
    if (this.disposed) {
      return;
    }

    this._dataLookup[index] = event.data;
    --this._running;

    if (this._running === 0) {
      this._resolveJob();
    }
  };
  /**
   * Resolve a job.  If there are no more worker threads, the processor callback
   * will be called.
   */


  Processor.prototype._resolveJob = function () {
    var job = this._job;
    var threads = this._workers.length;
    var data, meta;

    if (threads === 1) {
      data = new Uint8ClampedArray(this._dataLookup[0]['buffer']);
      meta = this._dataLookup[0]['meta'];
    } else {
      var length_1 = job.inputs[0].data.length;
      data = new Uint8ClampedArray(length_1);
      meta = new Array(threads);
      var segmentLength = 4 * Math.ceil(length_1 / 4 / threads);

      for (var i = 0; i < threads; ++i) {
        var buffer = this._dataLookup[i]['buffer'];
        var offset = i * segmentLength;
        data.set(new Uint8ClampedArray(buffer), offset);
        meta[i] = this._dataLookup[i]['meta'];
      }
    }

    this._job = null;
    this._dataLookup = {};
    job.callback(null, newImageData(data, job.inputs[0].width, job.inputs[0].height), meta);

    this._dispatch();
  };
  /**
   * Terminate all workers associated with the processor.
   */


  Processor.prototype.disposeInternal = function () {
    for (var i = 0; i < this._workers.length; ++i) {
      this._workers[i].terminate();
    }

    this._workers.length = 0;
  };

  return Processor;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/**
 * A function that takes an array of input data, performs some operation, and
 * returns an array of output data.
 * For `pixel` type operations, the function will be called with an array of
 * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the
 * range of 0 - 255. It should return a single pixel array.
 * For `'image'` type operations, functions will be called with an array of
 * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)
 * and should return a single
 * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).
 * The operations
 * are called with a second "data" argument, which can be used for storage.  The
 * data object is accessible from raster events, where it can be initialized in
 * "beforeoperations" and accessed again in "afteroperations".
 *
 * @typedef {function((Array<Array<number>>|Array<ImageData>), Object):
 *     (Array<number>|ImageData)} Operation
 */

/**
 * @enum {string}
 */

var RasterEventType = {
  /**
   * Triggered before operations are run.  Listeners will receive an event object with
   * a `data` property that can be used to make data available to operations.
   * @event module:wg/source/Raster.RasterSourceEvent#beforeoperations
   * @api
   */
  BEFOREOPERATIONS: 'beforeoperations',

  /**
   * Triggered after operations are run.  Listeners will receive an event object with
   * a `data` property.  If more than one thread is used, `data` will be an array of
   * objects.  If a single thread is used, `data` will be a single object.
   * @event module:wg/source/Raster.RasterSourceEvent#afteroperations
   * @api
   */
  AFTEROPERATIONS: 'afteroperations'
};
/**
 * Raster operation type. Supported values are `'pixel'` and `'image'`.
 * @enum {string}
 */

var RasterOperationType = {
  PIXEL: 'pixel',
  IMAGE: 'image'
};
/**
 * @typedef {import("./Image.js").ImageSourceEventTypes|'beforeoperations'|'afteroperations'} RasterSourceEventTypes
 */

/**
 * @classdesc
 * Events emitted by {@link module:wg/source/Raster~RasterSource} instances are instances of this
 * type.
 */

var RasterSourceEvent =
/** @class */
function (_super) {
  __extends(RasterSourceEvent, _super);
  /**
   * @param {string} type Type.
   * @param {import("../PluggableMap.js").FrameState} frameState The frame state.
   * @param {Object|Array<Object>} data An object made available to operations.  For "afteroperations" evenets
   * this will be an array of objects if more than one thread is used.
   */


  function RasterSourceEvent(type, frameState, data) {
    var _this = _super.call(this, type) || this;
    /**
     * The raster extent.
     * @type {import("../extent.js").Extent}
     * @api
     */


    _this.extent = frameState.extent;
    /**
     * The pixel resolution (map units per pixel).
     * @type {number}
     * @api
     */

    _this.resolution = frameState.viewState.resolution / frameState.pixelRatio;
    /**
     * An object made available to all operations.  This can be used by operations
     * as a storage object (e.g. for calculating statistics).
     * @type {Object}
     * @api
     */

    _this.data = data;
    return _this;
  }

  return RasterSourceEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/**
 * @typedef {Object} Options
 * @property {Array<import("./Source.js").default|import("../layer/Layer.js").default>} sources Input
 * sources or layers.  For vector data, use an VectorImage layer.
 * @property {Operation} [operation] Raster operation.
 * The operation will be called with data from input sources
 * and the output will be assigned to the raster source.
 * @property {Object} [lib] Functions that will be made available to operations run in a worker.
 * @property {number} [threads] By default, operations will be run in a single worker thread.
 * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can
 * be run in multiple worker threads.  Note that there is additional overhead in
 * transferring data to multiple workers, and that depending on the user's
 * system, it may not be possible to parallelize the work.
 * @property {RasterOperationType} [operationType='pixel'] Operation type.
 * Supported values are `'pixel'` and `'image'`.  By default,
 * `'pixel'` operations are assumed, and operations will be called with an
 * array of pixels from input sources.  If set to `'image'`, operations will
 * be called with an array of ImageData objects from input sources.
 */

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./Image.js").ImageSourceEventTypes, import("./Image.js").ImageSourceEvent, Return> &
 *   import("../Observable").OnSignature<RasterSourceEventTypes, RasterSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types
 *     |RasterSourceEventTypes, Return>} RasterSourceOnSignature
 */

/**
 * @classdesc
 * A source that transforms data from any number of input sources using an
 * {@link module:wg/source/Raster~Operation} function to transform input pixel values into
 * output pixel values.
 *
 * @fires module:wg/source/Raster.RasterSourceEvent
 * @api
 */

var RasterSource =
/** @class */
function (_super) {
  __extends(RasterSource, _super);
  /**
   * @param {Options} options Options.
   */


  function RasterSource(options) {
    var _this = _super.call(this, {
      projection: null
    }) || this;
    /***
     * @type {RasterSourceOnSignature<import("../events").EventsKey>}
     */


    _this.on;
    /***
     * @type {RasterSourceOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {RasterSourceOnSignature<void>}
     */

    _this.un;
    /**
     * @private
     * @type {Processor}
     */

    _this.processor_ = null;
    /**
     * @private
     * @type {RasterOperationType}
     */

    _this.operationType_ = options.operationType !== undefined ? options.operationType : RasterOperationType.PIXEL;
    /**
     * @private
     * @type {number}
     */

    _this.threads_ = options.threads !== undefined ? options.threads : 1;
    /**
     * @private
     * @type {Array<import("../layer/Layer.js").default>}
     */

    _this.layers_ = createLayers(options.sources);

    var changed = _this.changed.bind(_this);

    for (var i = 0, ii = _this.layers_.length; i < ii; ++i) {
      _this.layers_[i].addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, changed);
    }
    /**
     * @private
     * @type {import("../TileQueue.js").default}
     */


    _this.tileQueue_ = new _TileQueue_js__WEBPACK_IMPORTED_MODULE_3__["default"](function () {
      return 1;
    }, _this.changed.bind(_this));
    /**
     * The most recently requested frame state.
     * @type {import("../PluggableMap.js").FrameState}
     * @private
     */

    _this.requestedFrameState_;
    /**
     * The most recently rendered image canvas.
     * @type {import("../ImageCanvas.js").default}
     * @private
     */

    _this.renderedImageCanvas_ = null;
    /**
     * The most recently rendered revision.
     * @type {number}
     */

    _this.renderedRevision_;
    /**
     * @private
     * @type {import("../PluggableMap.js").FrameState}
     */

    _this.frameState_ = {
      animate: false,
      coordinateToPixelTransform: (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.create)(),
      declutterTree: null,
      extent: null,
      index: 0,
      layerIndex: 0,
      layerStatesArray: getLayerStatesArray(_this.layers_),
      pixelRatio: 1,
      pixelToCoordinateTransform: (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.create)(),
      postRenderFunctions: [],
      size: [0, 0],
      tileQueue: _this.tileQueue_,
      time: Date.now(),
      usedTiles: {},
      viewState:
      /** @type {import("../View.js").State} */
      {
        rotation: 0
      },
      viewHints: [],
      wantedTiles: {},
      mapId: (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(_this),
      renderTargets: {}
    };

    _this.setAttributions(function (frameState) {
      var attributions = [];

      for (var index = 0, iMax = options.sources.length; index < iMax; ++index) {
        var sourceOrLayer = options.sources[index];
        var source = sourceOrLayer instanceof _Source_js__WEBPACK_IMPORTED_MODULE_6__["default"] ? sourceOrLayer : sourceOrLayer.getSource();
        var attributionGetter = source.getAttributions();

        if (typeof attributionGetter === 'function') {
          var sourceAttribution = attributionGetter(frameState);
          attributions.push.apply(attributions, sourceAttribution);
        }
      }

      return attributions.length !== 0 ? attributions : null;
    });

    if (options.operation !== undefined) {
      _this.setOperation(options.operation, options.lib);
    }

    return _this;
  }
  /**
   * Set the operation.
   * @param {Operation} operation New operation.
   * @param {Object} [opt_lib] Functions that will be available to operations run
   *     in a worker.
   * @api
   */


  RasterSource.prototype.setOperation = function (operation, opt_lib) {
    if (this.processor_) {
      this.processor_.dispose();
    }

    this.processor_ = new Processor({
      operation: operation,
      imageOps: this.operationType_ === RasterOperationType.IMAGE,
      queue: 1,
      lib: opt_lib,
      threads: this.threads_
    });
    this.changed();
  };
  /**
   * Update the stored frame state.
   * @param {import("../extent.js").Extent} extent The view extent (in map units).
   * @param {number} resolution The view resolution.
   * @param {import("../proj/Projection.js").default} projection The view projection.
   * @return {import("../PluggableMap.js").FrameState} The updated frame state.
   * @private
   */


  RasterSource.prototype.updateFrameState_ = function (extent, resolution, projection) {
    var frameState =
    /** @type {import("../PluggableMap.js").FrameState} */
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.assign)({}, this.frameState_);
    frameState.viewState =
    /** @type {import("../View.js").State} */
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.assign)({}, frameState.viewState);
    var center = (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getCenter)(extent);
    frameState.extent = extent.slice();
    frameState.size[0] = Math.round((0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getWidth)(extent) / resolution);
    frameState.size[1] = Math.round((0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getHeight)(extent) / resolution);
    frameState.time = Date.now();
    var viewState = frameState.viewState;
    viewState.center = center;
    viewState.projection = projection;
    viewState.resolution = resolution;
    return frameState;
  };
  /**
   * Determine if all sources are ready.
   * @return {boolean} All sources are ready.
   * @private
   */


  RasterSource.prototype.allSourcesReady_ = function () {
    var ready = true;
    var source;

    for (var i = 0, ii = this.layers_.length; i < ii; ++i) {
      source = this.layers_[i].getSource();

      if (source.getState() !== _State_js__WEBPACK_IMPORTED_MODULE_9__["default"].READY) {
        ready = false;
        break;
      }
    }

    return ready;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageCanvas.js").default} Single image.
   */


  RasterSource.prototype.getImage = function (extent, resolution, pixelRatio, projection) {
    if (!this.allSourcesReady_()) {
      return null;
    }

    var frameState = this.updateFrameState_(extent, resolution, projection);
    this.requestedFrameState_ = frameState; // check if we can't reuse the existing ol/ImageCanvas

    if (this.renderedImageCanvas_) {
      var renderedResolution = this.renderedImageCanvas_.getResolution();
      var renderedExtent = this.renderedImageCanvas_.getExtent();

      if (resolution !== renderedResolution || !(0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.equals)(extent, renderedExtent)) {
        this.renderedImageCanvas_ = null;
      }
    }

    if (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) {
      this.processSources_();
    }

    frameState.tileQueue.loadMoreTiles(16, 16);

    if (frameState.animate) {
      requestAnimationFrame(this.changed.bind(this));
    }

    return this.renderedImageCanvas_;
  };
  /**
   * Start processing source data.
   * @private
   */


  RasterSource.prototype.processSources_ = function () {
    var frameState = this.requestedFrameState_;
    var len = this.layers_.length;
    var imageDatas = new Array(len);

    for (var i = 0; i < len; ++i) {
      frameState.layerIndex = i;
      var imageData = getImageData(this.layers_[i], frameState);

      if (imageData) {
        imageDatas[i] = imageData;
      } else {
        return;
      }
    }

    var data = {};
    this.dispatchEvent(new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data));
    this.processor_.process(imageDatas, data, this.onWorkerComplete_.bind(this, frameState));
  };
  /**
   * Called when pixel processing is complete.
   * @param {import("../PluggableMap.js").FrameState} frameState The frame state.
   * @param {Error} err Any error during processing.
   * @param {ImageData} output The output image data.
   * @param {Object|Array<Object>} data The user data (or an array if more than one thread).
   * @private
   */


  RasterSource.prototype.onWorkerComplete_ = function (frameState, err, output, data) {
    if (err || !output) {
      return;
    } // do nothing if extent or resolution changed


    var extent = frameState.extent;
    var resolution = frameState.viewState.resolution;

    if (resolution !== this.requestedFrameState_.viewState.resolution || !(0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.equals)(extent, this.requestedFrameState_.extent)) {
      return;
    }

    var context;

    if (this.renderedImageCanvas_) {
      context = this.renderedImageCanvas_.getImage().getContext('2d');
    } else {
      var width = Math.round((0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getWidth)(extent) / resolution);
      var height = Math.round((0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getHeight)(extent) / resolution);
      context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_10__.createCanvasContext2D)(width, height);
      this.renderedImageCanvas_ = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_11__["default"](extent, resolution, 1, context.canvas);
    }

    context.putImageData(output, 0, 0);
    this.changed();
    this.renderedRevision_ = this.getRevision();
    this.dispatchEvent(new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data));

    if (frameState.animate) {
      requestAnimationFrame(this.changed.bind(this));
    }
  };

  RasterSource.prototype.disposeInternal = function () {
    if (this.processor_) {
      this.processor_.dispose();
    }

    _super.prototype.disposeInternal.call(this);
  };

  return RasterSource;
}(_Image_js__WEBPACK_IMPORTED_MODULE_12__["default"]);
/**
 * Clean up and unregister the worker.
 * @function
 * @api
 */


RasterSource.prototype.dispose;
/**
 * A reusable canvas context.
 * @type {CanvasRenderingContext2D}
 * @private
 */

var sharedContext = null;
/**
 * Get image data from a layer.
 * @param {import("../layer/Layer.js").default} layer Layer to render.
 * @param {import("../PluggableMap.js").FrameState} frameState The frame state.
 * @return {ImageData} The image data.
 */

function getImageData(layer, frameState) {
  var renderer = layer.getRenderer();

  if (!renderer) {
    throw new Error('Unsupported layer type: ' + layer);
  }

  if (!renderer.prepareFrame(frameState)) {
    return null;
  }

  var width = frameState.size[0];
  var height = frameState.size[1];

  if (width === 0 || height === 0) {
    return null;
  }

  var container = renderer.renderFrame(frameState, null);
  var element;

  if (container instanceof HTMLCanvasElement) {
    element = container;
  } else {
    if (container) {
      element = container.firstElementChild;
    }

    if (!(element instanceof HTMLCanvasElement)) {
      throw new Error('Unsupported rendered element: ' + element);
    }

    if (element.width === width && element.height === height) {
      var context_1 = element.getContext('2d');
      return context_1.getImageData(0, 0, width, height);
    }
  }

  if (!sharedContext) {
    sharedContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_10__.createCanvasContext2D)(width, height);
  } else {
    var canvas = sharedContext.canvas;

    if (canvas.width !== width || canvas.height !== height) {
      sharedContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_10__.createCanvasContext2D)(width, height);
    } else {
      sharedContext.clearRect(0, 0, width, height);
    }
  }

  sharedContext.drawImage(element, 0, 0, width, height);
  return sharedContext.getImageData(0, 0, width, height);
}
/**
 * Get a list of layer states from a list of layers.
 * @param {Array<import("../layer/Layer.js").default>} layers Layers.
 * @return {Array<import("../layer/Layer.js").State>} The layer states.
 */


function getLayerStatesArray(layers) {
  return layers.map(function (layer) {
    return layer.getLayerState();
  });
}
/**
 * Create layers for all sources.
 * @param {Array<import("./Source.js").default|import("../layer/Layer.js").default>} sources The sources.
 * @return {Array<import("../layer/Layer.js").default>} Array of layers.
 */


function createLayers(sources) {
  var len = sources.length;
  var layers = new Array(len);

  for (var i = 0; i < len; ++i) {
    layers[i] = createLayer(sources[i]);
  }

  return layers;
}
/**
 * Create a layer for the provided source.
 * @param {import("./Source.js").default|import("../layer/Layer.js").default} layerOrSource The layer or source.
 * @return {import("../layer/Layer.js").default} The layer.
 */


function createLayer(layerOrSource) {
  // @type {import("../layer/Layer.js").default}
  var layer;

  if (layerOrSource instanceof _Source_js__WEBPACK_IMPORTED_MODULE_6__["default"]) {
    if (layerOrSource instanceof _Tile_js__WEBPACK_IMPORTED_MODULE_13__["default"]) {
      layer = new _layer_Tile_js__WEBPACK_IMPORTED_MODULE_14__["default"]({
        source: layerOrSource
      });
    } else if (layerOrSource instanceof _Image_js__WEBPACK_IMPORTED_MODULE_12__["default"]) {
      layer = new _layer_Image_js__WEBPACK_IMPORTED_MODULE_15__["default"]({
        source: layerOrSource
      });
    }
  } else {
    layer = layerOrSource;
  }

  return layer;
}

/* harmony default export */ __webpack_exports__["default"] = (RasterSource);

/***/ }),

/***/ "./build/wg/source/Source.js":
/*!***********************************!*\
  !*** ./build/wg/source/Source.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Object.js */ "./build/wg/Object.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./State.js */ "./build/wg/source/State.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/source/Source
 */






/**
 * A function that takes a {@link module:wg/PluggableMap~FrameState} and returns a string or
 * an array of strings representing source attributions.
 *
 * @typedef {function(import("../PluggableMap.js").FrameState): (string|Array<string>)} Attribution
 */

/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings ({@link module:wg/source/Source~Attribution})
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */

/**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("./State.js").default} [state='ready'] State.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:wg/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */

var Source =
/** @class */
function (_super) {
  __extends(Source, _super);
  /**
   * @param {Options} options Source options.
   */


  function Source(options) {
    var _this = _super.call(this) || this;
    /**
     * @protected
     * @type {import("../proj/Projection.js").default}
     */


    _this.projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.projection);
    /**
     * @private
     * @type {?Attribution}
     */

    _this.attributions_ = adaptAttributions(options.attributions);
    /**
     * @private
     * @type {boolean}
     */

    _this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ? options.attributionsCollapsible : true;
    /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */

    _this.loading = false;
    /**
     * @private
     * @type {import("./State.js").default}
     */

    _this.state_ = options.state !== undefined ? options.state : _State_js__WEBPACK_IMPORTED_MODULE_1__["default"].READY;
    /**
     * @private
     * @type {boolean}
     */

    _this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
    /**
     * @private
     * @type {boolean}
     */

    _this.interpolate_ = !!options.interpolate;
    /**
     * @protected
     * @type {function(import("../View.js").ViewOptions):void}
     */

    _this.viewResolver = null;
    /**
     * @protected
     * @type {function(Error):void}
     */

    _this.viewRejector = null;
    var self = _this;
    /**
     * @private
     * @type {Promise<import("../View.js").ViewOptions>}
     */

    _this.viewPromise_ = new Promise(function (resolve, reject) {
      self.viewResolver = resolve;
      self.viewRejector = reject;
    });
    return _this;
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */


  Source.prototype.getAttributions = function () {
    return this.attributions_;
  };
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */


  Source.prototype.getAttributionsCollapsible = function () {
    return this.attributionsCollapsible_;
  };
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */


  Source.prototype.getProjection = function () {
    return this.projection;
  };
  /**
   * @abstract
   * @return {Array<number>|null} Resolutions.
   */


  Source.prototype.getResolutions = function () {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.abstract)();
  };
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */


  Source.prototype.getView = function () {
    return this.viewPromise_;
  };
  /**
   * Get the state of the source, see {@link module:wg/source/State~State} for possible states.
   * @return {import("./State.js").default} State.
   * @api
   */


  Source.prototype.getState = function () {
    return this.state_;
  };
  /**
   * @return {boolean|undefined} Wrap X.
   */


  Source.prototype.getWrapX = function () {
    return this.wrapX_;
  };
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */


  Source.prototype.getInterpolate = function () {
    return this.interpolate_;
  };
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */


  Source.prototype.refresh = function () {
    this.changed();
  };
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:wg/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */


  Source.prototype.setAttributions = function (attributions) {
    this.attributions_ = adaptAttributions(attributions);
    this.changed();
  };
  /**
   * Set the state of the source.
   * @param {import("./State.js").default} state State.
   */


  Source.prototype.setState = function (state) {
    this.state_ = state;
    this.changed();
  };

  return Source;
}(_Object_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {Attribution|null} An attribution function (or null).
 */


function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }

  if (Array.isArray(attributionLike)) {
    return function (frameState) {
      return attributionLike;
    };
  }

  if (typeof attributionLike === 'function') {
    return attributionLike;
  }

  return function (frameState) {
    return [attributionLike];
  };
}

/* harmony default export */ __webpack_exports__["default"] = (Source);

/***/ }),

/***/ "./build/wg/source/Stamen.js":
/*!***********************************!*\
  !*** ./build/wg/source/Stamen.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _XYZ_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XYZ.js */ "./build/wg/source/XYZ.js");
/* harmony import */ var _OSM_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OSM.js */ "./build/wg/source/OSM.js");
/**
 * @module wg/source/Stamen
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();



/**
 * @const
 * @type {Array<string>}
 */

var ATTRIBUTIONS = ['Map tiles by <a href="https://stamen.com/" target="_blank">Stamen Design</a>, ' + 'under <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">CC BY' + ' 3.0</a>.', _OSM_js__WEBPACK_IMPORTED_MODULE_0__.ATTRIBUTION];
/**
 * @type {Object<string, {extension: string, opaque: boolean}>}
 */

var LayerConfig = {
  'terrain': {
    extension: 'jpg',
    opaque: true
  },
  'terrain-background': {
    extension: 'jpg',
    opaque: true
  },
  'terrain-labels': {
    extension: 'png',
    opaque: false
  },
  'terrain-lines': {
    extension: 'png',
    opaque: false
  },
  'toner-background': {
    extension: 'png',
    opaque: true
  },
  'toner': {
    extension: 'png',
    opaque: true
  },
  'toner-hybrid': {
    extension: 'png',
    opaque: false
  },
  'toner-labels': {
    extension: 'png',
    opaque: false
  },
  'toner-lines': {
    extension: 'png',
    opaque: false
  },
  'toner-lite': {
    extension: 'png',
    opaque: true
  },
  'watercolor': {
    extension: 'jpg',
    opaque: true
  }
};
/**
 * @type {Object<string, {minZoom: number, maxZoom: number}>}
 */

var ProviderConfig = {
  'terrain': {
    minZoom: 0,
    maxZoom: 18
  },
  'toner': {
    minZoom: 0,
    maxZoom: 20
  },
  'watercolor': {
    minZoom: 0,
    maxZoom: 18
  }
};
/**
 * @typedef {Object} Options
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {string} layer Layer name.
 * @property {number} [minZoom] Minimum zoom.
 * @property {number} [maxZoom] Maximum zoom.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction]
 * Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for the Stamen tile server.
 * @api
 */

var Stamen =
/** @class */
function (_super) {
  __extends(Stamen, _super);
  /**
   * @param {Options} options Stamen options.
   */


  function Stamen(options) {
    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    var i = options.layer.indexOf('-');
    var provider = i == -1 ? options.layer : options.layer.slice(0, i);
    var providerConfig = ProviderConfig[provider];
    var layerConfig = LayerConfig[options.layer];
    var url = options.url !== undefined ? options.url : 'https://stamen-tiles-{a-d}.a.ssl.fastly.net/' + options.layer + '/{z}/{x}/{y}.' + layerConfig.extension;
    return _super.call(this, {
      attributions: ATTRIBUTIONS,
      cacheSize: options.cacheSize,
      crossOrigin: 'anonymous',
      interpolate: interpolate,
      maxZoom: options.maxZoom != undefined ? options.maxZoom : providerConfig.maxZoom,
      minZoom: options.minZoom != undefined ? options.minZoom : providerConfig.minZoom,
      opaque: layerConfig.opaque,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url: url,
      wrapX: options.wrapX,
      zDirection: options.zDirection
    }) || this;
  }

  return Stamen;
}(_XYZ_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Stamen);

/***/ }),

/***/ "./build/wg/source/State.js":
/*!**********************************!*\
  !*** ./build/wg/source/State.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/source/State
 */

/**
 * @enum {string}
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  UNDEFINED: 'undefined',
  LOADING: 'loading',
  READY: 'ready',
  ERROR: 'error'
});

/***/ }),

/***/ "./build/wg/source/Tile.js":
/*!*********************************!*\
  !*** ./build/wg/source/Tile.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TileSourceEvent": function() { return /* binding */ TileSourceEvent; }
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Source.js */ "./build/wg/source/Source.js");
/* harmony import */ var _TileCache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileCache.js */ "./build/wg/TileCache.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../TileState.js */ "./build/wg/TileState.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tilecoord.js */ "./build/wg/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tilegrid.js */ "./build/wg/tilegrid.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../size.js */ "./build/wg/size.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/source/Tile
 */












/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./TileEventType").TileSourceEventTypes, TileSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./TileEventType").TileSourceEventTypes, Return>} TileSourceOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] CacheSize.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./State.js").default} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * @abstract
 * @api
 */

var TileSource =
/** @class */
function (_super) {
  __extends(TileSource, _super);
  /**
   * @param {Options} options SourceTile source options.
   */


  function TileSource(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate
    }) || this;
    /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */


    _this.on;
    /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {TileSourceOnSignature<void>}
     */

    _this.un;
    /**
     * @private
     * @type {boolean}
     */

    _this.opaque_ = options.opaque !== undefined ? options.opaque : false;
    /**
     * @private
     * @type {number}
     */

    _this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;
    /**
     * @type {import("../tilegrid/TileGrid.js").default|null}
     */

    _this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;
    var tileSize = [256, 256];

    if (_this.tileGrid) {
      (0,_size_js__WEBPACK_IMPORTED_MODULE_1__.toSize)(_this.tileGrid.getTileSize(_this.tileGrid.getMinZoom()), tileSize);
    }
    /**
     * @protected
     * @type {import("../TileCache.js").default}
     */


    _this.tileCache = new _TileCache_js__WEBPACK_IMPORTED_MODULE_2__["default"](options.cacheSize || 0);
    /**
     * @protected
     * @type {import("../size.js").Size}
     */

    _this.tmpSize = [0, 0];
    /**
     * @private
     * @type {string}
     */

    _this.key_ = options.key || '';
    /**
     * @protected
     * @type {import("../Tile.js").Options}
     */

    _this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate
    };
    /**
     * zDirection hint, read by the renderer. Indicates which resolution should be used
     * by a renderer if the views resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @type {number|import("../array.js").NearestDirectionFunction}
     */

    _this.zDirection = options.zDirection ? options.zDirection : 0;
    return _this;
  }
  /**
   * @return {boolean} Can expire cache.
   */


  TileSource.prototype.canExpireCache = function () {
    return this.tileCache.canExpireCache();
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */


  TileSource.prototype.expireCache = function (projection, usedTiles) {
    var tileCache = this.getTileCacheForProjection(projection);

    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */


  TileSource.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {
    var tileCache = this.getTileCacheForProjection(projection);

    if (!tileCache) {
      return false;
    }

    var covered = true;
    var tile, tileCoordKey, loaded;

    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_3__.getKeyZXY)(z, x, y);
        loaded = false;

        if (tileCache.containsKey(tileCoordKey)) {
          tile =
          /** @type {!import("../Tile.js").default} */
          tileCache.get(tileCoordKey);
          loaded = tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED;

          if (loaded) {
            loaded = callback(tile) !== false;
          }
        }

        if (!loaded) {
          covered = false;
        }
      }
    }

    return covered;
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */


  TileSource.prototype.getGutterForProjection = function (projection) {
    return 0;
  };
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */


  TileSource.prototype.getKey = function () {
    return this.key_;
  };
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */


  TileSource.prototype.setKey = function (key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */


  TileSource.prototype.getOpaque = function (projection) {
    return this.opaque_;
  };
  /**
   * @return {Array<number>|null} Resolutions.
   */


  TileSource.prototype.getResolutions = function () {
    if (!this.tileGrid) {
      return null;
    }

    return this.tileGrid.getResolutions();
  };
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */


  TileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  };
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */


  TileSource.prototype.getTileGrid = function () {
    return this.tileGrid;
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */


  TileSource.prototype.getTileGridForProjection = function (projection) {
    if (!this.tileGrid) {
      return (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_6__.getForProjection)(projection);
    } else {
      return this.tileGrid;
    }
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */


  TileSource.prototype.getTileCacheForProjection = function (projection) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)((0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(this.getProjection(), projection), 68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.
    );
    return this.tileCache;
  };
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */


  TileSource.prototype.getTilePixelRatio = function (pixelRatio) {
    return this.tilePixelRatio_;
  };
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */


  TileSource.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
    var tileGrid = this.getTileGridForProjection(projection);
    var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_1__.toSize)(tileGrid.getTileSize(z), this.tmpSize);

    if (tilePixelRatio == 1) {
      return tileSize;
    } else {
      return (0,_size_js__WEBPACK_IMPORTED_MODULE_1__.scale)(tileSize, tilePixelRatio, this.tmpSize);
    }
  };
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [opt_projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */


  TileSource.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {
    var projection = opt_projection !== undefined ? opt_projection : this.getProjection();
    var tileGrid = this.getTileGridForProjection(projection);

    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_6__.wrapX)(tileGrid, tileCoord, projection);
    }

    return (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_3__.withinExtentAndZ)(tileCoord, tileGrid) ? tileCoord : null;
  };
  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */


  TileSource.prototype.clear = function () {
    this.tileCache.clear();
  };

  TileSource.prototype.refresh = function () {
    this.clear();

    _super.prototype.refresh.call(this);
  };
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */


  TileSource.prototype.updateCacheSize = function (tileCount, projection) {
    var tileCache = this.getTileCacheForProjection(projection);

    if (tileCount > tileCache.highWaterMark) {
      tileCache.highWaterMark = tileCount;
    }
  };
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */


  TileSource.prototype.useTile = function (z, x, y, projection) {};

  return TileSource;
}(_Source_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
/**
 * @classdesc
 * Events emitted by {@link module:wg/source/Tile~TileSource} instances are instances of this
 * type.
 */


var TileSourceEvent =
/** @class */
function (_super) {
  __extends(TileSourceEvent, _super);
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */


  function TileSourceEvent(type, tile) {
    var _this = _super.call(this, type) || this;
    /**
     * The tile related to the event.
     * @type {import("../Tile.js").default}
     * @api
     */


    _this.tile = tile;
    return _this;
  }

  return TileSourceEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_9__["default"]);


/* harmony default export */ __webpack_exports__["default"] = (TileSource);

/***/ }),

/***/ "./build/wg/source/TileArcGISRest.js":
/*!*******************************************!*\
  !*** ./build/wg/source/TileArcGISRest.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TileImage.js */ "./build/wg/source/TileImage.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../uri.js */ "./build/wg/uri.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../size.js */ "./build/wg/size.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tilecoord.js */ "./build/wg/tilecoord.js");
/**
 * @module wg/source/TileArcGISRest
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();








/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service defaults will be
 * used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is `IMAGE` by
 * default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`,
 * and `IMAGESR` will be set dynamically. Set `LAYERS` to
 * override the default service layer visibility. See
 * https://developers.arcgis.com/rest/services-reference/export-map.htm
 * for further reference.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid. Base this on the resolutions,
 * tilesize and extent supported by the server.
 * If this is not defined, a default grid will be used: if there is a projection
 * extent, the grid will be based on that; if not, a grid based on a global
 * extent with origin at 0,0 will be used.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * The projection code must contain a numeric end portion separated by :
 * or the entire code must form a valid ArcGIS SpatialReference definition.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL.
 * The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The
 * url should include /MapServer or /ImageServer.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.  To disable the opacity
 * transition, pass `transition: 0`.
 * @property {Array<string>} [urls] ArcGIS Rest service urls. Use this instead of `url` when the ArcGIS
 * Service supports multiple urls for export requests.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for tile data from ArcGIS Rest services. Map and Image
 * Services are supported.
 *
 * For cached ArcGIS services, better performance is available using the
 * {@link module:wg/source/XYZ~XYZ} data source.
 * @api
 */

var TileArcGISRest =
/** @class */
function (_super) {
  __extends(TileArcGISRest, _super);
  /**
   * @param {Options} [opt_options] Tile ArcGIS Rest options.
   */


  function TileArcGISRest(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: interpolate,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    }) || this;
    /**
     * @private
     * @type {!Object}
     */

    _this.params_ = options.params || {};
    /**
     * @private
     * @type {boolean}
     */

    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    _this.tmpExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createEmpty)();

    _this.setKey(_this.getKeyForParams_());

    return _this;
  }
  /**
   * @private
   * @return {string} The key for the current params.
   */


  TileArcGISRest.prototype.getKeyForParams_ = function () {
    var i = 0;
    var res = [];

    for (var key in this.params_) {
      res[i++] = key + '-' + this.params_[key];
    }

    return res.join('/');
  };
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */


  TileArcGISRest.prototype.getParams = function () {
    return this.params_;
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../size.js").Size} tileSize Tile size.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */


  TileArcGISRest.prototype.getRequestUrl_ = function (tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
    var urls = this.urls;

    if (!urls) {
      return undefined;
    } // ArcGIS Server only wants the numeric portion of the projection ID.
    // (if there is no numeric portion the entire projection code must
    // form a valid ArcGIS SpatialReference definition).


    var srid = projection.getCode().split(/:(?=\d+$)/).pop();
    params['SIZE'] = tileSize[0] + ',' + tileSize[1];
    params['BBOX'] = tileExtent.join(',');
    params['BBOXSR'] = srid;
    params['IMAGESR'] = srid;
    params['DPI'] = Math.round(params['DPI'] ? params['DPI'] * pixelRatio : 90 * pixelRatio);
    var url;

    if (urls.length == 1) {
      url = urls[0];
    } else {
      var index = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.modulo)((0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_2__.hash)(tileCoord), urls.length);
      url = urls[index];
    }

    var modifiedUrl = url.replace(/MapServer\/?$/, 'MapServer/export').replace(/ImageServer\/?$/, 'ImageServer/exportImage');
    return (0,_uri_js__WEBPACK_IMPORTED_MODULE_3__.appendParams)(modifiedUrl, params);
  };
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */


  TileArcGISRest.prototype.getTilePixelRatio = function (pixelRatio) {
    return this.hidpi_ ? pixelRatio : 1;
  };
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */


  TileArcGISRest.prototype.updateParams = function (params) {
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_4__.assign)(this.params_, params);
    this.setKey(this.getKeyForParams_());
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */


  TileArcGISRest.prototype.tileUrlFunction = function (tileCoord, pixelRatio, projection) {
    var tileGrid = this.getTileGrid();

    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projection);
    }

    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return undefined;
    }

    if (pixelRatio != 1 && !this.hidpi_) {
      pixelRatio = 1;
    }

    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);

    if (pixelRatio != 1) {
      tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.scale)(tileSize, pixelRatio, this.tmpSize);
    } // Apply default params and override with user specified values.


    var baseParams = {
      'F': 'image',
      'FORMAT': 'PNG32',
      'TRANSPARENT': true
    };
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_4__.assign)(baseParams, this.params_);
    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
  };

  return TileArcGISRest;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_6__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (TileArcGISRest);

/***/ }),

/***/ "./build/wg/source/TileDebug.js":
/*!**************************************!*\
  !*** ./build/wg/source/TileDebug.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _XYZ_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./XYZ.js */ "./build/wg/source/XYZ.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./build/wg/dom.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../size.js */ "./build/wg/size.js");
/**
 * @module wg/source/TileDebug
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();




/**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Optional projection.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Set to `1` when debugging `VectorTile` sources with a default configuration.
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 * @property {string} [template='z:{z} x:{x} y:{y}'] Template for labeling the tiles.
 * Should include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 */

/**
 * @classdesc
 * A pseudo tile source, which does not fetch tiles from a server, but renders
 * a grid outline for the tile grid/projection along with the coordinates for
 * each tile. See examples/canvas-tiles for an example.
 * @api
 */

var TileDebug =
/** @class */
function (_super) {
  __extends(TileDebug, _super);
  /**
   * @param {Options} [opt_options] Debug tile options.
   */


  function TileDebug(opt_options) {
    var _this = this;
    /**
     * @type {Options}
     */


    var options = opt_options || {};
    _this = _super.call(this, {
      opaque: false,
      projection: options.projection,
      tileGrid: options.tileGrid,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      zDirection: options.zDirection,
      url: options.template || 'z:{z} x:{x} y:{y}',
      tileLoadFunction: function tileLoadFunction(tile, text) {
        var z = tile.getTileCoord()[0];
        var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(_this.tileGrid.getTileSize(z));
        var context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(tileSize[0], tileSize[1]);
        context.strokeStyle = 'grey';
        context.strokeRect(0.5, 0.5, tileSize[0] + 0.5, tileSize[1] + 0.5);
        context.fillStyle = 'grey';
        context.strokeStyle = 'white';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.font = '24px sans-serif';
        context.lineWidth = 4;
        context.strokeText(text, tileSize[0] / 2, tileSize[1] / 2, tileSize[0]);
        context.fillText(text, tileSize[0] / 2, tileSize[1] / 2, tileSize[0]);
        /** @type {import("../ImageTile.js").default} */

        tile.setImage(context.canvas);
      }
    }) || this;
    return _this;
  }

  return TileDebug;
}(_XYZ_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (TileDebug);

/***/ }),

/***/ "./build/wg/source/TileEventType.js":
/*!******************************************!*\
  !*** ./build/wg/source/TileEventType.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/source/TileEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when a tile starts loading.
   * @event module:wg/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:wg/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error.
   * @event module:wg/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror'
});
/**
 * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes
 */

/***/ }),

/***/ "./build/wg/source/TileImage.js":
/*!**************************************!*\
  !*** ./build/wg/source/TileImage.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _ImageTile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageTile.js */ "./build/wg/ImageTile.js");
/* harmony import */ var _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../reproj/Tile.js */ "./build/wg/reproj/Tile.js");
/* harmony import */ var _TileCache_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../TileCache.js */ "./build/wg/TileCache.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../TileState.js */ "./build/wg/TileState.js");
/* harmony import */ var _UrlTile_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./UrlTile.js */ "./build/wg/source/UrlTile.js");
/* harmony import */ var _reproj_common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../reproj/common.js */ "./build/wg/reproj/common.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tilecoord.js */ "./build/wg/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tilegrid.js */ "./build/wg/tilegrid.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/source/TileImage
 */













/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./State.js").default} [state] Source state.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:wg/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [key] Optional tile key for proper cache fetching
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */

var TileImage =
/** @class */
function (_super) {
  __extends(TileImage, _super);
  /**
   * @param {!Options} options Image tile options.
   */


  function TileImage(options) {
    var _this = this;

    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    }) || this;
    /**
     * @protected
     * @type {?string}
     */

    _this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
    /**
     * @protected
     * @type {typeof ImageTile}
     */

    _this.tileClass = options.tileClass !== undefined ? options.tileClass : _ImageTile_js__WEBPACK_IMPORTED_MODULE_1__["default"];
    /**
     * @protected
     * @type {!Object<string, TileCache>}
     */

    _this.tileCacheForProjection = {};
    /**
     * @protected
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */

    _this.tileGridForProjection = {};
    /**
     * @private
     * @type {number|undefined}
     */

    _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
    /**
     * @private
     * @type {boolean}
     */

    _this.renderReprojectionEdges_ = false;
    return _this;
  }
  /**
   * @return {boolean} Can expire cache.
   */


  TileImage.prototype.canExpireCache = function () {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_2__.ENABLE_RASTER_REPROJECTION) {
      return _super.prototype.canExpireCache.call(this);
    }

    if (this.tileCache.canExpireCache()) {
      return true;
    } else {
      for (var key in this.tileCacheForProjection) {
        if (this.tileCacheForProjection[key].canExpireCache()) {
          return true;
        }
      }
    }

    return false;
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */


  TileImage.prototype.expireCache = function (projection, usedTiles) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_2__.ENABLE_RASTER_REPROJECTION) {
      _super.prototype.expireCache.call(this, projection, usedTiles);

      return;
    }

    var usedTileCache = this.getTileCacheForProjection(projection);
    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});

    for (var id in this.tileCacheForProjection) {
      var tileCache = this.tileCacheForProjection[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */


  TileImage.prototype.getGutterForProjection = function (projection) {
    if (_reproj_common_js__WEBPACK_IMPORTED_MODULE_2__.ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !(0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(this.getProjection(), projection)) {
      return 0;
    } else {
      return this.getGutter();
    }
  };
  /**
   * @return {number} Gutter.
   */


  TileImage.prototype.getGutter = function () {
    return 0;
  };
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */


  TileImage.prototype.getKey = function () {
    var key = _super.prototype.getKey.call(this);

    if (!this.getInterpolate()) {
      key += ':disable-interpolation';
    }

    return key;
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */


  TileImage.prototype.getOpaque = function (projection) {
    if (_reproj_common_js__WEBPACK_IMPORTED_MODULE_2__.ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !(0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(this.getProjection(), projection)) {
      return false;
    } else {
      return _super.prototype.getOpaque.call(this, projection);
    }
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */


  TileImage.prototype.getTileGridForProjection = function (projection) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_2__.ENABLE_RASTER_REPROJECTION) {
      return _super.prototype.getTileGridForProjection.call(this, projection);
    }

    var thisProj = this.getProjection();

    if (this.tileGrid && (!thisProj || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(thisProj, projection))) {
      return this.tileGrid;
    } else {
      var projKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.getUid)(projection);

      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_4__.getForProjection)(projection);
      }

      return this.tileGridForProjection[projKey];
    }
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */


  TileImage.prototype.getTileCacheForProjection = function (projection) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_2__.ENABLE_RASTER_REPROJECTION) {
      return _super.prototype.getTileCacheForProjection.call(this, projection);
    }

    var thisProj = this.getProjection();

    if (!thisProj || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(thisProj, projection)) {
      return this.tileCache;
    } else {
      var projKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.getUid)(projection);

      if (!(projKey in this.tileCacheForProjection)) {
        this.tileCacheForProjection[projKey] = new _TileCache_js__WEBPACK_IMPORTED_MODULE_5__["default"](this.tileCache.highWaterMark);
      }

      return this.tileCacheForProjection[projKey];
    }
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */


  TileImage.prototype.createTile_ = function (z, x, y, pixelRatio, projection, key) {
    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
    var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
    var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? _TileState_js__WEBPACK_IMPORTED_MODULE_6__["default"].IDLE : _TileState_js__WEBPACK_IMPORTED_MODULE_6__["default"].EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);
    tile.key = key;
    tile.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, this.handleTileChange.bind(this));
    return tile;
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */


  TileImage.prototype.getTile = function (z, x, y, pixelRatio, projection) {
    var sourceProjection = this.getProjection();

    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_2__.ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(sourceProjection, projection)) {
      return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
    } else {
      var cache = this.getTileCacheForProjection(projection);
      var tileCoord = [z, x, y];
      var tile = void 0;
      var tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_8__.getKey)(tileCoord);

      if (cache.containsKey(tileCoordKey)) {
        tile = cache.get(tileCoordKey);
      }

      var key = this.getKey();

      if (tile && tile.key == key) {
        return tile;
      } else {
        var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
        var targetTileGrid = this.getTileGridForProjection(projection);
        var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
        var newTile = new _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_9__["default"](sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function (z, x, y, pixelRatio) {
          return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
        }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.getInterpolate());
        newTile.key = key;

        if (tile) {
          newTile.interimTile = tile;
          newTile.refreshInterimChain();
          cache.replace(tileCoordKey, newTile);
        } else {
          cache.set(tileCoordKey, newTile);
        }

        return newTile;
      }
    }
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   * @protected
   */


  TileImage.prototype.getTileInternal = function (z, x, y, pixelRatio, projection) {
    var tile = null;
    var tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_8__.getKeyZXY)(z, x, y);
    var key = this.getKey();

    if (!this.tileCache.containsKey(tileCoordKey)) {
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);
      this.tileCache.set(tileCoordKey, tile);
    } else {
      tile = this.tileCache.get(tileCoordKey);

      if (tile.key != key) {
        // The source's params changed. If the tile has an interim tile and if we
        // can use it then we use it. Otherwise we create a new tile.  In both
        // cases we attempt to assign an interim tile to the new tile.
        var interimTile = tile;
        tile = this.createTile_(z, x, y, pixelRatio, projection, key); //make the new tile the head of the list,

        if (interimTile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_6__["default"].IDLE) {
          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
          tile.interimTile = interimTile.interimTile;
        } else {
          tile.interimTile = interimTile;
        }

        tile.refreshInterimChain();
        this.tileCache.replace(tileCoordKey, tile);
      }
    }

    return tile;
  };
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */


  TileImage.prototype.setRenderReprojectionEdges = function (render) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_2__.ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render) {
      return;
    }

    this.renderReprojectionEdges_ = render;

    for (var id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }

    this.changed();
  };
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */


  TileImage.prototype.setTileGridForProjection = function (projection, tilegrid) {
    if (_reproj_common_js__WEBPACK_IMPORTED_MODULE_2__.ENABLE_RASTER_REPROJECTION) {
      var proj = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection);

      if (proj) {
        var projKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.getUid)(proj);

        if (!(projKey in this.tileGridForProjection)) {
          this.tileGridForProjection[projKey] = tilegrid;
        }
      }
    }
  };

  return TileImage;
}(_UrlTile_js__WEBPACK_IMPORTED_MODULE_10__["default"]);
/**
 * @param {ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */


function defaultTileLoadFunction(imageTile, src) {
  /** @type {HTMLImageElement|HTMLVideoElement} */
  imageTile.getImage().src = src;
}

/* harmony default export */ __webpack_exports__["default"] = (TileImage);

/***/ }),

/***/ "./build/wg/source/TileJSON.js":
/*!*************************************!*\
  !*** ./build/wg/source/TileJSON.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./State.js */ "./build/wg/source/State.js");
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TileImage.js */ "./build/wg/source/TileImage.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tileurlfunction.js */ "./build/wg/tileurlfunction.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tilegrid.js */ "./build/wg/tilegrid.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _net_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../net.js */ "./build/wg/net.js");
/**
 * @module wg/source/TileJSON
 */
// FIXME check order of async callbacks
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * See https://mapbox.com/developers/api/.
 */










/**
 * @typedef {Object} Config
 * @property {string} [name] The name.
 * @property {string} [description] The description.
 * @property {string} [version] The version.
 * @property {string} [attribution] The attribution.
 * @property {string} [template] The template.
 * @property {string} [legend] The legend.
 * @property {string} [scheme] The scheme.
 * @property {Array<string>} tiles The tile URL templates.
 * @property {Array<string>} [grids] Optional grids.
 * @property {number} [minzoom] Minimum zoom level.
 * @property {number} [maxzoom] Maximum zoom level.
 * @property {Array<number>} [bounds] Optional bounds.
 * @property {Array<number>} [center] Optional center.
 */

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.
 * Useful when the server does not support CORS..
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {Config} [tileJSON] TileJSON configuration for this source.
 * If not provided, `url` must be configured.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * Note: `tileSize` and other non-standard TileJSON properties are currently ignored.
 * @property {string} [url] URL to the TileJSON file. If not provided, `tileJSON` must be configured.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for tile data in TileJSON format.
 * @api
 */

var TileJSON =
/** @class */
function (_super) {
  __extends(TileJSON, _super);
  /**
   * @param {Options} options TileJSON options.
   */


  function TileJSON(options) {
    var _this = this;

    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: interpolate,
      projection: (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:3857'),
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: _State_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING,
      tileLoadFunction: options.tileLoadFunction,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    }) || this;
    /**
     * @type {Config}
     * @private
     */

    _this.tileJSON_ = null;
    /**
     * @type {number|import("../size.js").Size}
     * @private
     */

    _this.tileSize_ = options.tileSize;

    if (options.url) {
      if (options.jsonp) {
        (0,_net_js__WEBPACK_IMPORTED_MODULE_2__.jsonp)(options.url, _this.handleTileJSONResponse.bind(_this), _this.handleTileJSONError.bind(_this));
      } else {
        var client = new XMLHttpRequest();
        client.addEventListener('load', _this.onXHRLoad_.bind(_this));
        client.addEventListener('error', _this.onXHRError_.bind(_this));
        client.open('GET', options.url);
        client.send();
      }
    } else if (options.tileJSON) {
      _this.handleTileJSONResponse(options.tileJSON);
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, 51); // Either `url` or `tileJSON` options must be provided
    }

    return _this;
  }
  /**
   * @private
   * @param {Event} event The load event.
   */


  TileJSON.prototype.onXHRLoad_ = function (event) {
    var client =
    /** @type {XMLHttpRequest} */
    event.target; // status will be 0 for file:// urls

    if (!client.status || client.status >= 200 && client.status < 300) {
      var response = void 0;

      try {
        response =
        /** @type {Config} */
        JSON.parse(client.responseText);
      } catch (err) {
        this.handleTileJSONError();
        return;
      }

      this.handleTileJSONResponse(response);
    } else {
      this.handleTileJSONError();
    }
  };
  /**
   * @private
   * @param {Event} event The error event.
   */


  TileJSON.prototype.onXHRError_ = function (event) {
    this.handleTileJSONError();
  };
  /**
   * @return {Config} The tilejson object.
   * @api
   */


  TileJSON.prototype.getTileJSON = function () {
    return this.tileJSON_;
  };
  /**
   * @protected
   * @param {Config} tileJSON Tile JSON.
   */


  TileJSON.prototype.handleTileJSONResponse = function (tileJSON) {
    var epsg4326Projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:4326');
    var sourceProjection = this.getProjection();
    var extent;

    if (tileJSON['bounds'] !== undefined) {
      var transform = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransformFromProjections)(epsg4326Projection, sourceProjection);
      extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.applyTransform)(tileJSON['bounds'], transform);
    }

    var gridExtent = (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_5__.extentFromProjection)(sourceProjection);
    var minZoom = tileJSON['minzoom'] || 0;
    var maxZoom = tileJSON['maxzoom'] || 22;
    var tileGrid = (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_5__.createXYZ)({
      extent: gridExtent,
      maxZoom: maxZoom,
      minZoom: minZoom,
      tileSize: this.tileSize_
    });
    this.tileGrid = tileGrid;
    this.tileUrlFunction = (0,_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_6__.createFromTemplates)(tileJSON['tiles'], tileGrid);

    if (tileJSON['attribution'] !== undefined && !this.getAttributions()) {
      var attributionExtent_1 = extent !== undefined ? extent : gridExtent;
      this.setAttributions(function (frameState) {
        if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.intersects)(attributionExtent_1, frameState.extent)) {
          return [tileJSON['attribution']];
        }

        return null;
      });
    }

    this.tileJSON_ = tileJSON;
    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_1__["default"].READY);
  };
  /**
   * @protected
   */


  TileJSON.prototype.handleTileJSONError = function () {
    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR);
  };

  return TileJSON;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_7__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (TileJSON);

/***/ }),

/***/ "./build/wg/source/TileWMS.js":
/*!************************************!*\
  !*** ./build/wg/source/TileWMS.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common.js */ "./build/wg/source/common.js");
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./TileImage.js */ "./build/wg/source/TileImage.js");
/* harmony import */ var _WMSServerType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./WMSServerType.js */ "./build/wg/source/WMSServerType.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../uri.js */ "./build/wg/uri.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../size.js */ "./build/wg/size.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../reproj.js */ "./build/wg/reproj.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../string.js */ "./build/wg/string.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../tilecoord.js */ "./build/wg/tilecoord.js");
/**
 * @module wg/source/TileWMS
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();














/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object<string,*>} params WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
 * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
 * @property {number} [gutter=0]
 * The size in pixels of the gutter around image tiles to ignore. By setting
 * this property to a non-zero value, images will be requested that are wider
 * and taller than the tile size by a value of `2 x gutter`.
 * Using a non-zero value allows artifacts of rendering at tile edges to be
 * ignored. If you control the WMS service it is recommended to address
 * "artifacts at tile edges" issues by properly configuring the WMS service. For
 * example, MapServer has a `tile_map_edge_buffer` configuration parameter for
 * this. See https://mapserver.org/output/tile_mode.html.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:wg/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid. Base this on the resolutions,
 * tilesize and extent supported by the server.
 * If this is not defined, a default grid will be used: if there is a projection
 * extent, the grid will be based on that; if not, a grid based on a global
 * extent with origin at 0,0 will be used..
 * @property {import("./WMSServerType.js").default|string} [serverType]
 * The type of the remote WMS server. Currently only used when `hidpi` is
 * `true`.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] WMS service URL.
 * @property {Array<string>} [urls] WMS service urls.
 * Use this instead of `url` when the WMS supports multiple urls for GetMap requests.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When `true`, tiles will be requested for one world only,
 * but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for tile data from WMS servers.
 * @api
 */

var TileWMS =
/** @class */
function (_super) {
  __extends(TileWMS, _super);
  /**
   * @param {Options} [opt_options] Tile WMS options.
   */


  function TileWMS(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options :
    /** @type {Options} */
    {};
    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    var params = options.params || {};
    var transparent = 'TRANSPARENT' in params ? params['TRANSPARENT'] : true;
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: interpolate,
      opaque: !transparent,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    }) || this;
    /**
     * @private
     * @type {number}
     */

    _this.gutter_ = options.gutter !== undefined ? options.gutter : 0;
    /**
     * @private
     * @type {!Object}
     */

    _this.params_ = params;
    /**
     * @private
     * @type {boolean}
     */

    _this.v13_ = true;
    /**
     * @private
     * @type {import("./WMSServerType.js").default|undefined}
     */

    _this.serverType_ =
    /** @type {import("./WMSServerType.js").default|undefined} */
    options.serverType;
    /**
     * @private
     * @type {boolean}
     */

    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    _this.tmpExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createEmpty)();

    _this.updateV13_();

    _this.setKey(_this.getKeyForParams_());

    return _this;
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */


  TileWMS.prototype.getFeatureInfoUrl = function (coordinate, resolution, projection, params) {
    var projectionObj = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection);
    var sourceProjectionObj = this.getProjection();
    var tileGrid = this.getTileGrid();

    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projectionObj);
    }

    var z = tileGrid.getZForResolution(resolution, this.zDirection);
    var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);

    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return undefined;
    }

    var tileResolution = tileGrid.getResolution(tileCoord[0]);
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_2__.toSize)(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
    var gutter = this.gutter_;

    if (gutter !== 0) {
      tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_2__.buffer)(tileSize, gutter, this.tmpSize);
      tileExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.buffer)(tileExtent, tileResolution * gutter, tileExtent);
    }

    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      tileResolution = (0,_reproj_js__WEBPACK_IMPORTED_MODULE_3__.calculateSourceResolution)(sourceProjectionObj, projectionObj, coordinate, tileResolution);
      tileExtent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.transformExtent)(tileExtent, projectionObj, sourceProjectionObj);
      coordinate = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.transform)(coordinate, projectionObj, sourceProjectionObj);
    }

    var baseParams = {
      'SERVICE': 'WMS',
      'VERSION': _common_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_WMS_VERSION,
      'REQUEST': 'GetFeatureInfo',
      'FORMAT': 'image/png',
      'TRANSPARENT': true,
      'QUERY_LAYERS': this.params_['LAYERS']
    };
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_5__.assign)(baseParams, this.params_, params);
    var x = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);
    var y = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);
    baseParams[this.v13_ ? 'I' : 'X'] = x;
    baseParams[this.v13_ ? 'J' : 'Y'] = y;
    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, 1, sourceProjectionObj || projectionObj, baseParams);
  };
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */


  TileWMS.prototype.getLegendUrl = function (resolution, params) {
    if (this.urls[0] === undefined) {
      return undefined;
    }

    var baseParams = {
      'SERVICE': 'WMS',
      'VERSION': _common_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_WMS_VERSION,
      'REQUEST': 'GetLegendGraphic',
      'FORMAT': 'image/png'
    };

    if (params === undefined || params['LAYER'] === undefined) {
      var layers = this.params_.LAYERS;
      var isSingleLayer = !Array.isArray(layers) || layers.length === 1;

      if (!isSingleLayer) {
        return undefined;
      }

      baseParams['LAYER'] = layers;
    }

    if (resolution !== undefined) {
      var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
      var pixelSize = 0.00028;
      baseParams['SCALE'] = resolution * mpu / pixelSize;
    }

    (0,_obj_js__WEBPACK_IMPORTED_MODULE_5__.assign)(baseParams, params);
    return (0,_uri_js__WEBPACK_IMPORTED_MODULE_6__.appendParams)(
    /** @type {string} */
    this.urls[0], baseParams);
  };
  /**
   * @return {number} Gutter.
   */


  TileWMS.prototype.getGutter = function () {
    return this.gutter_;
  };
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */


  TileWMS.prototype.getParams = function () {
    return this.params_;
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../size.js").Size} tileSize Tile size.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */


  TileWMS.prototype.getRequestUrl_ = function (tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
    var urls = this.urls;

    if (!urls) {
      return undefined;
    }

    params['WIDTH'] = tileSize[0];
    params['HEIGHT'] = tileSize[1];
    params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();

    if (!('STYLES' in this.params_)) {
      params['STYLES'] = '';
    }

    if (pixelRatio != 1) {
      switch (this.serverType_) {
        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_7__["default"].GEOSERVER:
          var dpi = 90 * pixelRatio + 0.5 | 0;

          if ('FORMAT_OPTIONS' in params) {
            params['FORMAT_OPTIONS'] += ';dpi:' + dpi;
          } else {
            params['FORMAT_OPTIONS'] = 'dpi:' + dpi;
          }

          break;

        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_7__["default"].MAPSERVER:
          params['MAP_RESOLUTION'] = 90 * pixelRatio;
          break;

        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CARMENTA_SERVER:
        case _WMSServerType_js__WEBPACK_IMPORTED_MODULE_7__["default"].QGIS:
          params['DPI'] = 90 * pixelRatio;
          break;

        default:
          (0,_asserts_js__WEBPACK_IMPORTED_MODULE_8__.assert)(false, 52); // Unknown `serverType` configured

          break;
      }
    }

    var axisOrientation = projection.getAxisOrientation();
    var bbox = tileExtent;

    if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {
      var tmp = void 0;
      tmp = tileExtent[0];
      bbox[0] = tileExtent[1];
      bbox[1] = tmp;
      tmp = tileExtent[2];
      bbox[2] = tileExtent[3];
      bbox[3] = tmp;
    }

    params['BBOX'] = bbox.join(',');
    var url;

    if (urls.length == 1) {
      url = urls[0];
    } else {
      var index = (0,_math_js__WEBPACK_IMPORTED_MODULE_9__.modulo)((0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_10__.hash)(tileCoord), urls.length);
      url = urls[index];
    }

    return (0,_uri_js__WEBPACK_IMPORTED_MODULE_6__.appendParams)(url, params);
  };
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */


  TileWMS.prototype.getTilePixelRatio = function (pixelRatio) {
    return !this.hidpi_ || this.serverType_ === undefined ? 1 : pixelRatio;
  };
  /**
   * @private
   * @return {string} The key for the current params.
   */


  TileWMS.prototype.getKeyForParams_ = function () {
    var i = 0;
    var res = [];

    for (var key in this.params_) {
      res[i++] = key + '-' + this.params_[key];
    }

    return res.join('/');
  };
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */


  TileWMS.prototype.updateParams = function (params) {
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_5__.assign)(this.params_, params);
    this.updateV13_();
    this.setKey(this.getKeyForParams_());
  };
  /**
   * @private
   */


  TileWMS.prototype.updateV13_ = function () {
    var version = this.params_['VERSION'] || _common_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_WMS_VERSION;
    this.v13_ = (0,_string_js__WEBPACK_IMPORTED_MODULE_11__.compareVersions)(version, '1.3') >= 0;
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */


  TileWMS.prototype.tileUrlFunction = function (tileCoord, pixelRatio, projection) {
    var tileGrid = this.getTileGrid();

    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projection);
    }

    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return undefined;
    }

    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {
      pixelRatio = 1;
    }

    var tileResolution = tileGrid.getResolution(tileCoord[0]);
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_2__.toSize)(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
    var gutter = this.gutter_;

    if (gutter !== 0) {
      tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_2__.buffer)(tileSize, gutter, this.tmpSize);
      tileExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.buffer)(tileExtent, tileResolution * gutter, tileExtent);
    }

    if (pixelRatio != 1) {
      tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_2__.scale)(tileSize, pixelRatio, this.tmpSize);
    }

    var baseParams = {
      'SERVICE': 'WMS',
      'VERSION': _common_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_WMS_VERSION,
      'REQUEST': 'GetMap',
      'FORMAT': 'image/png',
      'TRANSPARENT': true
    };
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_5__.assign)(baseParams, this.params_);
    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
  };

  return TileWMS;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_12__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (TileWMS);

/***/ }),

/***/ "./build/wg/source/UTFGrid.js":
/*!************************************!*\
  !*** ./build/wg/source/UTFGrid.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CustomTile": function() { return /* binding */ CustomTile; }
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./State.js */ "./build/wg/source/State.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Tile.js */ "./build/wg/Tile.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Tile.js */ "./build/wg/source/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TileState.js */ "./build/wg/TileState.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tileurlfunction.js */ "./build/wg/tileurlfunction.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../tilegrid.js */ "./build/wg/tilegrid.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../tilecoord.js */ "./build/wg/tilecoord.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./build/wg/events.js");
/* harmony import */ var _net_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../net.js */ "./build/wg/net.js");
/**
 * @module wg/source/UTFGrid
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();














/**
 * @typedef {Object} UTFGridJSON
 * @property {Array<string>} grid The grid.
 * @property {Array<string>} keys The keys.
 * @property {Object<string, Object>} [data] Optional data.
 */

var CustomTile =
/** @class */
function (_super) {
  __extends(CustomTile, _super);
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {import("../extent.js").Extent} extent Extent of the tile.
   * @param {boolean} preemptive Load the tile when visible (before it's needed).
   * @param {boolean} jsonp Load the tile as a script.
   */


  function CustomTile(tileCoord, state, src, extent, preemptive, jsonp) {
    var _this = _super.call(this, tileCoord, state) || this;
    /**
     * @private
     * @type {string}
     */


    _this.src_ = src;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    _this.extent_ = extent;
    /**
     * @private
     * @type {boolean}
     */

    _this.preemptive_ = preemptive;
    /**
     * @private
     * @type {Array<string>}
     */

    _this.grid_ = null;
    /**
     * @private
     * @type {Array<string>}
     */

    _this.keys_ = null;
    /**
     * @private
     * @type {Object<string, Object>|undefined}
     */

    _this.data_ = null;
    /**
     * @private
     * @type {boolean}
     */

    _this.jsonp_ = jsonp;
    return _this;
  }
  /**
   * Get the image element for this tile.
   * @return {HTMLImageElement} Image.
   */


  CustomTile.prototype.getImage = function () {
    return null;
  };
  /**
   * Synchronously returns data at given coordinate (if available).
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {*} The data.
   */


  CustomTile.prototype.getData = function (coordinate) {
    if (!this.grid_ || !this.keys_) {
      return null;
    }

    var xRelative = (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);
    var yRelative = (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);
    var row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];

    if (typeof row !== 'string') {
      return null;
    }

    var code = row.charCodeAt(Math.floor(xRelative * row.length));

    if (code >= 93) {
      code--;
    }

    if (code >= 35) {
      code--;
    }

    code -= 32;
    var data = null;

    if (code in this.keys_) {
      var id = this.keys_[code];

      if (this.data_ && id in this.data_) {
        data = this.data_[id];
      } else {
        data = id;
      }
    }

    return data;
  };
  /**
   * Calls the callback (synchronously by default) with the available data
   * for given coordinate (or `null` if not yet loaded).
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(*): void} callback Callback.
   * @param {boolean} [opt_request] If `true` the callback is always async.
   *                               The tile data is requested if not yet loaded.
   */


  CustomTile.prototype.forDataAtCoordinate = function (coordinate, callback, opt_request) {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY && opt_request === true) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE;
      (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listenOnce)(this, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, function (e) {
        callback(this.getData(coordinate));
      }, this);
      this.loadInternal_();
    } else {
      if (opt_request === true) {
        setTimeout(function () {
          callback(this.getData(coordinate));
        }.bind(this), 0);
      } else {
        callback(this.getData(coordinate));
      }
    }
  };
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */


  CustomTile.prototype.getKey = function () {
    return this.src_;
  };
  /**
   * @private
   */


  CustomTile.prototype.handleError_ = function () {
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    this.changed();
  };
  /**
   * @param {!UTFGridJSON} json UTFGrid data.
   * @private
   */


  CustomTile.prototype.handleLoad_ = function (json) {
    this.grid_ = json['grid'];
    this.keys_ = json['keys'];
    this.data_ = json['data'];
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    this.changed();
  };
  /**
   * @private
   */


  CustomTile.prototype.loadInternal_ = function () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;

      if (this.jsonp_) {
        (0,_net_js__WEBPACK_IMPORTED_MODULE_4__.jsonp)(this.src_, this.handleLoad_.bind(this), this.handleError_.bind(this));
      } else {
        var client = new XMLHttpRequest();
        client.addEventListener('load', this.onXHRLoad_.bind(this));
        client.addEventListener('error', this.onXHRError_.bind(this));
        client.open('GET', this.src_);
        client.send();
      }
    }
  };
  /**
   * @private
   * @param {Event} event The load event.
   */


  CustomTile.prototype.onXHRLoad_ = function (event) {
    var client =
    /** @type {XMLHttpRequest} */
    event.target; // status will be 0 for file:// urls

    if (!client.status || client.status >= 200 && client.status < 300) {
      var response = void 0;

      try {
        response =
        /** @type {!UTFGridJSON} */
        JSON.parse(client.responseText);
      } catch (err) {
        this.handleError_();
        return;
      }

      this.handleLoad_(response);
    } else {
      this.handleError_();
    }
  };
  /**
   * @private
   * @param {Event} event The error event.
   */


  CustomTile.prototype.onXHRError_ = function (event) {
    this.handleError_();
  };
  /**
   */


  CustomTile.prototype.load = function () {
    if (this.preemptive_) {
      this.loadInternal_();
    } else {
      this.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY);
    }
  };

  return CustomTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_5__["default"]);


/**
 * @typedef {Object} Options
 * @property {boolean} [preemptive=true]
 * If `true` the UTFGrid source loads the tiles based on their "visibility".
 * This improves the speed of response, but increases traffic.
 * Note that if set to `false` (lazy loading), you need to pass `true` as
 * `opt_request` to the `forDataAtCoordinateAndResolution` method otherwise no
 * data will ever be loaded.
 * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.
 * Useful when the server does not support CORS..
 * @property {import("./TileJSON.js").Config} [tileJSON] TileJSON configuration for this source.
 * If not provided, `url` must be configured.
 * @property {string} [url] TileJSON endpoint that provides the configuration for this source.
 * Request will be made through JSONP. If not provided, `tileJSON` must be configured.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for UTFGrid interaction data loaded from TileJSON format.
 * @api
 */

var UTFGrid =
/** @class */
function (_super) {
  __extends(UTFGrid, _super);
  /**
   * @param {Options} options Source options.
   */


  function UTFGrid(options) {
    var _this = _super.call(this, {
      projection: (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:3857'),
      state: _State_js__WEBPACK_IMPORTED_MODULE_6__["default"].LOADING,
      zDirection: options.zDirection
    }) || this;
    /**
     * @private
     * @type {boolean}
     */


    _this.preemptive_ = options.preemptive !== undefined ? options.preemptive : true;
    /**
     * @private
     * @type {!import("../Tile.js").UrlFunction}
     */

    _this.tileUrlFunction_ = _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_7__.nullTileUrlFunction;
    /**
     * @private
     * @type {string|undefined}
     */

    _this.template_ = undefined;
    /**
     * @private
     * @type {boolean}
     */

    _this.jsonp_ = options.jsonp || false;

    if (options.url) {
      if (_this.jsonp_) {
        (0,_net_js__WEBPACK_IMPORTED_MODULE_4__.jsonp)(options.url, _this.handleTileJSONResponse.bind(_this), _this.handleTileJSONError.bind(_this));
      } else {
        var client = new XMLHttpRequest();
        client.addEventListener('load', _this.onXHRLoad_.bind(_this));
        client.addEventListener('error', _this.onXHRError_.bind(_this));
        client.open('GET', options.url);
        client.send();
      }
    } else if (options.tileJSON) {
      _this.handleTileJSONResponse(options.tileJSON);
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_8__.assert)(false, 51); // Either `url` or `tileJSON` options must be provided
    }

    return _this;
  }
  /**
   * @private
   * @param {Event} event The load event.
   */


  UTFGrid.prototype.onXHRLoad_ = function (event) {
    var client =
    /** @type {XMLHttpRequest} */
    event.target; // status will be 0 for file:// urls

    if (!client.status || client.status >= 200 && client.status < 300) {
      var response = void 0;

      try {
        response =
        /** @type {import("./TileJSON.js").Config} */
        JSON.parse(client.responseText);
      } catch (err) {
        this.handleTileJSONError();
        return;
      }

      this.handleTileJSONResponse(response);
    } else {
      this.handleTileJSONError();
    }
  };
  /**
   * @private
   * @param {Event} event The error event.
   */


  UTFGrid.prototype.onXHRError_ = function (event) {
    this.handleTileJSONError();
  };
  /**
   * Return the template from TileJSON.
   * @return {string|undefined} The template from TileJSON.
   * @api
   */


  UTFGrid.prototype.getTemplate = function () {
    return this.template_;
  };
  /**
   * Calls the callback (synchronously by default) with the available data
   * for given coordinate and resolution (or `null` if not yet loaded or
   * in case of an error).
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {function(*): void} callback Callback.
   * @param {boolean} [opt_request] If `true` the callback is always async.
   *                               The tile data is requested if not yet loaded.
   * @api
   */


  UTFGrid.prototype.forDataAtCoordinateAndResolution = function (coordinate, resolution, callback, opt_request) {
    if (this.tileGrid) {
      var z = this.tileGrid.getZForResolution(resolution, this.zDirection);
      var tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      var tile =
      /** @type {!CustomTile} */
      this.getTile(tileCoord[0], tileCoord[1], tileCoord[2], 1, this.getProjection());
      tile.forDataAtCoordinate(coordinate, callback, opt_request);
    } else {
      if (opt_request === true) {
        setTimeout(function () {
          callback(null);
        }, 0);
      } else {
        callback(null);
      }
    }
  };
  /**
   * @protected
   */


  UTFGrid.prototype.handleTileJSONError = function () {
    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_6__["default"].ERROR);
  };
  /**
   * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse
   * @protected
   * @param {import("./TileJSON.js").Config} tileJSON Tile JSON.
   */


  UTFGrid.prototype.handleTileJSONResponse = function (tileJSON) {
    var epsg4326Projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:4326');
    var sourceProjection = this.getProjection();
    var extent;

    if (tileJSON['bounds'] !== undefined) {
      var transform = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransformFromProjections)(epsg4326Projection, sourceProjection);
      extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_9__.applyTransform)(tileJSON['bounds'], transform);
    }

    var gridExtent = (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_10__.extentFromProjection)(sourceProjection);
    var minZoom = tileJSON['minzoom'] || 0;
    var maxZoom = tileJSON['maxzoom'] || 22;
    var tileGrid = (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_10__.createXYZ)({
      extent: gridExtent,
      maxZoom: maxZoom,
      minZoom: minZoom
    });
    this.tileGrid = tileGrid;
    this.template_ = tileJSON['template'];
    var grids = tileJSON['grids'];

    if (!grids) {
      this.setState(_State_js__WEBPACK_IMPORTED_MODULE_6__["default"].ERROR);
      return;
    }

    this.tileUrlFunction_ = (0,_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_7__.createFromTemplates)(grids, tileGrid);

    if (tileJSON['attribution'] !== undefined) {
      var attributionExtent_1 = extent !== undefined ? extent : gridExtent;
      this.setAttributions(function (frameState) {
        if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_9__.intersects)(attributionExtent_1, frameState.extent)) {
          return [tileJSON['attribution']];
        }

        return null;
      });
    }

    this.setState(_State_js__WEBPACK_IMPORTED_MODULE_6__["default"].READY);
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!CustomTile} Tile.
   */


  UTFGrid.prototype.getTile = function (z, x, y, pixelRatio, projection) {
    var tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_11__.getKeyZXY)(z, x, y);

    if (this.tileCache.containsKey(tileCoordKey)) {
      return this.tileCache.get(tileCoordKey);
    } else {
      var tileCoord = [z, x, y];
      var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);
      var tile = new CustomTile(tileCoord, tileUrl !== undefined ? _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE : _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY, tileUrl !== undefined ? tileUrl : '', this.tileGrid.getTileCoordExtent(tileCoord), this.preemptive_, this.jsonp_);
      this.tileCache.set(tileCoordKey, tile);
      return tile;
    }
  };
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */


  UTFGrid.prototype.useTile = function (z, x, y) {
    var tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_11__.getKeyZXY)(z, x, y);

    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  };

  return UTFGrid;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_12__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (UTFGrid);

/***/ }),

/***/ "./build/wg/source/UrlTile.js":
/*!************************************!*\
  !*** ./build/wg/source/UrlTile.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileEventType.js */ "./build/wg/source/TileEventType.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Tile.js */ "./build/wg/source/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TileState.js */ "./build/wg/TileState.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tileurlfunction.js */ "./build/wg/tileurlfunction.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tilecoord.js */ "./build/wg/tilecoord.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/source/UrlTile
 */








/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Cache size.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./State.js").default} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {import("../Tile.js").LoadFunction} tileLoadFunction TileLoadFunction.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] TileUrlFunction.
 * @property {string} [url] Url.
 * @property {Array<string>} [urls] Urls.
 * @property {boolean} [wrapX=true] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @fires import("./Tile.js").TileSourceEvent
 */

var UrlTile =
/** @class */
function (_super) {
  __extends(UrlTile, _super);
  /**
   * @param {Options} options Image tile options.
   */


  function UrlTile(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    }) || this;
    /**
     * @private
     * @type {boolean}
     */


    _this.generateTileUrlFunction_ = _this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;
    /**
     * @protected
     * @type {import("../Tile.js").LoadFunction}
     */

    _this.tileLoadFunction = options.tileLoadFunction;

    if (options.tileUrlFunction) {
      _this.tileUrlFunction = options.tileUrlFunction;
    }
    /**
     * @protected
     * @type {!Array<string>|null}
     */


    _this.urls = null;

    if (options.urls) {
      _this.setUrls(options.urls);
    } else if (options.url) {
      _this.setUrl(options.url);
    }
    /**
     * @private
     * @type {!Object<string, boolean>}
     */


    _this.tileLoadingKeys_ = {};
    return _this;
  }
  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */


  UrlTile.prototype.getTileLoadFunction = function () {
    return this.tileLoadFunction;
  };
  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */


  UrlTile.prototype.getTileUrlFunction = function () {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  };
  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */


  UrlTile.prototype.getUrls = function () {
    return this.urls;
  };
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */


  UrlTile.prototype.handleTileChange = function (event) {
    var tile =
    /** @type {import("../Tile.js").default} */
    event.target;
    var uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getUid)(tile);
    var tileState = tile.getState();
    var type;

    if (tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = _TileEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR ? _TileEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].TILELOADERROR : tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED ? _TileEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].TILELOADEND : undefined;
    }

    if (type != undefined) {
      this.dispatchEvent(new _Tile_js__WEBPACK_IMPORTED_MODULE_3__.TileSourceEvent(type, tile));
    }
  };
  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */


  UrlTile.prototype.setTileLoadFunction = function (tileLoadFunction) {
    this.tileCache.clear();
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  };
  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */


  UrlTile.prototype.setTileUrlFunction = function (tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    this.tileCache.pruneExceptNewestZ();

    if (typeof key !== 'undefined') {
      this.setKey(key);
    } else {
      this.changed();
    }
  };
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */


  UrlTile.prototype.setUrl = function (url) {
    var urls = (0,_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_4__.expandUrl)(url);
    this.urls = urls;
    this.setUrls(urls);
  };
  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */


  UrlTile.prototype.setUrls = function (urls) {
    this.urls = urls;
    var key = urls.join('\n');

    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction((0,_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_4__.createFromTemplates)(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */


  UrlTile.prototype.tileUrlFunction = function (tileCoord, pixelRatio, projection) {
    return undefined;
  };
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */


  UrlTile.prototype.useTile = function (z, x, y) {
    var tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_5__.getKeyZXY)(z, x, y);

    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  };

  return UrlTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (UrlTile);

/***/ }),

/***/ "./build/wg/source/Vector.js":
/*!***********************************!*\
  !*** ./build/wg/source/Vector.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VectorSourceEvent": function() { return /* binding */ VectorSourceEvent; }
/* harmony export */ });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Collection.js */ "./build/wg/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../CollectionEventType.js */ "./build/wg/CollectionEventType.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./build/wg/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../ObjectEventType.js */ "./build/wg/ObjectEventType.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../structs/RBush.js */ "./build/wg/structs/RBush.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Source.js */ "./build/wg/source/Source.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./State.js */ "./build/wg/source/State.js");
/* harmony import */ var _VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./VectorEventType.js */ "./build/wg/source/VectorEventType.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./build/wg/functions.js");
/* harmony import */ var _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../loadingstrategy.js */ "./build/wg/loadingstrategy.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../events.js */ "./build/wg/events.js");
/* harmony import */ var _featureloader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../featureloader.js */ "./build/wg/featureloader.js");
/**
 * @module wg/source/Vector
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();



















/**
 * A function that takes an {@link module:wg/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:wg/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:wg/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number, import("../proj/Projection.js").default): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */

/**
 * @classdesc
 * Events emitted by {@link module:wg/source/Vector~VectorSource} instances are instances of this
 * type.
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 */

var VectorSourceEvent =
/** @class */
function (_super) {
  __extends(VectorSourceEvent, _super);
  /**
   * @param {string} type Type.
   * @param {import("../Feature.js").default<Geometry>} [opt_feature] Feature.
   * @param {Array<import("../Feature.js").default<Geometry>>} [opt_features] Features.
   */


  function VectorSourceEvent(type, opt_feature, opt_features) {
    var _this = _super.call(this, type) || this;
    /**
     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.
     * @type {import("../Feature.js").default<Geometry>|undefined}
     * @api
     */


    _this.feature = opt_feature;
    /**
     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.
     * @type {Array<import("../Feature.js").default<Geometry>>|undefined}
     * @api
     */

    _this.features = opt_features;
    return _this;
  }

  return VectorSourceEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./VectorEventType").VectorSourceEventTypes, VectorSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./VectorEventType").VectorSourceEventTypes, Return>} VectorSourceOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<import("../Feature.js").default>|Collection<import("../Feature.js").default>} [features]
 * Features. If provided as {@link module:wg/Collection~Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events
 * will only fire if the `success` and `failure` callbacks are used.
 *
 * Example:
 *
 * ```js
 * import {Vector} from 'wg/source';
 * import {GeoJSON} from 'wg/format';
 * import {bbox} from 'wg/loadingstrategy';
 *
 * var vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection, success, failure) {
 *      var proj = projection.getCode();
 *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      var xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      var onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *        failure();
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          var features = vectorSource.getFormat().readFeatures(xhr.responseText);
 *          vectorSource.addFeatures(features);
 *          success(features);
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:wg/loadingstrategy.all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:wg/featureloader.xhr}). Use a `string` and an
 * {@link module:wg/loadingstrategy.all} for a one-off download of all features from
 * the given URL. Use a {@link module:wg/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:wg/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:wg/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:wg/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:wg/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:wg/Collection~Collection}, which can be retrieved through
 * {@link module:wg/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180° and 180° meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 */

/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:wg/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires VectorSourceEvent
 * @api
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 */

var VectorSource =
/** @class */
function (_super) {
  __extends(VectorSource, _super);
  /**
   * @param {Options} [opt_options] Vector source options.
   */


  function VectorSource(opt_options) {
    var _this = this;

    var options = opt_options || {};
    _this = _super.call(this, {
      attributions: options.attributions,
      interpolate: true,
      projection: undefined,
      state: _State_js__WEBPACK_IMPORTED_MODULE_1__["default"].READY,
      wrapX: options.wrapX !== undefined ? options.wrapX : true
    }) || this;
    /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */

    _this.on;
    /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */

    _this.once;
    /***
     * @type {VectorSourceOnSignature<void>}
     */

    _this.un;
    /**
     * @private
     * @type {import("../featureloader.js").FeatureLoader}
     */

    _this.loader_ = _functions_js__WEBPACK_IMPORTED_MODULE_2__.VOID;
    /**
     * @private
     * @type {import("../format/Feature.js").default|undefined}
     */

    _this.format_ = options.format;
    /**
     * @private
     * @type {boolean}
     */

    _this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;
    /**
     * @private
     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
     */

    _this.url_ = options.url;

    if (options.loader !== undefined) {
      _this.loader_ = options.loader;
    } else if (_this.url_ !== undefined) {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(_this.format_, 7); // `format` must be set when `url` is set
      // create a XHR feature loader for "url" and "format"

      _this.loader_ = (0,_featureloader_js__WEBPACK_IMPORTED_MODULE_4__.xhr)(_this.url_,
      /** @type {import("../format/Feature.js").default} */
      _this.format_);
    }
    /**
     * @private
     * @type {LoadingStrategy}
     */


    _this.strategy_ = options.strategy !== undefined ? options.strategy : _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_5__.all;
    var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
    /**
     * @private
     * @type {RBush<import("../Feature.js").default<Geometry>>}
     */

    _this.featuresRtree_ = useSpatialIndex ? new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_6__["default"]() : null;
    /**
     * @private
     * @type {RBush<{extent: import("../extent.js").Extent}>}
     */

    _this.loadedExtentsRtree_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_6__["default"]();
    /**
     * @type {number}
     * @private
     */

    _this.loadingExtentsCount_ = 0;
    /**
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */

    _this.nullGeometryFeatures_ = {};
    /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */

    _this.idIndex_ = {};
    /**
     * A lookup of features by uid (using getUid(feature)).
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */

    _this.uidIndex_ = {};
    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */

    _this.featureChangeKeys_ = {};
    /**
     * @private
     * @type {Collection<import("../Feature.js").default<Geometry>>|null}
     */

    _this.featuresCollection_ = null;
    var collection, features;

    if (Array.isArray(options.features)) {
      features =
      /** @type {Array<import("../Feature.js").default<Geometry>>} */
      options.features;
    } else if (options.features) {
      collection =
      /** @type {Collection<import("../Feature.js").default<Geometry>>} */
      options.features;
      features = collection.getArray();
    }

    if (!useSpatialIndex && collection === undefined) {
      collection = new _Collection_js__WEBPACK_IMPORTED_MODULE_7__["default"](features);
    }

    if (features !== undefined) {
      _this.addFeaturesInternal(features);
    }

    if (collection !== undefined) {
      _this.bindFeaturesCollection_(collection);
    }

    return _this;
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:wg/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:wg/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
   * @api
   */


  VectorSource.prototype.addFeature = function (feature) {
    this.addFeatureInternal(feature);
    this.changed();
  };
  /**
   * Add a feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @protected
   */


  VectorSource.prototype.addFeatureInternal = function (feature) {
    var featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);

    if (!this.addToIndex_(featureKey, feature)) {
      if (this.featuresCollection_) {
        this.featuresCollection_.remove(feature);
      }

      return;
    }

    this.setupChangeEvents_(featureKey, feature);
    var geometry = feature.getGeometry();

    if (geometry) {
      var extent = geometry.getExtent();

      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }

    this.dispatchEvent(new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADDFEATURE, feature));
  };
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @private
   */


  VectorSource.prototype.setupChangeEvents_ = function (featureKey, feature) {
    this.featureChangeKeys_[featureKey] = [(0,_events_js__WEBPACK_IMPORTED_MODULE_10__.listen)(feature, _events_EventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].CHANGE, this.handleFeatureChange_, this), (0,_events_js__WEBPACK_IMPORTED_MODULE_10__.listen)(feature, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_12__["default"].PROPERTYCHANGE, this.handleFeatureChange_, this)];
  };
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */


  VectorSource.prototype.addToIndex_ = function (featureKey, feature) {
    var valid = true;
    var id = feature.getId();

    if (id !== undefined) {
      if (!(id.toString() in this.idIndex_)) {
        this.idIndex_[id.toString()] = feature;
      } else {
        valid = false;
      }
    }

    if (valid) {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(!(featureKey in this.uidIndex_), 30); // The passed `feature` was already added to the source

      this.uidIndex_[featureKey] = feature;
    }

    return valid;
  };
  /**
   * Add a batch of features to the source.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
   * @api
   */


  VectorSource.prototype.addFeatures = function (features) {
    this.addFeaturesInternal(features);
    this.changed();
  };
  /**
   * Add features without firing a `change` event.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
   * @protected
   */


  VectorSource.prototype.addFeaturesInternal = function (features) {
    var extents = [];
    var newFeatures = [];
    var geometryFeatures = [];

    for (var i = 0, length_1 = features.length; i < length_1; i++) {
      var feature = features[i];
      var featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);

      if (this.addToIndex_(featureKey, feature)) {
        newFeatures.push(feature);
      }
    }

    for (var i = 0, length_2 = newFeatures.length; i < length_2; i++) {
      var feature = newFeatures[i];
      var featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);
      this.setupChangeEvents_(featureKey, feature);
      var geometry = feature.getGeometry();

      if (geometry) {
        var extent = geometry.getExtent();
        extents.push(extent);
        geometryFeatures.push(feature);
      } else {
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    }

    if (this.featuresRtree_) {
      this.featuresRtree_.load(extents, geometryFeatures);
    }

    if (this.hasListener(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADDFEATURE)) {
      for (var i = 0, length_3 = newFeatures.length; i < length_3; i++) {
        this.dispatchEvent(new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADDFEATURE, newFeatures[i]));
      }
    }
  };
  /**
   * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
   * @private
   */


  VectorSource.prototype.bindFeaturesCollection_ = function (collection) {
    var modifyingCollection = false;
    this.addEventListener(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADDFEATURE,
    /**
     * @param {VectorSourceEvent<Geometry>} evt The vector source event
     */
    function (evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        collection.push(evt.feature);
        modifyingCollection = false;
      }
    });
    this.addEventListener(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].REMOVEFEATURE,
    /**
     * @param {VectorSourceEvent<Geometry>} evt The vector source event
     */
    function (evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        collection.remove(evt.feature);
        modifyingCollection = false;
      }
    });
    collection.addEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].ADD,
    /**
     * @param {import("../Collection.js").CollectionEvent} evt The collection event
     */
    function (evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        this.addFeature(
        /** @type {import("../Feature.js").default<Geometry>} */
        evt.element);
        modifyingCollection = false;
      }
    }.bind(this));
    collection.addEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].REMOVE,
    /**
     * @param {import("../Collection.js").CollectionEvent} evt The collection event
     */
    function (evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        this.removeFeature(
        /** @type {import("../Feature.js").default<Geometry>} */
        evt.element);
        modifyingCollection = false;
      }
    }.bind(this));
    this.featuresCollection_ = collection;
  };
  /**
   * Remove all features from the source.
   * @param {boolean} [opt_fast] Skip dispatching of {@link module:wg/source/Vector.VectorSourceEvent#event:removefeature removefeature} events.
   * @api
   */


  VectorSource.prototype.clear = function (opt_fast) {
    if (opt_fast) {
      for (var featureId in this.featureChangeKeys_) {
        var keys = this.featureChangeKeys_[featureId];
        keys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_10__.unlistenByKey);
      }

      if (!this.featuresCollection_) {
        this.featureChangeKeys_ = {};
        this.idIndex_ = {};
        this.uidIndex_ = {};
      }
    } else {
      if (this.featuresRtree_) {
        var removeAndIgnoreReturn = function (feature) {
          this.removeFeatureInternal(feature);
        }.bind(this);

        this.featuresRtree_.forEach(removeAndIgnoreReturn);

        for (var id in this.nullGeometryFeatures_) {
          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
      }
    }

    if (this.featuresCollection_) {
      this.featuresCollection_.clear();
    }

    if (this.featuresRtree_) {
      this.featuresRtree_.clear();
    }

    this.nullGeometryFeatures_ = {};
    var clearEvent = new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CLEAR);
    this.dispatchEvent(clearEvent);
    this.changed();
  };
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */


  VectorSource.prototype.forEachFeature = function (callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEach(callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */


  VectorSource.prototype.forEachFeatureAtCoordinateDirect = function (coordinate, callback) {
    var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
    return this.forEachFeatureInExtent(extent, function (feature) {
      var geometry = feature.getGeometry();

      if (geometry.intersectsCoordinate(coordinate)) {
        return callback(feature);
      } else {
        return undefined;
      }
    });
  };
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:wg/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:wg/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */


  VectorSource.prototype.forEachFeatureInExtent = function (extent, callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEachInExtent(extent, callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:wg/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */


  VectorSource.prototype.forEachFeatureIntersectingExtent = function (extent, callback) {
    return this.forEachFeatureInExtent(extent,
    /**
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     * @return {T|undefined} The return value from the last call to the callback.
     */
    function (feature) {
      var geometry = feature.getGeometry();

      if (geometry.intersectsExtent(extent)) {
        var result = callback(feature);

        if (result) {
          return result;
        }
      }
    });
  };
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:wg/Collection~Collection} as `features`.
   * @return {Collection<import("../Feature.js").default<Geometry>>|null} The collection of features.
   * @api
   */


  VectorSource.prototype.getFeaturesCollection = function () {
    return this.featuresCollection_;
  };
  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */


  VectorSource.prototype.getFeatures = function () {
    var features;

    if (this.featuresCollection_) {
      features = this.featuresCollection_.getArray().slice(0);
    } else if (this.featuresRtree_) {
      features = this.featuresRtree_.getAll();

      if (!(0,_obj_js__WEBPACK_IMPORTED_MODULE_14__.isEmpty)(this.nullGeometryFeatures_)) {
        (0,_array_js__WEBPACK_IMPORTED_MODULE_15__.extend)(features, (0,_obj_js__WEBPACK_IMPORTED_MODULE_14__.getValues)(this.nullGeometryFeatures_));
      }
    }

    return (
      /** @type {Array<import("../Feature.js").default<Geometry>>} */
      features
    );
  };
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */


  VectorSource.prototype.getFeaturesAtCoordinate = function (coordinate) {
    var features = [];
    this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {
      features.push(feature);
    });
    return features;
  };
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */


  VectorSource.prototype.getFeaturesInExtent = function (extent) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.getInExtent(extent);
    } else if (this.featuresCollection_) {
      return this.featuresCollection_.getArray().slice(0);
    } else {
      return [];
    }
  };
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>):boolean} [opt_filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:wg/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {import("../Feature.js").default<Geometry>} Closest feature.
   * @api
   */


  VectorSource.prototype.getClosestFeatureToCoordinate = function (coordinate, opt_filter) {
    // Find the closest feature using branch and bound.  We start searching an
    // infinite extent, and find the distance from the first feature found.  This
    // becomes the closest feature.  We then compute a smaller extent which any
    // closer feature must intersect.  We continue searching with this smaller
    // extent, trying to find a closer feature.  Every time we find a closer
    // feature, we update the extent being searched so that any even closer
    // feature must intersect it.  We continue until we run out of features.
    var x = coordinate[0];
    var y = coordinate[1];
    var closestFeature = null;
    var closestPoint = [NaN, NaN];
    var minSquaredDistance = Infinity;
    var extent = [-Infinity, -Infinity, Infinity, Infinity];
    var filter = opt_filter ? opt_filter : _functions_js__WEBPACK_IMPORTED_MODULE_2__.TRUE;
    this.featuresRtree_.forEachInExtent(extent,
    /**
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     */
    function (feature) {
      if (filter(feature)) {
        var geometry = feature.getGeometry();
        var previousMinSquaredDistance = minSquaredDistance;
        minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);

        if (minSquaredDistance < previousMinSquaredDistance) {
          closestFeature = feature; // This is sneaky.  Reduce the extent that it is currently being
          // searched while the R-Tree traversal using this same extent object
          // is still in progress.  This is safe because the new extent is
          // strictly contained by the old extent.

          var minDistance = Math.sqrt(minSquaredDistance);
          extent[0] = x - minDistance;
          extent[1] = y - minDistance;
          extent[2] = x + minDistance;
          extent[3] = y + minDistance;
        }
      }
    });
    return closestFeature;
  };
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [opt_extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  VectorSource.prototype.getExtent = function (opt_extent) {
    return this.featuresRtree_.getExtent(opt_extent);
  };
  /**
   * Get a feature by its identifier (the value returned by feature.getId()).
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   * @api
   */


  VectorSource.prototype.getFeatureById = function (id) {
    var feature = this.idIndex_[id.toString()];
    return feature !== undefined ? feature : null;
  };
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   */


  VectorSource.prototype.getFeatureByUid = function (uid) {
    var feature = this.uidIndex_[uid];
    return feature !== undefined ? feature : null;
  };
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default|undefined} The feature format.
   * @api
   */


  VectorSource.prototype.getFormat = function () {
    return this.format_;
  };
  /**
   * @return {boolean} The source can have overlapping geometries.
   */


  VectorSource.prototype.getOverlaps = function () {
    return this.overlaps_;
  };
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */


  VectorSource.prototype.getUrl = function () {
    return this.url_;
  };
  /**
   * @param {Event} event Event.
   * @private
   */


  VectorSource.prototype.handleFeatureChange_ = function (event) {
    var feature =
    /** @type {import("../Feature.js").default<Geometry>} */
    event.target;
    var featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);
    var geometry = feature.getGeometry();

    if (!geometry) {
      if (!(featureKey in this.nullGeometryFeatures_)) {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }

        this.nullGeometryFeatures_[featureKey] = feature;
      }
    } else {
      var extent = geometry.getExtent();

      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];

        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent, feature);
        }
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.update(extent, feature);
        }
      }
    }

    var id = feature.getId();

    if (id !== undefined) {
      var sid = id.toString();

      if (this.idIndex_[sid] !== feature) {
        this.removeFromIdIndex_(feature);
        this.idIndex_[sid] = feature;
      }
    } else {
      this.removeFromIdIndex_(feature);
      this.uidIndex_[featureKey] = feature;
    }

    this.changed();
    this.dispatchEvent(new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CHANGEFEATURE, feature));
  };
  /**
   * Returns true if the feature is contained within the source.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */


  VectorSource.prototype.hasFeature = function (feature) {
    var id = feature.getId();

    if (id !== undefined) {
      return id in this.idIndex_;
    } else {
      return (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature) in this.uidIndex_;
    }
  };
  /**
   * @return {boolean} Is empty.
   */


  VectorSource.prototype.isEmpty = function () {
    if (this.featuresRtree_) {
      return this.featuresRtree_.isEmpty() && (0,_obj_js__WEBPACK_IMPORTED_MODULE_14__.isEmpty)(this.nullGeometryFeatures_);
    }

    if (this.featuresCollection_) {
      return this.featuresCollection_.getLength() === 0;
    }

    return true;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */


  VectorSource.prototype.loadFeatures = function (extent, resolution, projection) {
    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var extentsToLoad = this.strategy_(extent, resolution, projection);

    var _loop_1 = function _loop_1(i, ii) {
      var extentToLoad = extentsToLoad[i];
      var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,
      /**
       * @param {{extent: import("../extent.js").Extent}} object Object.
       * @return {boolean} Contains.
       */
      function (object) {
        return (0,_extent_js__WEBPACK_IMPORTED_MODULE_16__.containsExtent)(object.extent, extentToLoad);
      });

      if (!alreadyLoaded) {
        ++this_1.loadingExtentsCount_;
        this_1.dispatchEvent(new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].FEATURESLOADSTART));
        this_1.loader_.call(this_1, extentToLoad, resolution, projection, function (features) {
          --this.loadingExtentsCount_;
          this.dispatchEvent(new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].FEATURESLOADEND, undefined, features));
        }.bind(this_1), function () {
          --this.loadingExtentsCount_;
          this.dispatchEvent(new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].FEATURESLOADERROR));
        }.bind(this_1));
        loadedExtentsRtree.insert(extentToLoad, {
          extent: extentToLoad.slice()
        });
      }
    };

    var this_1 = this;

    for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {
      _loop_1(i, ii);
    }

    this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
  };

  VectorSource.prototype.refresh = function () {
    this.clear(true);
    this.loadedExtentsRtree_.clear();

    _super.prototype.refresh.call(this);
  };
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */


  VectorSource.prototype.removeLoadedExtent = function (extent) {
    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var obj;
    loadedExtentsRtree.forEachInExtent(extent, function (object) {
      if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_16__.equals)(object.extent, extent)) {
        obj = object;
        return true;
      }
    });

    if (obj) {
      loadedExtentsRtree.remove(obj);
    }
  };
  /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:wg/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
   * @api
   */


  VectorSource.prototype.removeFeature = function (feature) {
    if (!feature) {
      return;
    }

    var featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);

    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
    }

    var result = this.removeFeatureInternal(feature);

    if (result) {
      this.changed();
    }
  };
  /**
   * Remove feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {import("../Feature.js").default<Geometry>|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */


  VectorSource.prototype.removeFeatureInternal = function (feature) {
    var featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);
    var featureChangeKeys = this.featureChangeKeys_[featureKey];

    if (!featureChangeKeys) {
      return;
    }

    featureChangeKeys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_10__.unlistenByKey);
    delete this.featureChangeKeys_[featureKey];
    var id = feature.getId();

    if (id !== undefined) {
      delete this.idIndex_[id.toString()];
    }

    delete this.uidIndex_[featureKey];
    this.dispatchEvent(new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].REMOVEFEATURE, feature));
    return feature;
  };
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */


  VectorSource.prototype.removeFromIdIndex_ = function (feature) {
    var removed = false;

    for (var id in this.idIndex_) {
      if (this.idIndex_[id] === feature) {
        delete this.idIndex_[id];
        removed = true;
        break;
      }
    }

    return removed;
  };
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */


  VectorSource.prototype.setLoader = function (loader) {
    this.loader_ = loader;
  };
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */


  VectorSource.prototype.setUrl = function (url) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.format_, 7); // `format` must be set when `url` is set

    this.url_ = url;
    this.setLoader((0,_featureloader_js__WEBPACK_IMPORTED_MODULE_4__.xhr)(url, this.format_));
  };

  return VectorSource;
}(_Source_js__WEBPACK_IMPORTED_MODULE_17__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VectorSource);

/***/ }),

/***/ "./build/wg/source/VectorEventType.js":
/*!********************************************!*\
  !*** ./build/wg/source/VectorEventType.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/source/VectorEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when a feature is added to the source.
   * @event module:wg/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: 'addfeature',

  /**
   * Triggered when a feature is updated.
   * @event module:wg/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: 'changefeature',

  /**
   * Triggered when the clear method is called on the source.
   * @event module:wg/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: 'clear',

  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:wg/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:wg/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: 'removefeature',

  /**
   * Triggered when features starts loading.
   * @event module:wg/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: 'featuresloadstart',

  /**
   * Triggered when features finishes loading.
   * @event module:wg/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: 'featuresloadend',

  /**
   * Triggered if feature loading results in an error.
   * @event module:wg/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: 'featuresloaderror'
});
/**
 * @typedef {'addfeature'|'changefeature'|'clear'|'removefeature'|'featuresloadstart'|'featuresloadend'|'featuresloaderror'} VectorSourceEventTypes
 */

/***/ }),

/***/ "./build/wg/source/VectorTile.js":
/*!***************************************!*\
  !*** ./build/wg/source/VectorTile.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultLoadFunction": function() { return /* binding */ defaultLoadFunction; }
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _VectorTile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VectorTile.js */ "./build/wg/VectorTile.js");
/* harmony import */ var _TileCache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TileCache.js */ "./build/wg/TileCache.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../TileState.js */ "./build/wg/TileState.js");
/* harmony import */ var _UrlTile_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./UrlTile.js */ "./build/wg/source/UrlTile.js");
/* harmony import */ var _VectorRenderTile_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../VectorRenderTile.js */ "./build/wg/VectorRenderTile.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tilegrid.js */ "./build/wg/tilegrid.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tilecoord.js */ "./build/wg/tilecoord.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _featureloader_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../featureloader.js */ "./build/wg/featureloader.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../size.js */ "./build/wg/size.js");
/**
 * @module wg/source/VectorTile
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();













/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {import("../format/Feature.js").default} [format] Feature format for tiles. Used and required by the default.
 * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this
 * to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.
 * @property {import("./State.js").default} [state] Source state.
 * @property {typeof import("../VectorTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:wg/VectorTile~VectorTile}.
 * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number|import("../size.js").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction]
 * Optional function to load a tile given a URL. Could look like this for pbf tiles:
 * ```js
 * function(tile, url) {
 *   tile.setLoader(function(extent, resolution, projection) {
 *     fetch(url).then(function(response) {
 *       response.arrayBuffer().then(function(data) {
 *         const format = tile.getFormat() // ol/format/MVT configured as source format
 *         const features = format.readFeatures(data, {
 *           extent: extent,
 *           featureProjection: projection
 *         });
 *         tile.setFeatures(features);
 *       });
 *     });
 *   });
 * }
 * ```
 * If you do not need extent, resolution and projection to get the features for a tile (e.g.
 * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure
 * to call `setFeatures()` on the tile:
 * ```js
 * const format = new GeoJSON({featureProjection: map.getView().getProjection()});
 * async function tileLoadFunction(tile, url) {
 *   const response = await fetch(url);
 *   const data = await response.json();
 *   tile.setFeatures(format.readFeatures(data));
 * }
 * ```
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {number} [transition] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When set to `true`, tiles will be wrapped horizontally to
 * render multiple worlds.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=1]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Class for layer sources providing vector data divided into a tile grid, to be
 * used with {@link module:wg/layer/VectorTile~VectorTileLayer}. Although this source receives tiles
 * with vector features from the server, it is not meant for feature editing.
 * Features are optimized for rendering, their geometries are clipped at or near
 * tile boundaries and simplified for a view resolution. See
 * {@link module:wg/source/Vector~VectorSource} for vector sources that are suitable for feature
 * editing.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */

var VectorTile =
/** @class */
function (_super) {
  __extends(VectorTile, _super);
  /**
   * @param {!Options} options Vector tile options.
   */


  function VectorTile(options) {
    var _this = this;

    var projection = options.projection || 'EPSG:3857';
    var extent = options.extent || (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_0__.extentFromProjection)(projection);
    var tileGrid = options.tileGrid || (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_0__.createXYZ)({
      extent: extent,
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,
      minZoom: options.minZoom,
      tileSize: options.tileSize || 512
    });
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      interpolate: true,
      opaque: false,
      projection: projection,
      state: options.state,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX === undefined ? true : options.wrapX,
      transition: options.transition,
      zDirection: options.zDirection === undefined ? 1 : options.zDirection
    }) || this;
    /**
     * @private
     * @type {import("../format/Feature.js").default|null}
     */

    _this.format_ = options.format ? options.format : null;
    /**
     * @private
     * @type {TileCache}
     */

    _this.sourceTileCache = new _TileCache_js__WEBPACK_IMPORTED_MODULE_1__["default"](_this.tileCache.highWaterMark);
    /**
     * @private
     * @type {boolean}
     */

    _this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;
    /**
     * @protected
     * @type {typeof import("../VectorTile.js").default}
     */

    _this.tileClass = options.tileClass ? options.tileClass : _VectorTile_js__WEBPACK_IMPORTED_MODULE_2__["default"];
    /**
     * @private
     * @type {Object<string, import("../tilegrid/TileGrid.js").default>}
     */

    _this.tileGrids_ = {};
    return _this;
  }
  /**
   * Get features whose bounding box intersects the provided extent. Only features for cached
   * tiles for the last rendered zoom level are available in the source. So this method is only
   * suitable for requesting tiles for extents that are currently rendered.
   *
   * Features are returned in random tile order and as they are included in the tiles. This means
   * they can be clipped, duplicated across tiles, and simplified to the render resolution.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */


  VectorTile.prototype.getFeaturesInExtent = function (extent) {
    var features = [];
    var tileCache = this.tileCache;

    if (tileCache.getCount() === 0) {
      return features;
    }

    var z = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_3__.fromKey)(tileCache.peekFirstKey())[0];
    var tileGrid = this.tileGrid;
    tileCache.forEach(function (tile) {
      if (tile.tileCoord[0] !== z || tile.getState() !== _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED) {
        return;
      }

      var sourceTiles = tile.getSourceTiles();

      for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {
        var sourceTile = sourceTiles[i];
        var tileCoord = sourceTile.tileCoord;

        if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.intersects)(extent, tileGrid.getTileCoordExtent(tileCoord))) {
          var tileFeatures = sourceTile.getFeatures();

          if (tileFeatures) {
            for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {
              var candidate = tileFeatures[j];
              var geometry = candidate.getGeometry();

              if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.intersects)(extent, geometry.getExtent())) {
                features.push(candidate);
              }
            }
          }
        }
      }
    });
    return features;
  };
  /**
   * @return {boolean} The source can have overlapping geometries.
   */


  VectorTile.prototype.getOverlaps = function () {
    return this.overlaps_;
  };
  /**
   * clear {@link module:wg/TileCache~TileCache} and delete all source tiles
   * @api
   */


  VectorTile.prototype.clear = function () {
    this.tileCache.clear();
    this.sourceTileCache.clear();
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */


  VectorTile.prototype.expireCache = function (projection, usedTiles) {
    var tileCache = this.getTileCacheForProjection(projection);
    var usedSourceTiles = Object.keys(usedTiles).reduce(function (acc, key) {
      var cacheKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_3__.getCacheKeyForTileKey)(key);

      if (tileCache.containsKey(cacheKey)) {
        var sourceTiles = tileCache.get(cacheKey).sourceTiles;

        for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {
          acc[sourceTiles[i].getKey()] = true;
        }
      }

      return acc;
    }, {});

    _super.prototype.expireCache.call(this, projection, usedTiles);

    this.sourceTileCache.expireCache(usedSourceTiles);
  };
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection").default} projection Projection.
   * @param {VectorRenderTile} tile Vector image tile.
   * @return {Array<import("../VectorTile").default>} Tile keys.
   */


  VectorTile.prototype.getSourceTiles = function (pixelRatio, projection, tile) {
    var _this = this;

    if (tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE) {
      tile.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADING);
      var urlTileCoord = tile.wrappedTileCoord;
      var tileGrid = this.getTileGridForProjection(projection);
      var extent = tileGrid.getTileCoordExtent(urlTileCoord);
      var z = urlTileCoord[0];
      var resolution = tileGrid.getResolution(z); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space

      (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.buffer)(extent, -resolution, extent);
      var sourceTileGrid_1 = this.tileGrid;
      var sourceExtent = sourceTileGrid_1.getExtent();

      if (sourceExtent) {
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getIntersection)(extent, sourceExtent, extent);
      }

      var sourceZ = sourceTileGrid_1.getZForResolution(resolution, 1);
      sourceTileGrid_1.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {
        var tileUrl = _this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);

        var sourceTile = _this.sourceTileCache.containsKey(tileUrl) ? _this.sourceTileCache.get(tileUrl) : new _this.tileClass(sourceTileCoord, tileUrl ? _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE : _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].EMPTY, tileUrl, _this.format_, _this.tileLoadFunction);
        tile.sourceTiles.push(sourceTile);
        var sourceTileState = sourceTile.getState();

        if (sourceTileState < _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED) {
          var listenChange_1 = function listenChange_1(event) {
            _this.handleTileChange(event);

            var state = sourceTile.getState();

            if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED || state === _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR) {
              var sourceTileKey = sourceTile.getKey();

              if (sourceTileKey in tile.errorTileKeys) {
                if (sourceTile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED) {
                  delete tile.errorTileKeys[sourceTileKey];
                }
              } else {
                tile.loadingSourceTiles--;
              }

              if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR) {
                tile.errorTileKeys[sourceTileKey] = true;
              } else {
                sourceTile.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, listenChange_1);
              }

              if (tile.loadingSourceTiles === 0) {
                tile.setState((0,_obj_js__WEBPACK_IMPORTED_MODULE_7__.isEmpty)(tile.errorTileKeys) ? _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED : _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR);
              }
            }
          };

          sourceTile.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, listenChange_1);
          tile.loadingSourceTiles++;
        }

        if (sourceTileState === _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE) {
          sourceTile.extent = sourceTileGrid_1.getTileCoordExtent(sourceTileCoord);
          sourceTile.projection = projection;
          sourceTile.resolution = sourceTileGrid_1.getResolution(sourceTileCoord[0]);

          _this.sourceTileCache.set(tileUrl, sourceTile);

          sourceTile.load();
        }
      });

      if (!tile.loadingSourceTiles) {
        tile.setState(tile.sourceTiles.some(function (sourceTile) {
          return sourceTile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR;
        }) ? _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR : _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED);
      }
    }

    return tile.sourceTiles;
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!VectorRenderTile} Tile.
   */


  VectorTile.prototype.getTile = function (z, x, y, pixelRatio, projection) {
    var coordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_3__.getKeyZXY)(z, x, y);
    var key = this.getKey();
    var tile;

    if (this.tileCache.containsKey(coordKey)) {
      tile = this.tileCache.get(coordKey);

      if (tile.key === key) {
        return tile;
      }
    }

    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
    var sourceExtent = this.getTileGrid().getExtent();
    var tileGrid = this.getTileGridForProjection(projection);

    if (urlTileCoord && sourceExtent) {
      var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space

      (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.buffer)(tileExtent, -tileGrid.getResolution(z), tileExtent);

      if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.intersects)(sourceExtent, tileExtent)) {
        urlTileCoord = null;
      }
    }

    var empty = true;

    if (urlTileCoord !== null) {
      var sourceTileGrid = this.tileGrid;
      var resolution = tileGrid.getResolution(z);
      var sourceZ = sourceTileGrid.getZForResolution(resolution, 1); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space

      var extent = tileGrid.getTileCoordExtent(urlTileCoord);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.buffer)(extent, -resolution, extent);
      sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {
        empty = empty && !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);
      }.bind(this));
    }

    var newTile = new _VectorRenderTile_js__WEBPACK_IMPORTED_MODULE_8__["default"](tileCoord, empty ? _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].EMPTY : _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));
    newTile.key = key;

    if (tile) {
      newTile.interimTile = tile;
      newTile.refreshInterimChain();
      this.tileCache.replace(coordKey, newTile);
    } else {
      this.tileCache.set(coordKey, newTile);
    }

    return newTile;
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */


  VectorTile.prototype.getTileGridForProjection = function (projection) {
    var code = projection.getCode();
    var tileGrid = this.tileGrids_[code];

    if (!tileGrid) {
      // A tile grid that matches the tile size of the source tile grid is more
      // likely to have 1:1 relationships between source tiles and rendered tiles.
      var sourceTileGrid = this.tileGrid;
      tileGrid = (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_0__.createForProjection)(projection, undefined, sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);
      this.tileGrids_[code] = tileGrid;
    }

    return tileGrid;
  };
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */


  VectorTile.prototype.getTilePixelRatio = function (pixelRatio) {
    return pixelRatio;
  };
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */


  VectorTile.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
    var tileGrid = this.getTileGridForProjection(projection);
    var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_9__.toSize)(tileGrid.getTileSize(z), this.tmpSize);
    return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];
  };
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */


  VectorTile.prototype.updateCacheSize = function (tileCount, projection) {
    _super.prototype.updateCacheSize.call(this, tileCount * 2, projection);

    this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(projection).highWaterMark;
  };

  return VectorTile;
}(_UrlTile_js__WEBPACK_IMPORTED_MODULE_10__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VectorTile);
/**
 * Sets the loader for a tile.
 * @param {import("../VectorTile.js").default} tile Vector tile.
 * @param {string} url URL.
 */

function defaultLoadFunction(tile, url) {
  tile.setLoader(
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  function (extent, resolution, projection) {
    (0,_featureloader_js__WEBPACK_IMPORTED_MODULE_11__.loadFeaturesXhr)(url, tile.getFormat(), extent, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));
  });
}

/***/ }),

/***/ "./build/wg/source/WMSServerType.js":
/*!******************************************!*\
  !*** ./build/wg/source/WMSServerType.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/source/WMSServerType
 */

/**
 * Available server types: `'carmentaserver'`, `'geoserver'`, `'mapserver'`,
 *     `'qgis'`. These are servers that have vendor parameters beyond the WMS
 *     specification that OpenLayers can make use of.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * HiDPI support for [Carmenta Server](https://www.carmenta.com/en/products/carmenta-server)
   * @api
   */
  CARMENTA_SERVER: 'carmentaserver',

  /**
   * HiDPI support for [GeoServer](https://geoserver.org/)
   * @api
   */
  GEOSERVER: 'geoserver',

  /**
   * HiDPI support for [MapServer](https://mapserver.org/)
   * @api
   */
  MAPSERVER: 'mapserver',

  /**
   * HiDPI support for [QGIS](https://qgis.org/)
   * @api
   */
  QGIS: 'qgis'
});

/***/ }),

/***/ "./build/wg/source/WMTS.js":
/*!*********************************!*\
  !*** ./build/wg/source/WMTS.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "optionsFromCapabilities": function() { return /* binding */ optionsFromCapabilities; }
/* harmony export */ });
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TileImage.js */ "./build/wg/source/TileImage.js");
/* harmony import */ var _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WMTSRequestEncoding.js */ "./build/wg/source/WMTSRequestEncoding.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../uri.js */ "./build/wg/uri.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _tilegrid_WMTS_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tilegrid/WMTS.js */ "./build/wg/tilegrid/WMTS.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tileurlfunction.js */ "./build/wg/tileurlfunction.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/**
 * @module wg/source/WMTS
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();










/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../tilegrid/WMTS.js").default} tileGrid Tile grid.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./WMTSRequestEncoding.js").default|string} [requestEncoding='KVP'] Request encoding.
 * @property {string} layer Layer name as advertised in the WMTS capabilities.
 * @property {string} style Style name as advertised in the WMTS capabilities.
 * @property {typeof import("../ImageTile.js").default} [tileClass]  Class used to instantiate image tiles. Default is {@link module:wg/ImageTile~ImageTile}.
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {string} [format='image/jpeg'] Image format. Only used when `requestEncoding` is `'KVP'`.
 * @property {string} [version='1.0.0'] WMTS version.
 * @property {string} matrixSet Matrix set.
 * @property {!Object} [dimensions] Additional "dimensions" for tile requests.
 * This is an object with properties named like the advertised WMTS dimensions.
 * @property {string} [url]  A URL for the service.
 * For the RESTful request encoding, this is a URL
 * template.  For KVP encoding, it is normal URL. A `{?-?}` template pattern,
 * for example `subdomain{a-f}.domain.com`, may be used instead of defining
 * each one separately in the `urls` option.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {Array<string>} [urls] An array of URLs.
 * Requests will be distributed among the URLs in this array.
 * @property {boolean} [wrapX=false] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for tile data from WMTS servers.
 * @api
 */

var WMTS =
/** @class */
function (_super) {
  __extends(WMTS, _super);
  /**
   * @param {Options} options WMTS options.
   */


  function WMTS(options) {
    var _this = this;

    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    } // TODO: add support for TileMatrixLimits


    var requestEncoding = options.requestEncoding !== undefined ?
    /** @type {import("./WMTSRequestEncoding.js").default} */
    options.requestEncoding : _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_1__["default"].KVP; // FIXME: should we create a default tileGrid?
    // we could issue a getCapabilities xhr to retrieve missing configuration

    var tileGrid = options.tileGrid;
    var urls = options.urls;

    if (urls === undefined && options.url !== undefined) {
      urls = (0,_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__.expandUrl)(options.url);
    }

    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: interpolate,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      urls: urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : false,
      transition: options.transition,
      zDirection: options.zDirection
    }) || this;
    /**
     * @private
     * @type {string}
     */

    _this.version_ = options.version !== undefined ? options.version : '1.0.0';
    /**
     * @private
     * @type {string}
     */

    _this.format_ = options.format !== undefined ? options.format : 'image/jpeg';
    /**
     * @private
     * @type {!Object}
     */

    _this.dimensions_ = options.dimensions !== undefined ? options.dimensions : {};
    /**
     * @private
     * @type {string}
     */

    _this.layer_ = options.layer;
    /**
     * @private
     * @type {string}
     */

    _this.matrixSet_ = options.matrixSet;
    /**
     * @private
     * @type {string}
     */

    _this.style_ = options.style; // FIXME: should we guess this requestEncoding from options.url(s)
    //        structure? that would mean KVP only if a template is not provided.

    /**
     * @private
     * @type {import("./WMTSRequestEncoding.js").default}
     */

    _this.requestEncoding_ = requestEncoding;

    _this.setKey(_this.getKeyForDimensions_());

    if (urls && urls.length > 0) {
      _this.tileUrlFunction = (0,_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__.createFromTileUrlFunctions)(urls.map(_this.createFromWMTSTemplate.bind(_this)));
    }

    return _this;
  }
  /**
   * Set the URLs to use for requests.
   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
   * @param {Array<string>} urls URLs.
   */


  WMTS.prototype.setUrls = function (urls) {
    this.urls = urls;
    var key = urls.join('\n');
    this.setTileUrlFunction((0,_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__.createFromTileUrlFunctions)(urls.map(this.createFromWMTSTemplate.bind(this))), key);
  };
  /**
   * Get the dimensions, i.e. those passed to the constructor through the
   * "dimensions" option, and possibly updated using the updateDimensions
   * method.
   * @return {!Object} Dimensions.
   * @api
   */


  WMTS.prototype.getDimensions = function () {
    return this.dimensions_;
  };
  /**
   * Return the image format of the WMTS source.
   * @return {string} Format.
   * @api
   */


  WMTS.prototype.getFormat = function () {
    return this.format_;
  };
  /**
   * Return the layer of the WMTS source.
   * @return {string} Layer.
   * @api
   */


  WMTS.prototype.getLayer = function () {
    return this.layer_;
  };
  /**
   * Return the matrix set of the WMTS source.
   * @return {string} MatrixSet.
   * @api
   */


  WMTS.prototype.getMatrixSet = function () {
    return this.matrixSet_;
  };
  /**
   * Return the request encoding, either "KVP" or "REST".
   * @return {import("./WMTSRequestEncoding.js").default} Request encoding.
   * @api
   */


  WMTS.prototype.getRequestEncoding = function () {
    return this.requestEncoding_;
  };
  /**
   * Return the style of the WMTS source.
   * @return {string} Style.
   * @api
   */


  WMTS.prototype.getStyle = function () {
    return this.style_;
  };
  /**
   * Return the version of the WMTS source.
   * @return {string} Version.
   * @api
   */


  WMTS.prototype.getVersion = function () {
    return this.version_;
  };
  /**
   * @private
   * @return {string} The key for the current dimensions.
   */


  WMTS.prototype.getKeyForDimensions_ = function () {
    var i = 0;
    var res = [];

    for (var key in this.dimensions_) {
      res[i++] = key + '-' + this.dimensions_[key];
    }

    return res.join('/');
  };
  /**
   * Update the dimensions.
   * @param {Object} dimensions Dimensions.
   * @api
   */


  WMTS.prototype.updateDimensions = function (dimensions) {
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.assign)(this.dimensions_, dimensions);
    this.setKey(this.getKeyForDimensions_());
  };
  /**
   * @param {string} template Template.
   * @return {import("../Tile.js").UrlFunction} Tile URL function.
   */


  WMTS.prototype.createFromWMTSTemplate = function (template) {
    var requestEncoding = this.requestEncoding_; // context property names are lower case to allow for a case insensitive
    // replacement as some services use different naming conventions

    var context = {
      'layer': this.layer_,
      'style': this.style_,
      'tilematrixset': this.matrixSet_
    };

    if (requestEncoding == _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_1__["default"].KVP) {
      (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.assign)(context, {
        'Service': 'WMTS',
        'Request': 'GetTile',
        'Version': this.version_,
        'Format': this.format_
      });
    } // TODO: we may want to create our own appendParams function so that params
    // order conforms to wmts spec guidance, and so that we can avoid to escape
    // special template params


    template = requestEncoding == _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_1__["default"].KVP ? (0,_uri_js__WEBPACK_IMPORTED_MODULE_4__.appendParams)(template, context) : template.replace(/\{(\w+?)\}/g, function (m, p) {
      return p.toLowerCase() in context ? context[p.toLowerCase()] : m;
    });
    var tileGrid =
    /** @type {import("../tilegrid/WMTS.js").default} */
    this.tileGrid;
    var dimensions = this.dimensions_;
    return (
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function (tileCoord, pixelRatio, projection) {
        if (!tileCoord) {
          return undefined;
        } else {
          var localContext_1 = {
            'TileMatrix': tileGrid.getMatrixId(tileCoord[0]),
            'TileCol': tileCoord[1],
            'TileRow': tileCoord[2]
          };
          (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.assign)(localContext_1, dimensions);
          var url = template;

          if (requestEncoding == _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_1__["default"].KVP) {
            url = (0,_uri_js__WEBPACK_IMPORTED_MODULE_4__.appendParams)(url, localContext_1);
          } else {
            url = url.replace(/\{(\w+?)\}/g, function (m, p) {
              return localContext_1[p];
            });
          }

          return url;
        }
      }
    );
  };

  return WMTS;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_5__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (WMTS);
/**
 * Generate source options from a capabilities object.
 * @param {Object} wmtsCap An object representing the capabilities document.
 * @param {!Object} config Configuration properties for the layer.  Defaults for
 *                  the layer will apply if not provided.
 *
 * Required config properties:
 *  - layer - {string} The layer identifier.
 *
 * Optional config properties:
 *  - matrixSet - {string} The matrix set identifier, required if there is
 *       more than one matrix set in the layer capabilities.
 *  - projection - {string} The desired CRS when no matrixSet is specified.
 *       eg: "EPSG:3857". If the desired projection is not available,
 *       an error is thrown.
 *  - requestEncoding - {string} url encoding format for the layer. Default is
 *       the first tile url format found in the GetCapabilities response.
 *  - style - {string} The name of the style
 *  - format - {string} Image format for the layer. Default is the first
 *       format returned in the GetCapabilities response.
 *  - crossOrigin - {string|null|undefined} Cross origin. Default is `undefined`.
 * @return {Options|null} WMTS source options object or `null` if the layer was not found.
 * @api
 */

function optionsFromCapabilities(wmtsCap, config) {
  var layers = wmtsCap['Contents']['Layer'];
  var l = (0,_array_js__WEBPACK_IMPORTED_MODULE_6__.find)(layers, function (elt, index, array) {
    return elt['Identifier'] == config['layer'];
  });

  if (l === null) {
    return null;
  }

  var tileMatrixSets = wmtsCap['Contents']['TileMatrixSet'];
  var idx;

  if (l['TileMatrixSetLink'].length > 1) {
    if ('projection' in config) {
      idx = (0,_array_js__WEBPACK_IMPORTED_MODULE_6__.findIndex)(l['TileMatrixSetLink'], function (elt, index, array) {
        var tileMatrixSet = (0,_array_js__WEBPACK_IMPORTED_MODULE_6__.find)(tileMatrixSets, function (el) {
          return el['Identifier'] == elt['TileMatrixSet'];
        });
        var supportedCRS = tileMatrixSet['SupportedCRS'];
        var proj1 = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(supportedCRS);
        var proj2 = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(config['projection']);

        if (proj1 && proj2) {
          return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(proj1, proj2);
        } else {
          return supportedCRS == config['projection'];
        }
      });
    } else {
      idx = (0,_array_js__WEBPACK_IMPORTED_MODULE_6__.findIndex)(l['TileMatrixSetLink'], function (elt, index, array) {
        return elt['TileMatrixSet'] == config['matrixSet'];
      });
    }
  } else {
    idx = 0;
  }

  if (idx < 0) {
    idx = 0;
  }

  var matrixSet =
  /** @type {string} */
  l['TileMatrixSetLink'][idx]['TileMatrixSet'];
  var matrixLimits =
  /** @type {Array<Object>} */
  l['TileMatrixSetLink'][idx]['TileMatrixSetLimits'];
  var format =
  /** @type {string} */
  l['Format'][0];

  if ('format' in config) {
    format = config['format'];
  }

  idx = (0,_array_js__WEBPACK_IMPORTED_MODULE_6__.findIndex)(l['Style'], function (elt, index, array) {
    if ('style' in config) {
      return elt['Title'] == config['style'];
    } else {
      return elt['isDefault'];
    }
  });

  if (idx < 0) {
    idx = 0;
  }

  var style =
  /** @type {string} */
  l['Style'][idx]['Identifier'];
  var dimensions = {};

  if ('Dimension' in l) {
    l['Dimension'].forEach(function (elt, index, array) {
      var key = elt['Identifier'];
      var value = elt['Default'];

      if (value === undefined) {
        value = elt['Value'][0];
      }

      dimensions[key] = value;
    });
  }

  var matrixSets = wmtsCap['Contents']['TileMatrixSet'];
  var matrixSetObj = (0,_array_js__WEBPACK_IMPORTED_MODULE_6__.find)(matrixSets, function (elt, index, array) {
    return elt['Identifier'] == matrixSet;
  });
  var projection;
  var code = matrixSetObj['SupportedCRS'];

  if (code) {
    projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(code);
  }

  if ('projection' in config) {
    var projConfig = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(config['projection']);

    if (projConfig) {
      if (!projection || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(projConfig, projection)) {
        projection = projConfig;
      }
    }
  }

  var wrapX = false;
  var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';
  var matrix = matrixSetObj.TileMatrix[0]; // create default matrixLimit

  var selectedMatrixLimit = {
    MinTileCol: 0,
    MinTileRow: 0,
    // subtract one to end up at tile top left
    MaxTileCol: matrix.MatrixWidth - 1,
    MaxTileRow: matrix.MatrixHeight - 1
  }; //in case of matrix limits, use matrix limits to calculate extent

  if (matrixLimits) {
    selectedMatrixLimit = matrixLimits[matrixLimits.length - 1];
    var m = (0,_array_js__WEBPACK_IMPORTED_MODULE_6__.find)(matrixSetObj.TileMatrix, function (tileMatrixValue) {
      return tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix || matrixSetObj.Identifier + ':' + tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix;
    });

    if (m) {
      matrix = m;
    }
  }

  var resolution = matrix.ScaleDenominator * 0.00028 / projection.getMetersPerUnit(); // WMTS 1.0.0: standardized rendering pixel size

  var origin = switchOriginXY ? [matrix.TopLeftCorner[1], matrix.TopLeftCorner[0]] : matrix.TopLeftCorner;
  var tileSpanX = matrix.TileWidth * resolution;
  var tileSpanY = matrix.TileHeight * resolution;
  var matrixSetExtent = matrixSetObj['BoundingBox'];
  var extent = [origin[0] + tileSpanX * selectedMatrixLimit.MinTileCol, // add one to get proper bottom/right coordinate
  origin[1] - tileSpanY * (1 + selectedMatrixLimit.MaxTileRow), origin[0] + tileSpanX * (1 + selectedMatrixLimit.MaxTileCol), origin[1] - tileSpanY * selectedMatrixLimit.MinTileRow];

  if (matrixSetExtent !== undefined && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_7__.containsExtent)(matrixSetExtent, extent)) {
    var wgs84BoundingBox = l['WGS84BoundingBox'];
    var wgs84ProjectionExtent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:4326').getExtent();
    extent = matrixSetExtent;

    if (wgs84BoundingBox) {
      wrapX = wgs84BoundingBox[0] === wgs84ProjectionExtent[0] && wgs84BoundingBox[2] === wgs84ProjectionExtent[2];
    } else {
      var wgs84MatrixSetExtent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.transformExtent)(matrixSetExtent, matrixSetObj['SupportedCRS'], 'EPSG:4326'); // Ignore slight deviation from the correct x limits

      wrapX = wgs84MatrixSetExtent[0] - 1e-10 <= wgs84ProjectionExtent[0] && wgs84MatrixSetExtent[2] + 1e-10 >= wgs84ProjectionExtent[2];
    }
  }

  var tileGrid = (0,_tilegrid_WMTS_js__WEBPACK_IMPORTED_MODULE_8__.createFromCapabilitiesMatrixSet)(matrixSetObj, extent, matrixLimits);
  /** @type {!Array<string>} */

  var urls = [];
  var requestEncoding = config['requestEncoding'];
  requestEncoding = requestEncoding !== undefined ? requestEncoding : '';

  if ('OperationsMetadata' in wmtsCap && 'GetTile' in wmtsCap['OperationsMetadata']) {
    var gets = wmtsCap['OperationsMetadata']['GetTile']['DCP']['HTTP']['Get'];

    for (var i = 0, ii = gets.length; i < ii; ++i) {
      if (gets[i]['Constraint']) {
        var constraint = (0,_array_js__WEBPACK_IMPORTED_MODULE_6__.find)(gets[i]['Constraint'], function (element) {
          return element['name'] == 'GetEncoding';
        });
        var encodings = constraint['AllowedValues']['Value'];

        if (requestEncoding === '') {
          // requestEncoding not provided, use the first encoding from the list
          requestEncoding = encodings[0];
        }

        if (requestEncoding === _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_1__["default"].KVP) {
          if ((0,_array_js__WEBPACK_IMPORTED_MODULE_6__.includes)(encodings, _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_1__["default"].KVP)) {
            urls.push(
            /** @type {string} */
            gets[i]['href']);
          }
        } else {
          break;
        }
      } else if (gets[i]['href']) {
        requestEncoding = _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_1__["default"].KVP;
        urls.push(
        /** @type {string} */
        gets[i]['href']);
      }
    }
  }

  if (urls.length === 0) {
    requestEncoding = _WMTSRequestEncoding_js__WEBPACK_IMPORTED_MODULE_1__["default"].REST;
    l['ResourceURL'].forEach(function (element) {
      if (element['resourceType'] === 'tile') {
        format = element['format'];
        urls.push(
        /** @type {string} */
        element['template']);
      }
    });
  }

  return {
    urls: urls,
    layer: config['layer'],
    matrixSet: matrixSet,
    format: format,
    projection: projection,
    requestEncoding: requestEncoding,
    tileGrid: tileGrid,
    style: style,
    dimensions: dimensions,
    wrapX: wrapX,
    crossOrigin: config['crossOrigin']
  };
}

/***/ }),

/***/ "./build/wg/source/WMTSRequestEncoding.js":
/*!************************************************!*\
  !*** ./build/wg/source/WMTSRequestEncoding.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/source/WMTSRequestEncoding
 */

/**
 * Request encoding. One of 'KVP', 'REST'.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  KVP: 'KVP',
  REST: 'REST' // see spec §10

});

/***/ }),

/***/ "./build/wg/source/XYZ.js":
/*!********************************!*\
  !*** ./build/wg/source/XYZ.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileImage.js */ "./build/wg/source/TileImage.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tilegrid.js */ "./build/wg/tilegrid.js");
/**
 * @module wg/source/XYZ
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();



/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * Not used if `tileGrid` is provided.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get
 * tile URL given a tile coordinate and the projection.
 * Required if `url` or `urls` are not provided.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case
 * a `tileUrlFunction` can be used, such as:
 * ```js
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';
 *  }
 * ```
 * @api
 */

var XYZ =
/** @class */
function (_super) {
  __extends(XYZ, _super);
  /**
   * @param {Options} [opt_options] XYZ options.
   */


  function XYZ(opt_options) {
    var options = opt_options || {};
    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    var projection = options.projection !== undefined ? options.projection : 'EPSG:3857';
    var tileGrid = options.tileGrid !== undefined ? options.tileGrid : (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_0__.createXYZ)({
      extent: (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_0__.extentFromProjection)(projection),
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom,
      minZoom: options.minZoom,
      tileSize: options.tileSize
    });
    return _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: interpolate,
      opaque: options.opaque,
      projection: projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    }) || this;
  }

  return XYZ;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (XYZ);

/***/ }),

/***/ "./build/wg/source/Zoomify.js":
/*!************************************!*\
  !*** ./build/wg/source/Zoomify.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CustomTile": function() { return /* binding */ CustomTile; }
/* harmony export */ });
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tilegrid/common.js */ "./build/wg/tilegrid/common.js");
/* harmony import */ var _ImageTile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageTile.js */ "./build/wg/ImageTile.js");
/* harmony import */ var _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tilegrid/TileGrid.js */ "./build/wg/tilegrid/TileGrid.js");
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TileImage.js */ "./build/wg/source/TileImage.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../TileState.js */ "./build/wg/TileState.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./build/wg/dom.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tileurlfunction.js */ "./build/wg/tileurlfunction.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../size.js */ "./build/wg/size.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/source/Zoomify
 */












/**
 * @enum {string}
 */

var TierSizeCalculation = {
  DEFAULT: 'default',
  TRUNCATED: 'truncated'
};

var CustomTile =
/** @class */
function (_super) {
  __extends(CustomTile, _super);
  /**
   * @param {import("../size.js").Size} tileSize Full tile size.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("../Tile.js").Options} [opt_options] Tile options.
   */


  function CustomTile(tileSize, tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
    var _this = _super.call(this, tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) || this;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
     */


    _this.zoomifyImage_ = null;
    /**
     * @type {import("../size.js").Size}
     */

    _this.tileSize_ = tileSize;
    return _this;
  }
  /**
   * Get the image element for this tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */


  CustomTile.prototype.getImage = function () {
    if (this.zoomifyImage_) {
      return this.zoomifyImage_;
    }

    var image = _super.prototype.getImage.call(this);

    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED) {
      var tileSize = this.tileSize_;

      if (image.width == tileSize[0] && image.height == tileSize[1]) {
        this.zoomifyImage_ = image;
        return image;
      } else {
        var context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(tileSize[0], tileSize[1]);
        context.drawImage(image, 0, 0);
        this.zoomifyImage_ = context.canvas;
        return context.canvas;
      }
    } else {
      return image;
    }
  };

  return CustomTile;
}(_ImageTile_js__WEBPACK_IMPORTED_MODULE_2__["default"]);


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value  you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {number} [tilePixelRatio] The pixel ratio used by the tile service. For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px by 512px images (for retina/hidpi devices) then `tilePixelRatio` should be set to `2`
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {string} url URL template or base URL of the Zoomify service.
 * A base URL is the fixed part
 * of the URL, excluding the tile group, z, x, and y folder structure, e.g.
 * `http://my.zoomify.info/IMAGE.TIF/`. A URL template must include
 * `{TileGroup}`, `{x}`, `{y}`, and `{z}` placeholders, e.g.
 * `http://my.zoomify.info/IMAGE.TIF/{TileGroup}/{z}-{x}-{y}.jpg`.
 * Internet Imaging Protocol (IIP) with JTL extension can be also used with
 * `{tileIndex}` and `{z}` placeholders, e.g.
 * `http://my.zoomify.info?FIF=IMAGE.TIF&JTL={z},{tileIndex}`.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {string} [tierSizeCalculation] Tier size calculation method: `default` or `truncated`.
 * @property {import("../size.js").Size} size Size.
 * @property {import("../extent.js").Extent} [extent] Extent for the TileGrid that is created.
 * Default sets the TileGrid in the
 * fourth quadrant, meaning extent is `[0, -height, width, 0]`. To change the
 * extent to the first quadrant (the default for OpenLayers 2) set the extent
 * as `[0, 0, width, height]`.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number} [tileSize=256] Tile size. Same tile size is used for all zoom levels.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:wg/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for tile data in Zoomify format (both Zoomify and Internet
 * Imaging Protocol are supported).
 * @api
 */

var Zoomify =
/** @class */
function (_super) {
  __extends(Zoomify, _super);
  /**
   * @param {Options} opt_options Options.
   */


  function Zoomify(opt_options) {
    var _this = this;

    var options = opt_options;
    var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;

    if (options.interpolate !== undefined) {
      interpolate = options.interpolate;
    }

    var size = options.size;
    var tierSizeCalculation = options.tierSizeCalculation !== undefined ? options.tierSizeCalculation : TierSizeCalculation.DEFAULT;
    var tilePixelRatio = options.tilePixelRatio || 1;
    var imageWidth = size[0];
    var imageHeight = size[1];
    var tierSizeInTiles = [];
    var tileSize = options.tileSize || _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_TILE_SIZE;
    var tileSizeForTierSizeCalculation = tileSize * tilePixelRatio;

    switch (tierSizeCalculation) {
      case TierSizeCalculation.DEFAULT:
        while (imageWidth > tileSizeForTierSizeCalculation || imageHeight > tileSizeForTierSizeCalculation) {
          tierSizeInTiles.push([Math.ceil(imageWidth / tileSizeForTierSizeCalculation), Math.ceil(imageHeight / tileSizeForTierSizeCalculation)]);
          tileSizeForTierSizeCalculation += tileSizeForTierSizeCalculation;
        }

        break;

      case TierSizeCalculation.TRUNCATED:
        var width = imageWidth;
        var height = imageHeight;

        while (width > tileSizeForTierSizeCalculation || height > tileSizeForTierSizeCalculation) {
          tierSizeInTiles.push([Math.ceil(width / tileSizeForTierSizeCalculation), Math.ceil(height / tileSizeForTierSizeCalculation)]);
          width >>= 1;
          height >>= 1;
        }

        break;

      default:
        (0,_asserts_js__WEBPACK_IMPORTED_MODULE_4__.assert)(false, 53); // Unknown `tierSizeCalculation` configured

        break;
    }

    tierSizeInTiles.push([1, 1]);
    tierSizeInTiles.reverse();
    var resolutions = [tilePixelRatio];
    var tileCountUpToTier = [0];

    for (var i = 1, ii = tierSizeInTiles.length; i < ii; i++) {
      resolutions.push(tilePixelRatio << i);
      tileCountUpToTier.push(tierSizeInTiles[i - 1][0] * tierSizeInTiles[i - 1][1] + tileCountUpToTier[i - 1]);
    }

    resolutions.reverse();
    var tileGrid = new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
      tileSize: tileSize,
      extent: options.extent || [0, -imageHeight, imageWidth, 0],
      resolutions: resolutions
    });
    var url = options.url;

    if (url && url.indexOf('{TileGroup}') == -1 && url.indexOf('{tileIndex}') == -1) {
      url += '{TileGroup}/{z}-{x}-{y}.jpg';
    }

    var urls = (0,_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_6__.expandUrl)(url);
    var tileWidth = tileSize * tilePixelRatio;
    /**
     * @param {string} template Template.
     * @return {import("../Tile.js").UrlFunction} Tile URL function.
     */

    function createFromTemplate(template) {
      return (
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile Coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        function (tileCoord, pixelRatio, projection) {
          if (!tileCoord) {
            return undefined;
          } else {
            var tileCoordZ = tileCoord[0];
            var tileCoordX = tileCoord[1];
            var tileCoordY = tileCoord[2];
            var tileIndex = tileCoordX + tileCoordY * tierSizeInTiles[tileCoordZ][0];
            var tileGroup = (tileIndex + tileCountUpToTier[tileCoordZ]) / tileWidth | 0;
            var localContext_1 = {
              'z': tileCoordZ,
              'x': tileCoordX,
              'y': tileCoordY,
              'tileIndex': tileIndex,
              'TileGroup': 'TileGroup' + tileGroup
            };
            return template.replace(/\{(\w+?)\}/g, function (m, p) {
              return localContext_1[p];
            });
          }
        }
      );
    }

    var tileUrlFunction = (0,_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_6__.createFromTileUrlFunctions)(urls.map(createFromTemplate));
    var ZoomifyTileClass = CustomTile.bind(null, (0,_size_js__WEBPACK_IMPORTED_MODULE_7__.toSize)(tileSize * tilePixelRatio));
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: interpolate,
      projection: options.projection,
      tilePixelRatio: tilePixelRatio,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: ZoomifyTileClass,
      tileGrid: tileGrid,
      tileUrlFunction: tileUrlFunction,
      transition: options.transition
    }) || this;
    /**
     * @type {number|import("../array.js").NearestDirectionFunction}
     */

    _this.zDirection = options.zDirection; // Server retina tile detection (non-standard):
    // Try loading the center tile for the highest resolution. If it is not
    // available, we are dealing with retina tiles, and need to adjust the
    // tile url calculation.

    var tileUrl = tileGrid.getTileCoordForCoordAndResolution((0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getCenter)(tileGrid.getExtent()), resolutions[resolutions.length - 1]);
    var testTileUrl = tileUrlFunction(tileUrl, 1, null);
    var image = new Image();
    image.addEventListener('error', function () {
      tileWidth = tileSize;
      this.changed();
    }.bind(_this));
    image.src = testTileUrl;
    return _this;
  }

  return Zoomify;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_9__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Zoomify);

/***/ }),

/***/ "./build/wg/source/common.js":
/*!***********************************!*\
  !*** ./build/wg/source/common.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_WMS_VERSION": function() { return /* binding */ DEFAULT_WMS_VERSION; }
/* harmony export */ });
/**
 * @module wg/source/common
 */

/**
 * Default WMS version.
 * @type {string}
 */
var DEFAULT_WMS_VERSION = '1.3.0';

/***/ }),

/***/ "./build/wg/source/ogcTileUtil.js":
/*!****************************************!*\
  !*** ./build/wg/source/ogcTileUtil.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getMapTileUrlTemplate": function() { return /* binding */ getMapTileUrlTemplate; },
/* harmony export */   "getVectorTileUrlTemplate": function() { return /* binding */ getVectorTileUrlTemplate; },
/* harmony export */   "getTileSetInfo": function() { return /* binding */ getTileSetInfo; }
/* harmony export */ });
/* harmony import */ var _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tilegrid/TileGrid.js */ "./build/wg/tilegrid/TileGrid.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _net_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../net.js */ "./build/wg/net.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/**
 * @module wg/source/ogcTileUtil
 */





/**
 * See https://ogcapi.ogc.org/tiles/.
 */

/**
 * @typedef {'map' | 'vector'} TileType
 */

/**
 * @typedef {'topLeft' | 'bottomLeft'} CornerOfOrigin
 */

/**
 * @typedef {Object} TileSet
 * @property {TileType} dataType Type of data represented in the tileset.
 * @property {string} [tileMatrixSetDefinition] Reference to a tile matrix set definition.
 * @property {TileMatrixSet} [tileMatrixSet] Tile matrix set definition.
 * @property {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.
 * @property {Array<Link>} links Tileset links.
 */

/**
 * @typedef {Object} Link
 * @property {string} rel The link rel attribute.
 * @property {string} href The link URL.
 * @property {string} type The link type.
 */

/**
 * @typedef {Object} TileMatrixSetLimit
 * @property {string} tileMatrix The tile matrix id.
 * @property {number} minTileRow The minimum tile row.
 * @property {number} maxTileRow The maximum tile row.
 * @property {number} minTileCol The minimum tile column.
 * @property {number} maxTileCol The maximum tile column.
 */

/**
 * @typedef {Object} TileMatrixSet
 * @property {string} id The tile matrix set identifier.
 * @property {string} crs The coordinate reference system.
 * @property {Array<TileMatrix>} tileMatrices Array of tile matrices.
 */

/**
 * @typedef {Object} TileMatrix
 * @property {string} id The tile matrix identifier.
 * @property {number} cellSize The pixel resolution (map units per pixel).
 * @property {Array<number>} pointOfOrigin The map location of the matrix origin.
 * @property {CornerOfOrigin} [cornerOfOrigin='topLeft'] The corner of the matrix that represents the origin ('topLeft' or 'bottomLeft').
 * @property {number} matrixWidth The number of columns.
 * @property {number} matrixHeight The number of rows.
 * @property {number} tileWidth The pixel width of a tile.
 * @property {number} tileHeight The pixel height of a tile.
 */

/**
 * @type {Object<string, boolean>}
 */

var knownMapMediaTypes = {
  'image/png': true,
  'image/jpeg': true,
  'image/gif': true,
  'image/webp': true
};
/**
 * @type {Object<string, boolean>}
 */

var knownVectorMediaTypes = {
  'application/vnd.mapbox-vector-tile': true,
  'application/geo+json': true
};
/**
 * @typedef {Object} TileSetInfo
 * @property {string} urlTemplate The tile URL template.
 * @property {import("../tilegrid/TileGrid.js").default} grid The tile grid.
 * @property {import("../Tile.js").UrlFunction} urlFunction The tile URL function.
 */

/**
 * @typedef {Object} SourceInfo
 * @property {string} url The tile set URL.
 * @property {string} mediaType The preferred tile media type.
 * @property {Array<string>} [supportedMediaTypes] The supported media types.
 * @property {import("../proj/Projection.js").default} projection The source projection.
 * @property {Object} [context] Optional context for constructing the URL.
 */

/**
 * @param {Array<Link>} links Tileset links.
 * @param {string} [mediaType] The preferred media type.
 * @return {string} The tile URL template.
 */

function getMapTileUrlTemplate(links, mediaType) {
  var tileUrlTemplate;
  var fallbackUrlTemplate;

  for (var i = 0; i < links.length; ++i) {
    var link = links[i];

    if (link.rel === 'item') {
      if (link.type === mediaType) {
        tileUrlTemplate = link.href;
        break;
      }

      if (knownMapMediaTypes[link.type]) {
        fallbackUrlTemplate = link.href;
      } else if (!fallbackUrlTemplate && link.type.indexOf('image/') === 0) {
        fallbackUrlTemplate = link.href;
      }
    }
  }

  if (!tileUrlTemplate) {
    if (fallbackUrlTemplate) {
      tileUrlTemplate = fallbackUrlTemplate;
    } else {
      throw new Error('Could not find "item" link');
    }
  }

  return tileUrlTemplate;
}
/**
 * @param {Array<Link>} links Tileset links.
 * @param {string} [mediaType] The preferred media type.
 * @param {Array<string>} [supportedMediaTypes] The media types supported by the parser.
 * @return {string} The tile URL template.
 */

function getVectorTileUrlTemplate(links, mediaType, supportedMediaTypes) {
  var tileUrlTemplate;
  var fallbackUrlTemplate;
  /**
   * Lookup of URL by media type.
   * @type {Object<string, string>}
   */

  var hrefLookup = {};

  for (var i = 0; i < links.length; ++i) {
    var link = links[i];
    hrefLookup[link.type] = link.href;

    if (link.rel === 'item') {
      if (link.type === mediaType) {
        tileUrlTemplate = link.href;
        break;
      }

      if (knownVectorMediaTypes[link.type]) {
        fallbackUrlTemplate = link.href;
      }
    }
  }

  if (!tileUrlTemplate && supportedMediaTypes) {
    for (var i = 0; i < supportedMediaTypes.length; ++i) {
      var supportedMediaType = supportedMediaTypes[i];

      if (hrefLookup[supportedMediaType]) {
        tileUrlTemplate = hrefLookup[supportedMediaType];
        break;
      }
    }
  }

  if (!tileUrlTemplate) {
    if (fallbackUrlTemplate) {
      tileUrlTemplate = fallbackUrlTemplate;
    } else {
      throw new Error('Could not find "item" link');
    }
  }

  return tileUrlTemplate;
}
/**
 * @param {SourceInfo} sourceInfo The source info.
 * @param {TileMatrixSet} tileMatrixSet Tile matrix set.
 * @param {string} tileUrlTemplate Tile URL template.
 * @param {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.
 * @return {TileSetInfo} Tile set info.
 */

function parseTileMatrixSet(sourceInfo, tileMatrixSet, tileUrlTemplate, tileMatrixSetLimits) {
  var projection = sourceInfo.projection;

  if (!projection) {
    projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(tileMatrixSet.crs);

    if (!projection) {
      throw new Error("Unsupported CRS: ".concat(tileMatrixSet.crs));
    }
  }

  var backwards = projection.getAxisOrientation().substr(0, 2) !== 'en';
  var matrices = tileMatrixSet.tileMatrices;
  /**
   * @type {Object<string, TileMatrix>}
   */

  var matrixLookup = {};

  for (var i = 0; i < matrices.length; ++i) {
    var matrix = matrices[i];
    matrixLookup[matrix.id] = matrix;
  }
  /**
   * @type {Object<string, TileMatrixSetLimit>}
   */


  var limitLookup = {};
  /**
   * @type {Array<string>}
   */

  var matrixIds = [];

  if (tileMatrixSetLimits) {
    for (var i = 0; i < tileMatrixSetLimits.length; ++i) {
      var limit = tileMatrixSetLimits[i];
      var id = limit.tileMatrix;
      matrixIds.push(id);
      limitLookup[id] = limit;
    }
  } else {
    for (var i = 0; i < matrices.length; ++i) {
      var id = matrices[i].id;
      matrixIds.push(id);
    }
  }

  var length = matrixIds.length;
  var origins = new Array(length);
  var resolutions = new Array(length);
  var sizes = new Array(length);
  var tileSizes = new Array(length);
  var extent = [-Infinity, -Infinity, Infinity, Infinity];

  for (var i = 0; i < length; ++i) {
    var id = matrixIds[i];
    var matrix = matrixLookup[id];
    var origin_1 = matrix.pointOfOrigin;

    if (backwards) {
      origins[i] = [origin_1[1], origin_1[0]];
    } else {
      origins[i] = origin_1;
    }

    resolutions[i] = matrix.cellSize;
    sizes[i] = [matrix.matrixWidth, matrix.matrixHeight];
    tileSizes[i] = [matrix.tileWidth, matrix.tileHeight];
    var limit = limitLookup[id];

    if (limit) {
      var tileMapWidth = matrix.cellSize * matrix.tileWidth;
      var minX = origins[i][0] + limit.minTileCol * tileMapWidth;
      var maxX = origins[i][0] + (limit.maxTileCol + 1) * tileMapWidth;
      var tileMapHeight = matrix.cellSize * matrix.tileHeight;
      var upsideDown = matrix.cornerOfOrigin === 'bottomLeft';
      var minY = void 0;
      var maxY = void 0;

      if (upsideDown) {
        minY = origins[i][1] + limit.minTileRow * tileMapHeight;
        maxY = origins[i][1] + (limit.maxTileRow + 1) * tileMapHeight;
      } else {
        minY = origins[i][1] - (limit.maxTileRow + 1) * tileMapHeight;
        maxY = origins[i][1] - limit.minTileRow * tileMapHeight;
      }

      (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getIntersection)(extent, [minX, minY, maxX, maxY], extent);
    }
  }

  var tileGrid = new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
    origins: origins,
    resolutions: resolutions,
    sizes: sizes,
    tileSizes: tileSizes,
    extent: tileMatrixSetLimits ? extent : undefined
  });
  var context = sourceInfo.context;
  var base = sourceInfo.url;

  function tileUrlFunction(tileCoord, pixelRatio, projection) {
    if (!tileCoord) {
      return undefined;
    }

    var id = matrixIds[tileCoord[0]];
    var matrix = matrixLookup[id];
    var upsideDown = matrix.cornerOfOrigin === 'bottomLeft';
    var localContext = {
      tileMatrix: id,
      tileCol: tileCoord[1],
      tileRow: upsideDown ? -tileCoord[2] - 1 : tileCoord[2]
    };

    if (tileMatrixSetLimits) {
      var limit = limitLookup[matrix.id];

      if (localContext.tileCol < limit.minTileCol || localContext.tileCol > limit.maxTileCol || localContext.tileRow < limit.minTileRow || localContext.tileRow > limit.maxTileRow) {
        return undefined;
      }
    }

    (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.assign)(localContext, context);
    var url = tileUrlTemplate.replace(/\{(\w+?)\}/g, function (m, p) {
      return localContext[p];
    });
    return (0,_net_js__WEBPACK_IMPORTED_MODULE_4__.resolveUrl)(base, url);
  }

  return {
    grid: tileGrid,
    urlTemplate: tileUrlTemplate,
    urlFunction: tileUrlFunction
  };
}
/**
 * @param {SourceInfo} sourceInfo The source info.
 * @param {TileSet} tileSet Tile set.
 * @return {TileSetInfo|Promise<TileSetInfo>} Tile set info.
 */


function parseTileSetMetadata(sourceInfo, tileSet) {
  var tileMatrixSetLimits = tileSet.tileMatrixSetLimits;
  var tileUrlTemplate;

  if (tileSet.dataType === 'map') {
    tileUrlTemplate = getMapTileUrlTemplate(tileSet.links, sourceInfo.mediaType);
  } else if (tileSet.dataType === 'vector') {
    tileUrlTemplate = getVectorTileUrlTemplate(tileSet.links, sourceInfo.mediaType, sourceInfo.supportedMediaTypes);
  } else {
    throw new Error('Expected tileset data type to be "map" or "vector"');
  }

  if (tileSet.tileMatrixSet) {
    return parseTileMatrixSet(sourceInfo, tileSet.tileMatrixSet, tileUrlTemplate, tileMatrixSetLimits);
  }

  var tileMatrixSetLink = tileSet.links.find(function (link) {
    return link.rel === 'http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme';
  });

  if (!tileMatrixSetLink) {
    throw new Error('Expected http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme link or tileMatrixSet');
  }

  var tileMatrixSetDefinition = tileMatrixSetLink.href;
  var url = (0,_net_js__WEBPACK_IMPORTED_MODULE_4__.resolveUrl)(sourceInfo.url, tileMatrixSetDefinition);
  return (0,_net_js__WEBPACK_IMPORTED_MODULE_4__.getJSON)(url).then(function (tileMatrixSet) {
    return parseTileMatrixSet(sourceInfo, tileMatrixSet, tileUrlTemplate, tileMatrixSetLimits);
  });
}
/**
 * @param {SourceInfo} sourceInfo Source info.
 * @return {Promise<TileSetInfo>} Tile set info.
 */


function getTileSetInfo(sourceInfo) {
  return (0,_net_js__WEBPACK_IMPORTED_MODULE_4__.getJSON)(sourceInfo.url).then(function (tileSet) {
    return parseTileSetMetadata(sourceInfo, tileSet);
  });
}

/***/ }),

/***/ "./build/wg/sphere.js":
/*!****************************!*\
  !*** ./build/wg/sphere.js ***!
  \****************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_RADIUS": function() { return /* binding */ DEFAULT_RADIUS; },
/* harmony export */   "getDistance": function() { return /* binding */ getDistance; },
/* harmony export */   "getLength": function() { return /* binding */ getLength; },
/* harmony export */   "getArea": function() { return /* binding */ getArea; },
/* harmony export */   "offset": function() { return /* binding */ offset; }
/* harmony export */ });
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./build/wg/math.js");
/**
 * @module wg/sphere
 */


/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the
 * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
 * for the WGS84 ellipsoid is used.
 */

/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */

var DEFAULT_RADIUS = 6371008.8;
/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} [opt_radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */

function getDistance(c1, c2, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c1[1]);
  var lat2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */

function getLengthInternal(coordinates, radius) {
  var length = 0;

  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += getDistance(coordinates[i], coordinates[i + 1], radius);
  }

  return length;
}
/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [opt_options] Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */


function getLength(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();

  if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }

  var length = 0;
  var coordinates, coords, i, ii, j, jj;

  switch (type) {
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT:
      {
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINEAR_RING:
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();
        length = getLengthInternal(coordinates, radius);
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON:
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          length += getLengthInternal(coordinates[i], radius);
        }

        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON:
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];

          for (j = 0, jj = coords.length; j < jj; ++j) {
            length += getLengthInternal(coords[j], radius);
          }
        }

        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION:
      {
        var geometries =
        /** @type {import("./geom/GeometryCollection.js").default} */
        geometry.getGeometries();

        for (i = 0, ii = geometries.length; i < ii; ++i) {
          length += getLength(geometries[i], opt_options);
        }

        break;
      }

    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }

  return length;
}
/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */

function getAreaInternal(coordinates, radius) {
  var area = 0;
  var len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];

  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0];
    var y2 = coordinates[i][1];
    area += (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(x2 - x1) * (2 + Math.sin((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(y1)) + Math.sin((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(y2)));
    x1 = x2;
    y1 = y2;
  }

  return area * radius * radius / 2.0;
}
/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [opt_options] Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */


function getArea(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();

  if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }

  var area = 0;
  var coordinates, coords, i, ii, j, jj;

  switch (type) {
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINEAR_RING:
      {
        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON:
      {
        coordinates =
        /** @type {import("./geom/Polygon.js").default} */
        geometry.getCoordinates();
        area = Math.abs(getAreaInternal(coordinates[0], radius));

        for (i = 1, ii = coordinates.length; i < ii; ++i) {
          area -= Math.abs(getAreaInternal(coordinates[i], radius));
        }

        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON:
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          area += Math.abs(getAreaInternal(coords[0], radius));

          for (j = 1, jj = coords.length; j < jj; ++j) {
            area -= Math.abs(getAreaInternal(coords[j], radius));
          }
        }

        break;
      }

    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION:
      {
        var geometries =
        /** @type {import("./geom/GeometryCollection.js").default} */
        geometry.getGeometries();

        for (i = 0, ii = geometries.length; i < ii; ++i) {
          area += getArea(geometries[i], opt_options);
        }

        break;
      }

    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }

  return area;
}
/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number} [opt_radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */

function offset(c1, distance, bearing, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c1[1]);
  var lon1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c1[0]);
  var dByR = distance / radius;
  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toDegrees)(lon), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toDegrees)(lat)];
}

/***/ }),

/***/ "./build/wg/string.js":
/*!****************************!*\
  !*** ./build/wg/string.js ***!
  \****************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "padNumber": function() { return /* binding */ padNumber; },
/* harmony export */   "compareVersions": function() { return /* binding */ compareVersions; }
/* harmony export */ });
/**
 * @module wg/string
 */

/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number} [opt_precision] Precision of the output string (i.e. number of decimal places)
 * @return {string} Formatted string
 */
function padNumber(number, width, opt_precision) {
  var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
  var decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
}
/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @return {number} Value
 */

function compareVersions(v1, v2) {
  var s1 = ('' + v1).split('.');
  var s2 = ('' + v2).split('.');

  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
    var n1 = parseInt(s1[i] || '0', 10);
    var n2 = parseInt(s2[i] || '0', 10);

    if (n1 > n2) {
      return 1;
    }

    if (n2 > n1) {
      return -1;
    }
  }

  return 0;
}

/***/ }),

/***/ "./build/wg/structs/LRUCache.js":
/*!**************************************!*\
  !*** ./build/wg/structs/LRUCache.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/**
 * @module wg/structs/LRUCache
 */

/**
 * @typedef {Object} Entry
 * @property {string} key_ Key.
 * @property {Object} newer Newer.
 * @property {Object} older Older.
 * @property {*} value_ Value.
 */

/**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").default
 * @template T
 */

var LRUCache =
/** @class */
function () {
  /**
   * @param {number} [opt_highWaterMark] High water mark.
   */
  function LRUCache(opt_highWaterMark) {
    /**
     * Desired max cache size after expireCache(). If set to 0, no cache entries
     * will be pruned at all.
     * @type {number}
     */
    this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;
    /**
     * @private
     * @type {number}
     */

    this.count_ = 0;
    /**
     * @private
     * @type {!Object<string, Entry>}
     */

    this.entries_ = {};
    /**
     * @private
     * @type {?Entry}
     */

    this.oldest_ = null;
    /**
     * @private
     * @type {?Entry}
     */

    this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */


  LRUCache.prototype.canExpireCache = function () {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  };
  /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */


  LRUCache.prototype.expireCache = function (keep) {
    while (this.canExpireCache()) {
      this.pop();
    }
  };
  /**
   * FIXME empty description for jsdoc
   */


  LRUCache.prototype.clear = function () {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  };
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */


  LRUCache.prototype.containsKey = function (key) {
    return this.entries_.hasOwnProperty(key);
  };
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */


  LRUCache.prototype.forEach = function (f) {
    var entry = this.oldest_;

    while (entry) {
      f(entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  };
  /**
   * @param {string} key Key.
   * @param {*} [opt_options] Options (reserved for subclasses).
   * @return {T} Value.
   */


  LRUCache.prototype.get = function (key, opt_options) {
    var entry = this.entries_[key];
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache

    if (entry === this.newest_) {
      return entry.value_;
    } else if (entry === this.oldest_) {
      this.oldest_ =
      /** @type {Entry} */
      this.oldest_.newer;
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }

    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  };
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */


  LRUCache.prototype.remove = function (key) {
    var entry = this.entries_[key];
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache

    if (entry === this.newest_) {
      this.newest_ =
      /** @type {Entry} */
      entry.older;

      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ =
      /** @type {Entry} */
      entry.newer;

      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }

    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  };
  /**
   * @return {number} Count.
   */


  LRUCache.prototype.getCount = function () {
    return this.count_;
  };
  /**
   * @return {Array<string>} Keys.
   */


  LRUCache.prototype.getKeys = function () {
    var keys = new Array(this.count_);
    var i = 0;
    var entry;

    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }

    return keys;
  };
  /**
   * @return {Array<T>} Values.
   */


  LRUCache.prototype.getValues = function () {
    var values = new Array(this.count_);
    var i = 0;
    var entry;

    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }

    return values;
  };
  /**
   * @return {T} Last value.
   */


  LRUCache.prototype.peekLast = function () {
    return this.oldest_.value_;
  };
  /**
   * @return {string} Last key.
   */


  LRUCache.prototype.peekLastKey = function () {
    return this.oldest_.key_;
  };
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */


  LRUCache.prototype.peekFirstKey = function () {
    return this.newest_.key_;
  };
  /**
   * @return {T} value Value.
   */


  LRUCache.prototype.pop = function () {
    var entry = this.oldest_;
    delete this.entries_[entry.key_];

    if (entry.newer) {
      entry.newer.older = null;
    }

    this.oldest_ =
    /** @type {Entry} */
    entry.newer;

    if (!this.oldest_) {
      this.newest_ = null;
    }

    --this.count_;
    return entry.value_;
  };
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */


  LRUCache.prototype.replace = function (key, value) {
    this.get(key); // update `newest_`

    this.entries_[key].value_ = value;
  };
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */


  LRUCache.prototype.set = function (key, value) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!(key in this.entries_), 16); // Tried to set a value for a key that is used already

    var entry = {
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    };

    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }

    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  };
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */


  LRUCache.prototype.setSize = function (size) {
    this.highWaterMark = size;
  };

  return LRUCache;
}();

/* harmony default export */ __webpack_exports__["default"] = (LRUCache);

/***/ }),

/***/ "./build/wg/structs/LinkedList.js":
/*!****************************************!*\
  !*** ./build/wg/structs/LinkedList.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/structs/LinkedList
 */

/**
 * @typedef {Object} Item
 * @property {Item} [prev] Previous.
 * @property {Item} [next] Next.
 * @property {?} data Data.
 */

/**
 * @classdesc
 * Creates an empty linked list structure.
 */
var LinkedList =
/** @class */
function () {
  /**
   * @param {boolean} [opt_circular] The last item is connected to the first one,
   * and the first item to the last one. Default is true.
   */
  function LinkedList(opt_circular) {
    /**
     * @private
     * @type {Item|undefined}
     */
    this.first_;
    /**
     * @private
     * @type {Item|undefined}
     */

    this.last_;
    /**
     * @private
     * @type {Item|undefined}
     */

    this.head_;
    /**
     * @private
     * @type {boolean}
     */

    this.circular_ = opt_circular === undefined ? true : opt_circular;
    /**
     * @private
     * @type {number}
     */

    this.length_ = 0;
  }
  /**
   * Inserts an item into the linked list right after the current one.
   *
   * @param {?} data Item data.
   */


  LinkedList.prototype.insertItem = function (data) {
    /** @type {Item} */
    var item = {
      prev: undefined,
      next: undefined,
      data: data
    };
    var head = this.head_; //Initialize the list.

    if (!head) {
      this.first_ = item;
      this.last_ = item;

      if (this.circular_) {
        item.next = item;
        item.prev = item;
      }
    } else {
      //Link the new item to the adjacent ones.
      var next = head.next;
      item.prev = head;
      item.next = next;
      head.next = item;

      if (next) {
        next.prev = item;
      }

      if (head === this.last_) {
        this.last_ = item;
      }
    }

    this.head_ = item;
    this.length_++;
  };
  /**
   * Removes the current item from the list. Sets the cursor to the next item,
   * if possible.
   */


  LinkedList.prototype.removeItem = function () {
    var head = this.head_;

    if (head) {
      var next = head.next;
      var prev = head.prev;

      if (next) {
        next.prev = prev;
      }

      if (prev) {
        prev.next = next;
      }

      this.head_ = next || prev;

      if (this.first_ === this.last_) {
        this.head_ = undefined;
        this.first_ = undefined;
        this.last_ = undefined;
      } else if (this.first_ === head) {
        this.first_ = this.head_;
      } else if (this.last_ === head) {
        this.last_ = prev ? this.head_.prev : this.head_;
      }

      this.length_--;
    }
  };
  /**
   * Sets the cursor to the first item, and returns the associated data.
   *
   * @return {?} Item data.
   */


  LinkedList.prototype.firstItem = function () {
    this.head_ = this.first_;

    if (this.head_) {
      return this.head_.data;
    }

    return undefined;
  };
  /**
   * Sets the cursor to the last item, and returns the associated data.
   *
   * @return {?} Item data.
   */


  LinkedList.prototype.lastItem = function () {
    this.head_ = this.last_;

    if (this.head_) {
      return this.head_.data;
    }

    return undefined;
  };
  /**
   * Sets the cursor to the next item, and returns the associated data.
   *
   * @return {?} Item data.
   */


  LinkedList.prototype.nextItem = function () {
    if (this.head_ && this.head_.next) {
      this.head_ = this.head_.next;
      return this.head_.data;
    }

    return undefined;
  };
  /**
   * Returns the next item's data without moving the cursor.
   *
   * @return {?} Item data.
   */


  LinkedList.prototype.getNextItem = function () {
    if (this.head_ && this.head_.next) {
      return this.head_.next.data;
    }

    return undefined;
  };
  /**
   * Sets the cursor to the previous item, and returns the associated data.
   *
   * @return {?} Item data.
   */


  LinkedList.prototype.prevItem = function () {
    if (this.head_ && this.head_.prev) {
      this.head_ = this.head_.prev;
      return this.head_.data;
    }

    return undefined;
  };
  /**
   * Returns the previous item's data without moving the cursor.
   *
   * @return {?} Item data.
   */


  LinkedList.prototype.getPrevItem = function () {
    if (this.head_ && this.head_.prev) {
      return this.head_.prev.data;
    }

    return undefined;
  };
  /**
   * Returns the current item's data.
   *
   * @return {?} Item data.
   */


  LinkedList.prototype.getCurrItem = function () {
    if (this.head_) {
      return this.head_.data;
    }

    return undefined;
  };
  /**
   * Sets the first item of the list. This only works for circular lists, and sets
   * the last item accordingly.
   */


  LinkedList.prototype.setFirstItem = function () {
    if (this.circular_ && this.head_) {
      this.first_ = this.head_;
      this.last_ = this.head_.prev;
    }
  };
  /**
   * Concatenates two lists.
   * @param {LinkedList} list List to merge into the current list.
   */


  LinkedList.prototype.concat = function (list) {
    if (list.head_) {
      if (this.head_) {
        var end = this.head_.next;
        this.head_.next = list.first_;
        list.first_.prev = this.head_;
        end.prev = list.last_;
        list.last_.next = end;
        this.length_ += list.length_;
      } else {
        this.head_ = list.head_;
        this.first_ = list.first_;
        this.last_ = list.last_;
        this.length_ = list.length_;
      }

      list.head_ = undefined;
      list.first_ = undefined;
      list.last_ = undefined;
      list.length_ = 0;
    }
  };
  /**
   * Returns the current length of the list.
   *
   * @return {number} Length.
   */


  LinkedList.prototype.getLength = function () {
    return this.length_;
  };

  return LinkedList;
}();

/* harmony default export */ __webpack_exports__["default"] = (LinkedList);

/***/ }),

/***/ "./build/wg/structs/PriorityQueue.js":
/*!*******************************************!*\
  !*** ./build/wg/structs/PriorityQueue.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DROP": function() { return /* binding */ DROP; }
/* harmony export */ });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/**
 * @module wg/structs/PriorityQueue
 */


/**
 * @type {number}
 */

var DROP = Infinity;
/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See https://github.com/google/closure-library/blob/master/closure/goog/structs/heap.js
 * and https://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */

var PriorityQueue =
/** @class */
function () {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  function PriorityQueue(priorityFunction, keyFunction) {
    /**
     * @type {function(T): number}
     * @private
     */
    this.priorityFunction_ = priorityFunction;
    /**
     * @type {function(T): string}
     * @private
     */

    this.keyFunction_ = keyFunction;
    /**
     * @type {Array<T>}
     * @private
     */

    this.elements_ = [];
    /**
     * @type {Array<number>}
     * @private
     */

    this.priorities_ = [];
    /**
     * @type {!Object<string, boolean>}
     * @private
     */

    this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */


  PriorityQueue.prototype.clear = function () {
    this.elements_.length = 0;
    this.priorities_.length = 0;
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.clear)(this.queuedElements_);
  };
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */


  PriorityQueue.prototype.dequeue = function () {
    var elements = this.elements_;
    var priorities = this.priorities_;
    var element = elements[0];

    if (elements.length == 1) {
      elements.length = 0;
      priorities.length = 0;
    } else {
      elements[0] = elements.pop();
      priorities[0] = priorities.pop();
      this.siftUp_(0);
    }

    var elementKey = this.keyFunction_(element);
    delete this.queuedElements_[elementKey];
    return element;
  };
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */


  PriorityQueue.prototype.enqueue = function (element) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue

    var priority = this.priorityFunction_(element);

    if (priority != DROP) {
      this.elements_.push(element);
      this.priorities_.push(priority);
      this.queuedElements_[this.keyFunction_(element)] = true;
      this.siftDown_(0, this.elements_.length - 1);
      return true;
    }

    return false;
  };
  /**
   * @return {number} Count.
   */


  PriorityQueue.prototype.getCount = function () {
    return this.elements_.length;
  };
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */


  PriorityQueue.prototype.getLeftChildIndex_ = function (index) {
    return index * 2 + 1;
  };
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */


  PriorityQueue.prototype.getRightChildIndex_ = function (index) {
    return index * 2 + 2;
  };
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */


  PriorityQueue.prototype.getParentIndex_ = function (index) {
    return index - 1 >> 1;
  };
  /**
   * Make this a heap. O(N).
   * @private
   */


  PriorityQueue.prototype.heapify_ = function () {
    var i;

    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
      this.siftUp_(i);
    }
  };
  /**
   * @return {boolean} Is empty.
   */


  PriorityQueue.prototype.isEmpty = function () {
    return this.elements_.length === 0;
  };
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */


  PriorityQueue.prototype.isKeyQueued = function (key) {
    return key in this.queuedElements_;
  };
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */


  PriorityQueue.prototype.isQueued = function (element) {
    return this.isKeyQueued(this.keyFunction_(element));
  };
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */


  PriorityQueue.prototype.siftUp_ = function (index) {
    var elements = this.elements_;
    var priorities = this.priorities_;
    var count = elements.length;
    var element = elements[index];
    var priority = priorities[index];
    var startIndex = index;

    while (index < count >> 1) {
      var lIndex = this.getLeftChildIndex_(index);
      var rIndex = this.getRightChildIndex_(index);
      var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
      elements[index] = elements[smallerChildIndex];
      priorities[index] = priorities[smallerChildIndex];
      index = smallerChildIndex;
    }

    elements[index] = element;
    priorities[index] = priority;
    this.siftDown_(startIndex, index);
  };
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */


  PriorityQueue.prototype.siftDown_ = function (startIndex, index) {
    var elements = this.elements_;
    var priorities = this.priorities_;
    var element = elements[index];
    var priority = priorities[index];

    while (index > startIndex) {
      var parentIndex = this.getParentIndex_(index);

      if (priorities[parentIndex] > priority) {
        elements[index] = elements[parentIndex];
        priorities[index] = priorities[parentIndex];
        index = parentIndex;
      } else {
        break;
      }
    }

    elements[index] = element;
    priorities[index] = priority;
  };
  /**
   * FIXME empty description for jsdoc
   */


  PriorityQueue.prototype.reprioritize = function () {
    var priorityFunction = this.priorityFunction_;
    var elements = this.elements_;
    var priorities = this.priorities_;
    var index = 0;
    var n = elements.length;
    var element, i, priority;

    for (i = 0; i < n; ++i) {
      element = elements[i];
      priority = priorityFunction(element);

      if (priority == DROP) {
        delete this.queuedElements_[this.keyFunction_(element)];
      } else {
        priorities[index] = priority;
        elements[index++] = element;
      }
    }

    elements.length = index;
    priorities.length = index;
    this.heapify_();
  };

  return PriorityQueue;
}();

/* harmony default export */ __webpack_exports__["default"] = (PriorityQueue);

/***/ }),

/***/ "./build/wg/structs/RBush.js":
/*!***********************************!*\
  !*** ./build/wg/structs/RBush.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/rbush.min.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/**
 * @module wg/structs/RBush
 */




/**
 * @typedef {Object} Entry
 * @property {number} minX MinX.
 * @property {number} minY MinY.
 * @property {number} maxX MaxX.
 * @property {number} maxY MaxY.
 * @property {Object} [value] Value.
 */

/**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */

var RBush =
/** @class */
function () {
  /**
   * @param {number} [opt_maxEntries] Max entries.
   */
  function RBush(opt_maxEntries) {
    /**
     * @private
     */
    this.rbush_ = new rbush__WEBPACK_IMPORTED_MODULE_0__(opt_maxEntries);
    /**
     * A mapping between the objects added to this rbush wrapper
     * and the objects that are actually added to the internal rbush.
     * @private
     * @type {Object<string, Entry>}
     */

    this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */


  RBush.prototype.insert = function (extent, value) {
    /** @type {Entry} */
    var item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value: value
    };
    this.rbush_.insert(item);
    this.items_[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(value)] = item;
  };
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */


  RBush.prototype.load = function (extents, values) {
    var items = new Array(values.length);

    for (var i = 0, l = values.length; i < l; i++) {
      var extent = extents[i];
      var value = values[i];
      /** @type {Entry} */

      var item = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3],
        value: value
      };
      items[i] = item;
      this.items_[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(value)] = item;
    }

    this.rbush_.load(items);
  };
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */


  RBush.prototype.remove = function (value) {
    var uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(value); // get the object in which the value was wrapped when adding to the
    // internal rbush. then use that object to do the removal.

    var item = this.items_[uid];
    delete this.items_[uid];
    return this.rbush_.remove(item) !== null;
  };
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */


  RBush.prototype.update = function (extent, value) {
    var item = this.items_[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(value)];
    var bbox = [item.minX, item.minY, item.maxX, item.maxY];

    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.equals)(bbox, extent)) {
      this.remove(value);
      this.insert(extent, value);
    }
  };
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */


  RBush.prototype.getAll = function () {
    var items = this.rbush_.all();
    return items.map(function (item) {
      return item.value;
    });
  };
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */


  RBush.prototype.getInExtent = function (extent) {
    /** @type {Entry} */
    var bbox = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3]
    };
    var items = this.rbush_.search(bbox);
    return items.map(function (item) {
      return item.value;
    });
  };
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */


  RBush.prototype.forEach = function (callback) {
    return this.forEach_(this.getAll(), callback);
  };
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */


  RBush.prototype.forEachInExtent = function (extent, callback) {
    return this.forEach_(this.getInExtent(extent), callback);
  };
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */


  RBush.prototype.forEach_ = function (values, callback) {
    var result;

    for (var i = 0, l = values.length; i < l; i++) {
      result = callback(values[i]);

      if (result) {
        return result;
      }
    }

    return result;
  };
  /**
   * @return {boolean} Is empty.
   */


  RBush.prototype.isEmpty = function () {
    return (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.isEmpty)(this.items_);
  };
  /**
   * Remove all values from the RBush.
   */


  RBush.prototype.clear = function () {
    this.rbush_.clear();
    this.items_ = {};
  };
  /**
   * @param {import("../extent.js").Extent} [opt_extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */


  RBush.prototype.getExtent = function (opt_extent) {
    var data = this.rbush_.toJSON();
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createOrUpdate)(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
  };
  /**
   * @param {RBush} rbush R-Tree.
   */


  RBush.prototype.concat = function (rbush) {
    this.rbush_.load(rbush.rbush_.all());

    for (var i in rbush.items_) {
      this.items_[i] = rbush.items_[i];
    }
  };

  return RBush;
}();

/* harmony default export */ __webpack_exports__["default"] = (RBush);

/***/ }),

/***/ "./build/wg/style/Circle.js":
/*!**********************************!*\
  !*** ./build/wg/style/Circle.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _RegularShape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RegularShape.js */ "./build/wg/style/RegularShape.js");
/**
 * @module wg/style/Circle
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();


/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {Array<number>} [displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.
 * @property {number} [rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 */

/**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */

var CircleStyle =
/** @class */
function (_super) {
  __extends(CircleStyle, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function CircleStyle(opt_options) {
    var options = opt_options ? opt_options : {};
    return _super.call(this, {
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      scale: options.scale !== undefined ? options.scale : 1,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      rotateWithView: options.rotateWithView !== undefined ? options.rotateWithView : false,
      displacement: options.displacement !== undefined ? options.displacement : [0, 0]
    }) || this;
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */


  CircleStyle.prototype.clone = function () {
    var scale = this.getScale();
    var style = new CircleStyle({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      radius: this.getRadius(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice()
    });
    style.setOpacity(this.getOpacity());
    return style;
  };
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */


  CircleStyle.prototype.setRadius = function (radius) {
    this.radius_ = radius;
    this.render();
  };

  return CircleStyle;
}(_RegularShape_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CircleStyle);

/***/ }),

/***/ "./build/wg/style/Fill.js":
/*!********************************!*\
  !*** ./build/wg/style/Fill.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/style/Fill
 */

/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike|null} [color=null] A color, gradient or pattern.
 * See {@link module:wg/color~Color} and {@link module:wg/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */

/**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */
var Fill =
/** @class */
function () {
  /**
   * @param {Options} [opt_options] Options.
   */
  function Fill(opt_options) {
    var options = opt_options || {};
    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike|null}
     */

    this.color_ = options.color !== undefined ? options.color : null;
  }
  /**
   * Clones the style. The color is not cloned if it is an {@link module:wg/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */


  Fill.prototype.clone = function () {
    var color = this.getColor();
    return new Fill({
      color: Array.isArray(color) ? color.slice() : color || undefined
    });
  };
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
   * @api
   */


  Fill.prototype.getColor = function () {
    return this.color_;
  };
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
   * @api
   */


  Fill.prototype.setColor = function (color) {
    this.color_ = color;
  };

  return Fill;
}();

/* harmony default export */ __webpack_exports__["default"] = (Fill);

/***/ }),

/***/ "./build/wg/style/Icon.js":
/*!********************************!*\
  !*** ./build/wg/style/Icon.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IconAnchorUnits.js */ "./build/wg/style/IconAnchorUnits.js");
/* harmony import */ var _IconOrigin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IconOrigin.js */ "./build/wg/style/IconOrigin.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ImageState.js */ "./build/wg/ImageState.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Image.js */ "./build/wg/style/Image.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../color.js */ "./build/wg/color.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _IconImage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./IconImage.js */ "./build/wg/style/IconImage.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/style/Icon
 */











/**
 * @typedef {Object} Options
 * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {import("./IconOrigin.js").default} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("./IconAnchorUnits.js").default} [anchorXUnits='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {import("./IconAnchorUnits.js").default} [anchorYUnits='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {HTMLImageElement|HTMLCanvasElement} [img] Image object for the icon. If the `src` option is not provided then the
 * provided image must already be loaded. And in that case, it is required
 * to provide the size of the image, with the `imgSize` option.
 * @property {Array<number>} [offset=[0, 0]] Offset, which, together with the size and the offset origin, define the
 * sub-rectangle to use from the original icon image.
 * @property {Array<number>} [displacement=[0,0]] Displacement of the icon.
 * @property {import("./IconOrigin.js").default} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {number} [opacity=1] Opacity of the icon.
 * @property {number|import("../size.js").Size} [scale=1] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {import("../size.js").Size} [size] Icon size in pixel. Can be used together with `offset` to define the
 * sub-rectangle to use from the origin (sprite) icon image.
 * @property {import("../size.js").Size} [imgSize] Image size in pixels. Only required if `img` is set and `src` is not, and
 * for SVG images in Internet Explorer 11. The provided `imgSize` needs to match the actual size of the image.
 * @property {string} [src] Image source URI.
 */

/**
 * @classdesc
 * Set icon style for vector features.
 * @api
 */

var Icon =
/** @class */
function (_super) {
  __extends(Icon, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function Icon(opt_options) {
    var _this = this;

    var options = opt_options || {};
    /**
     * @type {number}
     */

    var opacity = options.opacity !== undefined ? options.opacity : 1;
    /**
     * @type {number}
     */

    var rotation = options.rotation !== undefined ? options.rotation : 0;
    /**
     * @type {number|import("../size.js").Size}
     */

    var scale = options.scale !== undefined ? options.scale : 1;
    /**
     * @type {boolean}
     */

    var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
    _this = _super.call(this, {
      opacity: opacity,
      rotation: rotation,
      scale: scale,
      displacement: options.displacement !== undefined ? options.displacement : [0, 0],
      rotateWithView: rotateWithView
    }) || this;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];
    /**
     * @private
     * @type {Array<number>}
     */

    _this.normalizedAnchor_ = null;
    /**
     * @private
     * @type {import("./IconOrigin.js").default}
     */

    _this.anchorOrigin_ = options.anchorOrigin !== undefined ? options.anchorOrigin : _IconOrigin_js__WEBPACK_IMPORTED_MODULE_0__["default"].TOP_LEFT;
    /**
     * @private
     * @type {import("./IconAnchorUnits.js").default}
     */

    _this.anchorXUnits_ = options.anchorXUnits !== undefined ? options.anchorXUnits : _IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_1__["default"].FRACTION;
    /**
     * @private
     * @type {import("./IconAnchorUnits.js").default}
     */

    _this.anchorYUnits_ = options.anchorYUnits !== undefined ? options.anchorYUnits : _IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_1__["default"].FRACTION;
    /**
     * @private
     * @type {?string}
     */

    _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
    /**
     * @type {HTMLImageElement|HTMLCanvasElement}
     */

    var image = options.img !== undefined ? options.img : null;
    /**
     * @private
     * @type {import("../size.js").Size|undefined}
     */

    _this.imgSize_ = options.imgSize;
    /**
     * @type {string|undefined}
     */

    var src = options.src;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time

    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!image || image && _this.imgSize_, 5); // `imgSize` must be set when `image` is provided

    if ((src === undefined || src.length === 0) && image) {
      src =
      /** @type {HTMLImageElement} */
      image.src || (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.getUid)(image);
    }

    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_2__.assert)(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided

    /**
     * @type {import("../ImageState.js").default}
     */

    var imageState = options.src !== undefined ? _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE : _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED;
    /**
     * @private
     * @type {import("../color.js").Color}
     */

    _this.color_ = options.color !== undefined ? (0,_color_js__WEBPACK_IMPORTED_MODULE_5__.asArray)(options.color) : null;
    /**
     * @private
     * @type {import("./IconImage.js").default}
     */

    _this.iconImage_ = (0,_IconImage_js__WEBPACK_IMPORTED_MODULE_6__.get)(image,
    /** @type {string} */
    src, _this.imgSize_ !== undefined ? _this.imgSize_ : null, _this.crossOrigin_, imageState, _this.color_);
    /**
     * @private
     * @type {Array<number>}
     */

    _this.offset_ = options.offset !== undefined ? options.offset : [0, 0];
    /**
     * @private
     * @type {import("./IconOrigin.js").default}
     */

    _this.offsetOrigin_ = options.offsetOrigin !== undefined ? options.offsetOrigin : _IconOrigin_js__WEBPACK_IMPORTED_MODULE_0__["default"].TOP_LEFT;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.origin_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.size_ = options.size !== undefined ? options.size : null;
    return _this;
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */


  Icon.prototype.clone = function () {
    var scale = this.getScale();
    return new Icon({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || undefined,
      crossOrigin: this.crossOrigin_,
      imgSize: this.imgSize_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      size: this.size_ !== null ? this.size_.slice() : undefined,
      src: this.getSrc()
    });
  };
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */


  Icon.prototype.getAnchor = function () {
    var anchor = this.normalizedAnchor_;

    if (!anchor) {
      anchor = this.anchor_;
      var size = this.getSize();

      if (this.anchorXUnits_ == _IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_1__["default"].FRACTION || this.anchorYUnits_ == _IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_1__["default"].FRACTION) {
        if (!size) {
          return null;
        }

        anchor = this.anchor_.slice();

        if (this.anchorXUnits_ == _IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_1__["default"].FRACTION) {
          anchor[0] *= size[0];
        }

        if (this.anchorYUnits_ == _IconAnchorUnits_js__WEBPACK_IMPORTED_MODULE_1__["default"].FRACTION) {
          anchor[1] *= size[1];
        }
      }

      if (this.anchorOrigin_ != _IconOrigin_js__WEBPACK_IMPORTED_MODULE_0__["default"].TOP_LEFT) {
        if (!size) {
          return null;
        }

        if (anchor === this.anchor_) {
          anchor = this.anchor_.slice();
        }

        if (this.anchorOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_0__["default"].TOP_RIGHT || this.anchorOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_0__["default"].BOTTOM_RIGHT) {
          anchor[0] = -anchor[0] + size[0];
        }

        if (this.anchorOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_0__["default"].BOTTOM_LEFT || this.anchorOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_0__["default"].BOTTOM_RIGHT) {
          anchor[1] = -anchor[1] + size[1];
        }
      }

      this.normalizedAnchor_ = anchor;
    }

    var displacement = this.getDisplacement();
    return [anchor[0] - displacement[0], anchor[1] + displacement[1]];
  };
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */


  Icon.prototype.setAnchor = function (anchor) {
    this.anchor_ = anchor;
    this.normalizedAnchor_ = null;
  };
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */


  Icon.prototype.getColor = function () {
    return this.color_;
  };
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   * @api
   */


  Icon.prototype.getImage = function (pixelRatio) {
    return this.iconImage_.getImage(pixelRatio);
  };
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */


  Icon.prototype.getPixelRatio = function (pixelRatio) {
    return this.iconImage_.getPixelRatio(pixelRatio);
  };
  /**
   * @return {import("../size.js").Size} Image size.
   */


  Icon.prototype.getImageSize = function () {
    return this.iconImage_.getSize();
  };
  /**
   * @return {import("../ImageState.js").default} Image state.
   */


  Icon.prototype.getImageState = function () {
    return this.iconImage_.getImageState();
  };
  /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */


  Icon.prototype.getHitDetectionImage = function () {
    return this.iconImage_.getHitDetectionImage();
  };
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */


  Icon.prototype.getOrigin = function () {
    if (this.origin_) {
      return this.origin_;
    }

    var offset = this.offset_;

    if (this.offsetOrigin_ != _IconOrigin_js__WEBPACK_IMPORTED_MODULE_0__["default"].TOP_LEFT) {
      var size = this.getSize();
      var iconImageSize = this.iconImage_.getSize();

      if (!size || !iconImageSize) {
        return null;
      }

      offset = offset.slice();

      if (this.offsetOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_0__["default"].TOP_RIGHT || this.offsetOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_0__["default"].BOTTOM_RIGHT) {
        offset[0] = iconImageSize[0] - size[0] - offset[0];
      }

      if (this.offsetOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_0__["default"].BOTTOM_LEFT || this.offsetOrigin_ == _IconOrigin_js__WEBPACK_IMPORTED_MODULE_0__["default"].BOTTOM_RIGHT) {
        offset[1] = iconImageSize[1] - size[1] - offset[1];
      }
    }

    this.origin_ = offset;
    return this.origin_;
  };
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */


  Icon.prototype.getSrc = function () {
    return this.iconImage_.getSrc();
  };
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */


  Icon.prototype.getSize = function () {
    return !this.size_ ? this.iconImage_.getSize() : this.size_;
  };
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */


  Icon.prototype.listenImageChange = function (listener) {
    this.iconImage_.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, listener);
  };
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */


  Icon.prototype.load = function () {
    this.iconImage_.load();
  };
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */


  Icon.prototype.unlistenImageChange = function (listener) {
    this.iconImage_.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, listener);
  };

  return Icon;
}(_Image_js__WEBPACK_IMPORTED_MODULE_8__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Icon);

/***/ }),

/***/ "./build/wg/style/IconAnchorUnits.js":
/*!*******************************************!*\
  !*** ./build/wg/style/IconAnchorUnits.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/style/IconAnchorUnits
 */

/**
 * Icon anchor units. One of 'fraction', 'pixels'.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Anchor is a fraction
   * @api
   */
  FRACTION: 'fraction',

  /**
   * Anchor is in pixels
   * @api
   */
  PIXELS: 'pixels'
});

/***/ }),

/***/ "./build/wg/style/IconImage.js":
/*!*************************************!*\
  !*** ./build/wg/style/IconImage.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "get": function() { return /* binding */ get; }
/* harmony export */ });
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/Target.js */ "./build/wg/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ImageState.js */ "./build/wg/ImageState.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../color.js */ "./build/wg/color.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./build/wg/dom.js");
/* harmony import */ var _IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./IconImageCache.js */ "./build/wg/style/IconImageCache.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Image.js */ "./build/wg/Image.js");
/**
 * @module wg/style/IconImage
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();








/**
 * @type {CanvasRenderingContext2D}
 */

var taintedTestContext = null;

var IconImage =
/** @class */
function (_super) {
  __extends(IconImage, _super);
  /**
   * @param {HTMLImageElement|HTMLCanvasElement} image Image.
   * @param {string|undefined} src Src.
   * @param {import("../size.js").Size} size Size.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   */


  function IconImage(image, src, size, crossOrigin, imageState, color) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */


    _this.hitDetectionImage_ = null;
    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */

    _this.image_ = !image ? new Image() : image;

    if (crossOrigin !== null) {
      /** @type {HTMLImageElement} */
      _this.image_.crossOrigin = crossOrigin;
    }
    /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */


    _this.canvas_ = {};
    /**
     * @private
     * @type {import("../color.js").Color}
     */

    _this.color_ = color;
    /**
     * @private
     * @type {?function():void}
     */

    _this.unlisten_ = null;
    /**
     * @private
     * @type {import("../ImageState.js").default}
     */

    _this.imageState_ = imageState;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.size_ = size;
    /**
     * @private
     * @type {string|undefined}
     */

    _this.src_ = src;
    /**
     * @private
     */

    _this.tainted_;
    return _this;
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */


  IconImage.prototype.isTainted_ = function () {
    if (this.tainted_ === undefined && this.imageState_ === _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED) {
      if (!taintedTestContext) {
        taintedTestContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(1, 1);
      }

      taintedTestContext.drawImage(this.image_, 0, 0);

      try {
        taintedTestContext.getImageData(0, 0, 1, 1);
        this.tainted_ = false;
      } catch (e) {
        taintedTestContext = null;
        this.tainted_ = true;
      }
    }

    return this.tainted_ === true;
  };
  /**
   * @private
   */


  IconImage.prototype.dispatchChangeEvent_ = function () {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE);
  };
  /**
   * @private
   */


  IconImage.prototype.handleImageError_ = function () {
    this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR;
    this.unlistenImage_();
    this.dispatchChangeEvent_();
  };
  /**
   * @private
   */


  IconImage.prototype.handleImageLoad_ = function () {
    this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED;

    if (this.size_) {
      this.image_.width = this.size_[0];
      this.image_.height = this.size_[1];
    } else {
      this.size_ = [this.image_.width, this.image_.height];
    }

    this.unlistenImage_();
    this.dispatchChangeEvent_();
  };
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   */


  IconImage.prototype.getImage = function (pixelRatio) {
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
  };
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */


  IconImage.prototype.getPixelRatio = function (pixelRatio) {
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? pixelRatio : 1;
  };
  /**
   * @return {import("../ImageState.js").default} Image state.
   */


  IconImage.prototype.getImageState = function () {
    return this.imageState_;
  };
  /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */


  IconImage.prototype.getHitDetectionImage = function () {
    if (!this.hitDetectionImage_) {
      if (this.isTainted_()) {
        var width = this.size_[0];
        var height = this.size_[1];
        var context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(width, height);
        context.fillRect(0, 0, width, height);
        this.hitDetectionImage_ = context.canvas;
      } else {
        this.hitDetectionImage_ = this.image_;
      }
    }

    return this.hitDetectionImage_;
  };
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */


  IconImage.prototype.getSize = function () {
    return this.size_;
  };
  /**
   * @return {string|undefined} Image src.
   */


  IconImage.prototype.getSrc = function () {
    return this.src_;
  };
  /**
   * Load not yet loaded URI.
   */


  IconImage.prototype.load = function () {
    if (this.imageState_ == _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE) {
      this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADING;

      try {
        /** @type {HTMLImageElement} */
        this.image_.src = this.src_;
      } catch (e) {
        this.handleImageError_();
      }

      this.unlisten_ = (0,_Image_js__WEBPACK_IMPORTED_MODULE_3__.listenImage)(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
  };
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */


  IconImage.prototype.replaceColor_ = function (pixelRatio) {
    if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED) {
      return;
    }

    var canvas = document.createElement('canvas');
    this.canvas_[pixelRatio] = canvas;
    canvas.width = Math.ceil(this.image_.width * pixelRatio);
    canvas.height = Math.ceil(this.image_.height * pixelRatio);
    var ctx = canvas.getContext('2d');
    ctx.scale(pixelRatio, pixelRatio);
    ctx.drawImage(this.image_, 0, 0);
    ctx.globalCompositeOperation = 'multiply'; // Internet Explorer 11 does not support the multiply operation.
    // If the canvas is tainted in Internet Explorer this still produces
    // a solid color image with the shape of the icon.

    if (ctx.globalCompositeOperation === 'multiply' || this.isTainted_()) {
      ctx.fillStyle = (0,_color_js__WEBPACK_IMPORTED_MODULE_4__.asString)(this.color_);
      ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
      ctx.globalCompositeOperation = 'destination-in';
      ctx.drawImage(this.image_, 0, 0);
    } else {
      var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var data = imgData.data;
      var r = this.color_[0] / 255.0;
      var g = this.color_[1] / 255.0;
      var b = this.color_[2] / 255.0;
      var a = this.color_[3];

      for (var i = 0, ii = data.length; i < ii; i += 4) {
        data[i] *= r;
        data[i + 1] *= g;
        data[i + 2] *= b;
        data[i + 3] *= a;
      }

      ctx.putImageData(imgData, 0, 0);
    }
  };
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */


  IconImage.prototype.unlistenImage_ = function () {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  };

  return IconImage;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * @param {HTMLImageElement|HTMLCanvasElement} image Image.
 * @param {string} src Src.
 * @param {import("../size.js").Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../ImageState.js").default} imageState Image state.
 * @param {import("../color.js").Color} color Color.
 * @return {IconImage} Icon image.
 */


function get(image, src, size, crossOrigin, imageState, color) {
  var iconImage = _IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__.shared.get(src, crossOrigin, color);

  if (!iconImage) {
    iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);
    _IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__.shared.set(src, crossOrigin, color, iconImage);
  }

  return iconImage;
}
/* harmony default export */ __webpack_exports__["default"] = (IconImage);

/***/ }),

/***/ "./build/wg/style/IconImageCache.js":
/*!******************************************!*\
  !*** ./build/wg/style/IconImageCache.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shared": function() { return /* binding */ shared; }
/* harmony export */ });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ "./build/wg/color.js");
/**
 * @module wg/style/IconImageCache
 */

/**
 * @classdesc
 * Singleton class. Available through {@link module:wg/style/IconImageCache.shared}.
 */

var IconImageCache =
/** @class */
function () {
  function IconImageCache() {
    /**
     * @type {!Object<string, import("./IconImage.js").default>}
     * @private
     */
    this.cache_ = {};
    /**
     * @type {number}
     * @private
     */

    this.cacheSize_ = 0;
    /**
     * @type {number}
     * @private
     */

    this.maxCacheSize_ = 32;
  }
  /**
   * FIXME empty description for jsdoc
   */


  IconImageCache.prototype.clear = function () {
    this.cache_ = {};
    this.cacheSize_ = 0;
  };
  /**
   * @return {boolean} Can expire cache.
   */


  IconImageCache.prototype.canExpireCache = function () {
    return this.cacheSize_ > this.maxCacheSize_;
  };
  /**
   * FIXME empty description for jsdoc
   */


  IconImageCache.prototype.expire = function () {
    if (this.canExpireCache()) {
      var i = 0;

      for (var key in this.cache_) {
        var iconImage = this.cache_[key];

        if ((i++ & 3) === 0 && !iconImage.hasListener()) {
          delete this.cache_[key];
          --this.cacheSize_;
        }
      }
    }
  };
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */


  IconImageCache.prototype.get = function (src, crossOrigin, color) {
    var key = getKey(src, crossOrigin, color);
    return key in this.cache_ ? this.cache_[key] : null;
  };
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @param {import("./IconImage.js").default} iconImage Icon image.
   */


  IconImageCache.prototype.set = function (src, crossOrigin, color, iconImage) {
    var key = getKey(src, crossOrigin, color);
    this.cache_[key] = iconImage;
    ++this.cacheSize_;
  };
  /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */


  IconImageCache.prototype.setSize = function (maxCacheSize) {
    this.maxCacheSize_ = maxCacheSize;
    this.expire();
  };

  return IconImageCache;
}();
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../color.js").Color} color Color.
 * @return {string} Cache key.
 */


function getKey(src, crossOrigin, color) {
  var colorString = color ? (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.asString)(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
}

/* harmony default export */ __webpack_exports__["default"] = (IconImageCache);
/**
 * The {@link module:wg/style/IconImageCache~IconImageCache} for
 * {@link module:wg/style/Icon~Icon} images.
 * @api
 */

var shared = new IconImageCache();

/***/ }),

/***/ "./build/wg/style/IconOrigin.js":
/*!**************************************!*\
  !*** ./build/wg/style/IconOrigin.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/style/IconOrigin
 */

/**
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Origin is at bottom left
   * @api
   */
  BOTTOM_LEFT: 'bottom-left',

  /**
   * Origin is at bottom right
   * @api
   */
  BOTTOM_RIGHT: 'bottom-right',

  /**
   * Origin is at top left
   * @api
   */
  TOP_LEFT: 'top-left',

  /**
   * Origin is at top right
   * @api
   */
  TOP_RIGHT: 'top-right'
});

/***/ }),

/***/ "./build/wg/style/Image.js":
/*!*********************************!*\
  !*** ./build/wg/style/Image.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../size.js */ "./build/wg/size.js");
/**
 * @module wg/style/Image
 */


/**
 * @typedef {Object} Options
 * @property {number} opacity Opacity.
 * @property {boolean} rotateWithView If the image should get rotated with the view.
 * @property {number} rotation Rotation.
 * @property {number|import("../size.js").Size} scale Scale.
 * @property {Array<number>} displacement Displacement.
 */

/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:wg/style/Icon~Icon}, {@link module:wg/style/Circle~CircleStyle} and
 * {@link module:wg/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */

var ImageStyle =
/** @class */
function () {
  /**
   * @param {Options} options Options.
   */
  function ImageStyle(options) {
    /**
     * @private
     * @type {number}
     */
    this.opacity_ = options.opacity;
    /**
     * @private
     * @type {boolean}
     */

    this.rotateWithView_ = options.rotateWithView;
    /**
     * @private
     * @type {number}
     */

    this.rotation_ = options.rotation;
    /**
     * @private
     * @type {number|import("../size.js").Size}
     */

    this.scale_ = options.scale;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(options.scale);
    /**
     * @private
     * @type {Array<number>}
     */

    this.displacement_ = options.displacement;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */


  ImageStyle.prototype.clone = function () {
    var scale = this.getScale();
    return new ImageStyle({
      opacity: this.getOpacity(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice()
    });
  };
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */


  ImageStyle.prototype.getOpacity = function () {
    return this.opacity_;
  };
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */


  ImageStyle.prototype.getRotateWithView = function () {
    return this.rotateWithView_;
  };
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */


  ImageStyle.prototype.getRotation = function () {
    return this.rotation_;
  };
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */


  ImageStyle.prototype.getScale = function () {
    return this.scale_;
  };
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */


  ImageStyle.prototype.getScaleArray = function () {
    return this.scaleArray_;
  };
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */


  ImageStyle.prototype.getDisplacement = function () {
    return this.displacement_;
  };
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */


  ImageStyle.prototype.getAnchor = function () {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */


  ImageStyle.prototype.getImage = function (pixelRatio) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */


  ImageStyle.prototype.getHitDetectionImage = function () {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */


  ImageStyle.prototype.getPixelRatio = function (pixelRatio) {
    return 1;
  };
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */


  ImageStyle.prototype.getImageState = function () {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */


  ImageStyle.prototype.getImageSize = function () {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */


  ImageStyle.prototype.getOrigin = function () {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */


  ImageStyle.prototype.getSize = function () {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */


  ImageStyle.prototype.setDisplacement = function (displacement) {
    this.displacement_ = displacement;
  };
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */


  ImageStyle.prototype.setOpacity = function (opacity) {
    this.opacity_ = opacity;
  };
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */


  ImageStyle.prototype.setRotateWithView = function (rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  };
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */


  ImageStyle.prototype.setRotation = function (rotation) {
    this.rotation_ = rotation;
  };
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */


  ImageStyle.prototype.setScale = function (scale) {
    this.scale_ = scale;
    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(scale);
  };
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */


  ImageStyle.prototype.listenImageChange = function (listener) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * Load not yet loaded URI.
   * @abstract
   */


  ImageStyle.prototype.load = function () {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */


  ImageStyle.prototype.unlistenImageChange = function (listener) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  };

  return ImageStyle;
}();

/* harmony default export */ __webpack_exports__["default"] = (ImageStyle);

/***/ }),

/***/ "./build/wg/style/RegularShape.js":
/*!****************************************!*\
  !*** ./build/wg/style/RegularShape.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./build/wg/ImageState.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Image.js */ "./build/wg/style/Image.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../color.js */ "./build/wg/color.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../colorlike.js */ "./build/wg/colorlike.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom.js */ "./build/wg/dom.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../render/canvas.js */ "./build/wg/render/canvas.js");
/**
 * @module wg/style/RegularShape
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();







/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] First radius of a star. Ignored if radius is set.
 * @property {number} [radius2] Second radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
 * @property {Array<number>} [displacement=[0,0]] Displacement of the shape
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `radius`, `radius1` and `radius2`.
 */

/**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike} [strokeStyle] StrokeStyle.
 * @property {number} strokeWidth StrokeWidth.
 * @property {number} size Size.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} miterLimit MiterLimit.
 */

/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */

var RegularShape =
/** @class */
function (_super) {
  __extends(RegularShape, _super);
  /**
   * @param {Options} options Options.
   */


  function RegularShape(options) {
    var _this = this;
    /**
     * @type {boolean}
     */


    var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
    _this = _super.call(this, {
      opacity: 1,
      rotateWithView: rotateWithView,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      scale: options.scale !== undefined ? options.scale : 1,
      displacement: options.displacement !== undefined ? options.displacement : [0, 0]
    }) || this;
    /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */

    _this.canvas_ = undefined;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.hitDetectionCanvas_ = null;
    /**
     * @private
     * @type {import("./Fill.js").default}
     */

    _this.fill_ = options.fill !== undefined ? options.fill : null;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.origin_ = [0, 0];
    /**
     * @private
     * @type {number}
     */

    _this.points_ = options.points;
    /**
     * @protected
     * @type {number}
     */

    _this.radius_ = options.radius !== undefined ? options.radius : options.radius1;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.radius2_ = options.radius2;
    /**
     * @private
     * @type {number}
     */

    _this.angle_ = options.angle !== undefined ? options.angle : 0;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    _this.stroke_ = options.stroke !== undefined ? options.stroke : null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.size_ = null;
    /**
     * @private
     * @type {RenderOptions}
     */

    _this.renderOptions_ = null;

    _this.render();

    return _this;
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */


  RegularShape.prototype.clone = function () {
    var scale = this.getScale();
    var style = new RegularShape({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      displacement: this.getDisplacement().slice()
    });
    style.setOpacity(this.getOpacity());
    return style;
  };
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */


  RegularShape.prototype.getAnchor = function () {
    var size = this.size_;

    if (!size) {
      return null;
    }

    var displacement = this.getDisplacement();
    return [size[0] / 2 - displacement[0], size[1] / 2 + displacement[1]];
  };
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */


  RegularShape.prototype.getAngle = function () {
    return this.angle_;
  };
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */


  RegularShape.prototype.getFill = function () {
    return this.fill_;
  };
  /**
   * @return {HTMLCanvasElement} Image element.
   */


  RegularShape.prototype.getHitDetectionImage = function () {
    if (!this.hitDetectionCanvas_) {
      this.createHitDetectionCanvas_(this.renderOptions_);
    }

    return this.hitDetectionCanvas_;
  };
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */


  RegularShape.prototype.getImage = function (pixelRatio) {
    var image = this.canvas_[pixelRatio];

    if (!image) {
      var renderOptions = this.renderOptions_;
      var context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasContext2D)(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);
      this.draw_(renderOptions, context, pixelRatio);
      image = context.canvas;
      this.canvas_[pixelRatio] = image;
    }

    return image;
  };
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */


  RegularShape.prototype.getPixelRatio = function (pixelRatio) {
    return pixelRatio;
  };
  /**
   * @return {import("../size.js").Size} Image size.
   */


  RegularShape.prototype.getImageSize = function () {
    return this.size_;
  };
  /**
   * @return {import("../ImageState.js").default} Image state.
   */


  RegularShape.prototype.getImageState = function () {
    return _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
  };
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */


  RegularShape.prototype.getOrigin = function () {
    return this.origin_;
  };
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */


  RegularShape.prototype.getPoints = function () {
    return this.points_;
  };
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */


  RegularShape.prototype.getRadius = function () {
    return this.radius_;
  };
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */


  RegularShape.prototype.getRadius2 = function () {
    return this.radius2_;
  };
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */


  RegularShape.prototype.getSize = function () {
    return this.size_;
  };
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */


  RegularShape.prototype.getStroke = function () {
    return this.stroke_;
  };
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */


  RegularShape.prototype.listenImageChange = function (listener) {};
  /**
   * Load not yet loaded URI.
   */


  RegularShape.prototype.load = function () {};
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */


  RegularShape.prototype.unlistenImageChange = function (listener) {};
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */


  RegularShape.prototype.calculateLineJoinSize_ = function (lineJoin, strokeWidth, miterLimit) {
    if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== 'bevel' && lineJoin !== 'miter') {
      return strokeWidth;
    } // m  | ^
    // i  | |\                  .
    // t >|  #\
    // e  | |\ \              .
    // r      \s\
    //      |  \t\          .                 .
    //          \r\                      .   .
    //      |    \o\      .          .  . . .
    //          e \k\            .  .    . .
    //      |      \e\  .    .  .       . .
    //       d      \ \  .  .          . .
    //      | _ _a_ _\#  .            . .
    //   r1          / `             . .
    //      |                       . .
    //       b     /               . .
    //      |                     . .
    //           / r2            . .
    //      |                        .   .
    //         /                           .   .
    //      |α                                   .   .
    //       /                                         .   .
    //      ° center


    var r1 = this.radius_;
    var r2 = this.radius2_ === undefined ? r1 : this.radius2_;

    if (r1 < r2) {
      var tmp = r1;
      r1 = r2;
      r2 = tmp;
    }

    var points = this.radius2_ === undefined ? this.points_ : this.points_ * 2;
    var alpha = 2 * Math.PI / points;
    var a = r2 * Math.sin(alpha);
    var b = Math.sqrt(r2 * r2 - a * a);
    var d = r1 - b;
    var e = Math.sqrt(a * a + d * d);
    var miterRatio = e / a;

    if (lineJoin === 'miter' && miterRatio <= miterLimit) {
      return miterRatio * strokeWidth;
    } // Calculate the distnce from center to the stroke corner where
    // it was cut short because of the miter limit.
    //              l
    //        ----+---- <= distance from center to here is maxr
    //       /####|k ##\
    //      /#####^#####\
    //     /#### /+\# s #\
    //    /### h/+++\# t #\
    //   /### t/+++++\# r #\
    //  /### a/+++++++\# o #\
    // /### p/++ fill +\# k #\
    ///#### /+++++^+++++\# e #\
    //#####/+++++/+\+++++\#####\


    var k = strokeWidth / 2 / miterRatio;
    var l = strokeWidth / 2 * (d / e);
    var maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
    var bevelAdd = maxr - r1;

    if (this.radius2_ === undefined || lineJoin === 'bevel') {
      return bevelAdd * 2;
    } // If outer miter is over the miter limit the inner miter may reach through the
    // center and be longer than the bevel, same calculation as above but swap r1 / r2.


    var aa = r1 * Math.sin(alpha);
    var bb = Math.sqrt(r1 * r1 - aa * aa);
    var dd = r2 - bb;
    var ee = Math.sqrt(aa * aa + dd * dd);
    var innerMiterRatio = ee / aa;

    if (innerMiterRatio <= miterLimit) {
      var innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
      return 2 * Math.max(bevelAdd, innerLength);
    }

    return bevelAdd * 2;
  };
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */


  RegularShape.prototype.createRenderOptions = function () {
    var lineJoin = _render_canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultLineJoin;
    var miterLimit = 0;
    var lineDash = null;
    var lineDashOffset = 0;
    var strokeStyle;
    var strokeWidth = 0;

    if (this.stroke_) {
      strokeStyle = this.stroke_.getColor();

      if (strokeStyle === null) {
        strokeStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultStrokeStyle;
      }

      strokeStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_3__.asColorLike)(strokeStyle);
      strokeWidth = this.stroke_.getWidth();

      if (strokeWidth === undefined) {
        strokeWidth = _render_canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultLineWidth;
      }

      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset();
      lineJoin = this.stroke_.getLineJoin();

      if (lineJoin === undefined) {
        lineJoin = _render_canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultLineJoin;
      }

      miterLimit = this.stroke_.getMiterLimit();

      if (miterLimit === undefined) {
        miterLimit = _render_canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultMiterLimit;
      }
    }

    var add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
    var maxRadius = Math.max(this.radius_, this.radius2_ || 0);
    var size = Math.ceil(2 * maxRadius + add);
    return {
      strokeStyle: strokeStyle,
      strokeWidth: strokeWidth,
      size: size,
      lineDash: lineDash,
      lineDashOffset: lineDashOffset,
      lineJoin: lineJoin,
      miterLimit: miterLimit
    };
  };
  /**
   * @protected
   */


  RegularShape.prototype.render = function () {
    this.renderOptions_ = this.createRenderOptions();
    var size = this.renderOptions_.size;
    this.canvas_ = {};
    this.size_ = [size, size];
  };
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */


  RegularShape.prototype.draw_ = function (renderOptions, context, pixelRatio) {
    context.scale(pixelRatio, pixelRatio); // set origin to canvas center

    context.translate(renderOptions.size / 2, renderOptions.size / 2);
    this.createPath_(context);

    if (this.fill_) {
      var color = this.fill_.getColor();

      if (color === null) {
        color = _render_canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultFillStyle;
      }

      context.fillStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_3__.asColorLike)(color);
      context.fill();
    }

    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;

      if (context.setLineDash && renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }

      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  };
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   */


  RegularShape.prototype.createHitDetectionCanvas_ = function (renderOptions) {
    if (this.fill_) {
      var color = this.fill_.getColor(); // determine if fill is transparent (or pattern or gradient)

      var opacity = 0;

      if (typeof color === 'string') {
        color = (0,_color_js__WEBPACK_IMPORTED_MODULE_4__.asArray)(color);
      }

      if (color === null) {
        opacity = 1;
      } else if (Array.isArray(color)) {
        opacity = color.length === 4 ? color[3] : 1;
      }

      if (opacity === 0) {
        // if a transparent fill style is set, create an extra hit-detection image
        // with a default fill style
        var context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasContext2D)(renderOptions.size, renderOptions.size);
        this.hitDetectionCanvas_ = context.canvas;
        this.drawHitDetectionCanvas_(renderOptions, context);
      }
    }

    if (!this.hitDetectionCanvas_) {
      this.hitDetectionCanvas_ = this.getImage(1);
    }
  };
  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */


  RegularShape.prototype.createPath_ = function (context) {
    var points = this.points_;
    var radius = this.radius_;

    if (points === Infinity) {
      context.arc(0, 0, radius, 0, 2 * Math.PI);
    } else {
      var radius2 = this.radius2_ === undefined ? radius : this.radius2_;

      if (this.radius2_ !== undefined) {
        points *= 2;
      }

      var startAngle = this.angle_ - Math.PI / 2;
      var step = 2 * Math.PI / points;

      for (var i = 0; i < points; i++) {
        var angle0 = startAngle + i * step;
        var radiusC = i % 2 === 0 ? radius : radius2;
        context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
      }

      context.closePath();
    }
  };
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */


  RegularShape.prototype.drawHitDetectionCanvas_ = function (renderOptions, context) {
    // set origin to canvas center
    context.translate(renderOptions.size / 2, renderOptions.size / 2);
    this.createPath_(context);
    context.fillStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultFillStyle;
    context.fill();

    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;

      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }

      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  };

  return RegularShape;
}(_Image_js__WEBPACK_IMPORTED_MODULE_5__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (RegularShape);

/***/ }),

/***/ "./build/wg/style/Stroke.js":
/*!**********************************!*\
  !*** ./build/wg/style/Stroke.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/style/Stroke
 */

/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:wg/color~Color} and {@link module:wg/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
 * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on
 * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */

/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */
var Stroke =
/** @class */
function () {
  /**
   * @param {Options} [opt_options] Options.
   */
  function Stroke(opt_options) {
    var options = opt_options || {};
    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
     */

    this.color_ = options.color !== undefined ? options.color : null;
    /**
     * @private
     * @type {CanvasLineCap|undefined}
     */

    this.lineCap_ = options.lineCap;
    /**
     * @private
     * @type {Array<number>}
     */

    this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
    /**
     * @private
     * @type {number|undefined}
     */

    this.lineDashOffset_ = options.lineDashOffset;
    /**
     * @private
     * @type {CanvasLineJoin|undefined}
     */

    this.lineJoin_ = options.lineJoin;
    /**
     * @private
     * @type {number|undefined}
     */

    this.miterLimit_ = options.miterLimit;
    /**
     * @private
     * @type {number|undefined}
     */

    this.width_ = options.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */


  Stroke.prototype.clone = function () {
    var color = this.getColor();
    return new Stroke({
      color: Array.isArray(color) ? color.slice() : color || undefined,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  };
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */


  Stroke.prototype.getColor = function () {
    return this.color_;
  };
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */


  Stroke.prototype.getLineCap = function () {
    return this.lineCap_;
  };
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>} Line dash.
   * @api
   */


  Stroke.prototype.getLineDash = function () {
    return this.lineDash_;
  };
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */


  Stroke.prototype.getLineDashOffset = function () {
    return this.lineDashOffset_;
  };
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */


  Stroke.prototype.getLineJoin = function () {
    return this.lineJoin_;
  };
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */


  Stroke.prototype.getMiterLimit = function () {
    return this.miterLimit_;
  };
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */


  Stroke.prototype.getWidth = function () {
    return this.width_;
  };
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */


  Stroke.prototype.setColor = function (color) {
    this.color_ = color;
  };
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */


  Stroke.prototype.setLineCap = function (lineCap) {
    this.lineCap_ = lineCap;
  };
  /**
   * Set the line dash.
   *
   * Please note that Internet Explorer 10 and lower [do not support][mdn] the
   * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
   * property will have no visual effect in these browsers.
   *
   * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
   *
   * @param {Array<number>} lineDash Line dash.
   * @api
   */


  Stroke.prototype.setLineDash = function (lineDash) {
    this.lineDash_ = lineDash;
  };
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */


  Stroke.prototype.setLineDashOffset = function (lineDashOffset) {
    this.lineDashOffset_ = lineDashOffset;
  };
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */


  Stroke.prototype.setLineJoin = function (lineJoin) {
    this.lineJoin_ = lineJoin;
  };
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */


  Stroke.prototype.setMiterLimit = function (miterLimit) {
    this.miterLimit_ = miterLimit;
  };
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */


  Stroke.prototype.setWidth = function (width) {
    this.width_ = width;
  };

  return Stroke;
}();

/* harmony default export */ __webpack_exports__["default"] = (Stroke);

/***/ }),

/***/ "./build/wg/style/Style.js":
/*!*********************************!*\
  !*** ./build/wg/style/Style.js ***!
  \*********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toFunction": function() { return /* binding */ toFunction; },
/* harmony export */   "createDefaultStyle": function() { return /* binding */ createDefaultStyle; },
/* harmony export */   "createEditingStyle": function() { return /* binding */ createEditingStyle; }
/* harmony export */ });
/* harmony import */ var _Circle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Circle.js */ "./build/wg/style/Circle.js");
/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Fill.js */ "./build/wg/style/Fill.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./build/wg/geom/GeometryType.js");
/* harmony import */ var _Stroke_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Stroke.js */ "./build/wg/style/Stroke.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * @module wg/style/Style
 */





/**
 * A function that takes an {@link module:wg/Feature~Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:wg/style/Style~Style} or an array of them. This way e.g. a
 * vector layer can be styled. If the function returns `undefined`, the
 * feature will not be rendered.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
 */

/**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */

/**
 * A function that takes an {@link module:wg/Feature~Feature} as argument and returns an
 * {@link module:wg/geom/Geometry~Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */

/**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:wg/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State): void}
 * RenderFunction
 */

/**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {RenderFunction} [hitDetectionRenderer] Custom renderer for hit detection. If provided will be used
 * in hit detection rendering.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */

/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * ## Feature styles
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'wg/style';
 *
 *  const fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)',
 *  });
 *  const stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25,
 *  });
 *  const styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5,
 *      }),
 *      fill: fill,
 *      stroke: stroke,
 *    }),
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import GeometryType from 'wg/geom/GeometryType';
 *  import {Circle, Fill, Stroke, Style} from 'wg/style';
 *
 *  const styles = {};
 *  const white = [255, 255, 255, 1];
 *  const blue = [0, 153, 255, 1];
 *  const width = 3;
 *  styles[GeometryType.POLYGON] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5],
 *      }),
 *    }),
 *  ];
 *  styles[GeometryType.MULTI_POLYGON] = styles[GeometryType.POLYGON];
 *
 *  styles[GeometryType.LINE_STRING] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2,
 *      }),
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width,
 *      }),
 *    }),
 *  ];
 *  styles[GeometryType.MULTI_LINE_STRING] = styles[GeometryType.LINE_STRING];
 *
 *  styles[GeometryType.CIRCLE] = styles[GeometryType.POLYGON].concat(
 *    styles[GeometryType.LINE_STRING]
 *  );
 *
 *  styles[GeometryType.POINT] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue,
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2,
 *        }),
 *      }),
 *      zIndex: Infinity,
 *    }),
 *  ];
 *  styles[GeometryType.MULTI_POINT] = styles[GeometryType.POINT];
 *
 *  styles[GeometryType.GEOMETRY_COLLECTION] = styles[
 *    GeometryType.POLYGON
 *  ].concat(styles[GeometryType.LINE_STRING], styles[GeometryType.POINT]);
 * ```
 *
 * @api
 */

var Style =
/** @class */
function () {
  /**
   * @param {Options} [opt_options] Style options.
   */
  function Style(opt_options) {
    var options = opt_options || {};
    /**
     * @private
     * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
     */

    this.geometry_ = null;
    /**
     * @private
     * @type {!GeometryFunction}
     */

    this.geometryFunction_ = defaultGeometryFunction;

    if (options.geometry !== undefined) {
      this.setGeometry(options.geometry);
    }
    /**
     * @private
     * @type {import("./Fill.js").default}
     */


    this.fill_ = options.fill !== undefined ? options.fill : null;
    /**
     * @private
     * @type {import("./Image.js").default}
     */

    this.image_ = options.image !== undefined ? options.image : null;
    /**
     * @private
     * @type {RenderFunction|null}
     */

    this.renderer_ = options.renderer !== undefined ? options.renderer : null;
    /**
     * @private
     * @type {RenderFunction|null}
     */

    this.hitDetectionRenderer_ = options.hitDetectionRenderer !== undefined ? options.hitDetectionRenderer : null;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    this.stroke_ = options.stroke !== undefined ? options.stroke : null;
    /**
     * @private
     * @type {import("./Text.js").default}
     */

    this.text_ = options.text !== undefined ? options.text : null;
    /**
     * @private
     * @type {number|undefined}
     */

    this.zIndex_ = options.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */


  Style.prototype.clone = function () {
    var geometry = this.getGeometry();

    if (geometry && _typeof(geometry) === 'object') {
      geometry =
      /** @type {import("../geom/Geometry.js").default} */
      geometry.clone();
    }

    return new Style({
      geometry: geometry,
      fill: this.getFill() ? this.getFill().clone() : undefined,
      image: this.getImage() ? this.getImage().clone() : undefined,
      renderer: this.getRenderer(),
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      text: this.getText() ? this.getText().clone() : undefined,
      zIndex: this.getZIndex()
    });
  };
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */


  Style.prototype.getRenderer = function () {
    return this.renderer_;
  };
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */


  Style.prototype.setRenderer = function (renderer) {
    this.renderer_ = renderer;
  };
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */


  Style.prototype.setHitDetectionRenderer = function (renderer) {
    this.hitDetectionRenderer_ = renderer;
  };
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */


  Style.prototype.getHitDetectionRenderer = function () {
    return this.hitDetectionRenderer_;
  };
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */


  Style.prototype.getGeometry = function () {
    return this.geometry_;
  };
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */


  Style.prototype.getGeometryFunction = function () {
    return this.geometryFunction_;
  };
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */


  Style.prototype.getFill = function () {
    return this.fill_;
  };
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */


  Style.prototype.setFill = function (fill) {
    this.fill_ = fill;
  };
  /**
   * Get the image style.
   * @return {import("./Image.js").default} Image style.
   * @api
   */


  Style.prototype.getImage = function () {
    return this.image_;
  };
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */


  Style.prototype.setImage = function (image) {
    this.image_ = image;
  };
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */


  Style.prototype.getStroke = function () {
    return this.stroke_;
  };
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */


  Style.prototype.setStroke = function (stroke) {
    this.stroke_ = stroke;
  };
  /**
   * Get the text style.
   * @return {import("./Text.js").default} Text style.
   * @api
   */


  Style.prototype.getText = function () {
    return this.text_;
  };
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */


  Style.prototype.setText = function (text) {
    this.text_ = text;
  };
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */


  Style.prototype.getZIndex = function () {
    return this.zIndex_;
  };
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */


  Style.prototype.setGeometry = function (geometry) {
    if (typeof geometry === 'function') {
      this.geometryFunction_ = geometry;
    } else if (typeof geometry === 'string') {
      this.geometryFunction_ = function (feature) {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          feature.get(geometry)
        );
      };
    } else if (!geometry) {
      this.geometryFunction_ = defaultGeometryFunction;
    } else if (geometry !== undefined) {
      this.geometryFunction_ = function () {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          geometry
        );
      };
    }

    this.geometry_ = geometry;
  };
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */


  Style.prototype.setZIndex = function (zIndex) {
    this.zIndex_ = zIndex;
  };

  return Style;
}();
/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */


function toFunction(obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array<Style>}
     */
    var styles_1;

    if (Array.isArray(obj)) {
      styles_1 = obj;
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof
      /** @type {?} */
      obj.getZIndex === 'function', 41); // Expected an `Style` or an array of `Style`

      var style =
      /** @type {Style} */
      obj;
      styles_1 = [style];
    }

    styleFunction = function styleFunction() {
      return styles_1;
    };
  }

  return styleFunction;
}
/**
 * @type {Array<Style>|null}
 */

var defaultStyles = null;
/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */

function createDefaultStyle(feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!defaultStyles) {
    var fill = new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
      color: 'rgba(255,255,255,0.4)'
    });
    var stroke = new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
      color: '#3399CC',
      width: 1.25
    });
    defaultStyles = [new Style({
      image: new _Circle_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
        fill: fill,
        stroke: stroke,
        radius: 5
      }),
      fill: fill,
      stroke: stroke
    })];
  }

  return defaultStyles;
}
/**
 * Default styles for editing features.
 * @return {Object<import("../geom/GeometryType.js").default, Array<Style>>} Styles
 */

function createEditingStyle() {
  /** @type {Object<import("../geom/GeometryType.js").default, Array<Style>>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POLYGON] = [new Style({
    fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
      color: [255, 255, 255, 0.5]
    })
  })];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].MULTI_POLYGON] = styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POLYGON];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].LINE_STRING] = [new Style({
    stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
      color: white,
      width: width + 2
    })
  }), new Style({
    stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
      color: blue,
      width: width
    })
  })];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].MULTI_LINE_STRING] = styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].LINE_STRING];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CIRCLE] = styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POLYGON].concat(styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].LINE_STRING]);
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINT] = [new Style({
    image: new _Circle_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      radius: width * 2,
      fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
        color: blue
      }),
      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
        color: white,
        width: width / 2
      })
    }),
    zIndex: Infinity
  })];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].MULTI_POINT] = styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINT];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].GEOMETRY_COLLECTION] = styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POLYGON].concat(styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].LINE_STRING], styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINT]);
  return styles;
}
/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */

function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}

/* harmony default export */ __webpack_exports__["default"] = (Style);

/***/ }),

/***/ "./build/wg/style/Text.js":
/*!********************************!*\
  !*** ./build/wg/style/Text.js ***!
  \********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Fill.js */ "./build/wg/style/Fill.js");
/* harmony import */ var _TextPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TextPlacement.js */ "./build/wg/style/TextPlacement.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../size.js */ "./build/wg/size.js");
/**
 * @module wg/style/Text
 */



/**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 */

var DEFAULT_FILL_COLOR = '#333';
/**
 * @typedef {Object} Options
 * @property {string} [font] Font style as CSS 'font' value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is '10px sans-serif'
 * @property {number} [maxAngle=Math.PI/4] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {import("./TextPlacement.js").default|string} [placement='point'] Text placement.
 * @property {number|import("../size.js").Size} [scale] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {string|Array<string>} [text] Text content or rich text content. For plain text provide a string, which can
 * contain line breaks (`\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to
 * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\n', ''`).
 * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield "**foo** *bar* baz".
 * **Note:** Rich text is not supported for the immediate rendering API.
 * @property {string} [textAlign] Text alignment. Possible values: 'left', 'right', 'center', 'end' or 'start'.
 * Default is 'center' for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a
 * placement where `maxAngle` is not exceeded.
 * @property {string} [textBaseline='middle'] Text base line. Possible values: 'bottom', 'top', 'middle', 'alphabetic',
 * 'hanging', 'ideographic'.
 * @property {import("./Fill.js").default} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333).
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Fill.js").default} [backgroundFill] Fill style for the text background when `placement` is
 * `'point'`. Default is no fill.
 * @property {import("./Stroke.js").default} [backgroundStroke] Stroke style for the text background  when `placement`
 * is `'point'`. Default is no stroke.
 * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 */

/**
 * @classdesc
 * Set text style for vector features.
 * @api
 */

var Text =
/** @class */
function () {
  /**
   * @param {Options} [opt_options] Options.
   */
  function Text(opt_options) {
    var options = opt_options || {};
    /**
     * @private
     * @type {string|undefined}
     */

    this.font_ = options.font;
    /**
     * @private
     * @type {number|undefined}
     */

    this.rotation_ = options.rotation;
    /**
     * @private
     * @type {boolean|undefined}
     */

    this.rotateWithView_ = options.rotateWithView;
    /**
     * @private
     * @type {number|import("../size.js").Size|undefined}
     */

    this.scale_ = options.scale;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(options.scale !== undefined ? options.scale : 1);
    /**
     * @private
     * @type {string|Array<string>|undefined}
     */

    this.text_ = options.text;
    /**
     * @private
     * @type {string|undefined}
     */

    this.textAlign_ = options.textAlign;
    /**
     * @private
     * @type {string|undefined}
     */

    this.textBaseline_ = options.textBaseline;
    /**
     * @private
     * @type {import("./Fill.js").default}
     */

    this.fill_ = options.fill !== undefined ? options.fill : new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
      color: DEFAULT_FILL_COLOR
    });
    /**
     * @private
     * @type {number}
     */

    this.maxAngle_ = options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;
    /**
     * @private
     * @type {import("./TextPlacement.js").default|string}
     */

    this.placement_ = options.placement !== undefined ? options.placement : _TextPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINT;
    /**
     * @private
     * @type {boolean}
     */

    this.overflow_ = !!options.overflow;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    this.stroke_ = options.stroke !== undefined ? options.stroke : null;
    /**
     * @private
     * @type {number}
     */

    this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;
    /**
     * @private
     * @type {number}
     */

    this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;
    /**
     * @private
     * @type {import("./Fill.js").default}
     */

    this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
    /**
     * @private
     * @type {Array<number>|null}
     */

    this.padding_ = options.padding === undefined ? null : options.padding;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */


  Text.prototype.clone = function () {
    var scale = this.getScale();
    return new Text({
      font: this.getFont(),
      placement: this.getPlacement(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : undefined,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : undefined,
      padding: this.getPadding() || undefined
    });
  };
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */


  Text.prototype.getOverflow = function () {
    return this.overflow_;
  };
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */


  Text.prototype.getFont = function () {
    return this.font_;
  };
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */


  Text.prototype.getMaxAngle = function () {
    return this.maxAngle_;
  };
  /**
   * Get the label placement.
   * @return {import("./TextPlacement.js").default|string} Text placement.
   * @api
   */


  Text.prototype.getPlacement = function () {
    return this.placement_;
  };
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */


  Text.prototype.getOffsetX = function () {
    return this.offsetX_;
  };
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */


  Text.prototype.getOffsetY = function () {
    return this.offsetY_;
  };
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */


  Text.prototype.getFill = function () {
    return this.fill_;
  };
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */


  Text.prototype.getRotateWithView = function () {
    return this.rotateWithView_;
  };
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */


  Text.prototype.getRotation = function () {
    return this.rotation_;
  };
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */


  Text.prototype.getScale = function () {
    return this.scale_;
  };
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */


  Text.prototype.getScaleArray = function () {
    return this.scaleArray_;
  };
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */


  Text.prototype.getStroke = function () {
    return this.stroke_;
  };
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */


  Text.prototype.getText = function () {
    return this.text_;
  };
  /**
   * Get the text alignment.
   * @return {string|undefined} Text align.
   * @api
   */


  Text.prototype.getTextAlign = function () {
    return this.textAlign_;
  };
  /**
   * Get the text baseline.
   * @return {string|undefined} Text baseline.
   * @api
   */


  Text.prototype.getTextBaseline = function () {
    return this.textBaseline_;
  };
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */


  Text.prototype.getBackgroundFill = function () {
    return this.backgroundFill_;
  };
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */


  Text.prototype.getBackgroundStroke = function () {
    return this.backgroundStroke_;
  };
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */


  Text.prototype.getPadding = function () {
    return this.padding_;
  };
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */


  Text.prototype.setOverflow = function (overflow) {
    this.overflow_ = overflow;
  };
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */


  Text.prototype.setFont = function (font) {
    this.font_ = font;
  };
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */


  Text.prototype.setMaxAngle = function (maxAngle) {
    this.maxAngle_ = maxAngle;
  };
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */


  Text.prototype.setOffsetX = function (offsetX) {
    this.offsetX_ = offsetX;
  };
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */


  Text.prototype.setOffsetY = function (offsetY) {
    this.offsetY_ = offsetY;
  };
  /**
   * Set the text placement.
   *
   * @param {import("./TextPlacement.js").default|string} placement Placement.
   * @api
   */


  Text.prototype.setPlacement = function (placement) {
    this.placement_ = placement;
  };
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */


  Text.prototype.setRotateWithView = function (rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  };
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */


  Text.prototype.setFill = function (fill) {
    this.fill_ = fill;
  };
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */


  Text.prototype.setRotation = function (rotation) {
    this.rotation_ = rotation;
  };
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */


  Text.prototype.setScale = function (scale) {
    this.scale_ = scale;
    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(scale !== undefined ? scale : 1);
  };
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */


  Text.prototype.setStroke = function (stroke) {
    this.stroke_ = stroke;
  };
  /**
   * Set the text.
   *
   * @param {string|undefined} text Text.
   * @api
   */


  Text.prototype.setText = function (text) {
    this.text_ = text;
  };
  /**
   * Set the text alignment.
   *
   * @param {string|undefined} textAlign Text align.
   * @api
   */


  Text.prototype.setTextAlign = function (textAlign) {
    this.textAlign_ = textAlign;
  };
  /**
   * Set the text baseline.
   *
   * @param {string|undefined} textBaseline Text baseline.
   * @api
   */


  Text.prototype.setTextBaseline = function (textBaseline) {
    this.textBaseline_ = textBaseline;
  };
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */


  Text.prototype.setBackgroundFill = function (fill) {
    this.backgroundFill_ = fill;
  };
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */


  Text.prototype.setBackgroundStroke = function (stroke) {
    this.backgroundStroke_ = stroke;
  };
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */


  Text.prototype.setPadding = function (padding) {
    this.padding_ = padding;
  };

  return Text;
}();

/* harmony default export */ __webpack_exports__["default"] = (Text);

/***/ }),

/***/ "./build/wg/style/TextPlacement.js":
/*!*****************************************!*\
  !*** ./build/wg/style/TextPlacement.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/style/TextPlacement
 */

/**
 * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module:wg/geom/LineString~LineString},
 * {@link module:wg/geom/Polygon~Polygon}, {@link module:wg/geom/MultiLineString~MultiLineString} or
 * {@link module:wg/geom/MultiPolygon~MultiPolygon}.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  POINT: 'point',
  LINE: 'line'
});

/***/ }),

/***/ "./build/wg/style/expressions.js":
/*!***************************************!*\
  !*** ./build/wg/style/expressions.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ValueTypes": function() { return /* binding */ ValueTypes; },
/* harmony export */   "Operators": function() { return /* binding */ Operators; },
/* harmony export */   "getValueType": function() { return /* binding */ getValueType; },
/* harmony export */   "isTypeUnique": function() { return /* binding */ isTypeUnique; },
/* harmony export */   "numberToGlsl": function() { return /* binding */ numberToGlsl; },
/* harmony export */   "arrayToGlsl": function() { return /* binding */ arrayToGlsl; },
/* harmony export */   "colorToGlsl": function() { return /* binding */ colorToGlsl; },
/* harmony export */   "getStringNumberEquivalent": function() { return /* binding */ getStringNumberEquivalent; },
/* harmony export */   "stringToGlsl": function() { return /* binding */ stringToGlsl; },
/* harmony export */   "expressionToGlsl": function() { return /* binding */ expressionToGlsl; },
/* harmony export */   "uniformNameForVariable": function() { return /* binding */ uniformNameForVariable; },
/* harmony export */   "PALETTE_TEXTURE_ARRAY": function() { return /* binding */ PALETTE_TEXTURE_ARRAY; }
/* harmony export */ });
/* harmony import */ var _webgl_PaletteTexture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/PaletteTexture.js */ "./build/wg/webgl/PaletteTexture.js");
/* harmony import */ var _renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/webgl/TileLayer.js */ "./build/wg/renderer/webgl/TileLayer.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ "./build/wg/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
/**
 * Operators and utilities used for style expressions
 * @module wg/style/expressions
 */




/**
 * Base type used for literal style parameters; can be a number literal or the output of an operator,
 * which in turns takes {@link import("./expressions.js").ExpressionValue} arguments.
 *
 * The following operators can be used:
 *
 * * Reading operators:
 *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band
 *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values
 *     are in the 0..1 range. {@link import("../source/TileImage.js").default} sources have 4 bands: red,
 *     green, blue and alpha. {@link import("../source/DataTile.js").default} sources can have any number
 *     of bands, depending on the underlying data source and
 *     {@link import("../source/GeoTIFF.js").Options configuration}. `xOffset` and `yOffset` are optional
 *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.
 *   * `['get', 'attributeName']` fetches a feature attribute (it will be prefixed by `a_` in the shader)
 *     Note: those will be taken from the attributes provided to the renderer
 *   * `['resolution']` returns the current resolution
 *   * `['time']` returns the time in seconds since the creation of the layer
 *   * `['var', 'varName']` fetches a value from the style variables, or 0 if undefined
 *   * `['zoom']` returns the current zoom level
 *
 * * Math operators:
 *   * `['*', value1, value2]` multiplies `value1` by `value2`
 *   * `['/', value1, value2]` divides `value1` by `value2`
 *   * `['+', value1, value2]` adds `value1` and `value2`
 *   * `['-', value1, value2]` subtracts `value2` from `value1`
 *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`
 *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)
 *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power
 *   * `['abs', value1]` returns the absolute value of `value1`
 *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`
 *   * `['round', value1]` returns the nearest integer to `value1`
 *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`
 *   * `['sin', value1]` returns the sine of `value1`
 *   * `['cos', value1]` returns the cosine of `value1`
 *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`
 *
 * * Transform operators:
 *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding
 *     condition evaluates to `true`. If no match is found, returns the `fallback` value.
 *     All conditions should be `boolean`, output and fallback can be any kind.
 *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all
 *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,
 *     returns the `fallback` value.
 *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and
 *     `fallback` values must be of the same type, and can be of any kind.
 *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between
 *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is
 *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value
 *     of 1 is equivalent to `['linear']`.
 *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.
 *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised
 *     between `output1` and `outputN`.
 *
 * * Logical operators:
 *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.
 *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.
 *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.
 *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.
 *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.
 *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.
 *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.
 *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.
 *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.
 *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`
 *     (inclusively), or `false` otherwise.
 *
 * * Conversion operators:
 *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of
 *     values can currently only be 2, 3 or 4.
 *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is
 *     optional; if not specified, it will be set to 1.
 *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.
 *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`
 *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors
 *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),
 *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b
 *     in the 0-255 range and a in the 0-1 range).
 *
 * Values can either be literals or another operator, as they will be evaluated recursively.
 * Literal values can be of the following types:
 * * `boolean`
 * * `number`
 * * `string`
 * * {@link module:wg/color~Color}
 *
 * @typedef {Array<*>|import("../color.js").Color|string|number|boolean} ExpressionValue
 * @api
 */

/**
 * Possible inferred types from a given value or expression.
 * Note: these are binary flags.
 * @enum {number}
 */

var ValueTypes = {
  NUMBER: 1,
  STRING: 2,
  COLOR: 4,
  BOOLEAN: 8,
  NUMBER_ARRAY: 16,
  ANY: 31,
  NONE: 0
};
/**
 * An operator declaration must contain two methods: `getReturnType` which returns a type based on
 * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.
 * Note: both methods can process arguments recursively.
 * @typedef {Object} Operator
 * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types
 * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes=): string} toGlsl Returns a GLSL-compatible string
 * Note: takes in an optional type hint as 3rd parameter
 */

/**
 * Operator declarations
 * @type {Object<string, Operator>}
 */

var Operators = {};
/**
 * Returns the possible types for a given value (each type being a binary flag)
 * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`
 * @param {ExpressionValue} value Value
 * @return {ValueTypes|number} Type or types inferred from the value
 */

function getValueType(value) {
  if (typeof value === 'number') {
    return ValueTypes.NUMBER;
  }

  if (typeof value === 'boolean') {
    return ValueTypes.BOOLEAN;
  }

  if (typeof value === 'string') {
    if ((0,_color_js__WEBPACK_IMPORTED_MODULE_0__.isStringColor)(value)) {
      return ValueTypes.COLOR | ValueTypes.STRING;
    }

    return ValueTypes.STRING;
  }

  if (!Array.isArray(value)) {
    throw new Error("Unhandled value type: ".concat(JSON.stringify(value)));
  }

  var valueArr =
  /** @type {Array<*>} */
  value;
  var onlyNumbers = valueArr.every(function (v) {
    return typeof v === 'number';
  });

  if (onlyNumbers) {
    if (valueArr.length === 3 || valueArr.length === 4) {
      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;
    }

    return ValueTypes.NUMBER_ARRAY;
  }

  if (typeof valueArr[0] !== 'string') {
    throw new Error("Expected an expression operator but received: ".concat(JSON.stringify(valueArr)));
  }

  var operator = Operators[valueArr[0]];

  if (operator === undefined) {
    throw new Error("Unrecognized expression operator: ".concat(JSON.stringify(valueArr)));
  }

  return operator.getReturnType(valueArr.slice(1));
}
/**
 * Checks if only one value type is enabled in the input number.
 * @param {ValueTypes|number} valueType Number containing value type binary flags
 * @return {boolean} True if only one type flag is enabled, false if zero or multiple
 */

function isTypeUnique(valueType) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.log2)(valueType) % 1 === 0;
}
/**
 * Context available during the parsing of an expression.
 * @typedef {Object} ParsingContext
 * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader
 * @property {Array<string>} variables List of variables used in the expression; contains **unprefixed names**
 * @property {Array<string>} attributes List of attributes used in the expression; contains **unprefixed names**
 * @property {Object<string, number>} stringLiteralsMap This object maps all encountered string values to a number
 * @property {Object<string, string>} functions Lookup of functions used by the style.
 * @property {number} [bandCount] Number of bands per pixel.
 * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.
 */

/**
 * Will return the number as a float with a dot separator, which is required by GLSL.
 * @param {number} v Numerical value.
 * @return {string} The value as string.
 */

function numberToGlsl(v) {
  var s = v.toString();
  return s.indexOf('.') === -1 ? s + '.0' : s;
}
/**
 * Will return the number array as a float with a dot separator, concatenated with ', '.
 * @param {Array<number>} array Numerical values array.
 * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.
 */

function arrayToGlsl(array) {
  if (array.length < 2 || array.length > 4) {
    throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');
  }

  return "vec".concat(array.length, "(").concat(array.map(numberToGlsl).join(', '), ")");
}
/**
 * Will normalize and converts to string a `vec4` color array compatible with GLSL.
 * @param {string|import("../color.js").Color} color Color either in string format or [r, g, b, a] array format,
 * with RGB components in the 0..255 range and the alpha component in the 0..1 range.
 * Note that the final array will always have 4 components.
 * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.
 */

function colorToGlsl(color) {
  var array = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.asArray)(color).slice();

  if (array.length < 4) {
    array.push(1);
  }

  return arrayToGlsl(array.map(function (c, i) {
    return i < 3 ? c / 255 : c;
  }));
}
/**
 * Returns a stable equivalent number for the string literal.
 * @param {ParsingContext} context Parsing context
 * @param {string} string String literal value
 * @return {number} Number equivalent
 */

function getStringNumberEquivalent(context, string) {
  if (context.stringLiteralsMap[string] === undefined) {
    context.stringLiteralsMap[string] = Object.keys(context.stringLiteralsMap).length;
  }

  return context.stringLiteralsMap[string];
}
/**
 * Returns a stable equivalent number for the string literal, for use in shaders. This number is then
 * converted to be a GLSL-compatible string.
 * @param {ParsingContext} context Parsing context
 * @param {string} string String literal value
 * @return {string} GLSL-compatible string containing a number
 */

function stringToGlsl(context, string) {
  return numberToGlsl(getStringNumberEquivalent(context, string));
}
/**
 * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that
 * will be read and modified during the parsing operation.
 * @param {ParsingContext} context Parsing context
 * @param {ExpressionValue} value Value
 * @param {ValueTypes|number} [typeHint] Hint for the expected final type (can be several types combined)
 * @return {string} GLSL-compatible output
 */

function expressionToGlsl(context, value, typeHint) {
  // operator
  if (Array.isArray(value) && typeof value[0] === 'string') {
    var operator = Operators[value[0]];

    if (operator === undefined) {
      throw new Error("Unrecognized expression operator: ".concat(JSON.stringify(value)));
    }

    return operator.toGlsl(context, value.slice(1), typeHint);
  }

  var valueType = getValueType(value);

  if ((valueType & ValueTypes.NUMBER) > 0) {
    return numberToGlsl(
    /** @type {number} */
    value);
  }

  if ((valueType & ValueTypes.BOOLEAN) > 0) {
    return value.toString();
  }

  if ((valueType & ValueTypes.STRING) > 0 && (typeHint === undefined || typeHint == ValueTypes.STRING)) {
    return stringToGlsl(context, value.toString());
  }

  if ((valueType & ValueTypes.COLOR) > 0 && (typeHint === undefined || typeHint == ValueTypes.COLOR)) {
    return colorToGlsl(
    /** @type {Array<number> | string} */
    value);
  }

  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {
    return arrayToGlsl(
    /** @type {Array<number>} */
    value);
  }

  throw new Error("Unexpected expression ".concat(value, " (expected type ").concat(typeHint, ")"));
}

function assertNumber(value) {
  if (!(getValueType(value) & ValueTypes.NUMBER)) {
    throw new Error("A numeric value was expected, got ".concat(JSON.stringify(value), " instead"));
  }
}

function assertNumbers(values) {
  for (var i = 0; i < values.length; i++) {
    assertNumber(values[i]);
  }
}

function assertString(value) {
  if (!(getValueType(value) & ValueTypes.STRING)) {
    throw new Error("A string value was expected, got ".concat(JSON.stringify(value), " instead"));
  }
}

function assertBoolean(value) {
  if (!(getValueType(value) & ValueTypes.BOOLEAN)) {
    throw new Error("A boolean value was expected, got ".concat(JSON.stringify(value), " instead"));
  }
}

function assertArgsCount(args, count) {
  if (args.length !== count) {
    throw new Error("Exactly ".concat(count, " arguments were expected, got ").concat(args.length, " instead"));
  }
}

function assertArgsMinCount(args, count) {
  if (args.length < count) {
    throw new Error("At least ".concat(count, " arguments were expected, got ").concat(args.length, " instead"));
  }
}

function assertArgsMaxCount(args, count) {
  if (args.length > count) {
    throw new Error("At most ".concat(count, " arguments were expected, got ").concat(args.length, " instead"));
  }
}

function assertArgsEven(args) {
  if (args.length % 2 !== 0) {
    throw new Error("An even amount of arguments was expected, got ".concat(args, " instead"));
  }
}

function assertArgsOdd(args) {
  if (args.length % 2 === 0) {
    throw new Error("An odd amount of arguments was expected, got ".concat(args, " instead"));
  }
}

function assertUniqueInferredType(args, types) {
  if (!isTypeUnique(types)) {
    throw new Error("Could not infer only one type from the following expression: ".concat(JSON.stringify(args)));
  }
}

Operators['get'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.ANY;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 1);
    assertString(args[0]);
    var value = args[0].toString();

    if (context.attributes.indexOf(value) === -1) {
      context.attributes.push(value);
    }

    var prefix = context.inFragmentShader ? 'v_' : 'a_';
    return prefix + value;
  }
};
/**
 * Get the uniform name given a variable name.
 * @param {string} variableName The variable name.
 * @return {string} The uniform name.
 */

function uniformNameForVariable(variableName) {
  return 'u_var_' + variableName;
}
Operators['var'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.ANY;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 1);
    assertString(args[0]);
    var value = args[0].toString();

    if (context.variables.indexOf(value) === -1) {
      context.variables.push(value);
    }

    return uniformNameForVariable(value);
  }
};
var PALETTE_TEXTURE_ARRAY = 'u_paletteTextures'; // ['palette', index, colors]

Operators['palette'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.COLOR;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 2);
    assertNumber(args[0]);
    var index = expressionToGlsl(context, args[0]);
    var colors = args[1];

    if (!Array.isArray(colors)) {
      throw new Error('The second argument of palette must be an array');
    }

    var numColors = colors.length;
    var palette = new Uint8Array(numColors * 4);

    for (var i = 0; i < numColors; i++) {
      var candidate = colors[i];
      /**
       * @type {import('../color.js').Color}
       */

      var color = void 0;

      if (typeof candidate === 'string') {
        color = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.fromString)(candidate);
      } else {
        if (!Array.isArray(candidate)) {
          throw new Error('The second argument of palette must be an array of strings or colors');
        }

        var length_1 = candidate.length;

        if (length_1 === 4) {
          color = candidate;
        } else {
          if (length_1 !== 3) {
            throw new Error("Expected palette color to have 3 or 4 values, got ".concat(length_1));
          }

          color = [candidate[0], candidate[1], candidate[2], 1];
        }
      }

      var offset = i * 4;
      palette[offset] = color[0];
      palette[offset + 1] = color[1];
      palette[offset + 2] = color[2];
      palette[offset + 3] = color[3] * 255;
    }

    if (!context.paletteTextures) {
      context.paletteTextures = [];
    }

    var paletteName = "".concat(PALETTE_TEXTURE_ARRAY, "[").concat(context.paletteTextures.length, "]");
    var paletteTexture = new _webgl_PaletteTexture_js__WEBPACK_IMPORTED_MODULE_2__["default"](paletteName, palette);
    context.paletteTextures.push(paletteTexture);
    return "texture2D(".concat(paletteName, ", vec2((").concat(index, " + 0.5) / ").concat(numColors, ".0, 0.5))");
  }
};
var GET_BAND_VALUE_FUNC = 'getBandValue';
Operators['band'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsMinCount(args, 1);
    assertArgsMaxCount(args, 3);
    var band = args[0];

    if (!(GET_BAND_VALUE_FUNC in context.functions)) {
      var ifBlocks = '';
      var bandCount = context.bandCount || 1;

      for (var i = 0; i < bandCount; i++) {
        var colorIndex = Math.floor(i / 4);
        var bandIndex = i % 4;

        if (bandIndex === bandCount - 1 && bandIndex === 1) {
          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha
          bandIndex = 3;
        }

        var textureName = "".concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_3__.Uniforms.TILE_TEXTURE_ARRAY, "[").concat(colorIndex, "]");
        ifBlocks += "\n          if (band == ".concat(i + 1, ".0) {\n            return texture2D(").concat(textureName, ", v_textureCoord + vec2(dx, dy))[").concat(bandIndex, "];\n          }\n        ");
      }

      context.functions[GET_BAND_VALUE_FUNC] = "\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ".concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_3__.Uniforms.TEXTURE_PIXEL_WIDTH, ";\n          float dy = yOffset / ").concat(_renderer_webgl_TileLayer_js__WEBPACK_IMPORTED_MODULE_3__.Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n          ").concat(ifBlocks, "\n        }\n      ");
    }

    var bandExpression = expressionToGlsl(context, band);
    var xOffsetExpression = expressionToGlsl(context, args[1] || 0);
    var yOffsetExpression = expressionToGlsl(context, args[2] || 0);
    return "".concat(GET_BAND_VALUE_FUNC, "(").concat(bandExpression, ", ").concat(xOffsetExpression, ", ").concat(yOffsetExpression, ")");
  }
};
Operators['time'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 0);
    return 'u_time';
  }
};
Operators['zoom'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 0);
    return 'u_zoom';
  }
};
Operators['resolution'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 0);
    return 'u_resolution';
  }
};
Operators['*'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " * ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators['/'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " / ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators['+'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " + ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators['-'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " - ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators['clamp'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 3);
    assertNumbers(args);
    var min = expressionToGlsl(context, args[1]);
    var max = expressionToGlsl(context, args[2]);
    return "clamp(".concat(expressionToGlsl(context, args[0]), ", ").concat(min, ", ").concat(max, ")");
  }
};
Operators['%'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "mod(".concat(expressionToGlsl(context, args[0]), ", ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators['^'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "pow(".concat(expressionToGlsl(context, args[0]), ", ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators['abs'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "abs(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators['floor'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "floor(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators['round'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "floor(".concat(expressionToGlsl(context, args[0]), " + 0.5)");
  }
};
Operators['ceil'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "ceil(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators['sin'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "sin(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators['cos'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "cos(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators['atan'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsMinCount(args, 1);
    assertArgsMaxCount(args, 2);
    assertNumbers(args);
    return args.length === 2 ? "atan(".concat(expressionToGlsl(context, args[0]), ", ").concat(expressionToGlsl(context, args[1]), ")") : "atan(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators['>'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " > ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators['>='] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " >= ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators['<'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " < ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators['<='] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " <= ").concat(expressionToGlsl(context, args[1]), ")");
  }
};

function getEqualOperator(operator) {
  return {
    getReturnType: function getReturnType(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 2); // find common type

      var type = ValueTypes.ANY;

      for (var i = 0; i < args.length; i++) {
        type &= getValueType(args[i]);
      }

      if (type === ValueTypes.NONE) {
        throw new Error("All arguments should be of compatible type, got ".concat(JSON.stringify(args), " instead"));
      } // Since it's not possible to have color types here, we can leave it out
      // This fixes issues in case the value type is ambiguously detected as a color (e.g. the string 'red')


      type &= ~ValueTypes.COLOR;
      return "(".concat(expressionToGlsl(context, args[0], type), " ").concat(operator, " ").concat(expressionToGlsl(context, args[1], type), ")");
    }
  };
}

Operators['=='] = getEqualOperator('==');
Operators['!='] = getEqualOperator('!=');
Operators['!'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 1);
    assertBoolean(args[0]);
    return "(!".concat(expressionToGlsl(context, args[0]), ")");
  }
};

function getDecisionOperator(operator) {
  return {
    getReturnType: function getReturnType(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsMinCount(args, 2);

      for (var i = 0; i < args.length; i++) {
        assertBoolean(args[i]);
      }

      var result = '';
      result = args.map(function (arg) {
        return expressionToGlsl(context, arg);
      }).join(" ".concat(operator, " "));
      result = "(".concat(result, ")");
      return result;
    }
  };
}

Operators['all'] = getDecisionOperator('&&');
Operators['any'] = getDecisionOperator('||');
Operators['between'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsCount(args, 3);
    assertNumbers(args);
    var min = expressionToGlsl(context, args[1]);
    var max = expressionToGlsl(context, args[2]);
    var value = expressionToGlsl(context, args[0]);
    return "(".concat(value, " >= ").concat(min, " && ").concat(value, " <= ").concat(max, ")");
  }
};
Operators['array'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.NUMBER_ARRAY;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsMinCount(args, 2);
    assertArgsMaxCount(args, 4);
    assertNumbers(args);
    var parsedArgs = args.map(function (val) {
      return expressionToGlsl(context, val, ValueTypes.NUMBER);
    });
    return "vec".concat(args.length, "(").concat(parsedArgs.join(', '), ")");
  }
};
Operators['color'] = {
  getReturnType: function getReturnType(args) {
    return ValueTypes.COLOR;
  },
  toGlsl: function toGlsl(context, args) {
    assertArgsMinCount(args, 3);
    assertArgsMaxCount(args, 4);
    assertNumbers(args);
    var array =
    /** @type {Array<number>} */
    args;

    if (args.length === 3) {
      array.push(1);
    }

    var parsedArgs = args.map(function (val, i) {
      return expressionToGlsl(context, val, ValueTypes.NUMBER) + (i < 3 ? ' / 255.0' : '');
    });
    return "vec".concat(args.length, "(").concat(parsedArgs.join(', '), ")");
  }
};
Operators['interpolate'] = {
  getReturnType: function getReturnType(args) {
    var type = ValueTypes.COLOR | ValueTypes.NUMBER;

    for (var i = 3; i < args.length; i += 2) {
      type = type & getValueType(args[i]);
    }

    return type;
  },
  toGlsl: function toGlsl(context, args, opt_typeHint) {
    assertArgsEven(args);
    assertArgsMinCount(args, 6); // validate interpolation type

    var type = args[0];
    var interpolation;

    switch (type[0]) {
      case 'linear':
        interpolation = 1;
        break;

      case 'exponential':
        interpolation = type[1];
        break;

      default:
        interpolation = null;
    }

    if (!interpolation) {
      throw new Error("Invalid interpolation type for \"interpolate\" operator, received: ".concat(JSON.stringify(type)));
    } // compute input/output types


    var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;
    var outputType = Operators['interpolate'].getReturnType(args) & typeHint;
    assertUniqueInferredType(args, outputType);
    var input = expressionToGlsl(context, args[1]);
    var exponent = numberToGlsl(interpolation);
    var result = '';

    for (var i = 2; i < args.length - 2; i += 2) {
      var stop1 = expressionToGlsl(context, args[i]);
      var output1 = result || expressionToGlsl(context, args[i + 1], outputType);
      var stop2 = expressionToGlsl(context, args[i + 2]);
      var output2 = expressionToGlsl(context, args[i + 3], outputType);
      result = "mix(".concat(output1, ", ").concat(output2, ", pow(clamp((").concat(input, " - ").concat(stop1, ") / (").concat(stop2, " - ").concat(stop1, "), 0.0, 1.0), ").concat(exponent, "))");
    }

    return result;
  }
};
Operators['match'] = {
  getReturnType: function getReturnType(args) {
    var type = ValueTypes.ANY;

    for (var i = 2; i < args.length; i += 2) {
      type = type & getValueType(args[i]);
    }

    type = type & getValueType(args[args.length - 1]);
    return type;
  },
  toGlsl: function toGlsl(context, args, opt_typeHint) {
    assertArgsEven(args);
    assertArgsMinCount(args, 4);
    var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;
    var outputType = Operators['match'].getReturnType(args) & typeHint;
    assertUniqueInferredType(args, outputType);
    var input = expressionToGlsl(context, args[0]);
    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);
    var result = null;

    for (var i = args.length - 3; i >= 1; i -= 2) {
      var match = expressionToGlsl(context, args[i]);
      var output = expressionToGlsl(context, args[i + 1], outputType);
      result = "(".concat(input, " == ").concat(match, " ? ").concat(output, " : ").concat(result || fallback, ")");
    }

    return result;
  }
};
Operators['case'] = {
  getReturnType: function getReturnType(args) {
    var type = ValueTypes.ANY;

    for (var i = 1; i < args.length; i += 2) {
      type = type & getValueType(args[i]);
    }

    type = type & getValueType(args[args.length - 1]);
    return type;
  },
  toGlsl: function toGlsl(context, args, opt_typeHint) {
    assertArgsOdd(args);
    assertArgsMinCount(args, 3);
    var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;
    var outputType = Operators['case'].getReturnType(args) & typeHint;
    assertUniqueInferredType(args, outputType);

    for (var i = 0; i < args.length - 1; i += 2) {
      assertBoolean(args[i]);
    }

    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);
    var result = null;

    for (var i = args.length - 3; i >= 0; i -= 2) {
      var condition = expressionToGlsl(context, args[i]);
      var output = expressionToGlsl(context, args[i + 1], outputType);
      result = "(".concat(condition, " ? ").concat(output, " : ").concat(result || fallback, ")");
    }

    return result;
  }
};

/***/ }),

/***/ "./build/wg/tilecoord.js":
/*!*******************************!*\
  !*** ./build/wg/tilecoord.js ***!
  \*******************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createOrUpdate": function() { return /* binding */ createOrUpdate; },
/* harmony export */   "getKeyZXY": function() { return /* binding */ getKeyZXY; },
/* harmony export */   "getKey": function() { return /* binding */ getKey; },
/* harmony export */   "getCacheKeyForTileKey": function() { return /* binding */ getCacheKeyForTileKey; },
/* harmony export */   "fromKey": function() { return /* binding */ fromKey; },
/* harmony export */   "hash": function() { return /* binding */ hash; },
/* harmony export */   "withinExtentAndZ": function() { return /* binding */ withinExtentAndZ; }
/* harmony export */ });
/**
 * @module wg/tilecoord
 */

/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
 * @typedef {Array<number>} TileCoord
 * @api
 */

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord} [opt_tileCoord] Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */
function createOrUpdate(z, x, y, opt_tileCoord) {
  if (opt_tileCoord !== undefined) {
    opt_tileCoord[0] = z;
    opt_tileCoord[1] = x;
    opt_tileCoord[2] = y;
    return opt_tileCoord;
  } else {
    return [z, x, y];
  }
}
/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */

function getKeyZXY(z, x, y) {
  return z + '/' + x + '/' + y;
}
/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */

function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
/**
 * Get the tile cache key for a tile key obtained through `tile.getKey()`.
 * @param {string} tileKey The tile key.
 * @return {string} The cache key.
 */

function getCacheKeyForTileKey(tileKey) {
  var _a = tileKey.substring(tileKey.lastIndexOf('/') + 1, tileKey.length).split(',').map(Number),
      z = _a[0],
      x = _a[1],
      y = _a[2];

  return getKeyZXY(z, x, y);
}
/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */

function fromKey(key) {
  return key.split('/').map(Number);
}
/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */

function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}
/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */

function withinExtentAndZ(tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }

  var tileRange = tileGrid.getFullTileRange(z);

  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
}

/***/ }),

/***/ "./build/wg/tilegrid.js":
/*!******************************!*\
  !*** ./build/wg/tilegrid.js ***!
  \******************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getForProjection": function() { return /* binding */ getForProjection; },
/* harmony export */   "wrapX": function() { return /* binding */ wrapX; },
/* harmony export */   "createForExtent": function() { return /* binding */ createForExtent; },
/* harmony export */   "createXYZ": function() { return /* binding */ createXYZ; },
/* harmony export */   "createForProjection": function() { return /* binding */ createForProjection; },
/* harmony export */   "extentFromProjection": function() { return /* binding */ extentFromProjection; }
/* harmony export */ });
/* harmony import */ var _extent_Corner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent/Corner.js */ "./build/wg/extent/Corner.js");
/* harmony import */ var _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tilegrid/TileGrid.js */ "./build/wg/tilegrid/TileGrid.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./proj/Units.js */ "./build/wg/proj/Units.js");
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tilegrid/common.js */ "./build/wg/tilegrid/common.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./build/wg/proj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent.js */ "./build/wg/extent.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./size.js */ "./build/wg/size.js");
/**
 * @module wg/tilegrid
 */







/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */

function getForProjection(projection) {
  var tileGrid = projection.getDefaultTileGrid();

  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }

  return tileGrid;
}
/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */

function wrapX(tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = extentFromProjection(projection);

  if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsCoordinate)(projectionExtent, center)) {
    var worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
}
/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [opt_maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [opt_tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent/Corner.js").default} [opt_corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */

function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== undefined ? opt_corner : _extent_Corner_js__WEBPACK_IMPORTED_MODULE_2__["default"].TOP_LEFT;
  var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);
  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
    extent: extent,
    origin: (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getCorner)(extent, corner),
    resolutions: resolutions,
    tileSize: opt_tileSize
  });
}
/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
 * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxResolution] Resolution at level zero.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */

/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions} [opt_options] Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */

function createXYZ(opt_options) {
  var xyzOptions = opt_options || {};
  var extent = xyzOptions.extent || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:3857').getExtent();
  var gridOptions = {
    extent: extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)
  };
  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_3__["default"](gridOptions);
}
/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [opt_maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [opt_tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {number} [opt_maxResolution] Resolution at level zero.
 * @return {!Array<number>} Resolutions array.
 */

function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {
  var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_MAX_ZOOM;
  var height = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getHeight)(extent);
  var width = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(extent);
  var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(opt_tileSize !== undefined ? opt_tileSize : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_TILE_SIZE);
  var maxResolution = opt_maxResolution > 0 ? opt_maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  var length = maxZoom + 1;
  var resolutions = new Array(length);

  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }

  return resolutions;
}
/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number} [opt_maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [opt_tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent/Corner.js").default} [opt_corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */


function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent = extentFromProjection(projection);
  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
}
/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */

function extentFromProjection(projection) {
  projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection);
  var extent = projection.getExtent();

  if (!extent) {
    var half = 180 * _proj_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[_proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["default"].DEGREES] / projection.getMetersPerUnit();
    extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createOrUpdate)(-half, -half, half, half);
  }

  return extent;
}

/***/ }),

/***/ "./build/wg/tilegrid/TileGrid.js":
/*!***************************************!*\
  !*** ./build/wg/tilegrid/TileGrid.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../TileRange.js */ "./build/wg/TileRange.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common.js */ "./build/wg/tilegrid/common.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./build/wg/math.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./build/wg/extent.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilecoord.js */ "./build/wg/tilecoord.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../size.js */ "./build/wg/size.js");
/**
 * @module wg/tilegrid/TileGrid
 */








/**
 * @private
 * @type {import("../tilecoord.js").TileCoord}
 */

var tmpTileCoord = [0, 0, 0];
/**
 * Number of decimal digits to consider in integer values when rounding.
 * @type {number}
 */

var DECIMALS = 5;
/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:wg/source/Tile~TileSource} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. If specified the values
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent
 * for which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */

/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */

var TileGrid =
/** @class */
function () {
  /**
   * @param {Options} options Tile grid options.
   */
  function TileGrid(options) {
    /**
     * @protected
     * @type {number}
     */
    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;
    /**
     * @private
     * @type {!Array<number>}
     */

    this.resolutions_ = options.resolutions;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_array_js__WEBPACK_IMPORTED_MODULE_1__.isSorted)(this.resolutions_, function (a, b) {
      return b - a;
    }, true), 17); // `resolutions` must be sorted in descending order
    // check if we've got a consistent zoom factor and origin

    var zoomFactor;

    if (!options.origins) {
      for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
        } else {
          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
            zoomFactor = undefined;
            break;
          }
        }
      }
    }
    /**
     * @private
     * @type {number|undefined}
     */


    this.zoomFactor_ = zoomFactor;
    /**
     * @protected
     * @type {number}
     */

    this.maxZoom = this.resolutions_.length - 1;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */

    this.origin_ = options.origin !== undefined ? options.origin : null;
    /**
     * @private
     * @type {Array<import("../coordinate.js").Coordinate>}
     */

    this.origins_ = null;

    if (options.origins !== undefined) {
      this.origins_ = options.origins;
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
    }

    var extent = options.extent;

    if (extent !== undefined && !this.origin_ && !this.origins_) {
      this.origin_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getTopLeft)(extent);
    }

    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both

    /**
     * @private
     * @type {Array<number|import("../size.js").Size>}
     */

    this.tileSizes_ = null;

    if (options.tileSizes !== undefined) {
      this.tileSizes_ = options.tileSizes;
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
    }
    /**
     * @private
     * @type {number|import("../size.js").Size}
     */


    this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? _common_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_TILE_SIZE : null;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    this.extent_ = extent !== undefined ? extent : null;
    /**
     * @private
     * @type {Array<import("../TileRange.js").default>}
     */

    this.fullTileRanges_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    this.tmpSize_ = [0, 0];
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    this.tmpExtent_ = [0, 0, 0, 0];

    if (options.sizes !== undefined) {
      this.fullTileRanges_ = options.sizes.map(function (size, z) {
        var tileRange = new _TileRange_js__WEBPACK_IMPORTED_MODULE_4__["default"](Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));

        if (extent) {
          var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }

        return tileRange;
      }, this);
    } else if (extent) {
      this.calculateTileRanges_(extent);
    }
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */


  TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {
    var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);

    for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
      for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
        callback([zoom, i, j]);
      }
    }
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [opt_tileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [opt_extent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */


  TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_tileRange, opt_extent) {
    var tileRange, x, y;
    var tileCoordExtent = null;
    var z = tileCoord[0] - 1;

    if (this.zoomFactor_ === 2) {
      x = tileCoord[1];
      y = tileCoord[2];
    } else {
      tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
    }

    while (z >= this.minZoom) {
      if (this.zoomFactor_ === 2) {
        x = Math.floor(x / 2);
        y = Math.floor(y / 2);
        tileRange = (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(x, x, y, y, opt_tileRange);
      } else {
        tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
      }

      if (callback(z, tileRange)) {
        return true;
      }

      --z;
    }

    return false;
  };
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  TileGrid.prototype.getExtent = function () {
    return this.extent_;
  };
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */


  TileGrid.prototype.getMaxZoom = function () {
    return this.maxZoom;
  };
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */


  TileGrid.prototype.getMinZoom = function () {
    return this.minZoom;
  };
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */


  TileGrid.prototype.getOrigin = function (z) {
    if (this.origin_) {
      return this.origin_;
    } else {
      return this.origins_[z];
    }
  };
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */


  TileGrid.prototype.getResolution = function (z) {
    return this.resolutions_[z];
  };
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */


  TileGrid.prototype.getResolutions = function () {
    return this.resolutions_;
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [opt_tileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [opt_extent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default} Tile range.
   */


  TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {
    if (tileCoord[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        var minX = tileCoord[1] * 2;
        var minY = tileCoord[2] * 2;
        return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(minX, minX + 1, minY, minY + 1, opt_tileRange);
      }

      var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent || this.tmpExtent_);
      return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
    }

    return null;
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [opt_tileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default} Tile range.
   */


  TileGrid.prototype.getTileRangeForTileCoordAndZ = function (tileCoord, z, opt_tileRange) {
    if (z > this.maxZoom || z < this.minZoom) {
      return null;
    }

    var tileCoordZ = tileCoord[0];
    var tileCoordX = tileCoord[1];
    var tileCoordY = tileCoord[2];

    if (z === tileCoordZ) {
      return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(tileCoordX, tileCoordY, tileCoordX, tileCoordY, opt_tileRange);
    }

    if (this.zoomFactor_) {
      var factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
      var minX = Math.floor(tileCoordX * factor);
      var minY = Math.floor(tileCoordY * factor);

      if (z < tileCoordZ) {
        return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(minX, minX, minY, minY, opt_tileRange);
      }

      var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
      var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
      return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(minX, maxX, minY, maxY, opt_tileRange);
    }

    var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
  };
  /**
   * Get the extent for a tile range.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {import("../extent.js").Extent} [opt_extent] Temporary import("../extent.js").Extent object.
   * @return {import("../extent.js").Extent} Extent.
   */


  TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {
    var origin = this.getOrigin(z);
    var resolution = this.getResolution(z);
    var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(z), this.tmpSize_);
    var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
    var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
    var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
    var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createOrUpdate)(minX, minY, maxX, maxY, opt_extent);
  };
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [opt_tileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */


  TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {
    var tileCoord = tmpTileCoord;
    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);
    var minX = tileCoord[1];
    var minY = tileCoord[2];
    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);
    return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */


  TileGrid.prototype.getTileCoordCenter = function (tileCoord) {
    var origin = this.getOrigin(tileCoord[0]);
    var resolution = this.getResolution(tileCoord[0]);
    var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
    return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution];
  };
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [opt_extent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {
    var origin = this.getOrigin(tileCoord[0]);
    var resolution = this.getResolution(tileCoord[0]);
    var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
    var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
    var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
    var maxX = minX + tileSize[0] * resolution;
    var maxY = minY + tileSize[1] * resolution;
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createOrUpdate)(minX, minY, maxX, maxY, opt_extent);
  };
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */


  TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {
    return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
  };
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */


  TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
    var z = this.getZForResolution(resolution);
    var scale = resolution / this.getResolution(z);
    var origin = this.getOrigin(z);
    var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(z), this.tmpSize_);
    var tileCoordX = scale * (x - origin[0]) / resolution / tileSize[0];
    var tileCoordY = scale * (origin[1] - y) / resolution / tileSize[1];

    if (reverseIntersectionPolicy) {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordX, DECIMALS) - 1;
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordX, DECIMALS);
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordY, DECIMALS);
    }

    return (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
  };
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */


  TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
    var origin = this.getOrigin(z);
    var resolution = this.getResolution(z);
    var tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(z), this.tmpSize_);
    var tileCoordX = (x - origin[0]) / resolution / tileSize[0];
    var tileCoordY = (origin[1] - y) / resolution / tileSize[1];

    if (reverseIntersectionPolicy) {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordX, DECIMALS) - 1;
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordX, DECIMALS);
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordY, DECIMALS);
    }

    return (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
  };
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Zoom level.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */


  TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {
    return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */


  TileGrid.prototype.getTileCoordResolution = function (tileCoord) {
    return this.resolutions_[tileCoord[0]];
  };
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:wg/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */


  TileGrid.prototype.getTileSize = function (z) {
    if (this.tileSize_) {
      return this.tileSize_;
    } else {
      return this.tileSizes_[z];
    }
  };
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
   */


  TileGrid.prototype.getFullTileRange = function (z) {
    if (!this.fullTileRanges_) {
      return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
    } else {
      return this.fullTileRanges_[z];
    }
  };
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:wg/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */


  TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {
    var z = (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.linearFindNearest)(this.resolutions_, resolution, opt_direction || 0);
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(z, this.minZoom, this.maxZoom);
  };
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */


  TileGrid.prototype.calculateTileRanges_ = function (extent) {
    var length = this.resolutions_.length;
    var fullTileRanges = new Array(length);

    for (var z = this.minZoom; z < length; ++z) {
      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
    }

    this.fullTileRanges_ = fullTileRanges;
  };

  return TileGrid;
}();

/* harmony default export */ __webpack_exports__["default"] = (TileGrid);

/***/ }),

/***/ "./build/wg/tilegrid/WMTS.js":
/*!***********************************!*\
  !*** ./build/wg/tilegrid/WMTS.js ***!
  \***********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFromCapabilitiesMatrixSet": function() { return /* binding */ createFromCapabilitiesMatrixSet; }
/* harmony export */ });
/* harmony import */ var _TileGrid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileGrid.js */ "./build/wg/tilegrid/TileGrid.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./build/wg/proj.js");
/**
 * @module wg/tilegrid/WMTS
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();




/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles
 * outside this extent will be requested by {@link module:wg/source/Tile~TileSource} sources.
 * When no `origin` or `origins` are configured, the `origin` will be set to the
 * top-left corner of the extent.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e.
 * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left
 * to right and downwards. If not specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins,
 * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If
 * given, the array length should match the length of the `resolutions` array, i.e.
 * each resolution can have a different origin. Tile coordinates increase left to
 * right and downwards. If not specified, `extent` or `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each
 * resolution needs to match the zoom level. This means that even if a `minZoom`
 * is configured, the resolutions array will have a length of `maxZoom + 1`
 * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs
 * to match the length of the `resolutions` array.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. The values here are the `TileMatrixWidth` and
 * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent for
 * which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. The length of
 * this array needs to match the length of the `resolutions` array.
 */

/**
 * @classdesc
 * Set the grid pattern for sources accessing WMTS tiled-image servers.
 * @api
 */

var WMTSTileGrid =
/** @class */
function (_super) {
  __extends(WMTSTileGrid, _super);
  /**
   * @param {Options} options WMTS options.
   */


  function WMTSTileGrid(options) {
    var _this = _super.call(this, {
      extent: options.extent,
      origin: options.origin,
      origins: options.origins,
      resolutions: options.resolutions,
      tileSize: options.tileSize,
      tileSizes: options.tileSizes,
      sizes: options.sizes
    }) || this;
    /**
     * @private
     * @type {!Array<string>}
     */


    _this.matrixIds_ = options.matrixIds;
    return _this;
  }
  /**
   * @param {number} z Z.
   * @return {string} MatrixId..
   */


  WMTSTileGrid.prototype.getMatrixId = function (z) {
    return this.matrixIds_[z];
  };
  /**
   * Get the list of matrix identifiers.
   * @return {Array<string>} MatrixIds.
   * @api
   */


  WMTSTileGrid.prototype.getMatrixIds = function () {
    return this.matrixIds_;
  };

  return WMTSTileGrid;
}(_TileGrid_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (WMTSTileGrid);
/**
 * Create a tile grid from a WMTS capabilities matrix set and an
 * optional TileMatrixSetLimits.
 * @param {Object} matrixSet An object representing a matrixSet in the
 *     capabilities document.
 * @param {import("../extent.js").Extent} [opt_extent] An optional extent to restrict the tile
 *     ranges the server provides.
 * @param {Array<Object>} [opt_matrixLimits] An optional object representing
 *     the available matrices for tileGrid.
 * @return {WMTSTileGrid} WMTS tileGrid instance.
 * @api
 */

function createFromCapabilitiesMatrixSet(matrixSet, opt_extent, opt_matrixLimits) {
  /** @type {!Array<number>} */
  var resolutions = [];
  /** @type {!Array<string>} */

  var matrixIds = [];
  /** @type {!Array<import("../coordinate.js").Coordinate>} */

  var origins = [];
  /** @type {!Array<import("../size.js").Size>} */

  var tileSizes = [];
  /** @type {!Array<import("../size.js").Size>} */

  var sizes = [];
  var matrixLimits = opt_matrixLimits !== undefined ? opt_matrixLimits : [];
  var supportedCRSPropName = 'SupportedCRS';
  var matrixIdsPropName = 'TileMatrix';
  var identifierPropName = 'Identifier';
  var scaleDenominatorPropName = 'ScaleDenominator';
  var topLeftCornerPropName = 'TopLeftCorner';
  var tileWidthPropName = 'TileWidth';
  var tileHeightPropName = 'TileHeight';
  var code = matrixSet[supportedCRSPropName];
  var projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(code);
  var metersPerUnit = projection.getMetersPerUnit(); // swap origin x and y coordinates if axis orientation is lat/long

  var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';
  matrixSet[matrixIdsPropName].sort(function (a, b) {
    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];
  });
  matrixSet[matrixIdsPropName].forEach(function (elt) {
    var matrixAvailable; // use of matrixLimits to filter TileMatrices from GetCapabilities
    // TileMatrixSet from unavailable matrix levels.

    if (matrixLimits.length > 0) {
      matrixAvailable = (0,_array_js__WEBPACK_IMPORTED_MODULE_2__.find)(matrixLimits, function (elt_ml) {
        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {
          return true;
        } // Fallback for tileMatrix identifiers that don't get prefixed
        // by their tileMatrixSet identifiers.


        if (elt[identifierPropName].indexOf(':') === -1) {
          return matrixSet[identifierPropName] + ':' + elt[identifierPropName] === elt_ml[matrixIdsPropName];
        }

        return false;
      });
    } else {
      matrixAvailable = true;
    }

    if (matrixAvailable) {
      matrixIds.push(elt[identifierPropName]);
      var resolution = elt[scaleDenominatorPropName] * 0.28e-3 / metersPerUnit;
      var tileWidth = elt[tileWidthPropName];
      var tileHeight = elt[tileHeightPropName];

      if (switchOriginXY) {
        origins.push([elt[topLeftCornerPropName][1], elt[topLeftCornerPropName][0]]);
      } else {
        origins.push(elt[topLeftCornerPropName]);
      }

      resolutions.push(resolution);
      tileSizes.push(tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]);
      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);
    }
  });
  return new WMTSTileGrid({
    extent: opt_extent,
    origins: origins,
    resolutions: resolutions,
    matrixIds: matrixIds,
    tileSizes: tileSizes,
    sizes: sizes
  });
}

/***/ }),

/***/ "./build/wg/tilegrid/common.js":
/*!*************************************!*\
  !*** ./build/wg/tilegrid/common.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_MAX_ZOOM": function() { return /* binding */ DEFAULT_MAX_ZOOM; },
/* harmony export */   "DEFAULT_TILE_SIZE": function() { return /* binding */ DEFAULT_TILE_SIZE; }
/* harmony export */ });
/**
 * @module wg/tilegrid/common
 */

/**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */
var DEFAULT_MAX_ZOOM = 42;
/**
 * Default tile size.
 * @type {number}
 */

var DEFAULT_TILE_SIZE = 256;

/***/ }),

/***/ "./build/wg/tileurlfunction.js":
/*!*************************************!*\
  !*** ./build/wg/tileurlfunction.js ***!
  \*************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFromTemplate": function() { return /* binding */ createFromTemplate; },
/* harmony export */   "createFromTemplates": function() { return /* binding */ createFromTemplates; },
/* harmony export */   "createFromTileUrlFunctions": function() { return /* binding */ createFromTileUrlFunctions; },
/* harmony export */   "nullTileUrlFunction": function() { return /* binding */ nullTileUrlFunction; },
/* harmony export */   "expandUrl": function() { return /* binding */ expandUrl; }
/* harmony export */ });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./build/wg/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./build/wg/math.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tilecoord.js */ "./build/wg/tilecoord.js");
/**
 * @module wg/tileurlfunction
 */



/**
 * @param {string} template Template.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */

function createFromTemplate(template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function () {
          var z = tileCoord[0];
          var range = tileGrid.getFullTileRange(z);
          (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(range, 55); // The {-y} placeholder requires a tile grid with extent

          var y = range.getHeight() - tileCoord[2] - 1;
          return y.toString();
        });
      }
    }
  );
}
/**
 * @param {Array<string>} templates Templates.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */

function createFromTemplates(templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);

  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }

  return createFromTileUrlFunctions(tileUrlFunctions);
}
/**
 * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */

function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }

  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var h = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__.hash)(tileCoord);
        var index = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.modulo)(h, tileUrlFunctions.length);
        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
      }
    }
  );
}
/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {string|undefined} Tile URL.
 */

function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return undefined;
}
/**
 * @param {string} url URL.
 * @return {Array<string>} Array of urls.
 */

function expandUrl(url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);

  if (match) {
    // char range
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode = void 0;

    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }

    return urls;
  }

  match = /\{(\d+)-(\d+)\}/.exec(url);

  if (match) {
    // number range
    var stop_1 = parseInt(match[2], 10);

    for (var i = parseInt(match[1], 10); i <= stop_1; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }

    return urls;
  }

  urls.push(url);
  return urls;
}

/***/ }),

/***/ "./build/wg/transform.js":
/*!*******************************!*\
  !*** ./build/wg/transform.js ***!
  \*******************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": function() { return /* binding */ create; },
/* harmony export */   "reset": function() { return /* binding */ reset; },
/* harmony export */   "multiply": function() { return /* binding */ multiply; },
/* harmony export */   "set": function() { return /* binding */ set; },
/* harmony export */   "setFromArray": function() { return /* binding */ setFromArray; },
/* harmony export */   "apply": function() { return /* binding */ apply; },
/* harmony export */   "rotate": function() { return /* binding */ rotate; },
/* harmony export */   "scale": function() { return /* binding */ scale; },
/* harmony export */   "makeScale": function() { return /* binding */ makeScale; },
/* harmony export */   "translate": function() { return /* binding */ translate; },
/* harmony export */   "compose": function() { return /* binding */ compose; },
/* harmony export */   "composeCssTransform": function() { return /* binding */ composeCssTransform; },
/* harmony export */   "invert": function() { return /* binding */ invert; },
/* harmony export */   "makeInverse": function() { return /* binding */ makeInverse; },
/* harmony export */   "determinant": function() { return /* binding */ determinant; },
/* harmony export */   "toString": function() { return /* binding */ toString; }
/* harmony export */ });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./has.js */ "./build/wg/has.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./build/wg/asserts.js");
/**
 * @module wg/transform
 */


/**
 * An array representing an affine 2d transformation for use with
 * {@link module:wg/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 * @api
 */

/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3×3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */

/**
 * @private
 * @type {Transform}
 */

var tmp_ = new Array(6);
/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */

function create() {
  return [1, 0, 0, 1, 0, 0];
}
/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */

function reset(transform) {
  return set(transform, 1, 0, 0, 1, 0, 0);
}
/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */

function multiply(transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];
  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;
  return transform1;
}
/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */

function set(transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
}
/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */

function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}
/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */

function apply(transform, coordinate) {
  var x = coordinate[0];
  var y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
}
/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */

function rotate(transform, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}
/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */

function scale(transform, x, y) {
  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}
/**
 * Creates a scale transform.
 * @param {!Transform} target Transform to overwrite.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scale transform.
 */

function makeScale(target, x, y) {
  return set(target, x, 0, 0, y, 0, 0);
}
/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */

function translate(transform, dx, dy) {
  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */

function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
}
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative). The resulting transform
 * string can be applied as `transform` property of an HTMLElement's style.
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {string} The composite css transform.
 * @api
 */

function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}
/**
 * Invert the given transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (source) transform.
 */

function invert(source) {
  return makeInverse(source, source);
}
/**
 * Invert the given transform.
 * @param {!Transform} target Transform to be set as the inverse of
 *     the source transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (target) transform.
 */

function makeInverse(target, source) {
  var det = determinant(source);
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(det !== 0, 32); // Transformation matrix cannot be inverted

  var a = source[0];
  var b = source[1];
  var c = source[2];
  var d = source[3];
  var e = source[4];
  var f = source[5];
  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;
  return target;
}
/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */

function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
/**
 * @type {HTMLElement}
 * @private
 */

var transformStringDiv;
/**
 * A rounded string version of the transform.  This can be used
 * for CSS transforms.
 * @param {!Transform} mat Matrix.
 * @return {string} The transform as a string.
 */

function toString(mat) {
  var transformString = 'matrix(' + mat.join(', ') + ')';

  if (_has_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_OFFSCREEN_CANVAS) {
    return transformString;
  }

  var node = transformStringDiv || (transformStringDiv = document.createElement('div'));
  node.style.transform = transformString;
  return node.style.transform;
}

/***/ }),

/***/ "./build/wg/uri.js":
/*!*************************!*\
  !*** ./build/wg/uri.js ***!
  \*************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "appendParams": function() { return /* binding */ appendParams; }
/* harmony export */ });
/**
 * @module wg/uri
 */

/**
 * Appends query parameters to a URI.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {!Object} params An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.
 * @return {string} The new URI.
 */
function appendParams(uri, params) {
  var keyParams = []; // Skip any null or undefined parameter values

  Object.keys(params).forEach(function (k) {
    if (params[k] !== null && params[k] !== undefined) {
      keyParams.push(k + '=' + encodeURIComponent(params[k]));
    }
  });
  var qs = keyParams.join('&'); // remove any trailing ? or &

  uri = uri.replace(/[?&]$/, ''); // append ? or & depending on whether uri has existing parameters

  uri = uri.indexOf('?') === -1 ? uri + '?' : uri + '&';
  return uri + qs;
}

/***/ }),

/***/ "./build/wg/util.js":
/*!**************************!*\
  !*** ./build/wg/util.js ***!
  \**************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "abstract": function() { return /* binding */ abstract; },
/* harmony export */   "getUid": function() { return /* binding */ getUid; },
/* harmony export */   "VERSION": function() { return /* binding */ VERSION; }
/* harmony export */ });
/**
 * @module wg/util
 */

/**
 * @return {?} Any return.
 */
function abstract() {
  return (
    /** @type {?} */
    function () {
      throw new Error('Unimplemented abstract method.');
    }()
  );
}
/**
 * Counter for getUid.
 * @type {number}
 * @private
 */

var uidCounter_ = 0;
/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @api
 */

function getUid(obj) {
  return obj.wg_uid || (obj.wg_uid = String(++uidCounter_));
}
/**
 * OpenLayers version.
 * @type {string}
 */

var VERSION = '6.13.1-dev';

/***/ }),

/***/ "./build/wg/vec/mat4.js":
/*!******************************!*\
  !*** ./build/wg/vec/mat4.js ***!
  \******************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": function() { return /* binding */ create; },
/* harmony export */   "fromTransform": function() { return /* binding */ fromTransform; }
/* harmony export */ });
/**
 * @module wg/vec/mat4
 */

/**
 * @return {Array<number>} "4x4 matrix representing a 3D identity transform."
 */
function create() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
/**
 * @param {Array<number>} mat4 Flattened 4x4 matrix receiving the result.
 * @param {import("../transform.js").Transform} transform Transformation matrix.
 * @return {Array<number>} "2D transformation matrix as flattened 4x4 matrix."
 */

function fromTransform(mat4, transform) {
  mat4[0] = transform[0];
  mat4[1] = transform[1];
  mat4[4] = transform[2];
  mat4[5] = transform[3];
  mat4[12] = transform[4];
  mat4[13] = transform[5];
  return mat4;
}

/***/ }),

/***/ "./build/wg/webgl.js":
/*!***************************!*\
  !*** ./build/wg/webgl.js ***!
  \***************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ARRAY_BUFFER": function() { return /* binding */ ARRAY_BUFFER; },
/* harmony export */   "ELEMENT_ARRAY_BUFFER": function() { return /* binding */ ELEMENT_ARRAY_BUFFER; },
/* harmony export */   "STREAM_DRAW": function() { return /* binding */ STREAM_DRAW; },
/* harmony export */   "STATIC_DRAW": function() { return /* binding */ STATIC_DRAW; },
/* harmony export */   "DYNAMIC_DRAW": function() { return /* binding */ DYNAMIC_DRAW; },
/* harmony export */   "UNSIGNED_BYTE": function() { return /* binding */ UNSIGNED_BYTE; },
/* harmony export */   "UNSIGNED_SHORT": function() { return /* binding */ UNSIGNED_SHORT; },
/* harmony export */   "UNSIGNED_INT": function() { return /* binding */ UNSIGNED_INT; },
/* harmony export */   "FLOAT": function() { return /* binding */ FLOAT; },
/* harmony export */   "getContext": function() { return /* binding */ getContext; },
/* harmony export */   "getSupportedExtensions": function() { return /* binding */ getSupportedExtensions; }
/* harmony export */ });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./obj.js */ "./build/wg/obj.js");
/**
 * @module wg/webgl
 */

/**
 * Constants taken from goog.webgl
 */

/**
 * Used by {@link module:wg/webgl/Helper~WebGLHelper} for buffers containing vertices data, such as
 * position, color, texture coordinate, etc. These vertices are then referenced by an index buffer
 * to be drawn on screen (see {@link module:wg/webgl.ELEMENT_ARRAY_BUFFER}).
 * @const
 * @type {number}
 * @api
 */

var ARRAY_BUFFER = 0x8892;
/**
 * Used by {@link module:wg/webgl/Helper~WebGLHelper} for buffers containing indices data.
 * Index buffers are essentially lists of references to vertices defined in a vertex buffer
 * (see {@link module:wg/webgl.ARRAY_BUFFER}), and define the primitives (triangles) to be drawn.
 * @const
 * @type {number}
 * @api
 */

var ELEMENT_ARRAY_BUFFER = 0x8893;
/**
 * Used by {link module:wg/webgl/Buffer~WebGLArrayBuffer}.
 * @const
 * @type {number}
 * @api
 */

var STREAM_DRAW = 0x88e0;
/**
 * Used by {link module:wg/webgl/Buffer~WebGLArrayBuffer}.
 * @const
 * @type {number}
 * @api
 */

var STATIC_DRAW = 0x88e4;
/**
 * Used by {link module:wg/webgl/Buffer~WebGLArrayBuffer}.
 * @const
 * @type {number}
 * @api
 */

var DYNAMIC_DRAW = 0x88e8;
/**
 * @const
 * @type {number}
 */

var UNSIGNED_BYTE = 0x1401;
/**
 * @const
 * @type {number}
 */

var UNSIGNED_SHORT = 0x1403;
/**
 * @const
 * @type {number}
 */

var UNSIGNED_INT = 0x1405;
/**
 * @const
 * @type {number}
 */

var FLOAT = 0x1406;
/** end of goog.webgl constants
 */

/**
 * @const
 * @type {Array<string>}
 */

var CONTEXT_IDS = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];
/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object} [opt_attributes] Attributes.
 * @return {WebGLRenderingContext} WebGL rendering context.
 */

function getContext(canvas, opt_attributes) {
  var attributes = (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.assign)({
    preserveDrawingBuffer: true
  }, opt_attributes);
  var ii = CONTEXT_IDS.length;

  for (var i = 0; i < ii; ++i) {
    try {
      var context = canvas.getContext(CONTEXT_IDS[i], attributes);

      if (context) {
        return (
          /** @type {!WebGLRenderingContext} */
          context
        );
      }
    } catch (e) {// pass
    }
  }

  return null;
}
/**
 * @type {Array<string>}
 */

var supportedExtensions;
/**
 * @return {Array<string>} List of supported WebGL extensions.
 */

function getSupportedExtensions() {
  if (!supportedExtensions) {
    var canvas = document.createElement('canvas');
    var gl = getContext(canvas);

    if (gl) {
      supportedExtensions = gl.getSupportedExtensions();
    }
  }

  return supportedExtensions;
}

/***/ }),

/***/ "./build/wg/webgl/Buffer.js":
/*!**********************************!*\
  !*** ./build/wg/webgl/Buffer.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BufferUsage": function() { return /* binding */ BufferUsage; },
/* harmony export */   "getArrayClassForType": function() { return /* binding */ getArrayClassForType; }
/* harmony export */ });
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl.js */ "./build/wg/webgl.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./build/wg/asserts.js");
/**
 * @module wg/webgl/Buffer
 */


/**
 * Used to describe the intended usage for the data: `STATIC_DRAW`, `STREAM_DRAW`
 * or `DYNAMIC_DRAW`.
 * @enum {number}
 */

var BufferUsage = {
  STATIC_DRAW: _webgl_js__WEBPACK_IMPORTED_MODULE_0__.STATIC_DRAW,
  STREAM_DRAW: _webgl_js__WEBPACK_IMPORTED_MODULE_0__.STREAM_DRAW,
  DYNAMIC_DRAW: _webgl_js__WEBPACK_IMPORTED_MODULE_0__.DYNAMIC_DRAW
};
/**
 * @classdesc
 * Object used to store an array of data as well as usage information for that data.
 * Stores typed arrays internally, either Float32Array or Uint16/32Array depending on
 * the buffer type (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER) and available extensions.
 *
 * To populate the array, you can either use:
 * * A size using `#ofSize(buffer)`
 * * An `ArrayBuffer` object using `#fromArrayBuffer(buffer)`
 * * A plain array using `#fromArray(array)`
 *
 * Note:
 * See the documentation of [WebGLRenderingContext.bufferData](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)
 * for more info on buffer usage.
 * @api
 */

var WebGLArrayBuffer =
/** @class */
function () {
  /**
   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
   * @param {number} [opt_usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.
   * Default is `DYNAMIC_DRAW`.
   */
  function WebGLArrayBuffer(type, opt_usage) {
    /**
     * @private
     * @type {Float32Array|Uint32Array}
     */
    this.array = null;
    /**
     * @private
     * @type {number}
     */

    this.type = type;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(type === _webgl_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_BUFFER || type === _webgl_js__WEBPACK_IMPORTED_MODULE_0__.ELEMENT_ARRAY_BUFFER, 62);
    /**
     * @private
     * @type {number}
     */

    this.usage = opt_usage !== undefined ? opt_usage : BufferUsage.STATIC_DRAW;
  }
  /**
   * Populates the buffer with an array of the given size (all values will be zeroes).
   * @param {number} size Array size
   */


  WebGLArrayBuffer.prototype.ofSize = function (size) {
    this.array = new (getArrayClassForType(this.type))(size);
  };
  /**
   * Populates the buffer with an array of the given size (all values will be zeroes).
   * @param {Array<number>} array Numerical array
   */


  WebGLArrayBuffer.prototype.fromArray = function (array) {
    var arrayClass = getArrayClassForType(this.type);
    this.array = arrayClass.from ? arrayClass.from(array) : new arrayClass(array);
  };
  /**
   * Populates the buffer with a raw binary array buffer.
   * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been
   * initialized for the same typed array class.
   */


  WebGLArrayBuffer.prototype.fromArrayBuffer = function (buffer) {
    this.array = new (getArrayClassForType(this.type))(buffer);
  };
  /**
   * @return {number} Buffer type.
   */


  WebGLArrayBuffer.prototype.getType = function () {
    return this.type;
  };
  /**
   * Will return null if the buffer was not initialized
   * @return {Float32Array|Uint32Array} Array.
   */


  WebGLArrayBuffer.prototype.getArray = function () {
    return this.array;
  };
  /**
   * @return {number} Usage.
   */


  WebGLArrayBuffer.prototype.getUsage = function () {
    return this.usage;
  };
  /**
   * Will return 0 if the buffer is not initialized
   * @return {number} Array size
   */


  WebGLArrayBuffer.prototype.getSize = function () {
    return this.array ? this.array.length : 0;
  };

  return WebGLArrayBuffer;
}();
/**
 * Returns a typed array constructor based on the given buffer type
 * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
 * @return {Float32ArrayConstructor|Uint32ArrayConstructor} The typed array class to use for this buffer.
 */


function getArrayClassForType(type) {
  switch (type) {
    case _webgl_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_BUFFER:
      return Float32Array;

    case _webgl_js__WEBPACK_IMPORTED_MODULE_0__.ELEMENT_ARRAY_BUFFER:
      return Uint32Array;

    default:
      return Float32Array;
  }
}
/* harmony default export */ __webpack_exports__["default"] = (WebGLArrayBuffer);

/***/ }),

/***/ "./build/wg/webgl/ContextEventType.js":
/*!********************************************!*\
  !*** ./build/wg/webgl/ContextEventType.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/webgl/ContextEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  LOST: 'webglcontextlost',
  RESTORED: 'webglcontextrestored'
});

/***/ }),

/***/ "./build/wg/webgl/Helper.js":
/*!**********************************!*\
  !*** ./build/wg/webgl/Helper.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShaderType": function() { return /* binding */ ShaderType; },
/* harmony export */   "DefaultUniform": function() { return /* binding */ DefaultUniform; },
/* harmony export */   "AttributeType": function() { return /* binding */ AttributeType; },
/* harmony export */   "computeAttributesStride": function() { return /* binding */ computeAttributesStride; }
/* harmony export */ });
/* harmony import */ var _webgl_ContextEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/ContextEventType.js */ "./build/wg/webgl/ContextEventType.js");
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Disposable.js */ "./build/wg/Disposable.js");
/* harmony import */ var _PostProcessingPass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PostProcessingPass.js */ "./build/wg/webgl/PostProcessingPass.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl.js */ "./build/wg/webgl.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transform.js */ "./build/wg/transform.js");
/* harmony import */ var _vec_mat4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../vec/mat4.js */ "./build/wg/vec/mat4.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module wg/webgl/Helper
 */










/**
 * @typedef {Object} BufferCacheEntry
 * @property {import("./Buffer.js").default} buffer Buffer.
 * @property {WebGLBuffer} webGlBuffer WebGlBuffer.
 */

/**
 * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.
 * @enum {number}
 */

var ShaderType = {
  FRAGMENT_SHADER: 0x8b30,
  VERTEX_SHADER: 0x8b31
};
/**
 * Uniform names used in the default shaders: `PROJECTION_MATRIX`, `OFFSET_SCALE_MATRIX`.
 * and `OFFSET_ROTATION_MATRIX`.
 * @enum {string}
 */

var DefaultUniform = {
  PROJECTION_MATRIX: 'u_projectionMatrix',
  OFFSET_SCALE_MATRIX: 'u_offsetScaleMatrix',
  OFFSET_ROTATION_MATRIX: 'u_offsetRotateMatrix',
  TIME: 'u_time',
  ZOOM: 'u_zoom',
  RESOLUTION: 'u_resolution'
};
/**
 * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`
 * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.
 * @enum {number}
 */

var AttributeType = {
  UNSIGNED_BYTE: _webgl_js__WEBPACK_IMPORTED_MODULE_0__.UNSIGNED_BYTE,
  UNSIGNED_SHORT: _webgl_js__WEBPACK_IMPORTED_MODULE_0__.UNSIGNED_SHORT,
  UNSIGNED_INT: _webgl_js__WEBPACK_IMPORTED_MODULE_0__.UNSIGNED_INT,
  FLOAT: _webgl_js__WEBPACK_IMPORTED_MODULE_0__.FLOAT
};
/**
 * Description of an attribute in a buffer
 * @typedef {Object} AttributeDescription
 * @property {string} name Attribute name to use in shaders
 * @property {number} size Number of components per attributes
 * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is
 * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).
 * Default is `FLOAT`.
 */

/**
 * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import("../transform").Transform} UniformLiteralValue
 */

/**
 * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning
 * one of the previous types.
 * @typedef {UniformLiteralValue|function(import("../PluggableMap.js").FrameState):UniformLiteralValue} UniformValue
 */

/**
 * @typedef {Object} PostProcessesOptions
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas which will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step
 */

/**
 * @typedef {Object} Options
 * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform
 * names in the provided or default shaders.
 * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions
 * @property {string} [canvasCacheKey] The cache key for the canvas.
 */

/**
 * @typedef {Object} UniformInternalDescription
 * @property {string} name Name
 * @property {UniformValue} [value] Value
 * @property {WebGLTexture} [texture] Texture
 * @private
 */

/**
 * @typedef {Object} CanvasCacheItem
 * @property {HTMLCanvasElement} canvas Canvas element.
 * @property {number} users The count of users of this canvas.
 */

/**
 * @type {Object<string,CanvasCacheItem>}
 */

var canvasCache = {};
/**
 * @param {string} key The cache key for the canvas.
 * @return {string} The shared cache key.
 */

function getSharedCanvasCacheKey(key) {
  return 'shared/' + key;
}

var uniqueCanvasCacheKeyCount = 0;
/**
 * @return {string} The unique cache key.
 */

function getUniqueCanvasCacheKey() {
  var key = 'unique/' + uniqueCanvasCacheKeyCount;
  uniqueCanvasCacheKeyCount += 1;
  return key;
}
/**
 * @param {string} key The cache key for the canvas.
 * @return {HTMLCanvasElement} The canvas.
 */


function getCanvas(key) {
  var cacheItem = canvasCache[key];

  if (!cacheItem) {
    var canvas = document.createElement('canvas');
    canvas.style.position = 'absolute';
    canvas.style.left = '0';
    cacheItem = {
      users: 0,
      canvas: canvas
    };
    canvasCache[key] = cacheItem;
  }

  cacheItem.users += 1;
  return cacheItem.canvas;
}
/**
 * @param {string} key The cache key for the canvas.
 */


function releaseCanvas(key) {
  var cacheItem = canvasCache[key];

  if (!cacheItem) {
    return;
  }

  cacheItem.users -= 1;

  if (cacheItem.users > 0) {
    return;
  }

  var canvas = cacheItem.canvas;
  var gl = (0,_webgl_js__WEBPACK_IMPORTED_MODULE_0__.getContext)(canvas);
  var extension = gl.getExtension('WEBGL_lose_context');

  if (extension) {
    extension.loseContext();
  }

  delete canvasCache[key];
}
/**
 * @classdesc
 * This class is intended to provide low-level functions related to WebGL rendering, so that accessing
 * directly the WebGL API should not be required anymore.
 *
 * Several operations are handled by the `WebGLHelper` class:
 *
 * ### Define custom shaders and uniforms
 *
 *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:
 *
 *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).
 *   Outputs are:
 *
 *   * `gl_Position`: position of the vertex in screen space
 *
 *   * Varyings usually prefixed with `v_` are passed on to the fragment shader
 *
 *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.
 *
 *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that
 *   can be changed at every frame and can be of type float, arrays of float or images.
 *
 *   Shaders must be compiled and assembled into a program like so:
 *   ```js
 *   // here we simply create two shaders and assemble them in a program which is then used
 *   // for subsequent rendering calls
 *   const vertexShader = new WebGLVertex(VERTEX_SHADER);
 *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);
 *   const program = this.context.getProgram(fragmentShader, vertexShader);
 *   helper.useProgram(this.program);
 *   ```
 *
 *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.
 *   You can also change their value along the way like so:
 *   ```js
 *   helper.setUniformFloatValue('u_value', valueAsNumber);
 *   ```
 *
 * ### Defining post processing passes
 *
 *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas
 *   while applying special effects in screen space.
 *   Typical uses are: blurring, color manipulation, depth of field, filtering...
 *
 *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.
 *   A post process step accepts the following options:
 *
 *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.
 *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.
 *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.
 *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.
 *
 *   The {@link module:wg/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.
 *
 * ### Binding WebGL buffers and flushing data into them
 *
 *   Data that must be passed to the GPU has to be transferred using {@link module:wg/webgl/Buffer~WebGLArrayBuffer} objects.
 *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.
 *   This is done using {@link bindBuffer}.
 *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using
 *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.
 *
 *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:wg/webgl.ARRAY_BUFFER}
 *   (if the buffer contains vertices data) or {@link module:wg/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).
 *
 *   Examples below:
 *   ```js
 *   // at initialization phase
 *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
 *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
 *
 *   // when array values have changed
 *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);
 *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
 *
 *   // at rendering phase
 *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);
 *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
 *   ```
 *
 * ### Specifying attributes
 *
 *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).
 *   Attributes are used to specify these uses. Specify the attribute names with
 *   {@link module:wg/webgl/Helper~WebGLHelper#enableAttributes enableAttributes()} (see code snippet below).
 *
 *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.
 *   ```js
 *   // here we indicate that the data array has the following structure:
 *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]
 *   helper.enableAttributes([
 *     {
 *        name: 'a_position',
 *        size: 2
 *     },
 *     {
 *       name: 'a_offset',
 *       size: 2
 *     },
 *     {
 *       name: 'a_texCoord',
 *       size: 2
 *     }
 *   ])
 *   ```
 *
 * ### Rendering primitives
 *
 *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.
 *   ```js
 *   // frame preparation step
 *   helper.prepareDraw(frameState);
 *
 *   // call this for every data array that has to be rendered on screen
 *   helper.drawElements(0, this.indicesBuffer.getArray().length);
 *
 *   // finalize the rendering by applying post processes
 *   helper.finalizeDraw(frameState);
 *   ```
 *
 * For an example usage of this class, refer to {@link module:wg/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.
 *
 * @api
 */


var WebGLHelper =
/** @class */
function (_super) {
  __extends(WebGLHelper, _super);
  /**
   * @param {Options} [opt_options] Options.
   */


  function WebGLHelper(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options || {};
    /** @private */

    _this.boundHandleWebGLContextLost_ = _this.handleWebGLContextLost.bind(_this);
    /** @private */

    _this.boundHandleWebGLContextRestored_ = _this.handleWebGLContextRestored.bind(_this);
    /**
     * @private
     * @type {string}
     */

    _this.canvasCacheKey_ = options.canvasCacheKey ? getSharedCanvasCacheKey(options.canvasCacheKey) : getUniqueCanvasCacheKey();
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.canvas_ = getCanvas(_this.canvasCacheKey_);
    /**
     * @private
     * @type {WebGLRenderingContext}
     */

    _this.gl_ = (0,_webgl_js__WEBPACK_IMPORTED_MODULE_0__.getContext)(_this.canvas_);
    /**
     * @private
     * @type {!Object<string, BufferCacheEntry>}
     */

    _this.bufferCache_ = {};
    /**
     * @private
     * @type {Object<string, Object>}
     */

    _this.extensionCache_ = {};
    /**
     * @private
     * @type {WebGLProgram}
     */

    _this.currentProgram_ = null;

    _this.canvas_.addEventListener(_webgl_ContextEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOST, _this.boundHandleWebGLContextLost_);

    _this.canvas_.addEventListener(_webgl_ContextEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].RESTORED, _this.boundHandleWebGLContextRestored_);
    /**
     * @private
     * @type {import("../transform.js").Transform}
     */


    _this.offsetRotateMatrix_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();
    /**
     * @private
     * @type {import("../transform.js").Transform}
     */

    _this.offsetScaleMatrix_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();
    /**
     * @private
     * @type {Array<number>}
     */

    _this.tmpMat4_ = (0,_vec_mat4_js__WEBPACK_IMPORTED_MODULE_3__.create)();
    /**
     * @private
     * @type {Object<string, WebGLUniformLocation>}
     */

    _this.uniformLocations_ = {};
    /**
     * @private
     * @type {Object<string, number>}
     */

    _this.attribLocations_ = {};
    /**
     * Holds info about custom uniforms used in the post processing pass.
     * If the uniform is a texture, the WebGL Texture object will be stored here.
     * @type {Array<UniformInternalDescription>}
     * @private
     */

    _this.uniforms_ = [];

    if (options.uniforms) {
      _this.setUniforms(options.uniforms);
    }

    var gl = _this.getGL();
    /**
     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the
     * options. If no post process was given, a default one is used (so as not to have to make an exception to
     * the frame buffer logic).
     * @type {Array<WebGLPostProcessingPass>}
     * @private
     */


    _this.postProcessPasses_ = options.postProcesses ? options.postProcesses.map(function (options) {
      return new _PostProcessingPass_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        webGlContext: gl,
        scaleRatio: options.scaleRatio,
        vertexShader: options.vertexShader,
        fragmentShader: options.fragmentShader,
        uniforms: options.uniforms
      });
    }) : [new _PostProcessingPass_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
      webGlContext: gl
    })];
    /**
     * @type {string|null}
     * @private
     */

    _this.shaderCompileErrors_ = null;
    /**
     * @type {number}
     * @private
     */

    _this.startTime_ = Date.now();
    return _this;
  }
  /**
   * @param {Object<string, UniformValue>} uniforms Uniform definitions.
   */


  WebGLHelper.prototype.setUniforms = function (uniforms) {
    this.uniforms_ = [];

    for (var name_1 in uniforms) {
      this.uniforms_.push({
        name: name_1,
        value: uniforms[name_1]
      });
    }

    this.uniformLocations_ = {};
  };
  /**
   * @param {string} canvasCacheKey The canvas cache key.
   * @return {boolean} The provided key matches the one this helper was constructed with.
   */


  WebGLHelper.prototype.canvasCacheKeyMatches = function (canvasCacheKey) {
    return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);
  };
  /**
   * Get a WebGL extension.  If the extension is not supported, null is returned.
   * Extensions are cached after they are enabled for the first time.
   * @param {string} name The extension name.
   * @return {Object|null} The extension or null if not supported.
   */


  WebGLHelper.prototype.getExtension = function (name) {
    if (name in this.extensionCache_) {
      return this.extensionCache_[name];
    }

    var extension = this.gl_.getExtension(name);
    this.extensionCache_[name] = extension;
    return extension;
  };
  /**
   * Just bind the buffer if it's in the cache. Otherwise create
   * the WebGL buffer, bind it, populate it, and add an entry to
   * the cache.
   * @param {import("./Buffer").default} buffer Buffer.
   * @api
   */


  WebGLHelper.prototype.bindBuffer = function (buffer) {
    var gl = this.getGL();
    var bufferKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(buffer);
    var bufferCache = this.bufferCache_[bufferKey];

    if (!bufferCache) {
      var webGlBuffer = gl.createBuffer();
      bufferCache = {
        buffer: buffer,
        webGlBuffer: webGlBuffer
      };
      this.bufferCache_[bufferKey] = bufferCache;
    }

    gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);
  };
  /**
   * Update the data contained in the buffer array; this is required for the
   * new data to be rendered
   * @param {import("./Buffer").default} buffer Buffer.
   * @api
   */


  WebGLHelper.prototype.flushBufferData = function (buffer) {
    var gl = this.getGL();
    this.bindBuffer(buffer);
    gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());
  };
  /**
   * @param {import("./Buffer.js").default} buf Buffer.
   */


  WebGLHelper.prototype.deleteBuffer = function (buf) {
    var gl = this.getGL();
    var bufferKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.getUid)(buf);
    var bufferCacheEntry = this.bufferCache_[bufferKey];

    if (bufferCacheEntry && !gl.isContextLost()) {
      gl.deleteBuffer(bufferCacheEntry.webGlBuffer);
    }

    delete this.bufferCache_[bufferKey];
  };
  /**
   * Clean up.
   */


  WebGLHelper.prototype.disposeInternal = function () {
    this.canvas_.removeEventListener(_webgl_ContextEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOST, this.boundHandleWebGLContextLost_);
    this.canvas_.removeEventListener(_webgl_ContextEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].RESTORED, this.boundHandleWebGLContextRestored_);
    releaseCanvas(this.canvasCacheKey_);
    delete this.gl_;
    delete this.canvas_;
  };
  /**
   * Clear the buffer & set the viewport to draw.
   * Post process passes will be initialized here, the first one being bound as a render target for
   * subsequent draw calls.
   * @param {import("../PluggableMap.js").FrameState} frameState current frame state
   * @param {boolean} [opt_disableAlphaBlend] If true, no alpha blending will happen.
   * @api
   */


  WebGLHelper.prototype.prepareDraw = function (frameState, opt_disableAlphaBlend) {
    var gl = this.getGL();
    var canvas = this.getCanvas();
    var size = frameState.size;
    var pixelRatio = frameState.pixelRatio;
    canvas.width = size[0] * pixelRatio;
    canvas.height = size[1] * pixelRatio;
    canvas.style.width = size[0] + 'px';
    canvas.style.height = size[1] + 'px';
    gl.useProgram(this.currentProgram_); // loop backwards in post processes list

    for (var i = this.postProcessPasses_.length - 1; i >= 0; i--) {
      this.postProcessPasses_[i].init(frameState);
    }

    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
    gl.useProgram(this.currentProgram_);
    this.applyFrameState(frameState);
    this.applyUniforms(frameState);
  };
  /**
   * Clear the render target & bind it for future draw operations.
   * This is similar to `prepareDraw`, only post processes will not be applied.
   * Note: the whole viewport will be drawn to the render target, regardless of its size.
   * @param {import("../PluggableMap.js").FrameState} frameState current frame state
   * @param {import("./RenderTarget.js").default} renderTarget Render target to draw to
   * @param {boolean} [opt_disableAlphaBlend] If true, no alpha blending will happen.
   */


  WebGLHelper.prototype.prepareDrawToRenderTarget = function (frameState, renderTarget, opt_disableAlphaBlend) {
    var gl = this.getGL();
    var size = renderTarget.getSize();
    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());
    gl.viewport(0, 0, size[0], size[1]);
    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());
    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
    gl.useProgram(this.currentProgram_);
    this.applyFrameState(frameState);
    this.applyUniforms(frameState);
  };
  /**
   * Execute a draw call based on the currently bound program, texture, buffers, attributes.
   * @param {number} start Start index.
   * @param {number} end End index.
   * @api
   */


  WebGLHelper.prototype.drawElements = function (start, end) {
    var gl = this.getGL();
    this.getExtension('OES_element_index_uint');
    var elementType = gl.UNSIGNED_INT;
    var elementSize = 4;
    var numItems = end - start;
    var offsetInBytes = start * elementSize;
    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);
  };
  /**
   * Apply the successive post process passes which will eventually render to the actual canvas.
   * @param {import("../PluggableMap.js").FrameState} frameState current frame state
   * @param {function(WebGLRenderingContext, import("../PluggableMap.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../PluggableMap.js").FrameState):void} [postCompose] Called before composing.
   */


  WebGLHelper.prototype.finalizeDraw = function (frameState, preCompose, postCompose) {
    // apply post processes using the next one as target
    for (var i = 0, ii = this.postProcessPasses_.length; i < ii; i++) {
      if (i === ii - 1) {
        this.postProcessPasses_[i].apply(frameState, null, preCompose, postCompose);
      } else {
        this.postProcessPasses_[i].apply(frameState, this.postProcessPasses_[i + 1]);
      }
    }
  };
  /**
   * @return {HTMLCanvasElement} Canvas.
   * @api
   */


  WebGLHelper.prototype.getCanvas = function () {
    return this.canvas_;
  };
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   * @api
   */


  WebGLHelper.prototype.getGL = function () {
    return this.gl_;
  };
  /**
   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @private
   */


  WebGLHelper.prototype.applyFrameState = function (frameState) {
    var size = frameState.size;
    var rotation = frameState.viewState.rotation;
    var offsetScaleMatrix = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.reset)(this.offsetScaleMatrix_);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.scale)(offsetScaleMatrix, 2 / size[0], 2 / size[1]);
    var offsetRotateMatrix = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.reset)(this.offsetRotateMatrix_);

    if (rotation !== 0) {
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.rotate)(offsetRotateMatrix, -rotation);
    }

    this.setUniformMatrixValue(DefaultUniform.OFFSET_SCALE_MATRIX, (0,_vec_mat4_js__WEBPACK_IMPORTED_MODULE_3__.fromTransform)(this.tmpMat4_, offsetScaleMatrix));
    this.setUniformMatrixValue(DefaultUniform.OFFSET_ROTATION_MATRIX, (0,_vec_mat4_js__WEBPACK_IMPORTED_MODULE_3__.fromTransform)(this.tmpMat4_, offsetRotateMatrix));
    this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 0.001);
    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);
    this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);
  };
  /**
   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @private
   */


  WebGLHelper.prototype.applyUniforms = function (frameState) {
    var gl = this.getGL();
    var value;
    var textureSlot = 0;
    this.uniforms_.forEach(function (uniform) {
      value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value; // apply value based on type

      if (value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof ImageData) {
        // create a texture & put data
        if (!uniform.texture) {
          uniform.prevValue = undefined;
          uniform.texture = gl.createTexture();
        }

        gl.activeTexture(gl["TEXTURE".concat(textureSlot)]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        var imageReady = !(value instanceof HTMLImageElement) ||
        /** @type {HTMLImageElement} */
        value.complete;

        if (imageReady && uniform.prevValue !== value) {
          uniform.prevValue = value;
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
        } // fill texture slots by increasing index


        gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);
      } else if (Array.isArray(value) && value.length === 6) {
        this.setUniformMatrixValue(uniform.name, (0,_vec_mat4_js__WEBPACK_IMPORTED_MODULE_3__.fromTransform)(this.tmpMat4_, value));
      } else if (Array.isArray(value) && value.length <= 4) {
        switch (value.length) {
          case 2:
            gl.uniform2f(this.getUniformLocation(uniform.name), value[0], value[1]);
            return;

          case 3:
            gl.uniform3f(this.getUniformLocation(uniform.name), value[0], value[1], value[2]);
            return;

          case 4:
            gl.uniform4f(this.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);
            return;

          default:
            return;
        }
      } else if (typeof value === 'number') {
        gl.uniform1f(this.getUniformLocation(uniform.name), value);
      }
    }.bind(this));
  };
  /**
   * Use a program.  If the program is already in use, this will return `false`.
   * @param {WebGLProgram} program Program.
   * @return {boolean} Changed.
   * @api
   */


  WebGLHelper.prototype.useProgram = function (program) {
    if (program == this.currentProgram_) {
      return false;
    } else {
      var gl = this.getGL();
      gl.useProgram(program);
      this.currentProgram_ = program;
      this.uniformLocations_ = {};
      this.attribLocations_ = {};
      return true;
    }
  };
  /**
   * Will attempt to compile a vertex or fragment shader based on source
   * On error, the shader will be returned but
   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`
   * Use `gl.getShaderInfoLog(shader)` to have details
   * @param {string} source Shader source
   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER
   * @return {WebGLShader} Shader object
   */


  WebGLHelper.prototype.compileShader = function (source, type) {
    var gl = this.getGL();
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
  };
  /**
   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.
   * @param {string} fragmentShaderSource Fragment shader source.
   * @param {string} vertexShaderSource Vertex shader source.
   * @return {WebGLProgram} Program
   * @api
   */


  WebGLHelper.prototype.getProgram = function (fragmentShaderSource, vertexShaderSource) {
    var gl = this.getGL();
    var fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
    var vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
    var program = gl.createProgram();
    gl.attachShader(program, fragmentShader);
    gl.attachShader(program, vertexShader);
    gl.linkProgram(program);

    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      var message = "Fragment shader compliation failed: ".concat(gl.getShaderInfoLog(fragmentShader));
      throw new Error(message);
    }

    gl.deleteShader(fragmentShader);

    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      var message = "Vertex shader compilation failed: ".concat(gl.getShaderInfoLog(vertexShader));
      throw new Error(message);
    }

    gl.deleteShader(vertexShader);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      var message = "GL program linking failed: ".concat(gl.getShaderInfoLog(vertexShader));
      throw new Error(message);
    }

    return program;
  };
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Uniform name
   * @return {WebGLUniformLocation} uniformLocation
   * @api
   */


  WebGLHelper.prototype.getUniformLocation = function (name) {
    if (this.uniformLocations_[name] === undefined) {
      this.uniformLocations_[name] = this.getGL().getUniformLocation(this.currentProgram_, name);
    }

    return this.uniformLocations_[name];
  };
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Attribute name
   * @return {number} attribLocation
   * @api
   */


  WebGLHelper.prototype.getAttributeLocation = function (name) {
    if (this.attribLocations_[name] === undefined) {
      this.attribLocations_[name] = this.getGL().getAttribLocation(this.currentProgram_, name);
    }

    return this.attribLocations_[name];
  };
  /**
   * Modifies the given transform to apply the rotation/translation/scaling of the given frame state.
   * The resulting transform can be used to convert world space coordinates to view coordinates.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../transform").Transform} transform Transform to update.
   * @return {import("../transform").Transform} The updated transform object.
   * @api
   */


  WebGLHelper.prototype.makeProjectionTransform = function (frameState, transform) {
    var size = frameState.size;
    var rotation = frameState.viewState.rotation;
    var resolution = frameState.viewState.resolution;
    var center = frameState.viewState.center;
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.reset)(transform);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.compose)(transform, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);
    return transform;
  };
  /**
   * Give a value for a standard float uniform
   * @param {string} uniform Uniform name
   * @param {number} value Value
   * @api
   */


  WebGLHelper.prototype.setUniformFloatValue = function (uniform, value) {
    this.getGL().uniform1f(this.getUniformLocation(uniform), value);
  };
  /**
   * Give a value for a vec4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */


  WebGLHelper.prototype.setUniformFloatVec4 = function (uniform, value) {
    this.getGL().uniform4fv(this.getUniformLocation(uniform), value);
  };
  /**
   * Give a value for a standard matrix4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Matrix value
   * @api
   */


  WebGLHelper.prototype.setUniformMatrixValue = function (uniform, value) {
    this.getGL().uniformMatrix4fv(this.getUniformLocation(uniform), false, value);
  };
  /**
   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`
   * internally.
   * @param {string} attribName Attribute name
   * @param {number} size Number of components per attributes
   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT
   * @param {number} stride Stride in bytes (0 means attribs are packed)
   * @param {number} offset Offset in bytes
   * @private
   */


  WebGLHelper.prototype.enableAttributeArray_ = function (attribName, size, type, stride, offset) {
    var location = this.getAttributeLocation(attribName); // the attribute has not been found in the shaders; do not enable it

    if (location < 0) {
      return;
    }

    this.getGL().enableVertexAttribArray(location);
    this.getGL().vertexAttribPointer(location, size, type, false, stride, offset);
  };
  /**
   * Will enable the following attributes to be read from the currently bound buffer,
   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the
   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.
   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
   * @api
   */


  WebGLHelper.prototype.enableAttributes = function (attributes) {
    var stride = computeAttributesStride(attributes);
    var offset = 0;

    for (var i = 0; i < attributes.length; i++) {
      var attr = attributes[i];
      this.enableAttributeArray_(attr.name, attr.size, attr.type || _webgl_js__WEBPACK_IMPORTED_MODULE_0__.FLOAT, stride, offset);
      offset += attr.size * getByteSizeFromType(attr.type);
    }
  };
  /**
   * WebGL context was lost
   * @private
   */


  WebGLHelper.prototype.handleWebGLContextLost = function () {
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_6__.clear)(this.bufferCache_);
    this.currentProgram_ = null;
  };
  /**
   * WebGL context was restored
   * @private
   */


  WebGLHelper.prototype.handleWebGLContextRestored = function () {};
  /**
   * Will create or reuse a given webgl texture and apply the given size. If no image data
   * specified, the texture will be empty, otherwise image data will be used and the `size`
   * parameter will be ignored.
   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.
   * @param {Array<number>} size Expected size of the texture
   * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [opt_data] Image data/object to bind to the texture
   * @param {WebGLTexture} [opt_texture] Existing texture to reuse
   * @return {WebGLTexture} The generated texture
   * @api
   */


  WebGLHelper.prototype.createTexture = function (size, opt_data, opt_texture) {
    var gl = this.getGL();
    var texture = opt_texture || gl.createTexture(); // set params & size

    var level = 0;
    var internalFormat = gl.RGBA;
    var border = 0;
    var format = gl.RGBA;
    var type = gl.UNSIGNED_BYTE;
    gl.bindTexture(gl.TEXTURE_2D, texture);

    if (opt_data) {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, opt_data);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format, type, null);
    }

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    return texture;
  };

  return WebGLHelper;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
/**
 * Compute a stride in bytes based on a list of attributes
 * @param {Array<AttributeDescription>} attributes Ordered list of attributes
 * @return {number} Stride, ie amount of values for each vertex in the vertex buffer
 * @api
 */


function computeAttributesStride(attributes) {
  var stride = 0;

  for (var i = 0; i < attributes.length; i++) {
    var attr = attributes[i];
    stride += attr.size * getByteSizeFromType(attr.type);
  }

  return stride;
}
/**
 * Computes the size in byte of an attribute type.
 * @param {AttributeType} type Attribute type
 * @return {number} The size in bytes
 */

function getByteSizeFromType(type) {
  switch (type) {
    case AttributeType.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;

    case AttributeType.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;

    case AttributeType.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;

    case AttributeType.FLOAT:
    default:
      return Float32Array.BYTES_PER_ELEMENT;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (WebGLHelper);

/***/ }),

/***/ "./build/wg/webgl/PaletteTexture.js":
/*!******************************************!*\
  !*** ./build/wg/webgl/PaletteTexture.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module wg/webgl/PaletteTexture
 */
var PaletteTexture =
/** @class */
function () {
  /**
   * @param {string} name The name of the texture.
   * @param {Uint8Array} data The texture data.
   */
  function PaletteTexture(name, data) {
    this.name = name;
    this.data = data;
    /**
     * @type {WebGLTexture}
     * @private
     */

    this.texture_ = null;
  }
  /**
   * @param {WebGLRenderingContext} gl Rendering context.
   * @return {WebGLTexture} The texture.
   */


  PaletteTexture.prototype.getTexture = function (gl) {
    if (!this.texture_) {
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.data.length / 4, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
      this.texture_ = texture;
    }

    return this.texture_;
  };

  return PaletteTexture;
}();

/* harmony default export */ __webpack_exports__["default"] = (PaletteTexture);

/***/ }),

/***/ "./build/wg/webgl/PostProcessingPass.js":
/*!**********************************************!*\
  !*** ./build/wg/webgl/PostProcessingPass.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./build/wg/util.js");
/**
 * @module wg/webgl/PostProcessingPass
 */

var DEFAULT_VERTEX_SHADER = "\n  precision mediump float;\n  \n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n  \n  uniform vec2 u_screenSize;\n   \n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n";
var DEFAULT_FRAGMENT_SHADER = "\n  precision mediump float;\n   \n  uniform sampler2D u_image;\n  uniform float u_opacity;\n   \n  varying vec2 v_texCoord;\n   \n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n  }\n";
/**
 * @typedef {Object} Options
 * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas that will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,import("./Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
 */

/**
 * @typedef {Object} UniformInternalDescription
 * @property {import("./Helper").UniformValue} value Value
 * @property {number} location Location
 * @property {WebGLTexture} [texture] Texture
 * @private
 */

/**
 * @classdesc
 * This class is used to define Post Processing passes with custom shaders and uniforms.
 * This is used internally by {@link module:wg/webgl/Helper~WebGLHelper}.
 *
 * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that
 * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).
 * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.
 *
 * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be
 * premultiplied.
 *
 * Default shaders are shown hereafter:
 *
 * * Vertex shader:
 *
 *   ```
 *   precision mediump float;
 *
 *   attribute vec2 a_position;
 *   varying vec2 v_texCoord;
 *   varying vec2 v_screenCoord;
 *
 *   uniform vec2 u_screenSize;
 *
 *   void main() {
 *     v_texCoord = a_position * 0.5 + 0.5;
 *     v_screenCoord = v_texCoord * u_screenSize;
 *     gl_Position = vec4(a_position, 0.0, 1.0);
 *   }
 *   ```
 *
 * * Fragment shader:
 *
 *   ```
 *   precision mediump float;
 *
 *   uniform sampler2D u_image;
 *   uniform float u_opacity;
 *
 *   varying vec2 v_texCoord;
 *
 *   void main() {
 *     gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
 *   }
 *   ```
 *
 * @api
 */

var WebGLPostProcessingPass =
/** @class */
function () {
  /**
   * @param {Options} options Options.
   */
  function WebGLPostProcessingPass(options) {
    this.gl_ = options.webGlContext;
    var gl = this.gl_;
    this.scaleRatio_ = options.scaleRatio || 1;
    this.renderTargetTexture_ = gl.createTexture();
    this.renderTargetTextureSize_ = null;
    this.frameBuffer_ = gl.createFramebuffer(); // compile the program for the frame buffer
    // TODO: make compilation errors show up

    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);
    gl.compileShader(vertexShader);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);
    gl.compileShader(fragmentShader);
    this.renderTargetProgram_ = gl.createProgram();
    gl.attachShader(this.renderTargetProgram_, vertexShader);
    gl.attachShader(this.renderTargetProgram_, fragmentShader);
    gl.linkProgram(this.renderTargetProgram_); // bind the vertices buffer for the frame buffer

    this.renderTargetVerticesBuffer_ = gl.createBuffer();
    var verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);
    this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, 'a_position');
    this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_screenSize');
    this.renderTargetOpacityLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_opacity');
    this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_image');
    /**
     * Holds info about custom uniforms used in the post processing pass
     * @type {Array<UniformInternalDescription>}
     * @private
     */

    this.uniforms_ = [];
    options.uniforms && Object.keys(options.uniforms).forEach(function (name) {
      this.uniforms_.push({
        value: options.uniforms[name],
        location: gl.getUniformLocation(this.renderTargetProgram_, name)
      });
    }.bind(this));
  }
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   * @api
   */


  WebGLPostProcessingPass.prototype.getGL = function () {
    return this.gl_;
  };
  /**
   * Initialize the render target texture of the post process, make sure it is at the
   * right size and bind it as a render target for the next draw calls.
   * The last step to be initialized will be the one where the primitives are rendered.
   * @param {import("../PluggableMap.js").FrameState} frameState current frame state
   * @api
   */


  WebGLPostProcessingPass.prototype.init = function (frameState) {
    var gl = this.getGL();
    var textureSize = [gl.drawingBufferWidth * this.scaleRatio_, gl.drawingBufferHeight * this.scaleRatio_]; // rendering goes to my buffer

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());
    gl.viewport(0, 0, textureSize[0], textureSize[1]); // if size has changed: adjust canvas & render target texture

    if (!this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {
      this.renderTargetTextureSize_ = textureSize; // create a new texture

      var level = 0;
      var internalFormat = gl.RGBA;
      var border = 0;
      var format = gl.RGBA;
      var type = gl.UNSIGNED_BYTE;
      var data = null;
      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); // bind the texture to the framebuffer

      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);
    }
  };
  /**
   * Render to the next postprocessing pass (or to the canvas if final pass).
   * @param {import("../PluggableMap.js").FrameState} frameState current frame state
   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional
   * @param {function(WebGLRenderingContext, import("../PluggableMap.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../PluggableMap.js").FrameState):void} [postCompose] Called before composing.
   * @api
   */


  WebGLPostProcessingPass.prototype.apply = function (frameState, nextPass, preCompose, postCompose) {
    var gl = this.getGL();
    var size = frameState.size;
    gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);

    if (!nextPass) {
      // clear the canvas if we are the first to render to it
      // and preserveDrawingBuffer is true
      var canvasId = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getUid)(gl.canvas);

      if (!frameState.renderTargets[canvasId]) {
        var attributes = gl.getContextAttributes();

        if (attributes && attributes.preserveDrawingBuffer) {
          gl.clearColor(0.0, 0.0, 0.0, 0.0);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }

        frameState.renderTargets[canvasId] = true;
      }
    }

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
    gl.useProgram(this.renderTargetProgram_);
    gl.enableVertexAttribArray(this.renderTargetAttribLocation_);
    gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);
    gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);
    gl.uniform1i(this.renderTargetTextureLocation_, 0);
    var opacity = frameState.layerStatesArray[frameState.layerIndex].opacity;
    gl.uniform1f(this.renderTargetOpacityLocation_, opacity);
    this.applyUniforms(frameState);

    if (preCompose) {
      preCompose(gl, frameState);
    }

    gl.drawArrays(gl.TRIANGLES, 0, 6);

    if (postCompose) {
      postCompose(gl, frameState);
    }
  };
  /**
   * @return {WebGLFramebuffer} Frame buffer
   * @api
   */


  WebGLPostProcessingPass.prototype.getFrameBuffer = function () {
    return this.frameBuffer_;
  };
  /**
   * Sets the custom uniforms based on what was given in the constructor.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @private
   */


  WebGLPostProcessingPass.prototype.applyUniforms = function (frameState) {
    var gl = this.getGL();
    var value;
    var textureSlot = 1;
    this.uniforms_.forEach(function (uniform) {
      value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value; // apply value based on type

      if (value instanceof HTMLCanvasElement || value instanceof ImageData) {
        // create a texture & put data
        if (!uniform.texture) {
          uniform.texture = gl.createTexture();
        }

        gl.activeTexture(gl["TEXTURE".concat(textureSlot)]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        if (value instanceof ImageData) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
        } // fill texture slots


        gl.uniform1i(uniform.location, textureSlot++);
      } else if (Array.isArray(value)) {
        switch (value.length) {
          case 2:
            gl.uniform2f(uniform.location, value[0], value[1]);
            return;

          case 3:
            gl.uniform3f(uniform.location, value[0], value[1], value[2]);
            return;

          case 4:
            gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);
            return;

          default:
            return;
        }
      } else if (typeof value === 'number') {
        gl.uniform1f(uniform.location, value);
      }
    });
  };

  return WebGLPostProcessingPass;
}();

/* harmony default export */ __webpack_exports__["default"] = (WebGLPostProcessingPass);

/***/ }),

/***/ "./build/wg/webgl/RenderTarget.js":
/*!****************************************!*\
  !*** ./build/wg/webgl/RenderTarget.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./build/wg/array.js");
/**
 * A wrapper class to simplify rendering to a texture instead of the final canvas
 * @module wg/webgl/RenderTarget
 */
 // for pixel color reading

var tmpArray4 = new Uint8Array(4);
/**
 * @classdesc
 * This class is a wrapper around the association of both a `WebGLTexture` and a `WebGLFramebuffer` instances,
 * simplifying initialization and binding for rendering.
 * @api
 */

var WebGLRenderTarget =
/** @class */
function () {
  /**
   * @param {import("./Helper.js").default} helper WebGL helper; mandatory.
   * @param {Array<number>} [opt_size] Expected size of the render target texture; note: this can be changed later on.
   */
  function WebGLRenderTarget(helper, opt_size) {
    /**
     * @private
     * @type {import("./Helper.js").default}
     */
    this.helper_ = helper;
    var gl = helper.getGL();
    /**
     * @private
     * @type {WebGLTexture}
     */

    this.texture_ = gl.createTexture();
    /**
     * @private
     * @type {WebGLFramebuffer}
     */

    this.framebuffer_ = gl.createFramebuffer();
    /**
     * @type {Array<number>}
     * @private
     */

    this.size_ = opt_size || [1, 1];
    /**
     * @type {Uint8Array}
     * @private
     */

    this.data_ = new Uint8Array(0);
    /**
     * @type {boolean}
     * @private
     */

    this.dataCacheDirty_ = true;
    this.updateSize_();
  }
  /**
   * Changes the size of the render target texture. Note: will do nothing if the size
   * is already the same.
   * @param {Array<number>} size Expected size of the render target texture
   * @api
   */


  WebGLRenderTarget.prototype.setSize = function (size) {
    if ((0,_array_js__WEBPACK_IMPORTED_MODULE_0__.equals)(size, this.size_)) {
      return;
    }

    this.size_[0] = size[0];
    this.size_[1] = size[1];
    this.updateSize_();
  };
  /**
   * Returns the size of the render target texture
   * @return {Array<number>} Size of the render target texture
   * @api
   */


  WebGLRenderTarget.prototype.getSize = function () {
    return this.size_;
  };
  /**
   * This will cause following calls to `#readAll` or `#readPixel` to download the content of the
   * render target into memory, which is an expensive operation.
   * This content will be kept in cache but should be cleared after each new render.
   * @api
   */


  WebGLRenderTarget.prototype.clearCachedData = function () {
    this.dataCacheDirty_ = true;
  };
  /**
   * Returns the full content of the frame buffer as a series of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * @return {Uint8Array} Integer array of color values
   * @api
   */


  WebGLRenderTarget.prototype.readAll = function () {
    if (this.dataCacheDirty_) {
      var size = this.size_;
      var gl = this.helper_.getGL();
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
      gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.UNSIGNED_BYTE, this.data_);
      this.dataCacheDirty_ = false;
    }

    return this.data_;
  };
  /**
   * Reads one pixel of the frame buffer as an array of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * If x and/or y are outside of existing data, an array filled with 0 is returned.
   * @param {number} x Pixel coordinate
   * @param {number} y Pixel coordinate
   * @return {Uint8Array} Integer array with one color value (4 components)
   * @api
   */


  WebGLRenderTarget.prototype.readPixel = function (x, y) {
    if (x < 0 || y < 0 || x > this.size_[0] || y >= this.size_[1]) {
      tmpArray4[0] = 0;
      tmpArray4[1] = 0;
      tmpArray4[2] = 0;
      tmpArray4[3] = 0;
      return tmpArray4;
    }

    this.readAll();
    var index = Math.floor(x) + (this.size_[1] - Math.floor(y) - 1) * this.size_[0];
    tmpArray4[0] = this.data_[index * 4];
    tmpArray4[1] = this.data_[index * 4 + 1];
    tmpArray4[2] = this.data_[index * 4 + 2];
    tmpArray4[3] = this.data_[index * 4 + 3];
    return tmpArray4;
  };
  /**
   * @return {WebGLTexture} Texture to render to
   */


  WebGLRenderTarget.prototype.getTexture = function () {
    return this.texture_;
  };
  /**
   * @return {WebGLFramebuffer} Frame buffer of the render target
   */


  WebGLRenderTarget.prototype.getFramebuffer = function () {
    return this.framebuffer_;
  };
  /**
   * @private
   */


  WebGLRenderTarget.prototype.updateSize_ = function () {
    var size = this.size_;
    var gl = this.helper_.getGL();
    this.texture_ = this.helper_.createTexture(size, null, this.texture_);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
    gl.viewport(0, 0, size[0], size[1]);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture_, 0);
    this.data_ = new Uint8Array(size[0] * size[1] * 4);
  };

  return WebGLRenderTarget;
}();

/* harmony default export */ __webpack_exports__["default"] = (WebGLRenderTarget);

/***/ }),

/***/ "./build/wg/webgl/ShaderBuilder.js":
/*!*****************************************!*\
  !*** ./build/wg/webgl/ShaderBuilder.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShaderBuilder": function() { return /* binding */ ShaderBuilder; },
/* harmony export */   "parseLiteralStyle": function() { return /* binding */ parseLiteralStyle; }
/* harmony export */ });
/* harmony import */ var _style_expressions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../style/expressions.js */ "./build/wg/style/expressions.js");
/**
 * Classes and utilities for generating shaders from literal style objects
 * @module wg/webgl/ShaderBuilder
 */

/**
 * @typedef {Object} VaryingDescription
 * @property {string} name Varying name, as will be declared in the header.
 * @property {string} type Varying type, either `float`, `vec2`, `vec4`...
 * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and
 * passed on to the fragment shader.
 */

/**
 * @classdesc
 * This class implements a classic builder pattern for generating many different types of shaders.
 * Methods can be chained, e. g.:
 *
 * ```js
 * const shader = new ShaderBuilder()
 *   .addVarying('v_width', 'float', 'a_width')
 *   .addUniform('u_time')
 *   .setColorExpression('...')
 *   .setSizeExpression('...')
 *   .outputSymbolFragmentShader();
 * ```
 */

var ShaderBuilder =
/** @class */
function () {
  function ShaderBuilder() {
    /**
     * Uniforms; these will be declared in the header (should include the type).
     * @type {Array<string>}
     * @private
     */
    this.uniforms = [];
    /**
     * Attributes; these will be declared in the header (should include the type).
     * @type {Array<string>}
     * @private
     */

    this.attributes = [];
    /**
     * Varyings with a name, a type and an expression.
     * @type {Array<VaryingDescription>}
     * @private
     */

    this.varyings = [];
    /**
     * @type {string}
     * @private
     */

    this.sizeExpression = 'vec2(1.0)';
    /**
     * @type {string}
     * @private
     */

    this.rotationExpression = '0.0';
    /**
     * @type {string}
     * @private
     */

    this.offsetExpression = 'vec2(0.0)';
    /**
     * @type {string}
     * @private
     */

    this.colorExpression = 'vec4(1.0)';
    /**
     * @type {string}
     * @private
     */

    this.texCoordExpression = 'vec4(0.0, 0.0, 1.0, 1.0)';
    /**
     * @type {string}
     * @private
     */

    this.discardExpression = 'false';
    /**
     * @type {boolean}
     * @private
     */

    this.rotateWithView = false;
  }
  /**
   * Adds a uniform accessible in both fragment and vertex shaders.
   * The given name should include a type, such as `sampler2D u_texture`.
   * @param {string} name Uniform name
   * @return {ShaderBuilder} the builder object
   */


  ShaderBuilder.prototype.addUniform = function (name) {
    this.uniforms.push(name);
    return this;
  };
  /**
   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.
   * The given name should include a type, such as `vec2 a_position`.
   * @param {string} name Attribute name
   * @return {ShaderBuilder} the builder object
   */


  ShaderBuilder.prototype.addAttribute = function (name) {
    this.attributes.push(name);
    return this;
  };
  /**
   * Adds a varying defined in the vertex shader and accessible from the fragment shader.
   * The type and expression of the varying have to be specified separately.
   * @param {string} name Varying name
   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type
   * @param {string} expression Expression used to assign a value to the varying.
   * @return {ShaderBuilder} the builder object
   */


  ShaderBuilder.prototype.addVarying = function (name, type, expression) {
    this.varyings.push({
      name: name,
      type: type,
      expression: expression
    });
    return this;
  };
  /**
   * Sets an expression to compute the size of the shape.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec2` value.
   * @param {string} expression Size expression
   * @return {ShaderBuilder} the builder object
   */


  ShaderBuilder.prototype.setSizeExpression = function (expression) {
    this.sizeExpression = expression;
    return this;
  };
  /**
   * Sets an expression to compute the rotation of the shape.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `float` value in radians.
   * @param {string} expression Size expression
   * @return {ShaderBuilder} the builder object
   */


  ShaderBuilder.prototype.setRotationExpression = function (expression) {
    this.rotationExpression = expression;
    return this;
  };
  /**
   * Sets an expression to compute the offset of the symbol from the point center.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec2` value.
   * Note: will only be used for point geometry shaders.
   * @param {string} expression Offset expression
   * @return {ShaderBuilder} the builder object
   */


  ShaderBuilder.prototype.setSymbolOffsetExpression = function (expression) {
    this.offsetExpression = expression;
    return this;
  };
  /**
   * Sets an expression to compute the color of the shape.
   * This expression can use all the uniforms, varyings and attributes available
   * in the fragment shader, and should evaluate to a `vec4` value.
   * @param {string} expression Color expression
   * @return {ShaderBuilder} the builder object
   */


  ShaderBuilder.prototype.setColorExpression = function (expression) {
    this.colorExpression = expression;
    return this;
  };
  /**
   * Sets an expression to compute the texture coordinates of the vertices.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec4` value.
   * @param {string} expression Texture coordinate expression
   * @return {ShaderBuilder} the builder object
   */


  ShaderBuilder.prototype.setTextureCoordinateExpression = function (expression) {
    this.texCoordExpression = expression;
    return this;
  };
  /**
   * Sets an expression to determine whether a fragment (pixel) should be discarded,
   * i.e. not drawn at all.
   * This expression can use all the uniforms, varyings and attributes available
   * in the fragment shader, and should evaluate to a `bool` value (it will be
   * used in an `if` statement)
   * @param {string} expression Fragment discard expression
   * @return {ShaderBuilder} the builder object
   */


  ShaderBuilder.prototype.setFragmentDiscardExpression = function (expression) {
    this.discardExpression = expression;
    return this;
  };
  /**
   * Sets whether the symbols should rotate with the view or stay aligned with the map.
   * Note: will only be used for point geometry shaders.
   * @param {boolean} rotateWithView Rotate with view
   * @return {ShaderBuilder} the builder object
   */


  ShaderBuilder.prototype.setSymbolRotateWithView = function (rotateWithView) {
    this.rotateWithView = rotateWithView;
    return this;
  };
  /**
   * @return {string} Previously set size expression
   */


  ShaderBuilder.prototype.getSizeExpression = function () {
    return this.sizeExpression;
  };
  /**
   * @return {string} Previously set symbol offset expression
   */


  ShaderBuilder.prototype.getOffsetExpression = function () {
    return this.offsetExpression;
  };
  /**
   * @return {string} Previously set color expression
   */


  ShaderBuilder.prototype.getColorExpression = function () {
    return this.colorExpression;
  };
  /**
   * @return {string} Previously set texture coordinate expression
   */


  ShaderBuilder.prototype.getTextureCoordinateExpression = function () {
    return this.texCoordExpression;
  };
  /**
   * @return {string} Previously set fragment discard expression
   */


  ShaderBuilder.prototype.getFragmentDiscardExpression = function () {
    return this.discardExpression;
  };
  /**
   * Generates a symbol vertex shader from the builder parameters,
   * intended to be used on point geometries.
   *
   * Three uniforms are hardcoded in all shaders: `u_projectionMatrix`, `u_offsetScaleMatrix`,
   * `u_offsetRotateMatrix`, `u_time`.
   *
   * The following attributes are hardcoded and expected to be present in the vertex buffers:
   * `vec2 a_position`, `float a_index` (being the index of the vertex in the quad, 0 to 3).
   *
   * The following varyings are hardcoded and gives the coordinate of the pixel both in the quad and on the texture:
   * `vec2 v_quadCoord`, `vec2 v_texCoord`
   *
   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables
   * (namely, hit color with encoded feature id).
   * @return {string} The full shader as a string.
   */


  ShaderBuilder.prototype.getSymbolVertexShader = function (forHitDetection) {
    var offsetMatrix = this.rotateWithView ? 'u_offsetScaleMatrix * u_offsetRotateMatrix' : 'u_offsetScaleMatrix';
    var attributes = this.attributes;
    var varyings = this.varyings;

    if (forHitDetection) {
      attributes = attributes.concat('vec4 a_hitColor');
      varyings = varyings.concat({
        name: 'v_hitColor',
        type: 'vec4',
        expression: 'a_hitColor'
      });
    }

    return "precision mediump float;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n".concat(this.uniforms.map(function (uniform) {
      return 'uniform ' + uniform + ';';
    }).join('\n'), "\nattribute vec2 a_position;\nattribute float a_index;\n").concat(attributes.map(function (attribute) {
      return 'attribute ' + attribute + ';';
    }).join('\n'), "\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n").concat(varyings.map(function (varying) {
      return 'varying ' + varying.type + ' ' + varying.name + ';';
    }).join('\n'), "\nvoid main(void) {\n  mat4 offsetMatrix = ").concat(offsetMatrix, ";\n  vec2 halfSize = ").concat(this.sizeExpression, " * 0.5;\n  vec2 offset = ").concat(this.offsetExpression, ";\n  float angle = ").concat(this.rotationExpression, ";\n  float offsetX;\n  float offsetY;\n  if (a_index == 0.0) {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  } else if (a_index == 1.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else if (a_index == 2.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  }\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  vec4 texCoord = ").concat(this.texCoordExpression, ";\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v_quadCoord = vec2(u, v);\n").concat(varyings.map(function (varying) {
      return '  ' + varying.name + ' = ' + varying.expression + ';';
    }).join('\n'), "\n}");
  };
  /**
   * Generates a symbol fragment shader from the builder parameters,
   * intended to be used on point geometries.
   *
   * Expects the following varyings to be transmitted by the vertex shader:
   * `vec2 v_quadCoord`, `vec2 v_texCoord`
   *
   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables
   * (namely, hit color with encoded feature id).
   * @return {string} The full shader as a string.
   */


  ShaderBuilder.prototype.getSymbolFragmentShader = function (forHitDetection) {
    var hitDetectionBypass = forHitDetection ? '  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;' : '';
    var varyings = this.varyings;

    if (forHitDetection) {
      varyings = varyings.concat({
        name: 'v_hitColor',
        type: 'vec4',
        expression: 'a_hitColor'
      });
    }

    return "precision mediump float;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n".concat(this.uniforms.map(function (uniform) {
      return 'uniform ' + uniform + ';';
    }).join('\n'), "\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n").concat(varyings.map(function (varying) {
      return 'varying ' + varying.type + ' ' + varying.name + ';';
    }).join('\n'), "\nvoid main(void) {\n  if (").concat(this.discardExpression, ") { discard; }\n  gl_FragColor = ").concat(this.colorExpression, ";\n  gl_FragColor.rgb *= gl_FragColor.a;\n").concat(hitDetectionBypass, "\n}");
  };

  return ShaderBuilder;
}();


/**
 * @typedef {Object} StyleParseResult
 * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style
 * @property {Object<string,import("./Helper").UniformValue>} uniforms Uniform definitions.
 * @property {Array<import("../renderer/webgl/PointsLayer").CustomAttribute>} attributes Attribute descriptions.
 */

/**
 * Parses a {@link import("../style/literal").LiteralStyle} object and returns a {@link ShaderBuilder}
 * object that has been configured according to the given style, as well as `attributes` and `uniforms`
 * arrays to be fed to the `WebGLPointsRenderer` class.
 *
 * Also returns `uniforms` and `attributes` properties as expected by the
 * {@link module:wg/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.
 *
 * @param {import("../style/literal").LiteralStyle} style Literal style.
 * @return {StyleParseResult} Result containing shader params, attributes and uniforms.
 */

function parseLiteralStyle(style) {
  var symbStyle = style.symbol;
  var size = symbStyle.size !== undefined ? symbStyle.size : 1;
  var color = symbStyle.color || 'white';
  var texCoord = symbStyle.textureCoord || [0, 0, 1, 1];
  var offset = symbStyle.offset || [0, 0];
  var opacity = symbStyle.opacity !== undefined ? symbStyle.opacity : 1;
  var rotation = symbStyle.rotation !== undefined ? symbStyle.rotation : 0;
  /**
   * @type {import("../style/expressions.js").ParsingContext}
   */

  var vertContext = {
    inFragmentShader: false,
    variables: [],
    attributes: [],
    stringLiteralsMap: {},
    functions: {}
  };
  var parsedSize = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.expressionToGlsl)(vertContext, size, _style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.ValueTypes.NUMBER_ARRAY | _style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.ValueTypes.NUMBER);
  var parsedOffset = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.expressionToGlsl)(vertContext, offset, _style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.ValueTypes.NUMBER_ARRAY);
  var parsedTexCoord = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.expressionToGlsl)(vertContext, texCoord, _style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.ValueTypes.NUMBER_ARRAY);
  var parsedRotation = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.expressionToGlsl)(vertContext, rotation, _style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.ValueTypes.NUMBER);
  /**
   * @type {import("../style/expressions.js").ParsingContext}
   */

  var fragContext = {
    inFragmentShader: true,
    variables: vertContext.variables,
    attributes: [],
    stringLiteralsMap: vertContext.stringLiteralsMap,
    functions: {}
  };
  var parsedColor = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.expressionToGlsl)(fragContext, color, _style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.ValueTypes.COLOR);
  var parsedOpacity = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.expressionToGlsl)(fragContext, opacity, _style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.ValueTypes.NUMBER);
  var opacityFilter = '1.0';
  var visibleSize = "vec2(".concat((0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.expressionToGlsl)(fragContext, size, _style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.ValueTypes.NUMBER_ARRAY | _style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.ValueTypes.NUMBER), ").x");

  switch (symbStyle.symbolType) {
    case 'square':
      break;

    case 'image':
      break;
    // taken from https://thebookofshaders.com/07/

    case 'circle':
      opacityFilter = "(1.0-smoothstep(1.-4./".concat(visibleSize, ",1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))");
      break;

    case 'triangle':
      var st = '(v_quadCoord*2.-1.)';
      var a = "(atan(".concat(st, ".x,").concat(st, ".y))");
      opacityFilter = "(1.0-smoothstep(.5-3./".concat(visibleSize, ",.5,cos(floor(.5+").concat(a, "/2.094395102)*2.094395102-").concat(a, ")*length(").concat(st, ")))");
      break;

    default:
      throw new Error('Unexpected symbol type: ' + symbStyle.symbolType);
  }

  var builder = new ShaderBuilder().setSizeExpression("vec2(".concat(parsedSize, ")")).setRotationExpression(parsedRotation).setSymbolOffsetExpression(parsedOffset).setTextureCoordinateExpression(parsedTexCoord).setSymbolRotateWithView(!!symbStyle.rotateWithView).setColorExpression("vec4(".concat(parsedColor, ".rgb, ").concat(parsedColor, ".a * ").concat(parsedOpacity, " * ").concat(opacityFilter, ")"));

  if (style.filter) {
    var parsedFilter = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.expressionToGlsl)(fragContext, style.filter, _style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.ValueTypes.BOOLEAN);
    builder.setFragmentDiscardExpression("!".concat(parsedFilter));
  }
  /** @type {Object<string,import("../webgl/Helper").UniformValue>} */


  var uniforms = {}; // define one uniform per variable

  fragContext.variables.forEach(function (varName) {
    var uniformName = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.uniformNameForVariable)(varName);
    builder.addUniform("float ".concat(uniformName));

    uniforms[uniformName] = function () {
      if (!style.variables || style.variables[varName] === undefined) {
        throw new Error("The following variable is missing from the style: ".concat(varName));
      }

      var value = style.variables[varName];

      if (typeof value === 'string') {
        value = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.getStringNumberEquivalent)(vertContext, value);
      }

      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal
    };
  });

  if (symbStyle.symbolType === 'image' && symbStyle.src) {
    var texture = new Image();
    texture.crossOrigin = symbStyle.crossOrigin === undefined ? 'anonymous' : symbStyle.crossOrigin;
    texture.src = symbStyle.src;
    builder.addUniform('sampler2D u_texture').setColorExpression(builder.getColorExpression() + ' * texture2D(u_texture, v_texCoord)');
    uniforms['u_texture'] = texture;
  } // for each feature attribute used in the fragment shader, define a varying that will be used to pass data
  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)


  fragContext.attributes.forEach(function (attrName) {
    if (vertContext.attributes.indexOf(attrName) === -1) {
      vertContext.attributes.push(attrName);
    }

    builder.addVarying("v_".concat(attrName), 'float', "a_".concat(attrName));
  }); // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.

  vertContext.attributes.forEach(function (attrName) {
    builder.addAttribute("float a_".concat(attrName));
  });
  return {
    builder: builder,
    attributes: vertContext.attributes.map(function (attributeName) {
      return {
        name: attributeName,
        callback: function callback(feature, props) {
          var value = props[attributeName];

          if (typeof value === 'string') {
            value = (0,_style_expressions_js__WEBPACK_IMPORTED_MODULE_0__.getStringNumberEquivalent)(vertContext, value);
          }

          return value !== undefined ? value : -9999999; // to avoid matching with the first string literal
        }
      };
    }),
    uniforms: uniforms
  };
}

/***/ }),

/***/ "./build/wg/webgl/TileTexture.js":
/*!***************************************!*\
  !*** ./build/wg/webgl/TileTexture.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DataTile_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../DataTile.js */ "./build/wg/DataTile.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../events/Target.js */ "./build/wg/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./build/wg/events/EventType.js");
/* harmony import */ var _ImageTile_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ImageTile.js */ "./build/wg/ImageTile.js");
/* harmony import */ var _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../reproj/Tile.js */ "./build/wg/reproj/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../TileState.js */ "./build/wg/TileState.js");
/* harmony import */ var _Buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Buffer.js */ "./build/wg/webgl/Buffer.js");
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl.js */ "./build/wg/webgl.js");
/* harmony import */ var _renderer_canvas_common_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../renderer/canvas/common.js */ "./build/wg/renderer/canvas/common.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../obj.js */ "./build/wg/obj.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../dom.js */ "./build/wg/dom.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../size.js */ "./build/wg/size.js");
/**
 * @module wg/webgl/TileTexture
 */
var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();













/**
 * @param {WebGLRenderingContext} gl The WebGL context.
 * @param {WebGLTexture} texture The texture.
 * @param {boolean} interpolate Interpolate when resampling.
 */

function bindAndConfigure(gl, texture, interpolate) {
  var resampleFilter = interpolate ? gl.LINEAR : gl.NEAREST;
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, resampleFilter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, resampleFilter);
}
/**
 * @param {WebGLRenderingContext} gl The WebGL context.
 * @param {WebGLTexture} texture The texture.
 * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image The image.
 * @param {boolean} interpolate Interpolate when resampling.
 */


function uploadImageTexture(gl, texture, image, interpolate) {
  bindAndConfigure(gl, texture, interpolate);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
}
/**
 * @param {import("./Helper.js").default} helper The WebGL helper.
 * @param {WebGLTexture} texture The texture.
 * @param {import("../DataTile.js").Data} data The pixel data.
 * @param {import("../size.js").Size} size The pixel size.
 * @param {number} bandCount The band count.
 * @param {boolean} interpolate Interpolate when resampling.
 */


function uploadDataTexture(helper, texture, data, size, bandCount, interpolate) {
  var gl = helper.getGL();
  bindAndConfigure(gl, texture, interpolate);
  var bytesPerRow = data.byteLength / size[1];
  var unpackAlignment = 1;

  if (bytesPerRow % 8 === 0) {
    unpackAlignment = 8;
  } else if (bytesPerRow % 4 === 0) {
    unpackAlignment = 4;
  } else if (bytesPerRow % 2 === 0) {
    unpackAlignment = 2;
  }

  var format;

  switch (bandCount) {
    case 1:
      {
        format = gl.LUMINANCE;
        break;
      }

    case 2:
      {
        format = gl.LUMINANCE_ALPHA;
        break;
      }

    case 3:
      {
        format = gl.RGB;
        break;
      }

    case 4:
      {
        format = gl.RGBA;
        break;
      }

    default:
      {
        throw new Error("Unsupported number of bands: ".concat(bandCount));
      }
  }

  var textureType;

  if (data instanceof Float32Array) {
    textureType = gl.FLOAT;
    helper.getExtension('OES_texture_float');
    helper.getExtension('OES_texture_float_linear');
  } else {
    textureType = gl.UNSIGNED_BYTE;
  }

  var oldUnpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, size[0], size[1], 0, format, textureType, data);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, oldUnpackAlignment);
}
/**
 * @type {CanvasRenderingContext2D}
 */


var pixelContext = null;

function createPixelContext() {
  var canvas = document.createElement('canvas');
  canvas.width = 1;
  canvas.height = 1;
  pixelContext = canvas.getContext('2d');
}
/**
 * @typedef {import("../DataTile.js").default|ImageTile|ReprojTile} TileType
 */

/**
 * @typedef {Object} Options
 * @property {TileType} tile The tile.
 * @property {import("../tilegrid/TileGrid.js").default} grid Tile grid.
 * @property {import("../webgl/Helper.js").default} helper WebGL helper.
 * @property {number} [tilePixelRatio=1] Tile pixel ratio.
 * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.
 */


var TileTexture =
/** @class */
function (_super) {
  __extends(TileTexture, _super);
  /**
   * @param {Options} options The tile texture options.
   */


  function TileTexture(options) {
    var _this = _super.call(this) || this;
    /**
     * @type {TileType}
     */


    _this.tile;
    /**
     * @type {Array<WebGLTexture>}
     */

    _this.textures = [];
    _this.handleTileChange_ = _this.handleTileChange_.bind(_this);
    /**
     * @type {import("../size.js").Size}
     */

    _this.size = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(options.grid.getTileSize(options.tile.tileCoord[0]));
    /**
     * @type {number}
     * @private
     */

    _this.tilePixelRatio_ = options.tilePixelRatio || 1;
    /**
     * @type {number}
     * @private
     */

    _this.gutter_ = options.gutter || 0;
    /**
     * @type {number}
     */

    _this.bandCount = NaN;
    /**
     * @type {import("../webgl/Helper.js").default}
     * @private
     */

    _this.helper_ = options.helper;
    var coords = new _Buffer_js__WEBPACK_IMPORTED_MODULE_1__["default"](_webgl_js__WEBPACK_IMPORTED_MODULE_2__.ARRAY_BUFFER, _webgl_js__WEBPACK_IMPORTED_MODULE_2__.STATIC_DRAW);
    coords.fromArray([0, 1, 1, 1, 1, 0, 0, 0]);

    _this.helper_.flushBufferData(coords);
    /**
     * @type {WebGLArrayBuffer}
     */


    _this.coords = coords;

    _this.setTile(options.tile);

    return _this;
  }
  /**
   * @param {TileType} tile Tile.
   */


  TileTexture.prototype.setTile = function (tile) {
    if (tile !== this.tile) {
      if (this.tile) {
        this.tile.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.handleTileChange_);
      }

      this.tile = tile;
      this.textures.length = 0;
      this.loaded = tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED;

      if (this.loaded) {
        this.uploadTile_();
      } else {
        if (tile instanceof _ImageTile_js__WEBPACK_IMPORTED_MODULE_5__["default"]) {
          var image = tile.getImage();

          if (image instanceof Image && !image.crossOrigin) {
            image.crossOrigin = 'anonymous';
          }
        }

        tile.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.handleTileChange_);
      }
    }
  };

  TileTexture.prototype.uploadTile_ = function () {
    var helper = this.helper_;
    var gl = helper.getGL();
    var tile = this.tile;

    if (tile instanceof _ImageTile_js__WEBPACK_IMPORTED_MODULE_5__["default"] || tile instanceof _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_6__["default"]) {
      var image = tile.getImage();

      if (this.gutter_ !== 0) {
        var gutter = this.tilePixelRatio_ * this.gutter_;
        var width = Math.round(image.width - 2 * gutter);
        var height = Math.round(image.height - 2 * gutter);
        var context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_7__.createCanvasContext2D)(width, height);

        if (!tile.interpolate) {
          (0,_obj_js__WEBPACK_IMPORTED_MODULE_8__.assign)(context, _renderer_canvas_common_js__WEBPACK_IMPORTED_MODULE_9__.IMAGE_SMOOTHING_DISABLED);
        }

        context.drawImage(image, gutter, gutter, width, height, 0, 0, width, height);
        image = context.canvas;
      }

      var texture = gl.createTexture();
      this.textures.push(texture);
      this.bandCount = 4;
      uploadImageTexture(gl, texture, image, tile.interpolate);
      return;
    }

    var pixelSize = [this.size[0] * this.tilePixelRatio_, this.size[1] * this.tilePixelRatio_];
    var data = tile.getData();
    var isFloat = data instanceof Float32Array;
    var pixelCount = pixelSize[0] * pixelSize[1];
    var DataType = isFloat ? Float32Array : Uint8Array;
    var bytesPerElement = DataType.BYTES_PER_ELEMENT;
    var bytesPerRow = data.byteLength / pixelSize[1];
    this.bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);
    var textureCount = Math.ceil(this.bandCount / 4);

    if (textureCount === 1) {
      var texture = gl.createTexture();
      this.textures.push(texture);
      uploadDataTexture(helper, texture, data, pixelSize, this.bandCount, tile.interpolate);
      return;
    }

    var textureDataArrays = new Array(textureCount);

    for (var textureIndex = 0; textureIndex < textureCount; ++textureIndex) {
      var texture = gl.createTexture();
      this.textures.push(texture);
      var bandCount = textureIndex < textureCount - 1 ? 4 : this.bandCount % 4;
      textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);
    }

    var dataIndex = 0;
    var rowOffset = 0;
    var colCount = pixelSize[0] * this.bandCount;

    for (var rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {
      for (var colIndex = 0; colIndex < colCount; ++colIndex) {
        var dataValue = data[rowOffset + colIndex];
        var pixelIndex = Math.floor(dataIndex / this.bandCount);
        var bandIndex = colIndex % this.bandCount;
        var textureIndex = Math.floor(bandIndex / 4);
        var textureData = textureDataArrays[textureIndex];
        var bandCount = textureData.length / pixelCount;
        var textureBandIndex = bandIndex % 4;
        textureData[pixelIndex * bandCount + textureBandIndex] = dataValue;
        ++dataIndex;
      }

      rowOffset += bytesPerRow / bytesPerElement;
    }

    for (var textureIndex = 0; textureIndex < textureCount; ++textureIndex) {
      var texture = this.textures[textureIndex];
      var textureData = textureDataArrays[textureIndex];
      var bandCount = textureData.length / pixelCount;
      uploadDataTexture(helper, texture, textureData, pixelSize, bandCount, tile.interpolate);
    }
  };

  TileTexture.prototype.handleTileChange_ = function () {
    if (this.tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED) {
      this.loaded = true;
      this.uploadTile_();
      this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE);
    }
  };

  TileTexture.prototype.disposeInternal = function () {
    var gl = this.helper_.getGL();
    this.helper_.deleteBuffer(this.coords);

    for (var i = 0; i < this.textures.length; ++i) {
      gl.deleteTexture(this.textures[i]);
    }

    this.tile.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.handleTileChange_);
  };
  /**
   * Get data for a pixel.  If the tile is not loaded, null is returned.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {import("../DataTile.js").Data|null} The data.
   */


  TileTexture.prototype.getPixelData = function (col, row) {
    if (!this.loaded) {
      return null;
    }

    col = Math.floor(this.tilePixelRatio_ * col);
    row = Math.floor(this.tilePixelRatio_ * row);

    if (this.tile instanceof _DataTile_js__WEBPACK_IMPORTED_MODULE_10__["default"]) {
      var data_1 = this.tile.getData();
      var pixelsPerRow = Math.floor(this.tilePixelRatio_ * this.size[0]);

      if (data_1 instanceof DataView) {
        var bytesPerPixel = data_1.byteLength / (this.size[0] * this.size[1]);
        var offset_1 = row * pixelsPerRow * bytesPerPixel + col * bytesPerPixel;
        var buffer = data_1.buffer.slice(offset_1, offset_1 + bytesPerPixel);
        return new DataView(buffer);
      }

      var offset = row * pixelsPerRow * this.bandCount + col * this.bandCount;
      return data_1.slice(offset, offset + this.bandCount);
    }

    if (!pixelContext) {
      createPixelContext();
    }

    pixelContext.clearRect(0, 0, 1, 1);
    var data;
    var image = this.tile.getImage();

    try {
      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
      data = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      return null;
    }

    return data;
  };

  return TileTexture;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_11__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (TileTexture);

/***/ }),

/***/ "./build/wg/worker/webgl.js":
/*!**********************************!*\
  !*** ./build/wg/worker/webgl.js ***!
  \**********************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": function() { return /* binding */ create; }
/* harmony export */ });
function create() {
  var source = "var e=\"function\"==typeof Object.assign?Object.assign:function(e,n){if(null==e)throw new TypeError(\"Cannot convert undefined or null to object\");for(var t=Object(e),r=1,o=arguments.length;r<o;++r){var i=arguments[r];if(null!=i)for(var f in i)i.hasOwnProperty(f)&&(t[f]=i[f])}return t},n=\"GENERATE_BUFFERS\",t=[],r={vertexPosition:0,indexPosition:0};function o(e,n,t,r,o){e[n+0]=t,e[n+1]=r,e[n+2]=o}function i(e,n,i,f,s,a){var u=3+s,l=e[n+0],v=e[n+1],c=t;c.length=s;for(var g=0;g<c.length;g++)c[g]=e[n+2+g];var b=a?a.vertexPosition:0,h=a?a.indexPosition:0,d=b/u;return o(i,b,l,v,0),c.length&&i.set(c,b+3),o(i,b+=u,l,v,1),c.length&&i.set(c,b+3),o(i,b+=u,l,v,2),c.length&&i.set(c,b+3),o(i,b+=u,l,v,3),c.length&&i.set(c,b+3),b+=u,f[h++]=d,f[h++]=d+1,f[h++]=d+3,f[h++]=d+1,f[h++]=d+2,f[h++]=d+3,r.vertexPosition=b,r.indexPosition=h,r}var f=self;f.onmessage=function(t){var r=t.data;if(r.type===n){for(var o,s=r.customAttributesCount,a=2+s,u=new Float32Array(r.renderInstructions),l=u.length/a,v=4*l*(s+3),c=new Uint32Array(6*l),g=new Float32Array(v),b=0;b<u.length;b+=a)o=i(u,b,g,c,s,o);var h=e({vertexBuffer:g.buffer,indexBuffer:c.buffer,renderInstructions:u.buffer},r);f.postMessage(h,[g.buffer,c.buffer,u.buffer])}};";
  return new Worker(typeof Blob === 'undefined' ? 'data:application/javascript;base64,' + Buffer.from(source, 'binary').toString('base64') : URL.createObjectURL(new Blob([source], {
    type: 'application/javascript'
  })));
}

/***/ }),

/***/ "./build/wg/xml.js":
/*!*************************!*\
  !*** ./build/wg/xml.js ***!
  \*************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "XML_SCHEMA_INSTANCE_URI": function() { return /* binding */ XML_SCHEMA_INSTANCE_URI; },
/* harmony export */   "createElementNS": function() { return /* binding */ createElementNS; },
/* harmony export */   "getAllTextContent": function() { return /* binding */ getAllTextContent; },
/* harmony export */   "getAllTextContent_": function() { return /* binding */ getAllTextContent_; },
/* harmony export */   "isDocument": function() { return /* binding */ isDocument; },
/* harmony export */   "getAttributeNS": function() { return /* binding */ getAttributeNS; },
/* harmony export */   "parse": function() { return /* binding */ parse; },
/* harmony export */   "makeArrayExtender": function() { return /* binding */ makeArrayExtender; },
/* harmony export */   "makeArrayPusher": function() { return /* binding */ makeArrayPusher; },
/* harmony export */   "makeReplacer": function() { return /* binding */ makeReplacer; },
/* harmony export */   "makeObjectPropertyPusher": function() { return /* binding */ makeObjectPropertyPusher; },
/* harmony export */   "makeObjectPropertySetter": function() { return /* binding */ makeObjectPropertySetter; },
/* harmony export */   "makeChildAppender": function() { return /* binding */ makeChildAppender; },
/* harmony export */   "makeArraySerializer": function() { return /* binding */ makeArraySerializer; },
/* harmony export */   "makeSimpleNodeFactory": function() { return /* binding */ makeSimpleNodeFactory; },
/* harmony export */   "OBJECT_PROPERTY_NODE_FACTORY": function() { return /* binding */ OBJECT_PROPERTY_NODE_FACTORY; },
/* harmony export */   "makeSequence": function() { return /* binding */ makeSequence; },
/* harmony export */   "makeStructureNS": function() { return /* binding */ makeStructureNS; },
/* harmony export */   "parseNode": function() { return /* binding */ parseNode; },
/* harmony export */   "pushParseAndPop": function() { return /* binding */ pushParseAndPop; },
/* harmony export */   "serialize": function() { return /* binding */ serialize; },
/* harmony export */   "pushSerializeAndPop": function() { return /* binding */ pushSerializeAndPop; },
/* harmony export */   "registerXMLSerializer": function() { return /* binding */ registerXMLSerializer; },
/* harmony export */   "getXMLSerializer": function() { return /* binding */ getXMLSerializer; },
/* harmony export */   "registerDocument": function() { return /* binding */ registerDocument; },
/* harmony export */   "getDocument": function() { return /* binding */ getDocument; }
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./build/wg/array.js");
/**
 * @module wg/xml
 */

/**
 * When using {@link module:wg/xml.makeChildAppender} or
 * {@link module:wg/xml.makeSimpleNodeFactory}, the top `objectStack` item needs
 * to have this structure.
 * @typedef {Object} NodeStackItem
 * @property {Element} node Node.
 */

/**
 * @typedef {function(Element, Array<*>): void} Parser
 */

/**
 * @typedef {function(Element, *, Array<*>): void} Serializer
 */

/**
 * @type {string}
 */

var XML_SCHEMA_INSTANCE_URI = 'http://www.w3.org/2001/XMLSchema-instance';
/**
 * @param {string} namespaceURI Namespace URI.
 * @param {string} qualifiedName Qualified name.
 * @return {Element} Node.
 */

function createElementNS(namespaceURI, qualifiedName) {
  return getDocument().createElementNS(namespaceURI, qualifiedName);
}
/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @return {string} All text content.
 * @api
 */

function getAllTextContent(node, normalizeWhitespace) {
  return getAllTextContent_(node, normalizeWhitespace, []).join('');
}
/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @param {Array<string>} accumulator Accumulator.
 * @private
 * @return {Array<string>} Accumulator.
 */

function getAllTextContent_(node, normalizeWhitespace, accumulator) {
  if (node.nodeType == Node.CDATA_SECTION_NODE || node.nodeType == Node.TEXT_NODE) {
    if (normalizeWhitespace) {
      accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
    } else {
      accumulator.push(node.nodeValue);
    }
  } else {
    var n = void 0;

    for (n = node.firstChild; n; n = n.nextSibling) {
      getAllTextContent_(n, normalizeWhitespace, accumulator);
    }
  }

  return accumulator;
}
/**
 * @param {Object} object Object.
 * @return {boolean} Is a document.
 */

function isDocument(object) {
  return 'documentElement' in object;
}
/**
 * @param {Element} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @return {string} Value
 */

function getAttributeNS(node, namespaceURI, name) {
  return node.getAttributeNS(namespaceURI, name) || '';
}
/**
 * Parse an XML string to an XML Document.
 * @param {string} xml XML.
 * @return {Document} Document.
 * @api
 */

function parse(xml) {
  return new DOMParser().parseFromString(xml, 'application/xml');
}
/**
 * Make an array extender function for extending the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.
 * @param {T} [opt_this] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */

function makeArrayExtender(valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);

      if (value !== undefined) {
        var array =
        /** @type {Array<*>} */
        objectStack[objectStack.length - 1];
        (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.extend)(array, value);
      }
    }
  );
}
/**
 * Make an array pusher function for pushing to the array at the top of the
 * object stack.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {T} [opt_this] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */

function makeArrayPusher(valueReader, opt_this) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);

      if (value !== undefined) {
        var array =
        /** @type {Array<*>} */
        objectStack[objectStack.length - 1];
        array.push(value);
      }
    }
  );
}
/**
 * Make an object stack replacer function for replacing the object at the
 * top of the stack.
 * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.
 * @param {T} [opt_this] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */

function makeReplacer(valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);

      if (value !== undefined) {
        objectStack[objectStack.length - 1] = value;
      }
    }
  );
}
/**
 * Make an object property pusher function for adding a property to the
 * object at the top of the stack.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {string} [opt_property] Property.
 * @param {T} [opt_this] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */

function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);

      if (value !== undefined) {
        var object =
        /** @type {!Object} */
        objectStack[objectStack.length - 1];
        var property = opt_property !== undefined ? opt_property : node.localName;
        var array = void 0;

        if (property in object) {
          array = object[property];
        } else {
          array = [];
          object[property] = array;
        }

        array.push(value);
      }
    }
  );
}
/**
 * Make an object property setter function.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {string} [opt_property] Property.
 * @param {T} [opt_this] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */

function makeObjectPropertySetter(valueReader, opt_property, opt_this) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);

      if (value !== undefined) {
        var object =
        /** @type {!Object} */
        objectStack[objectStack.length - 1];
        var property = opt_property !== undefined ? opt_property : node.localName;
        object[property] = value;
      }
    }
  );
}
/**
 * Create a serializer that appends nodes written by its `nodeWriter` to its
 * designated parent. The parent is the `node` of the
 * {@link module:wg/xml~NodeStackItem} at the top of the `objectStack`.
 * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.
 * @param {T} [opt_this] The object to use as `this` in `nodeWriter`.
 * @return {Serializer} Serializer.
 * @template T, V
 */

function makeChildAppender(nodeWriter, opt_this) {
  return function (node, value, objectStack) {
    nodeWriter.call(opt_this !== undefined ? opt_this : this, node, value, objectStack);
    var parent =
    /** @type {NodeStackItem} */
    objectStack[objectStack.length - 1];
    var parentNode = parent.node;
    parentNode.appendChild(node);
  };
}
/**
 * Create a serializer that calls the provided `nodeWriter` from
 * {@link module:wg/xml.serialize}. This can be used by the parent writer to have the
 * `nodeWriter` called with an array of values when the `nodeWriter` was
 * designed to serialize a single item. An example would be a LineString
 * geometry writer, which could be reused for writing MultiLineString
 * geometries.
 * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.
 * @param {T} [opt_this] The object to use as `this` in `nodeWriter`.
 * @return {Serializer} Serializer.
 * @template T, V
 */

function makeArraySerializer(nodeWriter, opt_this) {
  var serializersNS, nodeFactory;
  return function (node, value, objectStack) {
    if (serializersNS === undefined) {
      serializersNS = {};
      var serializers = {};
      serializers[node.localName] = nodeWriter;
      serializersNS[node.namespaceURI] = serializers;
      nodeFactory = makeSimpleNodeFactory(node.localName);
    }

    serialize(serializersNS, nodeFactory, value, objectStack);
  };
}
/**
 * Create a node factory which can use the `opt_keys` passed to
 * {@link module:wg/xml.serialize} or {@link module:wg/xml.pushSerializeAndPop} as node names,
 * or a fixed node name. The namespace of the created nodes can either be fixed,
 * or the parent namespace will be used.
 * @param {string} [opt_nodeName] Fixed node name which will be used for all
 *     created nodes. If not provided, the 3rd argument to the resulting node
 *     factory needs to be provided and will be the nodeName.
 * @param {string} [opt_namespaceURI] Fixed namespace URI which will be used for
 *     all created nodes. If not provided, the namespace of the parent node will
 *     be used.
 * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.
 */

function makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {
  var fixedNodeName = opt_nodeName;
  return (
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [opt_nodeName] Node name.
     * @return {Node} Node.
     */
    function (value, objectStack, opt_nodeName) {
      var context =
      /** @type {NodeStackItem} */
      objectStack[objectStack.length - 1];
      var node = context.node;
      var nodeName = fixedNodeName;

      if (nodeName === undefined) {
        nodeName = opt_nodeName;
      }

      var namespaceURI = opt_namespaceURI !== undefined ? opt_namespaceURI : node.namespaceURI;
      return createElementNS(namespaceURI,
      /** @type {string} */
      nodeName);
    }
  );
}
/**
 * A node factory that creates a node using the parent's `namespaceURI` and the
 * `nodeName` passed by {@link module:wg/xml.serialize} or
 * {@link module:wg/xml.pushSerializeAndPop} to the node factory.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */

var OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();
/**
 * Create an array of `values` to be used with {@link module:wg/xml.serialize} or
 * {@link module:wg/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as
 * `opt_key` argument.
 * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can
 *     be a subset of the `orderedKeys`.
 * @param {Array<string>} orderedKeys Keys in the order of the sequence.
 * @return {Array<*>} Values in the order of the sequence. The resulting array
 *     has the same length as the `orderedKeys` array. Values that are not
 *     present in `object` will be `undefined` in the resulting array.
 */

function makeSequence(object, orderedKeys) {
  var length = orderedKeys.length;
  var sequence = new Array(length);

  for (var i = 0; i < length; ++i) {
    sequence[i] = object[orderedKeys[i]];
  }

  return sequence;
}
/**
 * Create a namespaced structure, using the same values for each namespace.
 * This can be used as a starting point for versioned parsers, when only a few
 * values are version specific.
 * @param {Array<string>} namespaceURIs Namespace URIs.
 * @param {T} structure Structure.
 * @param {Object<string, T>} [opt_structureNS] Namespaced structure to add to.
 * @return {Object<string, T>} Namespaced structure.
 * @template T
 */

function makeStructureNS(namespaceURIs, structure, opt_structureNS) {
  /**
   * @type {Object<string, T>}
   */
  var structureNS = opt_structureNS !== undefined ? opt_structureNS : {};
  var i, ii;

  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {
    structureNS[namespaceURIs[i]] = structure;
  }

  return structureNS;
}
/**
 * Parse a node using the parsers and object stack.
 * @param {Object<string, Object<string, Parser>>} parsersNS
 *     Parsers by namespace.
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @param {*} [opt_this] The object to use as `this`.
 */

function parseNode(parsersNS, node, objectStack, opt_this) {
  var n;

  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    var parsers = parsersNS[n.namespaceURI];

    if (parsers !== undefined) {
      var parser = parsers[n.localName];

      if (parser !== undefined) {
        parser.call(opt_this, n, objectStack);
      }
    }
  }
}
/**
 * Push an object on top of the stack, parse and return the popped object.
 * @param {T} object Object.
 * @param {Object<string, Object<string, Parser>>} parsersNS
 *     Parsers by namespace.
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @param {*} [opt_this] The object to use as `this`.
 * @return {T} Object.
 * @template T
 */

function pushParseAndPop(object, parsersNS, node, objectStack, opt_this) {
  objectStack.push(object);
  parseNode(parsersNS, node, objectStack, opt_this);
  return (
    /** @type {T} */
    objectStack.pop()
  );
}
/**
 * Walk through an array of `values` and call a serializer for each value.
 * @param {Object<string, Object<string, Serializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array<*>} values Values to serialize. An example would be an array
 *     of {@link module:wg/Feature~Feature} instances.
 * @param {Array<*>} objectStack Node stack.
 * @param {Array<string>} [opt_keys] Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `opt_keys` has
 *     to match the length of `values`. For serializing a sequence, `opt_keys`
 *     determines the order of the sequence.
 * @param {T} [opt_this] The object to use as `this` for the node factory and
 *     serializers.
 * @template T
 */

function serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
  var length = (opt_keys !== undefined ? opt_keys : values).length;
  var value, node;

  for (var i = 0; i < length; ++i) {
    value = values[i];

    if (value !== undefined) {
      node = nodeFactory.call(opt_this !== undefined ? opt_this : this, value, objectStack, opt_keys !== undefined ? opt_keys[i] : undefined);

      if (node !== undefined) {
        serializersNS[node.namespaceURI][node.localName].call(opt_this, node, value, objectStack);
      }
    }
  }
}
/**
 * @param {O} object Object.
 * @param {Object<string, Object<string, Serializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array<*>} values Values to serialize. An example would be an array
 *     of {@link module:wg/Feature~Feature} instances.
 * @param {Array<*>} objectStack Node stack.
 * @param {Array<string>} [opt_keys] Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `opt_keys` has
 *     to match the length of `values`. For serializing a sequence, `opt_keys`
 *     determines the order of the sequence.
 * @param {T} [opt_this] The object to use as `this` for the node factory and
 *     serializers.
 * @return {O|undefined} Object.
 * @template O, T
 */

function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
  objectStack.push(object);
  serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);
  return (
    /** @type {O|undefined} */
    objectStack.pop()
  );
}
var xmlSerializer_ = undefined;
/**
 * Register a XMLSerializer. Can be used  to inject a XMLSerializer
 * where there is no globally available implementation.
 *
 * @param {XMLSerializer} xmlSerializer A XMLSerializer.
 * @api
 */

function registerXMLSerializer(xmlSerializer) {
  xmlSerializer_ = xmlSerializer;
}
/**
 * @return {XMLSerializer} The XMLSerializer.
 */

function getXMLSerializer() {
  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {
    xmlSerializer_ = new XMLSerializer();
  }

  return xmlSerializer_;
}
var document_ = undefined;
/**
 * Register a Document to use when creating nodes for XML serializations. Can be used
 * to inject a Document where there is no globally available implementation.
 *
 * @param {Document} document A Document.
 * @api
 */

function registerDocument(document) {
  document_ = document;
}
/**
 * Get a document that should be used when creating nodes for XML serializations.
 * @return {Document} The document.
 */

function getDocument() {
  if (document_ === undefined && typeof document !== 'undefined') {
    document_ = document.implementation.createDocument('', '', null);
  }

  return document_;
}

/***/ }),

/***/ "./node_modules/@petamoriken/float16/src/DataView.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/DataView.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getFloat16": function() { return /* binding */ getFloat16; },
/* harmony export */   "setFloat16": function() { return /* binding */ setFloat16; }
/* harmony export */ });
/* harmony import */ var _helper_converter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper/converter.mjs */ "./node_modules/@petamoriken/float16/src/helper/converter.mjs");
/* harmony import */ var _helper_is_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helper/is.mjs */ "./node_modules/@petamoriken/float16/src/helper/is.mjs");


/**
 * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView.
 * @param {DataView} dataView
 * @param {number} byteOffset
 * @param {[boolean]} opts
 * @returns {number}
 */

function getFloat16(dataView, byteOffset) {
  if (!(0,_helper_is_mjs__WEBPACK_IMPORTED_MODULE_0__.isDataView)(dataView)) {
    throw new TypeError("First argument to getFloat16 function must be a DataView");
  }

  for (var _len = arguments.length, opts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    opts[_key - 2] = arguments[_key];
  }

  return (0,_helper_converter_mjs__WEBPACK_IMPORTED_MODULE_1__.convertToNumber)(dataView.getUint16.apply(dataView, [byteOffset].concat(opts)));
}
/**
 * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView.
 * @param {DataView} dataView
 * @param {number} byteOffset
 * @param {number} value
 * @param {[boolean]} opts
 */

function setFloat16(dataView, byteOffset, value) {
  if (!(0,_helper_is_mjs__WEBPACK_IMPORTED_MODULE_0__.isDataView)(dataView)) {
    throw new TypeError("First argument to setFloat16 function must be a DataView");
  }

  for (var _len2 = arguments.length, opts = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    opts[_key2 - 3] = arguments[_key2];
  }

  dataView.setUint16.apply(dataView, [byteOffset, (0,_helper_converter_mjs__WEBPACK_IMPORTED_MODULE_1__.roundToFloat16Bits)(value)].concat(opts));
}

/***/ }),

/***/ "./node_modules/@petamoriken/float16/src/helper/converter.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/helper/converter.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "roundToFloat16Bits": function() { return /* binding */ roundToFloat16Bits; },
/* harmony export */   "convertToNumber": function() { return /* binding */ convertToNumber; }
/* harmony export */ });
// algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf
var buffer = new ArrayBuffer(4);
var floatView = new Float32Array(buffer);
var uint32View = new Uint32Array(buffer);
var baseTable = new Uint32Array(512);
var shiftTable = new Uint32Array(512);

for (var i = 0; i < 256; ++i) {
  var e = i - 127; // very small number (0, -0)

  if (e < -27) {
    baseTable[i] = 0x0000;
    baseTable[i | 0x100] = 0x8000;
    shiftTable[i] = 24;
    shiftTable[i | 0x100] = 24; // small number (denorm)
  } else if (e < -14) {
    baseTable[i] = 0x0400 >> -e - 14;
    baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;
    shiftTable[i] = -e - 1;
    shiftTable[i | 0x100] = -e - 1; // normal number
  } else if (e <= 15) {
    baseTable[i] = e + 15 << 10;
    baseTable[i | 0x100] = e + 15 << 10 | 0x8000;
    shiftTable[i] = 13;
    shiftTable[i | 0x100] = 13; // large number (Infinity, -Infinity)
  } else if (e < 128) {
    baseTable[i] = 0x7c00;
    baseTable[i | 0x100] = 0xfc00;
    shiftTable[i] = 24;
    shiftTable[i | 0x100] = 24; // stay (NaN, Infinity, -Infinity)
  } else {
    baseTable[i] = 0x7c00;
    baseTable[i | 0x100] = 0xfc00;
    shiftTable[i] = 13;
    shiftTable[i | 0x100] = 13;
  }
}
/**
 * round a number to a half float number bits.
 * @param {number} num - double float
 * @returns {number} half float number bits
 */


function roundToFloat16Bits(num) {
  floatView[0] = num;
  var f = uint32View[0];
  var e = f >> 23 & 0x1ff;
  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);
}
var mantissaTable = new Uint32Array(2048);
var exponentTable = new Uint32Array(64);
var offsetTable = new Uint32Array(64);
mantissaTable[0] = 0;

for (var _i = 1; _i < 1024; ++_i) {
  var m = _i << 13; // zero pad mantissa bits

  var _e = 0; // zero exponent
  // normalized

  while ((m & 0x00800000) === 0) {
    _e -= 0x00800000; // decrement exponent

    m <<= 1;
  }

  m &= ~0x00800000; // clear leading 1 bit

  _e += 0x38800000; // adjust bias

  mantissaTable[_i] = m | _e;
}

for (var _i2 = 1024; _i2 < 2048; ++_i2) {
  mantissaTable[_i2] = 0x38000000 + (_i2 - 1024 << 13);
}

exponentTable[0] = 0;

for (var _i3 = 1; _i3 < 31; ++_i3) {
  exponentTable[_i3] = _i3 << 23;
}

exponentTable[31] = 0x47800000;
exponentTable[32] = 0x80000000;

for (var _i4 = 33; _i4 < 63; ++_i4) {
  exponentTable[_i4] = 0x80000000 + (_i4 - 32 << 23);
}

exponentTable[63] = 0xc7800000;
offsetTable[0] = 0;

for (var _i5 = 1; _i5 < 64; ++_i5) {
  if (_i5 === 32) {
    offsetTable[_i5] = 0;
  } else {
    offsetTable[_i5] = 1024;
  }
}
/**
 * convert a half float number bits to a number.
 * @param {number} float16bits - half float number bits
 * @returns {number} double float
 */


function convertToNumber(float16bits) {
  var m = float16bits >> 10;
  uint32View[0] = mantissaTable[offsetTable[m] + (float16bits & 0x3ff)] + exponentTable[m];
  return floatView[0];
}

/***/ }),

/***/ "./node_modules/@petamoriken/float16/src/helper/is.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/helper/is.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isObject": function() { return /* binding */ isObject; },
/* harmony export */   "isObjectLike": function() { return /* binding */ isObjectLike; },
/* harmony export */   "isTypedArray": function() { return /* binding */ isTypedArray; },
/* harmony export */   "isUint16Array": function() { return /* binding */ isUint16Array; },
/* harmony export */   "isDataView": function() { return /* binding */ isDataView; },
/* harmony export */   "isArrayBuffer": function() { return /* binding */ isArrayBuffer; },
/* harmony export */   "isSharedArrayBuffer": function() { return /* binding */ isSharedArrayBuffer; },
/* harmony export */   "isIterable": function() { return /* binding */ isIterable; },
/* harmony export */   "isOrdinaryArray": function() { return /* binding */ isOrdinaryArray; },
/* harmony export */   "isOrdinaryTypedArray": function() { return /* binding */ isOrdinaryTypedArray; },
/* harmony export */   "isCanonicalIntegerIndexString": function() { return /* binding */ isCanonicalIntegerIndexString; }
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * @param {unknown} value
 * @returns {value is object}
 */
function isObject(value) {
  return value !== null && _typeof(value) === "object" || typeof value === "function";
}
/**
 * @param {unknown} value
 * @returns {value is object}
 */

function isObjectLike(value) {
  return value !== null && _typeof(value) === "object";
} // Inspired by util.types implementation of Node.js

var TypedArrayPrototype = Reflect.getPrototypeOf(Uint8Array).prototype;
var getTypedArrayPrototypeSybolToStringTag = Reflect.getOwnPropertyDescriptor(TypedArrayPrototype, Symbol.toStringTag).get;
/**
 * @param {unknown} value
 * @returns {value is Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array}
 */

function isTypedArray(value) {
  return getTypedArrayPrototypeSybolToStringTag.call(value) !== undefined;
}
/**
 * @param {unknown} value
 * @returns {value is Uint16Array}
 */

function isUint16Array(value) {
  return getTypedArrayPrototypeSybolToStringTag.call(value) === "Uint16Array";
}
var toString = Object.prototype.toString;
/**
 * @param {unknown} value
 * @returns {value is DataView}
 */

function isDataView(value) {
  if (!ArrayBuffer.isView(value)) {
    return false;
  }

  if (isTypedArray(value)) {
    return false;
  }

  if (toString.call(value) !== "[object DataView]") {
    return false;
  }

  return true;
}
/**
 * @param {unknown} value
 * @returns {value is ArrayBuffer}
 */

function isArrayBuffer(value) {
  return isObjectLike(value) && toString.call(value) === "[object ArrayBuffer]";
}
/**
 * @param {unknown} value
 * @returns {value is SharedArrayBuffer}
 */

function isSharedArrayBuffer(value) {
  return isObjectLike(value) && toString.call(value) === "[object SharedArrayBuffer]";
}
/**
 * @param {unknown} value
 * @returns {value is Iterable}
 */

function isIterable(value) {
  return isObject(value) && typeof value[Symbol.iterator] === "function";
}
/**
 * @param {unknown} value
 * @returns {value is any[]}
 */

function isOrdinaryArray(value) {
  if (!Array.isArray(value)) {
    return false;
  }

  var iterator = value[Symbol.iterator]();

  if (toString.call(iterator) !== "[object Array Iterator]") {
    return false;
  }

  return true;
}
/**
 * @param {unknown} value
 * @returns {value is any[]}
 */

function isOrdinaryTypedArray(value) {
  if (!isTypedArray(value)) {
    return false;
  }

  var iterator = value[Symbol.iterator]();

  if (toString.call(iterator) !== "[object Array Iterator]") {
    return false;
  }

  return true;
}
/**
 * @param {unknown} value
 * @returns {value is string}
 */

function isCanonicalIntegerIndexString(value) {
  if (typeof value !== "string") {
    return false;
  }

  var number = Number(value);

  if (value !== number + "") {
    return false;
  }

  if (!Number.isFinite(number)) {
    return false;
  }

  if (number !== Math.trunc(number)) {
    return false;
  }

  return true;
}

/***/ }),

/***/ "./node_modules/geotiff/dist-module/compression/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addDecoder": function() { return /* binding */ addDecoder; },
/* harmony export */   "getDecoder": function() { return /* binding */ getDecoder; }
/* harmony export */ });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var registry = new Map();
function addDecoder(cases, importFn) {
  if (!Array.isArray(cases)) {
    cases = [cases]; // eslint-disable-line no-param-reassign
  }

  cases.forEach(function (c) {
    return registry.set(c, importFn);
  });
}
function getDecoder(_x) {
  return _getDecoder.apply(this, arguments);
} // Add default decoders to registry (end-user may override with other implementations)

function _getDecoder() {
  _getDecoder = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(fileDirectory) {
    var importFn, Decoder;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            importFn = registry.get(fileDirectory.Compression);

            if (importFn) {
              _context.next = 3;
              break;
            }

            throw new Error("Unknown compression method identifier: ".concat(fileDirectory.Compression));

          case 3:
            _context.next = 5;
            return importFn();

          case 5:
            Decoder = _context.sent;
            return _context.abrupt("return", new Decoder(fileDirectory));

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getDecoder.apply(this, arguments);
}

addDecoder([undefined, 1], function () {
  return __webpack_require__.e(/*! import() */ "node_modules_geotiff_dist-module_compression_raw_js").then(__webpack_require__.bind(__webpack_require__, /*! ./raw.js */ "./node_modules/geotiff/dist-module/compression/raw.js")).then(function (m) {
    return m.default;
  });
});
addDecoder(5, function () {
  return __webpack_require__.e(/*! import() */ "vendors-node_modules_geotiff_dist-module_compression_lzw_js").then(__webpack_require__.bind(__webpack_require__, /*! ./lzw.js */ "./node_modules/geotiff/dist-module/compression/lzw.js")).then(function (m) {
    return m.default;
  });
});
addDecoder(6, function () {
  throw new Error('old style JPEG compression is not supported.');
});
addDecoder(7, function () {
  return __webpack_require__.e(/*! import() */ "vendors-node_modules_geotiff_dist-module_compression_jpeg_js").then(__webpack_require__.bind(__webpack_require__, /*! ./jpeg.js */ "./node_modules/geotiff/dist-module/compression/jpeg.js")).then(function (m) {
    return m.default;
  });
});
addDecoder([8, 32946], function () {
  return Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_geotiff_dist-module_compression_basedecoder_js-node_modules_pako_dist_pa-20f471"), __webpack_require__.e("node_modules_geotiff_dist-module_compression_deflate_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ./deflate.js */ "./node_modules/geotiff/dist-module/compression/deflate.js")).then(function (m) {
    return m.default;
  });
});
addDecoder(32773, function () {
  return __webpack_require__.e(/*! import() */ "vendors-node_modules_geotiff_dist-module_compression_packbits_js").then(__webpack_require__.bind(__webpack_require__, /*! ./packbits.js */ "./node_modules/geotiff/dist-module/compression/packbits.js")).then(function (m) {
    return m.default;
  });
});
addDecoder(34887, function () {
  return Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_geotiff_dist-module_compression_basedecoder_js-node_modules_pako_dist_pa-20f471"), __webpack_require__.e("vendors-node_modules_geotiff_dist-module_compression_lerc_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ./lerc.js */ "./node_modules/geotiff/dist-module/compression/lerc.js")).then(function (m) {
    return m.default;
  });
});
addDecoder(50001, function () {
  return __webpack_require__.e(/*! import() */ "vendors-node_modules_geotiff_dist-module_compression_webimage_js").then(__webpack_require__.bind(__webpack_require__, /*! ./webimage.js */ "./node_modules/geotiff/dist-module/compression/webimage.js")).then(function (m) {
    return m.default;
  });
});

/***/ }),

/***/ "./node_modules/geotiff/dist-module/dataslice.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataslice.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ DataSlice; }
/* harmony export */ });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var DataSlice = /*#__PURE__*/function () {
  function DataSlice(arrayBuffer, sliceOffset, littleEndian, bigTiff) {
    _classCallCheck(this, DataSlice);

    this._dataView = new DataView(arrayBuffer);
    this._sliceOffset = sliceOffset;
    this._littleEndian = littleEndian;
    this._bigTiff = bigTiff;
  }

  _createClass(DataSlice, [{
    key: "sliceOffset",
    get: function get() {
      return this._sliceOffset;
    }
  }, {
    key: "sliceTop",
    get: function get() {
      return this._sliceOffset + this.buffer.byteLength;
    }
  }, {
    key: "littleEndian",
    get: function get() {
      return this._littleEndian;
    }
  }, {
    key: "bigTiff",
    get: function get() {
      return this._bigTiff;
    }
  }, {
    key: "buffer",
    get: function get() {
      return this._dataView.buffer;
    }
  }, {
    key: "covers",
    value: function covers(offset, length) {
      return this.sliceOffset <= offset && this.sliceTop >= offset + length;
    }
  }, {
    key: "readUint8",
    value: function readUint8(offset) {
      return this._dataView.getUint8(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readInt8",
    value: function readInt8(offset) {
      return this._dataView.getInt8(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readUint16",
    value: function readUint16(offset) {
      return this._dataView.getUint16(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readInt16",
    value: function readInt16(offset) {
      return this._dataView.getInt16(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readUint32",
    value: function readUint32(offset) {
      return this._dataView.getUint32(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readInt32",
    value: function readInt32(offset) {
      return this._dataView.getInt32(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readFloat32",
    value: function readFloat32(offset) {
      return this._dataView.getFloat32(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readFloat64",
    value: function readFloat64(offset) {
      return this._dataView.getFloat64(offset - this._sliceOffset, this._littleEndian);
    }
  }, {
    key: "readUint64",
    value: function readUint64(offset) {
      var left = this.readUint32(offset);
      var right = this.readUint32(offset + 4);
      var combined;

      if (this._littleEndian) {
        combined = left + Math.pow(2, 32) * right;

        if (!Number.isSafeInteger(combined)) {
          throw new Error("".concat(combined, " exceeds MAX_SAFE_INTEGER. ") + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues');
        }

        return combined;
      }

      combined = Math.pow(2, 32) * left + right;

      if (!Number.isSafeInteger(combined)) {
        throw new Error("".concat(combined, " exceeds MAX_SAFE_INTEGER. ") + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues');
      }

      return combined;
    } // adapted from https://stackoverflow.com/a/55338384/8060591

  }, {
    key: "readInt64",
    value: function readInt64(offset) {
      var value = 0;
      var isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80) > 0;
      var carrying = true;

      for (var i = 0; i < 8; i++) {
        var byte = this._dataView.getUint8(offset + (this._littleEndian ? i : 7 - i));

        if (isNegative) {
          if (carrying) {
            if (byte !== 0x00) {
              byte = ~(byte - 1) & 0xff;
              carrying = false;
            }
          } else {
            byte = ~byte & 0xff;
          }
        }

        value += byte * Math.pow(256, i);
      }

      if (isNegative) {
        value = -value;
      }

      return value;
    }
  }, {
    key: "readOffset",
    value: function readOffset(offset) {
      if (this._bigTiff) {
        return this.readUint64(offset);
      }

      return this.readUint32(offset);
    }
  }]);

  return DataSlice;
}();



/***/ }),

/***/ "./node_modules/geotiff/dist-module/dataview64.js":
/*!********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataview64.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ DataView64; }
/* harmony export */ });
/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @petamoriken/float16 */ "./node_modules/@petamoriken/float16/src/DataView.mjs");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }



var DataView64 = /*#__PURE__*/function () {
  function DataView64(arrayBuffer) {
    _classCallCheck(this, DataView64);

    this._dataView = new DataView(arrayBuffer);
  }

  _createClass(DataView64, [{
    key: "buffer",
    get: function get() {
      return this._dataView.buffer;
    }
  }, {
    key: "getUint64",
    value: function getUint64(offset, littleEndian) {
      var left = this.getUint32(offset, littleEndian);
      var right = this.getUint32(offset + 4, littleEndian);
      var combined;

      if (littleEndian) {
        combined = left + Math.pow(2, 32) * right;

        if (!Number.isSafeInteger(combined)) {
          throw new Error("".concat(combined, " exceeds MAX_SAFE_INTEGER. ") + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues');
        }

        return combined;
      }

      combined = Math.pow(2, 32) * left + right;

      if (!Number.isSafeInteger(combined)) {
        throw new Error("".concat(combined, " exceeds MAX_SAFE_INTEGER. ") + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues');
      }

      return combined;
    } // adapted from https://stackoverflow.com/a/55338384/8060591

  }, {
    key: "getInt64",
    value: function getInt64(offset, littleEndian) {
      var value = 0;
      var isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;
      var carrying = true;

      for (var i = 0; i < 8; i++) {
        var byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));

        if (isNegative) {
          if (carrying) {
            if (byte !== 0x00) {
              byte = ~(byte - 1) & 0xff;
              carrying = false;
            }
          } else {
            byte = ~byte & 0xff;
          }
        }

        value += byte * Math.pow(256, i);
      }

      if (isNegative) {
        value = -value;
      }

      return value;
    }
  }, {
    key: "getUint8",
    value: function getUint8(offset, littleEndian) {
      return this._dataView.getUint8(offset, littleEndian);
    }
  }, {
    key: "getInt8",
    value: function getInt8(offset, littleEndian) {
      return this._dataView.getInt8(offset, littleEndian);
    }
  }, {
    key: "getUint16",
    value: function getUint16(offset, littleEndian) {
      return this._dataView.getUint16(offset, littleEndian);
    }
  }, {
    key: "getInt16",
    value: function getInt16(offset, littleEndian) {
      return this._dataView.getInt16(offset, littleEndian);
    }
  }, {
    key: "getUint32",
    value: function getUint32(offset, littleEndian) {
      return this._dataView.getUint32(offset, littleEndian);
    }
  }, {
    key: "getInt32",
    value: function getInt32(offset, littleEndian) {
      return this._dataView.getInt32(offset, littleEndian);
    }
  }, {
    key: "getFloat16",
    value: function getFloat16(offset, littleEndian) {
      return (0,_petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__.getFloat16)(this._dataView, offset, littleEndian);
    }
  }, {
    key: "getFloat32",
    value: function getFloat32(offset, littleEndian) {
      return this._dataView.getFloat32(offset, littleEndian);
    }
  }, {
    key: "getFloat64",
    value: function getFloat64(offset, littleEndian) {
      return this._dataView.getFloat64(offset, littleEndian);
    }
  }]);

  return DataView64;
}();



/***/ }),

/***/ "./node_modules/geotiff/dist-module/geotiff.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiff.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "globals": function() { return /* reexport module object */ _globals_js__WEBPACK_IMPORTED_MODULE_0__; },
/* harmony export */   "rgb": function() { return /* reexport module object */ _rgb_js__WEBPACK_IMPORTED_MODULE_1__; },
/* harmony export */   "getDecoder": function() { return /* reexport safe */ _compression_index_js__WEBPACK_IMPORTED_MODULE_2__.getDecoder; },
/* harmony export */   "addDecoder": function() { return /* reexport safe */ _compression_index_js__WEBPACK_IMPORTED_MODULE_2__.addDecoder; },
/* harmony export */   "setLogger": function() { return /* reexport safe */ _logging_js__WEBPACK_IMPORTED_MODULE_3__.setLogger; },
/* harmony export */   "GeoTIFF": function() { return /* binding */ GeoTIFF; },
/* harmony export */   "MultiGeoTIFF": function() { return /* binding */ MultiGeoTIFF; },
/* harmony export */   "fromUrl": function() { return /* binding */ fromUrl; },
/* harmony export */   "fromArrayBuffer": function() { return /* binding */ fromArrayBuffer; },
/* harmony export */   "fromFile": function() { return /* binding */ fromFile; },
/* harmony export */   "fromBlob": function() { return /* binding */ fromBlob; },
/* harmony export */   "fromUrls": function() { return /* binding */ fromUrls; },
/* harmony export */   "writeArrayBuffer": function() { return /* binding */ writeArrayBuffer; },
/* harmony export */   "Pool": function() { return /* reexport safe */ _pool_js__WEBPACK_IMPORTED_MODULE_12__["default"]; },
/* harmony export */   "GeoTIFFImage": function() { return /* reexport safe */ _geotiffimage_js__WEBPACK_IMPORTED_MODULE_5__["default"]; }
/* harmony export */ });
/* harmony import */ var _geotiffimage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./geotiffimage.js */ "./node_modules/geotiff/dist-module/geotiffimage.js");
/* harmony import */ var _dataview64_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dataview64.js */ "./node_modules/geotiff/dist-module/dataview64.js");
/* harmony import */ var _dataslice_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dataslice.js */ "./node_modules/geotiff/dist-module/dataslice.js");
/* harmony import */ var _pool_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./pool.js */ "./node_modules/geotiff/dist-module/pool.js");
/* harmony import */ var _source_remote_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./source/remote.js */ "./node_modules/geotiff/dist-module/source/remote.js");
/* harmony import */ var _source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./source/arraybuffer.js */ "./node_modules/geotiff/dist-module/source/arraybuffer.js");
/* harmony import */ var _source_filereader_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./source/filereader.js */ "./node_modules/geotiff/dist-module/source/filereader.js");
/* harmony import */ var _source_file_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./source/file.js */ "./node_modules/geotiff/dist-module/source/file.js");
/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.js */ "./node_modules/geotiff/dist-module/globals.js");
/* harmony import */ var _geotiffwriter_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./geotiffwriter.js */ "./node_modules/geotiff/dist-module/geotiffwriter.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/geotiff/dist-module/rgb.js");
/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compression/index.js */ "./node_modules/geotiff/dist-module/compression/index.js");
/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./logging.js */ "./node_modules/geotiff/dist-module/logging.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** @module geotiff */


















/**
 * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}
 * TypedArray
 */

function getFieldTypeLength(fieldType) {
  switch (fieldType) {
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.BYTE:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SBYTE:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.UNDEFINED:
      return 1;

    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SHORT:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SSHORT:
      return 2;

    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.FLOAT:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD:
      return 4;

    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.DOUBLE:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG8:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG8:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD8:
      return 8;

    default:
      throw new RangeError("Invalid field type: ".concat(fieldType));
  }
}

function parseGeoKeyDirectory(fileDirectory) {
  var rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;

  if (!rawGeoKeyDirectory) {
    return null;
  }

  var geoKeyDirectory = {};

  for (var i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {
    var key = _globals_js__WEBPACK_IMPORTED_MODULE_0__.geoKeyNames[rawGeoKeyDirectory[i]];
    var location = rawGeoKeyDirectory[i + 1] ? _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTagNames[rawGeoKeyDirectory[i + 1]] : null;
    var count = rawGeoKeyDirectory[i + 2];
    var offset = rawGeoKeyDirectory[i + 3];
    var value = null;

    if (!location) {
      value = offset;
    } else {
      value = fileDirectory[location];

      if (typeof value === 'undefined' || value === null) {
        throw new Error("Could not get value of geoKey '".concat(key, "'."));
      } else if (typeof value === 'string') {
        value = value.substring(offset, offset + count - 1);
      } else if (value.subarray) {
        value = value.subarray(offset, offset + count);

        if (count === 1) {
          value = value[0];
        }
      }
    }

    geoKeyDirectory[key] = value;
  }

  return geoKeyDirectory;
}

function getValues(dataSlice, fieldType, count, offset) {
  var values = null;
  var readMethod = null;
  var fieldTypeLength = getFieldTypeLength(fieldType);

  switch (fieldType) {
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.BYTE:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.UNDEFINED:
      values = new Uint8Array(count);
      readMethod = dataSlice.readUint8;
      break;

    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SBYTE:
      values = new Int8Array(count);
      readMethod = dataSlice.readInt8;
      break;

    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SHORT:
      values = new Uint16Array(count);
      readMethod = dataSlice.readUint16;
      break;

    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SSHORT:
      values = new Int16Array(count);
      readMethod = dataSlice.readInt16;
      break;

    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD:
      values = new Uint32Array(count);
      readMethod = dataSlice.readUint32;
      break;

    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG:
      values = new Int32Array(count);
      readMethod = dataSlice.readInt32;
      break;

    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG8:
    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD8:
      values = new Array(count);
      readMethod = dataSlice.readUint64;
      break;

    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG8:
      values = new Array(count);
      readMethod = dataSlice.readInt64;
      break;

    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL:
      values = new Uint32Array(count * 2);
      readMethod = dataSlice.readUint32;
      break;

    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL:
      values = new Int32Array(count * 2);
      readMethod = dataSlice.readInt32;
      break;

    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.FLOAT:
      values = new Float32Array(count);
      readMethod = dataSlice.readFloat32;
      break;

    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.DOUBLE:
      values = new Float64Array(count);
      readMethod = dataSlice.readFloat64;
      break;

    default:
      throw new RangeError("Invalid field type: ".concat(fieldType));
  } // normal fields


  if (!(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL)) {
    for (var i = 0; i < count; ++i) {
      values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);
    }
  } else {
    // RATIONAL or SRATIONAL
    for (var _i = 0; _i < count; _i += 2) {
      values[_i] = readMethod.call(dataSlice, offset + _i * fieldTypeLength);
      values[_i + 1] = readMethod.call(dataSlice, offset + (_i * fieldTypeLength + 4));
    }
  }

  if (fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII) {
    return new TextDecoder('utf-8').decode(values);
  }

  return values;
}
/**
 * Data class to store the parsed file directory, geo key directory and
 * offset to the next IFD
 */


var ImageFileDirectory = /*#__PURE__*/_createClass(function ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {
  _classCallCheck(this, ImageFileDirectory);

  this.fileDirectory = fileDirectory;
  this.geoKeyDirectory = geoKeyDirectory;
  this.nextIFDByteOffset = nextIFDByteOffset;
});
/**
 * Error class for cases when an IFD index was requested, that does not exist
 * in the file.
 */


var GeoTIFFImageIndexError = /*#__PURE__*/function (_Error) {
  _inherits(GeoTIFFImageIndexError, _Error);

  var _super = _createSuper(GeoTIFFImageIndexError);

  function GeoTIFFImageIndexError(index) {
    var _this;

    _classCallCheck(this, GeoTIFFImageIndexError);

    _this = _super.call(this, "No image at index ".concat(index));
    _this.index = index;
    return _this;
  }

  return _createClass(GeoTIFFImageIndexError);
}( /*#__PURE__*/_wrapNativeSuper(Error));

var GeoTIFFBase = /*#__PURE__*/function () {
  function GeoTIFFBase() {
    _classCallCheck(this, GeoTIFFBase);
  }

  _createClass(GeoTIFFBase, [{
    key: "readRasters",
    value:
    /**
     * (experimental) Reads raster data from the best fitting image. This function uses
     * the image with the lowest resolution that is still a higher resolution than the
     * requested resolution.
     * When specified, the `bbox` option is translated to the `window` option and the
     * `resX` and `resY` to `width` and `height` respectively.
     * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected
     * image is called and the result returned.
     * @see GeoTIFFImage.readRasters
     * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters
     * @returns {Promise<(TypedArray|TypedArray[])>} the decoded arrays as a promise
     */
    function () {
      var _readRasters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var options,
            imageWindow,
            width,
            height,
            resX,
            resY,
            bbox,
            firstImage,
            usedImage,
            imageCount,
            imgBBox,
            _firstImage$getOrigin,
            _firstImage$getOrigin2,
            oX,
            oY,
            _firstImage$getResolu,
            _firstImage$getResolu2,
            rX,
            rY,
            usedBBox,
            allImages,
            i,
            image,
            _image$fileDirectory,
            subfileType,
            newSubfileType,
            _i2,
            _image,
            imgResX,
            imgResY,
            wnd,
            _firstImage$getOrigin3,
            _firstImage$getOrigin4,
            _oX,
            _oY,
            _usedImage$getResolut,
            _usedImage$getResolut2,
            imageResX,
            imageResY,
            _args = arguments;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
                imageWindow = options.window, width = options.width, height = options.height;
                resX = options.resX, resY = options.resY, bbox = options.bbox;
                _context.next = 5;
                return this.getImage();

              case 5:
                firstImage = _context.sent;
                usedImage = firstImage;
                _context.next = 9;
                return this.getImageCount();

              case 9:
                imageCount = _context.sent;
                imgBBox = firstImage.getBoundingBox();

                if (!(imageWindow && bbox)) {
                  _context.next = 13;
                  break;
                }

                throw new Error('Both "bbox" and "window" passed.');

              case 13:
                if (!(width || height)) {
                  _context.next = 24;
                  break;
                }

                // if we have an image window (pixel coordinates), transform it to a BBox
                // using the origin/resolution of the first image.
                if (imageWindow) {
                  _firstImage$getOrigin = firstImage.getOrigin(), _firstImage$getOrigin2 = _slicedToArray(_firstImage$getOrigin, 2), oX = _firstImage$getOrigin2[0], oY = _firstImage$getOrigin2[1];
                  _firstImage$getResolu = firstImage.getResolution(), _firstImage$getResolu2 = _slicedToArray(_firstImage$getResolu, 2), rX = _firstImage$getResolu2[0], rY = _firstImage$getResolu2[1];
                  bbox = [oX + imageWindow[0] * rX, oY + imageWindow[1] * rY, oX + imageWindow[2] * rX, oY + imageWindow[3] * rY];
                } // if we have a bbox (or calculated one)


                usedBBox = bbox || imgBBox;

                if (!width) {
                  _context.next = 20;
                  break;
                }

                if (!resX) {
                  _context.next = 19;
                  break;
                }

                throw new Error('Both width and resX passed');

              case 19:
                resX = (usedBBox[2] - usedBBox[0]) / width;

              case 20:
                if (!height) {
                  _context.next = 24;
                  break;
                }

                if (!resY) {
                  _context.next = 23;
                  break;
                }

                throw new Error('Both width and resY passed');

              case 23:
                resY = (usedBBox[3] - usedBBox[1]) / height;

              case 24:
                if (!(resX || resY)) {
                  _context.next = 48;
                  break;
                }

                allImages = [];
                i = 0;

              case 27:
                if (!(i < imageCount)) {
                  _context.next = 36;
                  break;
                }

                _context.next = 30;
                return this.getImage(i);

              case 30:
                image = _context.sent;
                _image$fileDirectory = image.fileDirectory, subfileType = _image$fileDirectory.SubfileType, newSubfileType = _image$fileDirectory.NewSubfileType;

                if (i === 0 || subfileType === 2 || newSubfileType & 1) {
                  allImages.push(image);
                }

              case 33:
                ++i;
                _context.next = 27;
                break;

              case 36:
                allImages.sort(function (a, b) {
                  return a.getWidth() - b.getWidth();
                });
                _i2 = 0;

              case 38:
                if (!(_i2 < allImages.length)) {
                  _context.next = 48;
                  break;
                }

                _image = allImages[_i2];
                imgResX = (imgBBox[2] - imgBBox[0]) / _image.getWidth();
                imgResY = (imgBBox[3] - imgBBox[1]) / _image.getHeight();
                usedImage = _image;

                if (!(resX && resX > imgResX || resY && resY > imgResY)) {
                  _context.next = 45;
                  break;
                }

                return _context.abrupt("break", 48);

              case 45:
                ++_i2;
                _context.next = 38;
                break;

              case 48:
                wnd = imageWindow;

                if (bbox) {
                  _firstImage$getOrigin3 = firstImage.getOrigin(), _firstImage$getOrigin4 = _slicedToArray(_firstImage$getOrigin3, 2), _oX = _firstImage$getOrigin4[0], _oY = _firstImage$getOrigin4[1];
                  _usedImage$getResolut = usedImage.getResolution(firstImage), _usedImage$getResolut2 = _slicedToArray(_usedImage$getResolut, 2), imageResX = _usedImage$getResolut2[0], imageResY = _usedImage$getResolut2[1];
                  wnd = [Math.round((bbox[0] - _oX) / imageResX), Math.round((bbox[1] - _oY) / imageResY), Math.round((bbox[2] - _oX) / imageResX), Math.round((bbox[3] - _oY) / imageResY)];
                  wnd = [Math.min(wnd[0], wnd[2]), Math.min(wnd[1], wnd[3]), Math.max(wnd[0], wnd[2]), Math.max(wnd[1], wnd[3])];
                }

                return _context.abrupt("return", usedImage.readRasters(_objectSpread(_objectSpread({}, options), {}, {
                  window: wnd
                })));

              case 51:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function readRasters() {
        return _readRasters.apply(this, arguments);
      }

      return readRasters;
    }()
  }]);

  return GeoTIFFBase;
}();
/**
 * @typedef {Object} GeoTIFFOptions
 * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.
 */

/**
 * The abstraction for a whole GeoTIFF file.
 * @augments GeoTIFFBase
 */


var GeoTIFF = /*#__PURE__*/function (_GeoTIFFBase) {
  _inherits(GeoTIFF, _GeoTIFFBase);

  var _super2 = _createSuper(GeoTIFF);

  /**
   * @constructor
   * @param {*} source The datasource to read from.
   * @param {boolean} littleEndian Whether the image uses little endian.
   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.
   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image
   *                                to the first IFD.
   * @param {GeoTIFFOptions} [options] further options.
   */
  function GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset) {
    var _this2;

    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    _classCallCheck(this, GeoTIFF);

    _this2 = _super2.call(this);
    _this2.source = source;
    _this2.littleEndian = littleEndian;
    _this2.bigTiff = bigTiff;
    _this2.firstIFDOffset = firstIFDOffset;
    _this2.cache = options.cache || false;
    _this2.ifdRequests = [];
    _this2.ghostValues = null;
    return _this2;
  }

  _createClass(GeoTIFF, [{
    key: "getSlice",
    value: function () {
      var _getSlice = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(offset, size) {
        var fallbackSize;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                fallbackSize = this.bigTiff ? 4048 : 1024;
                _context2.t0 = _dataslice_js__WEBPACK_IMPORTED_MODULE_4__["default"];
                _context2.next = 4;
                return this.source.fetch([{
                  offset: offset,
                  length: typeof size !== 'undefined' ? size : fallbackSize
                }]);

              case 4:
                _context2.t1 = _context2.sent[0];
                _context2.t2 = offset;
                _context2.t3 = this.littleEndian;
                _context2.t4 = this.bigTiff;
                return _context2.abrupt("return", new _context2.t0(_context2.t1, _context2.t2, _context2.t3, _context2.t4));

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getSlice(_x, _x2) {
        return _getSlice.apply(this, arguments);
      }

      return getSlice;
    }()
    /**
     * Instructs to parse an image file directory at the given file offset.
     * As there is no way to ensure that a location is indeed the start of an IFD,
     * this function must be called with caution (e.g only using the IFD offsets from
     * the headers or other IFDs).
     * @param {number} offset the offset to parse the IFD at
     * @returns {Promise<ImageFileDirectory>} the parsed IFD
     */

  }, {
    key: "parseFileDirectoryAt",
    value: function () {
      var _parseFileDirectoryAt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(offset) {
        var entrySize, offsetSize, dataSlice, numDirEntries, byteSize, fileDirectory, i, entryCount, fieldTag, fieldType, typeCount, fieldValues, value, fieldTypeLength, valueOffset, actualOffset, length, fieldDataSlice, geoKeyDirectory, nextIFDByteOffset;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                entrySize = this.bigTiff ? 20 : 12;
                offsetSize = this.bigTiff ? 8 : 2;
                _context3.next = 4;
                return this.getSlice(offset);

              case 4:
                dataSlice = _context3.sent;
                numDirEntries = this.bigTiff ? dataSlice.readUint64(offset) : dataSlice.readUint16(offset); // if the slice does not cover the whole IFD, request a bigger slice, where the
                // whole IFD fits: num of entries + n x tag length + offset to next IFD

                byteSize = numDirEntries * entrySize + (this.bigTiff ? 16 : 6);

                if (dataSlice.covers(offset, byteSize)) {
                  _context3.next = 11;
                  break;
                }

                _context3.next = 10;
                return this.getSlice(offset, byteSize);

              case 10:
                dataSlice = _context3.sent;

              case 11:
                fileDirectory = {}; // loop over the IFD and create a file directory object

                i = offset + (this.bigTiff ? 8 : 2);
                entryCount = 0;

              case 14:
                if (!(entryCount < numDirEntries)) {
                  _context3.next = 41;
                  break;
                }

                fieldTag = dataSlice.readUint16(i);
                fieldType = dataSlice.readUint16(i + 2);
                typeCount = this.bigTiff ? dataSlice.readUint64(i + 4) : dataSlice.readUint32(i + 4);
                fieldValues = void 0;
                value = void 0;
                fieldTypeLength = getFieldTypeLength(fieldType);
                valueOffset = i + (this.bigTiff ? 12 : 8); // check whether the value is directly encoded in the tag or refers to a
                // different external byte range

                if (!(fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4))) {
                  _context3.next = 26;
                  break;
                }

                fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);
                _context3.next = 36;
                break;

              case 26:
                // resolve the reference to the actual byte range
                actualOffset = dataSlice.readOffset(valueOffset);
                length = getFieldTypeLength(fieldType) * typeCount; // check, whether we actually cover the referenced byte range; if not,
                // request a new slice of bytes to read from it

                if (!dataSlice.covers(actualOffset, length)) {
                  _context3.next = 32;
                  break;
                }

                fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);
                _context3.next = 36;
                break;

              case 32:
                _context3.next = 34;
                return this.getSlice(actualOffset, length);

              case 34:
                fieldDataSlice = _context3.sent;
                fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);

              case 36:
                // unpack single values from the array
                if (typeCount === 1 && _globals_js__WEBPACK_IMPORTED_MODULE_0__.arrayFields.indexOf(fieldTag) === -1 && !(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL)) {
                  value = fieldValues[0];
                } else {
                  value = fieldValues;
                } // write the tags value to the file directly


                fileDirectory[_globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTagNames[fieldTag]] = value;

              case 38:
                i += entrySize, ++entryCount;
                _context3.next = 14;
                break;

              case 41:
                geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);
                nextIFDByteOffset = dataSlice.readOffset(offset + offsetSize + entrySize * numDirEntries);
                return _context3.abrupt("return", new ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset));

              case 44:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function parseFileDirectoryAt(_x3) {
        return _parseFileDirectoryAt.apply(this, arguments);
      }

      return parseFileDirectoryAt;
    }()
  }, {
    key: "requestIFD",
    value: function () {
      var _requestIFD = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(index) {
        var _this3 = this;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this.ifdRequests[index]) {
                  _context5.next = 4;
                  break;
                }

                return _context5.abrupt("return", this.ifdRequests[index]);

              case 4:
                if (!(index === 0)) {
                  _context5.next = 9;
                  break;
                }

                // special case for index 0
                this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);
                return _context5.abrupt("return", this.ifdRequests[index]);

              case 9:
                if (this.ifdRequests[index - 1]) {
                  _context5.next = 19;
                  break;
                }

                _context5.prev = 10;
                this.ifdRequests[index - 1] = this.requestIFD(index - 1);
                _context5.next = 19;
                break;

              case 14:
                _context5.prev = 14;
                _context5.t0 = _context5["catch"](10);

                if (!(_context5.t0 instanceof GeoTIFFImageIndexError)) {
                  _context5.next = 18;
                  break;
                }

                throw new GeoTIFFImageIndexError(index);

              case 18:
                throw _context5.t0;

              case 19:
                // if the previous IFD was loaded, we can finally fetch the one we are interested in.
                // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed
                this.ifdRequests[index] = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
                  var previousIfd;
                  return regeneratorRuntime.wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          _context4.next = 2;
                          return _this3.ifdRequests[index - 1];

                        case 2:
                          previousIfd = _context4.sent;

                          if (!(previousIfd.nextIFDByteOffset === 0)) {
                            _context4.next = 5;
                            break;
                          }

                          throw new GeoTIFFImageIndexError(index);

                        case 5:
                          return _context4.abrupt("return", _this3.parseFileDirectoryAt(previousIfd.nextIFDByteOffset));

                        case 6:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                }))();
                return _context5.abrupt("return", this.ifdRequests[index]);

              case 21:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[10, 14]]);
      }));

      function requestIFD(_x4) {
        return _requestIFD.apply(this, arguments);
      }

      return requestIFD;
    }()
    /**
     * Get the n-th internal subfile of an image. By default, the first is returned.
     *
     * @param {number} [index=0] the index of the image to return.
     * @returns {Promise<GeoTIFFImage>} the image at the given index
     */

  }, {
    key: "getImage",
    value: function () {
      var _getImage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var index,
            ifd,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                index = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : 0;
                _context6.next = 3;
                return this.requestIFD(index);

              case 3:
                ifd = _context6.sent;
                return _context6.abrupt("return", new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_5__["default"](ifd.fileDirectory, ifd.geoKeyDirectory, this.dataView, this.littleEndian, this.cache, this.source));

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getImage() {
        return _getImage.apply(this, arguments);
      }

      return getImage;
    }()
    /**
     * Returns the count of the internal subfiles.
     *
     * @returns {Promise<number>} the number of internal subfile images
     */

  }, {
    key: "getImageCount",
    value: function () {
      var _getImageCount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var index, hasNext;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                index = 0; // loop until we run out of IFDs

                hasNext = true;

              case 2:
                if (!hasNext) {
                  _context7.next = 18;
                  break;
                }

                _context7.prev = 3;
                _context7.next = 6;
                return this.requestIFD(index);

              case 6:
                ++index;
                _context7.next = 16;
                break;

              case 9:
                _context7.prev = 9;
                _context7.t0 = _context7["catch"](3);

                if (!(_context7.t0 instanceof GeoTIFFImageIndexError)) {
                  _context7.next = 15;
                  break;
                }

                hasNext = false;
                _context7.next = 16;
                break;

              case 15:
                throw _context7.t0;

              case 16:
                _context7.next = 2;
                break;

              case 18:
                return _context7.abrupt("return", index);

              case 19:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[3, 9]]);
      }));

      function getImageCount() {
        return _getImageCount.apply(this, arguments);
      }

      return getImageCount;
    }()
    /**
     * Get the values of the COG ghost area as a parsed map.
     * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference
     * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found
     */

  }, {
    key: "getGhostValues",
    value: function () {
      var _getGhostValues = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var _this4 = this;

        var offset, detectionString, heuristicAreaSize, slice, valuesString, firstLine, metadataSize, fullString;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                offset = this.bigTiff ? 16 : 8;

                if (!this.ghostValues) {
                  _context8.next = 3;
                  break;
                }

                return _context8.abrupt("return", this.ghostValues);

              case 3:
                detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';
                heuristicAreaSize = detectionString.length + 100;
                _context8.next = 7;
                return this.getSlice(offset, heuristicAreaSize);

              case 7:
                slice = _context8.sent;

                if (!(detectionString === getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, detectionString.length, offset))) {
                  _context8.next = 19;
                  break;
                }

                valuesString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, heuristicAreaSize, offset);
                firstLine = valuesString.split('\n')[0];
                metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;

                if (!(metadataSize > heuristicAreaSize)) {
                  _context8.next = 16;
                  break;
                }

                _context8.next = 15;
                return this.getSlice(offset, metadataSize);

              case 15:
                slice = _context8.sent;

              case 16:
                fullString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, metadataSize, offset);
                this.ghostValues = {};
                fullString.split('\n').filter(function (line) {
                  return line.length > 0;
                }).map(function (line) {
                  return line.split('=');
                }).forEach(function (_ref2) {
                  var _ref3 = _slicedToArray(_ref2, 2),
                      key = _ref3[0],
                      value = _ref3[1];

                  _this4.ghostValues[key] = value;
                });

              case 19:
                return _context8.abrupt("return", this.ghostValues);

              case 20:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getGhostValues() {
        return _getGhostValues.apply(this, arguments);
      }

      return getGhostValues;
    }()
    /**
     * Parse a (Geo)TIFF file from the given source.
     *
     * @param {*} source The source of data to parse from.
     * @param {GeoTIFFOptions} [options] Additional options.
     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
     *                               to be aborted
     */

  }, {
    key: "close",
    value:
    /**
     * Closes the underlying file buffer
     * N.B. After the GeoTIFF has been completely processed it needs
     * to be closed but only if it has been constructed from a file.
     */
    function close() {
      if (typeof this.source.close === 'function') {
        return this.source.close();
      }

      return false;
    }
  }], [{
    key: "fromSource",
    value: function () {
      var _fromSource = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(source, options, signal) {
        var headerData, dataView, BOM, littleEndian, magicNumber, bigTiff, offsetByteSize, firstIFDOffset;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return source.fetch([{
                  offset: 0,
                  length: 1024
                }], signal);

              case 2:
                headerData = _context9.sent[0];
                dataView = new _dataview64_js__WEBPACK_IMPORTED_MODULE_6__["default"](headerData);
                BOM = dataView.getUint16(0, 0);

                if (!(BOM === 0x4949)) {
                  _context9.next = 9;
                  break;
                }

                littleEndian = true;
                _context9.next = 14;
                break;

              case 9:
                if (!(BOM === 0x4D4D)) {
                  _context9.next = 13;
                  break;
                }

                littleEndian = false;
                _context9.next = 14;
                break;

              case 13:
                throw new TypeError('Invalid byte order value.');

              case 14:
                magicNumber = dataView.getUint16(2, littleEndian);

                if (!(magicNumber === 42)) {
                  _context9.next = 19;
                  break;
                }

                bigTiff = false;
                _context9.next = 27;
                break;

              case 19:
                if (!(magicNumber === 43)) {
                  _context9.next = 26;
                  break;
                }

                bigTiff = true;
                offsetByteSize = dataView.getUint16(4, littleEndian);

                if (!(offsetByteSize !== 8)) {
                  _context9.next = 24;
                  break;
                }

                throw new Error('Unsupported offset byte-size.');

              case 24:
                _context9.next = 27;
                break;

              case 26:
                throw new TypeError('Invalid magic number.');

              case 27:
                firstIFDOffset = bigTiff ? dataView.getUint64(8, littleEndian) : dataView.getUint32(4, littleEndian);
                return _context9.abrupt("return", new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options));

              case 29:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));

      function fromSource(_x5, _x6, _x7) {
        return _fromSource.apply(this, arguments);
      }

      return fromSource;
    }()
  }]);

  return GeoTIFF;
}(GeoTIFFBase);


/* harmony default export */ __webpack_exports__["default"] = (GeoTIFF);
/**
 * Wrapper for GeoTIFF files that have external overviews.
 * @augments GeoTIFFBase
 */

var MultiGeoTIFF = /*#__PURE__*/function (_GeoTIFFBase2) {
  _inherits(MultiGeoTIFF, _GeoTIFFBase2);

  var _super3 = _createSuper(MultiGeoTIFF);

  /**
   * Construct a new MultiGeoTIFF from a main and several overview files.
   * @param {GeoTIFF} mainFile The main GeoTIFF file.
   * @param {GeoTIFF[]} overviewFiles An array of overview files.
   */
  function MultiGeoTIFF(mainFile, overviewFiles) {
    var _this5;

    _classCallCheck(this, MultiGeoTIFF);

    _this5 = _super3.call(this);
    _this5.mainFile = mainFile;
    _this5.overviewFiles = overviewFiles;
    _this5.imageFiles = [mainFile].concat(overviewFiles);
    _this5.fileDirectoriesPerFile = null;
    _this5.fileDirectoriesPerFileParsing = null;
    _this5.imageCount = null;
    return _this5;
  }

  _createClass(MultiGeoTIFF, [{
    key: "parseFileDirectoriesPerFile",
    value: function () {
      var _parseFileDirectoriesPerFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var requests;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map(function (file) {
                  return file.parseFileDirectoryAt(file.firstIFDOffset);
                }));
                _context10.next = 3;
                return Promise.all(requests);

              case 3:
                this.fileDirectoriesPerFile = _context10.sent;
                return _context10.abrupt("return", this.fileDirectoriesPerFile);

              case 5:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function parseFileDirectoriesPerFile() {
        return _parseFileDirectoriesPerFile.apply(this, arguments);
      }

      return parseFileDirectoriesPerFile;
    }()
    /**
     * Get the n-th internal subfile of an image. By default, the first is returned.
     *
     * @param {number} [index=0] the index of the image to return.
     * @returns {Promise<GeoTIFFImage>} the image at the given index
     */

  }, {
    key: "getImage",
    value: function () {
      var _getImage2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var index,
            visited,
            relativeIndex,
            i,
            imageFile,
            ii,
            ifd,
            _args11 = arguments;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                index = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : 0;
                _context11.next = 3;
                return this.getImageCount();

              case 3:
                _context11.next = 5;
                return this.parseFileDirectoriesPerFile();

              case 5:
                visited = 0;
                relativeIndex = 0;
                i = 0;

              case 8:
                if (!(i < this.imageFiles.length)) {
                  _context11.next = 26;
                  break;
                }

                imageFile = this.imageFiles[i];
                ii = 0;

              case 11:
                if (!(ii < this.imageCounts[i])) {
                  _context11.next = 22;
                  break;
                }

                if (!(index === visited)) {
                  _context11.next = 17;
                  break;
                }

                _context11.next = 15;
                return imageFile.requestIFD(relativeIndex);

              case 15:
                ifd = _context11.sent;
                return _context11.abrupt("return", new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_5__["default"](ifd.fileDirectory, ifd.geoKeyDirectory, imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source));

              case 17:
                visited++;
                relativeIndex++;

              case 19:
                ii++;
                _context11.next = 11;
                break;

              case 22:
                relativeIndex = 0;

              case 23:
                i++;
                _context11.next = 8;
                break;

              case 26:
                throw new RangeError('Invalid image index');

              case 27:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getImage() {
        return _getImage2.apply(this, arguments);
      }

      return getImage;
    }()
    /**
     * Returns the count of the internal subfiles.
     *
     * @returns {Promise<number>} the number of internal subfile images
     */

  }, {
    key: "getImageCount",
    value: function () {
      var _getImageCount2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var requests;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (!(this.imageCount !== null)) {
                  _context12.next = 2;
                  break;
                }

                return _context12.abrupt("return", this.imageCount);

              case 2:
                requests = [this.mainFile.getImageCount()].concat(this.overviewFiles.map(function (file) {
                  return file.getImageCount();
                }));
                _context12.next = 5;
                return Promise.all(requests);

              case 5:
                this.imageCounts = _context12.sent;
                this.imageCount = this.imageCounts.reduce(function (count, ifds) {
                  return count + ifds;
                }, 0);
                return _context12.abrupt("return", this.imageCount);

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getImageCount() {
        return _getImageCount2.apply(this, arguments);
      }

      return getImageCount;
    }()
  }]);

  return MultiGeoTIFF;
}(GeoTIFFBase);


/**
 * Creates a new GeoTIFF from a remote URL.
 * @param {string} url The URL to access the image from
 * @param {object} [options] Additional options to pass to the source.
 *                           See {@link makeRemoteSource} for details.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.
 */

function fromUrl(_x8) {
  return _fromUrl.apply(this, arguments);
}
/**
 * Construct a new GeoTIFF from an
 * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.
 * @param {ArrayBuffer} arrayBuffer The data to read the file from.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.
 */

function _fromUrl() {
  _fromUrl = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(url) {
    var options,
        signal,
        _args13 = arguments;
    return regeneratorRuntime.wrap(function _callee13$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            options = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : {};
            signal = _args13.length > 2 ? _args13[2] : undefined;
            return _context13.abrupt("return", GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_7__.makeRemoteSource)(url, options), signal));

          case 3:
          case "end":
            return _context13.stop();
        }
      }
    }, _callee13);
  }));
  return _fromUrl.apply(this, arguments);
}

function fromArrayBuffer(_x9, _x10) {
  return _fromArrayBuffer.apply(this, arguments);
}
/**
 * Construct a GeoTIFF from a local file path. This uses the node
 * [filesystem API]{@link https://nodejs.org/api/fs.html} and is
 * not available on browsers.
 *
 * N.B. After the GeoTIFF has been completely processed it needs
 * to be closed but only if it has been constructed from a file.
 * @param {string} path The file path to read from.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.
 */

function _fromArrayBuffer() {
  _fromArrayBuffer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(arrayBuffer, signal) {
    return regeneratorRuntime.wrap(function _callee14$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            return _context14.abrupt("return", GeoTIFF.fromSource((0,_source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_8__.makeBufferSource)(arrayBuffer), signal));

          case 1:
          case "end":
            return _context14.stop();
        }
      }
    }, _callee14);
  }));
  return _fromArrayBuffer.apply(this, arguments);
}

function fromFile(_x11, _x12) {
  return _fromFile.apply(this, arguments);
}
/**
 * Construct a GeoTIFF from an HTML
 * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or
 * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}
 * object.
 * @param {Blob|File} blob The Blob or File object to read from.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.
 */

function _fromFile() {
  _fromFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(path, signal) {
    return regeneratorRuntime.wrap(function _callee15$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            return _context15.abrupt("return", GeoTIFF.fromSource((0,_source_file_js__WEBPACK_IMPORTED_MODULE_9__.makeFileSource)(path), signal));

          case 1:
          case "end":
            return _context15.stop();
        }
      }
    }, _callee15);
  }));
  return _fromFile.apply(this, arguments);
}

function fromBlob(_x13, _x14) {
  return _fromBlob.apply(this, arguments);
}
/**
 * Construct a MultiGeoTIFF from the given URLs.
 * @param {string} mainUrl The URL for the main file.
 * @param {string[]} overviewUrls An array of URLs for the overview images.
 * @param {Object} [options] Additional options to pass to the source.
 *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}
 *                           for details.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.
 */

function _fromBlob() {
  _fromBlob = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(blob, signal) {
    return regeneratorRuntime.wrap(function _callee16$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            return _context16.abrupt("return", GeoTIFF.fromSource((0,_source_filereader_js__WEBPACK_IMPORTED_MODULE_10__.makeFileReaderSource)(blob), signal));

          case 1:
          case "end":
            return _context16.stop();
        }
      }
    }, _callee16);
  }));
  return _fromBlob.apply(this, arguments);
}

function fromUrls(_x15) {
  return _fromUrls.apply(this, arguments);
}
/**
 * Main creating function for GeoTIFF files.
 * @param {(Array)} array of pixel values
 * @returns {metadata} metadata
 */

function _fromUrls() {
  _fromUrls = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(mainUrl) {
    var overviewUrls,
        options,
        signal,
        mainFile,
        overviewFiles,
        _args17 = arguments;
    return regeneratorRuntime.wrap(function _callee17$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            overviewUrls = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : [];
            options = _args17.length > 2 && _args17[2] !== undefined ? _args17[2] : {};
            signal = _args17.length > 3 ? _args17[3] : undefined;
            _context17.next = 5;
            return GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_7__.makeRemoteSource)(mainUrl, options), signal);

          case 5:
            mainFile = _context17.sent;
            _context17.next = 8;
            return Promise.all(overviewUrls.map(function (url) {
              return GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_7__.makeRemoteSource)(url, options));
            }));

          case 8:
            overviewFiles = _context17.sent;
            return _context17.abrupt("return", new MultiGeoTIFF(mainFile, overviewFiles));

          case 10:
          case "end":
            return _context17.stop();
        }
      }
    }, _callee17);
  }));
  return _fromUrls.apply(this, arguments);
}

function writeArrayBuffer(values, metadata) {
  return (0,_geotiffwriter_js__WEBPACK_IMPORTED_MODULE_11__.writeGeotiff)(values, metadata);
}



/***/ }),

/***/ "./node_modules/geotiff/dist-module/geotiffimage.js":
/*!**********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffimage.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @petamoriken/float16 */ "./node_modules/@petamoriken/float16/src/DataView.mjs");
/* harmony import */ var xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xml-utils/get-attribute.js */ "./node_modules/xml-utils/get-attribute.js");
/* harmony import */ var xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xml-utils/find-tags-by-name.js */ "./node_modules/xml-utils/find-tags-by-name.js");
/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./globals.js */ "./node_modules/geotiff/dist-module/globals.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/geotiff/dist-module/rgb.js");
/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./compression/index.js */ "./node_modules/geotiff/dist-module/compression/index.js");
/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resample.js */ "./node_modules/geotiff/dist-module/resample.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/** @module geotiffimage */







/**
 * @typedef {Object} ReadRasterOptions
 * @property {Array<number>} [window=whole window] the subset to read data from in pixels.
 * @property {Array<number>} [bbox=whole image] the subset to read data from in
 *                                           geographical coordinates.
 * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.
 * @property {boolean} [interleave=false] whether the data shall be read
 *                                             in one single array or separate
 *                                             arrays.
 * @property {Pool} [pool=null] The optional decoder pool to use.
 * @property {number} [width] The desired width of the output. When the width is not the
 *                                 same as the images, resampling will be performed.
 * @property {number} [height] The desired height of the output. When the width is not the
 *                                  same as the images, resampling will be performed.
 * @property {string} [resampleMethod='nearest'] The desired resampling method.
 * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                                       to be aborted
 * @property {number|number[]} [fillValue] The value to use for parts of the image
 *                                              outside of the images extent. When multiple
 *                                              samples are requested, an array of fill values
 *                                              can be passed.
 */

/** @typedef {import("./geotiff.js").TypedArray} TypedArray */

function sum(array, start, end) {
  var s = 0;

  for (var i = start; i < end; ++i) {
    s += array[i];
  }

  return s;
}

function arrayForType(format, bitsPerSample, size) {
  switch (format) {
    case 1:
      // unsigned integer data
      if (bitsPerSample <= 8) {
        return new Uint8Array(size);
      } else if (bitsPerSample <= 16) {
        return new Uint16Array(size);
      } else if (bitsPerSample <= 32) {
        return new Uint32Array(size);
      }

      break;

    case 2:
      // twos complement signed integer data
      if (bitsPerSample === 8) {
        return new Int8Array(size);
      } else if (bitsPerSample === 16) {
        return new Int16Array(size);
      } else if (bitsPerSample === 32) {
        return new Int32Array(size);
      }

      break;

    case 3:
      // floating point data
      switch (bitsPerSample) {
        case 16:
        case 32:
          return new Float32Array(size);

        case 64:
          return new Float64Array(size);

        default:
          break;
      }

      break;

    default:
      break;
  }

  throw Error('Unsupported data format/bitsPerSample');
}

function needsNormalization(format, bitsPerSample) {
  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {
    return false;
  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {
    return false;
  }

  return true;
}

function normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {
  // const inByteArray = new Uint8Array(inBuffer);
  var view = new DataView(inBuffer);
  var outSize = planarConfiguration === 2 ? tileHeight * tileWidth : tileHeight * tileWidth * samplesPerPixel;
  var samplesToTransfer = planarConfiguration === 2 ? 1 : samplesPerPixel;
  var outArray = arrayForType(format, bitsPerSample, outSize); // let pixel = 0;

  var bitMask = parseInt('1'.repeat(bitsPerSample), 2);

  if (format === 1) {
    // unsigned integer
    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337
    var pixelBitSkip; // let sampleBitOffset = 0;

    if (planarConfiguration === 1) {
      pixelBitSkip = samplesPerPixel * bitsPerSample; // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;
    } else {
      pixelBitSkip = bitsPerSample;
    } // Bits per line rounds up to next byte boundary.


    var bitsPerLine = tileWidth * pixelBitSkip;

    if ((bitsPerLine & 7) !== 0) {
      bitsPerLine = bitsPerLine + 7 & ~7;
    }

    for (var y = 0; y < tileHeight; ++y) {
      var lineBitOffset = y * bitsPerLine;

      for (var x = 0; x < tileWidth; ++x) {
        var pixelBitOffset = lineBitOffset + x * samplesToTransfer * bitsPerSample;

        for (var i = 0; i < samplesToTransfer; ++i) {
          var bitOffset = pixelBitOffset + i * bitsPerSample;
          var outIndex = (y * tileWidth + x) * samplesToTransfer + i;
          var byteOffset = Math.floor(bitOffset / 8);
          var innerBitOffset = bitOffset % 8;

          if (innerBitOffset + bitsPerSample <= 8) {
            outArray[outIndex] = view.getUint8(byteOffset) >> 8 - bitsPerSample - innerBitOffset & bitMask;
          } else if (innerBitOffset + bitsPerSample <= 16) {
            outArray[outIndex] = view.getUint16(byteOffset) >> 16 - bitsPerSample - innerBitOffset & bitMask;
          } else if (innerBitOffset + bitsPerSample <= 24) {
            var raw = view.getUint16(byteOffset) << 8 | view.getUint8(byteOffset + 2);
            outArray[outIndex] = raw >> 24 - bitsPerSample - innerBitOffset & bitMask;
          } else {
            outArray[outIndex] = view.getUint32(byteOffset) >> 32 - bitsPerSample - innerBitOffset & bitMask;
          } // let outWord = 0;
          // for (let bit = 0; bit < bitsPerSample; ++bit) {
          //   if (inByteArray[bitOffset >> 3]
          //     & (0x80 >> (bitOffset & 7))) {
          //     outWord |= (1 << (bitsPerSample - 1 - bit));
          //   }
          //   ++bitOffset;
          // }
          // outArray[outIndex] = outWord;
          // outArray[pixel] = outWord;
          // pixel += 1;

        } // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;

      }
    }
  } else if (format === 3) {// floating point
    // Float16 is handled elsewhere
    // normalize 16/24 bit floats to 32 bit floats in the array
    // console.time();
    // if (bitsPerSample === 16) {
    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {
    //     outArray[outIndex] = getFloat16(view, byte);
    //   }
    // }
    // console.timeEnd()
  }

  return outArray.buffer;
}
/**
 * GeoTIFF sub-file image.
 */


var GeoTIFFImage = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Object} fileDirectory The parsed file directory
   * @param {Object} geoKeys The parsed geo-keys
   * @param {DataView} dataView The DataView for the underlying file.
   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian
   * @param {Boolean} cache Whether or not decoded tiles shall be cached
   * @param {Source} source The datasource to read from
   */
  function GeoTIFFImage(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {
    _classCallCheck(this, GeoTIFFImage);

    this.fileDirectory = fileDirectory;
    this.geoKeys = geoKeys;
    this.dataView = dataView;
    this.littleEndian = littleEndian;
    this.tiles = cache ? {} : null;
    this.isTiled = !fileDirectory.StripOffsets;
    var planarConfiguration = fileDirectory.PlanarConfiguration;
    this.planarConfiguration = typeof planarConfiguration === 'undefined' ? 1 : planarConfiguration;

    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {
      throw new Error('Invalid planar configuration.');
    }

    this.source = source;
  }
  /**
   * Returns the associated parsed file directory.
   * @returns {Object} the parsed file directory
   */


  _createClass(GeoTIFFImage, [{
    key: "getFileDirectory",
    value: function getFileDirectory() {
      return this.fileDirectory;
    }
    /**
     * Returns the associated parsed geo keys.
     * @returns {Object} the parsed geo keys
     */

  }, {
    key: "getGeoKeys",
    value: function getGeoKeys() {
      return this.geoKeys;
    }
    /**
     * Returns the width of the image.
     * @returns {Number} the width of the image
     */

  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.fileDirectory.ImageWidth;
    }
    /**
     * Returns the height of the image.
     * @returns {Number} the height of the image
     */

  }, {
    key: "getHeight",
    value: function getHeight() {
      return this.fileDirectory.ImageLength;
    }
    /**
     * Returns the number of samples per pixel.
     * @returns {Number} the number of samples per pixel
     */

  }, {
    key: "getSamplesPerPixel",
    value: function getSamplesPerPixel() {
      return typeof this.fileDirectory.SamplesPerPixel !== 'undefined' ? this.fileDirectory.SamplesPerPixel : 1;
    }
    /**
     * Returns the width of each tile.
     * @returns {Number} the width of each tile
     */

  }, {
    key: "getTileWidth",
    value: function getTileWidth() {
      return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();
    }
    /**
     * Returns the height of each tile.
     * @returns {Number} the height of each tile
     */

  }, {
    key: "getTileHeight",
    value: function getTileHeight() {
      if (this.isTiled) {
        return this.fileDirectory.TileLength;
      }

      if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {
        return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());
      }

      return this.getHeight();
    }
  }, {
    key: "getBlockWidth",
    value: function getBlockWidth() {
      return this.getTileWidth();
    }
  }, {
    key: "getBlockHeight",
    value: function getBlockHeight(y) {
      if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {
        return this.getTileHeight();
      } else {
        return this.getHeight() - y * this.getTileHeight();
      }
    }
    /**
     * Calculates the number of bytes for each pixel across all samples. Only full
     * bytes are supported, an exception is thrown when this is not the case.
     * @returns {Number} the bytes per pixel
     */

  }, {
    key: "getBytesPerPixel",
    value: function getBytesPerPixel() {
      var bytes = 0;

      for (var i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {
        bytes += this.getSampleByteSize(i);
      }

      return bytes;
    }
  }, {
    key: "getSampleByteSize",
    value: function getSampleByteSize(i) {
      if (i >= this.fileDirectory.BitsPerSample.length) {
        throw new RangeError("Sample index ".concat(i, " is out of range."));
      }

      return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);
    }
  }, {
    key: "getReaderForSample",
    value: function getReaderForSample(sampleIndex) {
      var format = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;
      var bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];

      switch (format) {
        case 1:
          // unsigned integer data
          if (bitsPerSample <= 8) {
            return DataView.prototype.getUint8;
          } else if (bitsPerSample <= 16) {
            return DataView.prototype.getUint16;
          } else if (bitsPerSample <= 32) {
            return DataView.prototype.getUint32;
          }

          break;

        case 2:
          // twos complement signed integer data
          if (bitsPerSample <= 8) {
            return DataView.prototype.getInt8;
          } else if (bitsPerSample <= 16) {
            return DataView.prototype.getInt16;
          } else if (bitsPerSample <= 32) {
            return DataView.prototype.getInt32;
          }

          break;

        case 3:
          switch (bitsPerSample) {
            case 16:
              return function (offset, littleEndian) {
                return (0,_petamoriken_float16__WEBPACK_IMPORTED_MODULE_2__.getFloat16)(this, offset, littleEndian);
              };

            case 32:
              return DataView.prototype.getFloat32;

            case 64:
              return DataView.prototype.getFloat64;

            default:
              break;
          }

          break;

        default:
          break;
      }

      throw Error('Unsupported data format/bitsPerSample');
    }
  }, {
    key: "getSampleFormat",
    value: function getSampleFormat() {
      var sampleIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;
    }
  }, {
    key: "getBitsPerSample",
    value: function getBitsPerSample() {
      var sampleIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this.fileDirectory.BitsPerSample[sampleIndex];
    }
  }, {
    key: "getArrayForSample",
    value: function getArrayForSample(sampleIndex, size) {
      var format = this.getSampleFormat(sampleIndex);
      var bitsPerSample = this.getBitsPerSample(sampleIndex);
      return arrayForType(format, bitsPerSample, size);
    }
    /**
     * Returns the decoded strip or tile.
     * @param {Number} x the strip or tile x-offset
     * @param {Number} y the tile y-offset (0 for stripped images)
     * @param {Number} sample the sample to get for separated samples
     * @param {import("./geotiff").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool
     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
     *                               to be aborted
     * @returns {Promise.<ArrayBuffer>}
     */

  }, {
    key: "getTileOrStrip",
    value: function () {
      var _getTileOrStrip = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(x, y, sample, poolOrDecoder, signal) {
        var _this = this;

        var numTilesPerRow, numTilesPerCol, index, tiles, offset, byteCount, slice, request;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());
                numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());
                tiles = this.tiles;

                if (this.planarConfiguration === 1) {
                  index = y * numTilesPerRow + x;
                } else if (this.planarConfiguration === 2) {
                  index = sample * numTilesPerRow * numTilesPerCol + y * numTilesPerRow + x;
                }

                if (this.isTiled) {
                  offset = this.fileDirectory.TileOffsets[index];
                  byteCount = this.fileDirectory.TileByteCounts[index];
                } else {
                  offset = this.fileDirectory.StripOffsets[index];
                  byteCount = this.fileDirectory.StripByteCounts[index];
                }

                _context2.next = 7;
                return this.source.fetch([{
                  offset: offset,
                  length: byteCount
                }], signal);

              case 7:
                slice = _context2.sent[0];

                if (tiles === null || !tiles[index]) {
                  // resolve each request by potentially applying array normalization
                  request = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                    var data, sampleFormat, bitsPerSample;
                    return regeneratorRuntime.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.next = 2;
                            return poolOrDecoder.decode(_this.fileDirectory, slice);

                          case 2:
                            data = _context.sent;
                            sampleFormat = _this.getSampleFormat();
                            bitsPerSample = _this.getBitsPerSample();

                            if (needsNormalization(sampleFormat, bitsPerSample)) {
                              data = normalizeArray(data, sampleFormat, _this.planarConfiguration, _this.getSamplesPerPixel(), bitsPerSample, _this.getTileWidth(), _this.getBlockHeight(y));
                            }

                            return _context.abrupt("return", data);

                          case 7:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }))(); // set the cache

                  if (tiles !== null) {
                    tiles[index] = request;
                  }
                } else {
                  // get from the cache
                  request = tiles[index];
                } // cache the tile request


                _context2.t0 = x;
                _context2.t1 = y;
                _context2.t2 = sample;
                _context2.next = 14;
                return request;

              case 14:
                _context2.t3 = _context2.sent;
                return _context2.abrupt("return", {
                  x: _context2.t0,
                  y: _context2.t1,
                  sample: _context2.t2,
                  data: _context2.t3
                });

              case 16:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getTileOrStrip(_x, _x2, _x3, _x4, _x5) {
        return _getTileOrStrip.apply(this, arguments);
      }

      return getTileOrStrip;
    }()
    /**
     * Internal read function.
     * @private
     * @param {Array} imageWindow The image window in pixel coordinates
     * @param {Array} samples The selected samples (0-based indices)
     * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into
     * @param {Boolean} interleave Whether or not to write in an interleaved manner
     * @param {import("./geotiff").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool
     * @param {number} width the width of window to be read into
     * @param {number} height the height of window to be read into
     * @param {number} resampleMethod the resampling method to be used when interpolating
     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
     *                               to be aborted
     * @returns {Promise<TypedArray[]>|Promise<TypedArray>}
     */

  }, {
    key: "_readRaster",
    value: function () {
      var _readRaster2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal) {
        var _this2 = this;

        var tileWidth, tileHeight, imageWidth, imageHeight, minXTile, maxXTile, minYTile, maxYTile, windowWidth, bytesPerPixel, srcSampleOffsets, sampleReaders, i, promises, littleEndian, yTile, xTile, _loop, sampleIndex, resampled;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                tileWidth = this.getTileWidth();
                tileHeight = this.getTileHeight();
                imageWidth = this.getWidth();
                imageHeight = this.getHeight();
                minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);
                maxXTile = Math.min(Math.ceil(imageWindow[2] / tileWidth), Math.ceil(imageWidth / tileWidth));
                minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);
                maxYTile = Math.min(Math.ceil(imageWindow[3] / tileHeight), Math.ceil(imageHeight / tileHeight));
                windowWidth = imageWindow[2] - imageWindow[0];
                bytesPerPixel = this.getBytesPerPixel();
                srcSampleOffsets = [];
                sampleReaders = [];

                for (i = 0; i < samples.length; ++i) {
                  if (this.planarConfiguration === 1) {
                    srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);
                  } else {
                    srcSampleOffsets.push(0);
                  }

                  sampleReaders.push(this.getReaderForSample(samples[i]));
                }

                promises = [];
                littleEndian = this.littleEndian;

                for (yTile = minYTile; yTile < maxYTile; ++yTile) {
                  for (xTile = minXTile; xTile < maxXTile; ++xTile) {
                    _loop = function _loop(sampleIndex) {
                      var si = sampleIndex;
                      var sample = samples[sampleIndex];

                      if (_this2.planarConfiguration === 2) {
                        bytesPerPixel = _this2.getSampleByteSize(sampleIndex);
                      }

                      var promise = _this2.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);

                      promises.push(promise);
                      promise.then(function (tile) {
                        var buffer = tile.data;
                        var dataView = new DataView(buffer);

                        var blockHeight = _this2.getBlockHeight(tile.y);

                        var firstLine = tile.y * tileHeight;
                        var firstCol = tile.x * tileWidth;
                        var lastLine = firstLine + blockHeight;
                        var lastCol = (tile.x + 1) * tileWidth;
                        var reader = sampleReaders[si];
                        var ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);
                        var xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);

                        for (var y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {
                          for (var x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {
                            var pixelOffset = (y * tileWidth + x) * bytesPerPixel;
                            var value = reader.call(dataView, pixelOffset + srcSampleOffsets[si], littleEndian);
                            var windowCoordinate = void 0;

                            if (interleave) {
                              windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth * samples.length + (x + firstCol - imageWindow[0]) * samples.length + si;
                              valueArrays[windowCoordinate] = value;
                            } else {
                              windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth + x + firstCol - imageWindow[0];
                              valueArrays[si][windowCoordinate] = value;
                            }
                          }
                        }
                      });
                    };

                    for (sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {
                      _loop(sampleIndex);
                    }
                  }
                }

                _context3.next = 18;
                return Promise.all(promises);

              case 18:
                if (!(width && imageWindow[2] - imageWindow[0] !== width || height && imageWindow[3] - imageWindow[1] !== height)) {
                  _context3.next = 23;
                  break;
                }

                if (interleave) {
                  resampled = (0,_resample_js__WEBPACK_IMPORTED_MODULE_3__.resampleInterleaved)(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, samples.length, resampleMethod);
                } else {
                  resampled = (0,_resample_js__WEBPACK_IMPORTED_MODULE_3__.resample)(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, resampleMethod);
                }

                resampled.width = width;
                resampled.height = height;
                return _context3.abrupt("return", resampled);

              case 23:
                valueArrays.width = width || imageWindow[2] - imageWindow[0];
                valueArrays.height = height || imageWindow[3] - imageWindow[1];
                return _context3.abrupt("return", valueArrays);

              case 26:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _readRaster(_x6, _x7, _x8, _x9, _x10, _x11, _x12, _x13, _x14) {
        return _readRaster2.apply(this, arguments);
      }

      return _readRaster;
    }()
    /**
     * Reads raster data from the image. This function reads all selected samples
     * into separate arrays of the correct type for that sample or into a single
     * combined array when `interleave` is set. When provided, only a subset
     * of the raster is read for each sample.
     *
     * @param {ReadRasterOptions} [options={}] optional parameters
     * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise
     */

  }, {
    key: "readRasters",
    value: function () {
      var _readRasters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _ref2,
            wnd,
            _ref2$samples,
            samples,
            interleave,
            _ref2$pool,
            pool,
            width,
            height,
            resampleMethod,
            fillValue,
            signal,
            imageWindow,
            imageWindowWidth,
            imageWindowHeight,
            numPixels,
            samplesPerPixel,
            i,
            _i,
            valueArrays,
            format,
            bitsPerSample,
            _i2,
            valueArray,
            poolOrDecoder,
            result,
            _args4 = arguments;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _ref2 = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {}, wnd = _ref2.window, _ref2$samples = _ref2.samples, samples = _ref2$samples === void 0 ? [] : _ref2$samples, interleave = _ref2.interleave, _ref2$pool = _ref2.pool, pool = _ref2$pool === void 0 ? null : _ref2$pool, width = _ref2.width, height = _ref2.height, resampleMethod = _ref2.resampleMethod, fillValue = _ref2.fillValue, signal = _ref2.signal;
                imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()]; // check parameters

                if (!(imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3])) {
                  _context4.next = 4;
                  break;
                }

                throw new Error('Invalid subsets');

              case 4:
                imageWindowWidth = imageWindow[2] - imageWindow[0];
                imageWindowHeight = imageWindow[3] - imageWindow[1];
                numPixels = imageWindowWidth * imageWindowHeight;
                samplesPerPixel = this.getSamplesPerPixel();

                if (!(!samples || !samples.length)) {
                  _context4.next = 12;
                  break;
                }

                for (i = 0; i < samplesPerPixel; ++i) {
                  samples.push(i);
                }

                _context4.next = 19;
                break;

              case 12:
                _i = 0;

              case 13:
                if (!(_i < samples.length)) {
                  _context4.next = 19;
                  break;
                }

                if (!(samples[_i] >= samplesPerPixel)) {
                  _context4.next = 16;
                  break;
                }

                return _context4.abrupt("return", Promise.reject(new RangeError("Invalid sample index '".concat(samples[_i], "'."))));

              case 16:
                ++_i;
                _context4.next = 13;
                break;

              case 19:
                if (interleave) {
                  format = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;
                  bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);
                  valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);

                  if (fillValue) {
                    valueArrays.fill(fillValue);
                  }
                } else {
                  valueArrays = [];

                  for (_i2 = 0; _i2 < samples.length; ++_i2) {
                    valueArray = this.getArrayForSample(samples[_i2], numPixels);

                    if (Array.isArray(fillValue) && _i2 < fillValue.length) {
                      valueArray.fill(fillValue[_i2]);
                    } else if (fillValue && !Array.isArray(fillValue)) {
                      valueArray.fill(fillValue);
                    }

                    valueArrays.push(valueArray);
                  }
                }

                _context4.t0 = pool;

                if (_context4.t0) {
                  _context4.next = 25;
                  break;
                }

                _context4.next = 24;
                return (0,_compression_index_js__WEBPACK_IMPORTED_MODULE_4__.getDecoder)(this.fileDirectory);

              case 24:
                _context4.t0 = _context4.sent;

              case 25:
                poolOrDecoder = _context4.t0;
                _context4.next = 28;
                return this._readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal);

              case 28:
                result = _context4.sent;
                return _context4.abrupt("return", result);

              case 30:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function readRasters() {
        return _readRasters.apply(this, arguments);
      }

      return readRasters;
    }()
    /**
     * Reads raster data from the image as RGB. The result is always an
     * interleaved typed array.
     * Colorspaces other than RGB will be transformed to RGB, color maps expanded.
     * When no other method is applicable, the first sample is used to produce a
     * greayscale image.
     * When provided, only a subset of the raster is read for each sample.
     *
     * @param {Object} [options] optional parameters
     * @param {Array<number>} [options.window] the subset to read data from in pixels.
     * @param {boolean} [options.interleave=true] whether the data shall be read
     *                                             in one single array or separate
     *                                             arrays.
     * @param {import("./geotiff").Pool} [options.pool=null] The optional decoder pool to use.
     * @param {number} [options.width] The desired width of the output. When the width is no the
     *                                 same as the images, resampling will be performed.
     * @param {number} [options.height] The desired height of the output. When the width is no the
     *                                  same as the images, resampling will be performed.
     * @param {string} [options.resampleMethod='nearest'] The desired resampling method.
     * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.
     * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is
     *                                       to be aborted
     * @returns {Promise<TypedArray|TypedArray[]>} the RGB array as a Promise
     */

  }, {
    key: "readRGB",
    value: function () {
      var _readRGB = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var _ref3,
            window,
            _ref3$interleave,
            interleave,
            _ref3$pool,
            pool,
            width,
            height,
            resampleMethod,
            _ref3$enableAlpha,
            enableAlpha,
            signal,
            imageWindow,
            pi,
            s,
            i,
            samples,
            subOptions,
            fileDirectory,
            raster,
            max,
            data,
            red,
            green,
            blue,
            _i3,
            j,
            _args5 = arguments;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _ref3 = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {}, window = _ref3.window, _ref3$interleave = _ref3.interleave, interleave = _ref3$interleave === void 0 ? true : _ref3$interleave, _ref3$pool = _ref3.pool, pool = _ref3$pool === void 0 ? null : _ref3$pool, width = _ref3.width, height = _ref3.height, resampleMethod = _ref3.resampleMethod, _ref3$enableAlpha = _ref3.enableAlpha, enableAlpha = _ref3$enableAlpha === void 0 ? false : _ref3$enableAlpha, signal = _ref3.signal;
                imageWindow = window || [0, 0, this.getWidth(), this.getHeight()]; // check parameters

                if (!(imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3])) {
                  _context5.next = 4;
                  break;
                }

                throw new Error('Invalid subsets');

              case 4:
                pi = this.fileDirectory.PhotometricInterpretation;

                if (!(pi === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.RGB)) {
                  _context5.next = 9;
                  break;
                }

                s = [0, 1, 2];

                if (!(this.fileDirectory.ExtraSamples === _globals_js__WEBPACK_IMPORTED_MODULE_5__.ExtraSamplesValues.Unspecified) && enableAlpha) {
                  s = [];

                  for (i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {
                    s.push(i);
                  }
                }

                return _context5.abrupt("return", this.readRasters({
                  window: window,
                  interleave: interleave,
                  samples: s,
                  pool: pool,
                  width: width,
                  height: height,
                  resampleMethod: resampleMethod,
                  signal: signal
                }));

              case 9:
                _context5.t0 = pi;
                _context5.next = _context5.t0 === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.WhiteIsZero ? 12 : _context5.t0 === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.BlackIsZero ? 12 : _context5.t0 === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.Palette ? 12 : _context5.t0 === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CMYK ? 14 : _context5.t0 === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.YCbCr ? 16 : _context5.t0 === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CIELab ? 16 : 18;
                break;

              case 12:
                samples = [0];
                return _context5.abrupt("break", 19);

              case 14:
                samples = [0, 1, 2, 3];
                return _context5.abrupt("break", 19);

              case 16:
                samples = [0, 1, 2];
                return _context5.abrupt("break", 19);

              case 18:
                throw new Error('Invalid or unsupported photometric interpretation.');

              case 19:
                subOptions = {
                  window: imageWindow,
                  interleave: true,
                  samples: samples,
                  pool: pool,
                  width: width,
                  height: height,
                  resampleMethod: resampleMethod,
                  signal: signal
                };
                fileDirectory = this.fileDirectory;
                _context5.next = 23;
                return this.readRasters(subOptions);

              case 23:
                raster = _context5.sent;
                max = Math.pow(2, this.fileDirectory.BitsPerSample[0]);
                _context5.t1 = pi;
                _context5.next = _context5.t1 === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.WhiteIsZero ? 28 : _context5.t1 === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.BlackIsZero ? 30 : _context5.t1 === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.Palette ? 32 : _context5.t1 === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CMYK ? 34 : _context5.t1 === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.YCbCr ? 36 : _context5.t1 === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CIELab ? 38 : 40;
                break;

              case 28:
                data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromWhiteIsZero)(raster, max);
                return _context5.abrupt("break", 41);

              case 30:
                data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromBlackIsZero)(raster, max);
                return _context5.abrupt("break", 41);

              case 32:
                data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromPalette)(raster, fileDirectory.ColorMap);
                return _context5.abrupt("break", 41);

              case 34:
                data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromCMYK)(raster);
                return _context5.abrupt("break", 41);

              case 36:
                data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromYCbCr)(raster);
                return _context5.abrupt("break", 41);

              case 38:
                data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromCIELab)(raster);
                return _context5.abrupt("break", 41);

              case 40:
                throw new Error('Unsupported photometric interpretation.');

              case 41:
                // if non-interleaved data is requested, we must split the channels
                // into their respective arrays
                if (!interleave) {
                  red = new Uint8Array(data.length / 3);
                  green = new Uint8Array(data.length / 3);
                  blue = new Uint8Array(data.length / 3);

                  for (_i3 = 0, j = 0; _i3 < data.length; _i3 += 3, ++j) {
                    red[j] = data[_i3];
                    green[j] = data[_i3 + 1];
                    blue[j] = data[_i3 + 2];
                  }

                  data = [red, green, blue];
                }

                data.width = raster.width;
                data.height = raster.height;
                return _context5.abrupt("return", data);

              case 45:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function readRGB() {
        return _readRGB.apply(this, arguments);
      }

      return readRGB;
    }()
    /**
     * Returns an array of tiepoints.
     * @returns {Object[]}
     */

  }, {
    key: "getTiePoints",
    value: function getTiePoints() {
      if (!this.fileDirectory.ModelTiepoint) {
        return [];
      }

      var tiePoints = [];

      for (var i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {
        tiePoints.push({
          i: this.fileDirectory.ModelTiepoint[i],
          j: this.fileDirectory.ModelTiepoint[i + 1],
          k: this.fileDirectory.ModelTiepoint[i + 2],
          x: this.fileDirectory.ModelTiepoint[i + 3],
          y: this.fileDirectory.ModelTiepoint[i + 4],
          z: this.fileDirectory.ModelTiepoint[i + 5]
        });
      }

      return tiePoints;
    }
    /**
     * Returns the parsed GDAL metadata items.
     *
     * If sample is passed to null, dataset-level metadata will be returned.
     * Otherwise only metadata specific to the provided sample will be returned.
     *
     * @param {number} [sample=null] The sample index.
     * @returns {Object}
     */

  }, {
    key: "getGDALMetadata",
    value: function getGDALMetadata() {
      var sample = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var metadata = {};

      if (!this.fileDirectory.GDAL_METADATA) {
        return null;
      }

      var string = this.fileDirectory.GDAL_METADATA;
      var items = xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_1__(string, 'Item');

      if (sample === null) {
        items = items.filter(function (item) {
          return xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'sample') === undefined;
        });
      } else {
        items = items.filter(function (item) {
          return Number(xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'sample')) === sample;
        });
      }

      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        metadata[xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'name')] = item.inner;
      }

      return metadata;
    }
    /**
     * Returns the GDAL nodata value
     * @returns {number|null}
     */

  }, {
    key: "getGDALNoData",
    value: function getGDALNoData() {
      if (!this.fileDirectory.GDAL_NODATA) {
        return null;
      }

      var string = this.fileDirectory.GDAL_NODATA;
      return Number(string.substring(0, string.length - 1));
    }
    /**
     * Returns the image origin as a XYZ-vector. When the image has no affine
     * transformation, then an exception is thrown.
     * @returns {Array<number>} The origin as a vector
     */

  }, {
    key: "getOrigin",
    value: function getOrigin() {
      var tiePoints = this.fileDirectory.ModelTiepoint;
      var modelTransformation = this.fileDirectory.ModelTransformation;

      if (tiePoints && tiePoints.length === 6) {
        return [tiePoints[3], tiePoints[4], tiePoints[5]];
      }

      if (modelTransformation) {
        return [modelTransformation[3], modelTransformation[7], modelTransformation[11]];
      }

      throw new Error('The image does not have an affine transformation.');
    }
    /**
     * Returns the image resolution as a XYZ-vector. When the image has no affine
     * transformation, then an exception is thrown.
     * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from
     *                                             in cases when the current image does not have the
     *                                             required tags on its own.
     * @returns {Array<number>} The resolution as a vector
     */

  }, {
    key: "getResolution",
    value: function getResolution() {
      var referenceImage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var modelPixelScale = this.fileDirectory.ModelPixelScale;
      var modelTransformation = this.fileDirectory.ModelTransformation;

      if (modelPixelScale) {
        return [modelPixelScale[0], -modelPixelScale[1], modelPixelScale[2]];
      }

      if (modelTransformation) {
        return [modelTransformation[0], modelTransformation[5], modelTransformation[10]];
      }

      if (referenceImage) {
        var _referenceImage$getRe = referenceImage.getResolution(),
            _referenceImage$getRe2 = _slicedToArray(_referenceImage$getRe, 3),
            refResX = _referenceImage$getRe2[0],
            refResY = _referenceImage$getRe2[1],
            refResZ = _referenceImage$getRe2[2];

        return [refResX * referenceImage.getWidth() / this.getWidth(), refResY * referenceImage.getHeight() / this.getHeight(), refResZ * referenceImage.getWidth() / this.getWidth()];
      }

      throw new Error('The image does not have an affine transformation.');
    }
    /**
     * Returns whether or not the pixels of the image depict an area (or point).
     * @returns {Boolean} Whether the pixels are a point
     */

  }, {
    key: "pixelIsArea",
    value: function pixelIsArea() {
      return this.geoKeys.GTRasterTypeGeoKey === 1;
    }
    /**
     * Returns the image bounding box as an array of 4 values: min-x, min-y,
     * max-x and max-y. When the image has no affine transformation, then an
     * exception is thrown.
     * @returns {Array<number>} The bounding box
     */

  }, {
    key: "getBoundingBox",
    value: function getBoundingBox() {
      var origin = this.getOrigin();
      var resolution = this.getResolution();
      var x1 = origin[0];
      var y1 = origin[1];
      var x2 = x1 + resolution[0] * this.getWidth();
      var y2 = y1 + resolution[1] * this.getHeight();
      return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];
    }
  }]);

  return GeoTIFFImage;
}();

/* harmony default export */ __webpack_exports__["default"] = (GeoTIFFImage);

/***/ }),

/***/ "./node_modules/geotiff/dist-module/geotiffwriter.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffwriter.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "writeGeotiff": function() { return /* binding */ writeGeotiff; }
/* harmony export */ });
/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.js */ "./node_modules/geotiff/dist-module/globals.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/geotiff/dist-module/utils.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/*
  Some parts of this file are based on UTIF.js,
  which was released under the MIT License.
  You can view that here:
  https://github.com/photopea/UTIF.js/blob/master/LICENSE
*/


var tagName2Code = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagNames);
var geoKeyName2Code = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.geoKeyNames);
var name2code = {};
(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assign)(name2code, tagName2Code);
(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assign)(name2code, geoKeyName2Code);
var typeName2byte = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTypeNames); // config variables

var numBytesInIfd = 1000;
var _binBE = {
  nextZero: function nextZero(data, o) {
    var oincr = o;

    while (data[oincr] !== 0) {
      oincr++;
    }

    return oincr;
  },
  readUshort: function readUshort(buff, p) {
    return buff[p] << 8 | buff[p + 1];
  },
  readShort: function readShort(buff, p) {
    var a = _binBE.ui8;
    a[0] = buff[p + 1];
    a[1] = buff[p + 0];
    return _binBE.i16[0];
  },
  readInt: function readInt(buff, p) {
    var a = _binBE.ui8;
    a[0] = buff[p + 3];
    a[1] = buff[p + 2];
    a[2] = buff[p + 1];
    a[3] = buff[p + 0];
    return _binBE.i32[0];
  },
  readUint: function readUint(buff, p) {
    var a = _binBE.ui8;
    a[0] = buff[p + 3];
    a[1] = buff[p + 2];
    a[2] = buff[p + 1];
    a[3] = buff[p + 0];
    return _binBE.ui32[0];
  },
  readASCII: function readASCII(buff, p, l) {
    return l.map(function (i) {
      return String.fromCharCode(buff[p + i]);
    }).join('');
  },
  readFloat: function readFloat(buff, p) {
    var a = _binBE.ui8;
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(4, function (i) {
      a[i] = buff[p + 3 - i];
    });
    return _binBE.fl32[0];
  },
  readDouble: function readDouble(buff, p) {
    var a = _binBE.ui8;
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(8, function (i) {
      a[i] = buff[p + 7 - i];
    });
    return _binBE.fl64[0];
  },
  writeUshort: function writeUshort(buff, p, n) {
    buff[p] = n >> 8 & 255;
    buff[p + 1] = n & 255;
  },
  writeUint: function writeUint(buff, p, n) {
    buff[p] = n >> 24 & 255;
    buff[p + 1] = n >> 16 & 255;
    buff[p + 2] = n >> 8 & 255;
    buff[p + 3] = n >> 0 & 255;
  },
  writeASCII: function writeASCII(buff, p, s) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(s.length, function (i) {
      buff[p + i] = s.charCodeAt(i);
    });
  },
  ui8: new Uint8Array(8)
};
_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);

_binBE.writeDouble = function (buff, p, n) {
  _binBE.fl64[0] = n;
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(8, function (i) {
    buff[p + i] = _binBE.ui8[7 - i];
  });
};

var _writeIFD = function _writeIFD(bin, data, _offset, ifd) {
  var offset = _offset;
  var keys = Object.keys(ifd).filter(function (key) {
    return key !== undefined && key !== null && key !== 'undefined';
  });
  bin.writeUshort(data, offset, keys.length);
  offset += 2;
  var eoff = offset + 12 * keys.length + 4;

  var _iterator = _createForOfIteratorHelper(keys),
      _step;

  try {
    var _loop = function _loop() {
      var key = _step.value;
      var tag = null;

      if (typeof key === 'number') {
        tag = key;
      } else if (typeof key === 'string') {
        tag = parseInt(key, 10);
      }

      var typeName = _globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[tag];
      var typeNum = typeName2byte[typeName];

      if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {
        throw new Error("unknown type of tag: ".concat(tag));
      }

      var val = ifd[key];

      if (val === undefined) {
        throw new Error("failed to get value for key ".concat(key));
      } // ASCIIZ format with trailing 0 character
      // http://www.fileformat.info/format/tiff/corion.htm
      // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii


      if (typeName === 'ASCII' && typeof val === 'string' && (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.endsWith)(val, "\0") === false) {
        val += "\0";
      }

      var num = val.length;
      bin.writeUshort(data, offset, tag);
      offset += 2;
      bin.writeUshort(data, offset, typeNum);
      offset += 2;
      bin.writeUint(data, offset, num);
      offset += 4;
      var dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;
      var toff = offset;

      if (dlen > 4) {
        bin.writeUint(data, offset, eoff);
        toff = eoff;
      }

      if (typeName === 'ASCII') {
        bin.writeASCII(data, toff, val);
      } else if (typeName === 'SHORT') {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, function (i) {
          bin.writeUshort(data, toff + 2 * i, val[i]);
        });
      } else if (typeName === 'LONG') {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, function (i) {
          bin.writeUint(data, toff + 4 * i, val[i]);
        });
      } else if (typeName === 'RATIONAL') {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, function (i) {
          bin.writeUint(data, toff + 8 * i, Math.round(val[i] * 10000));
          bin.writeUint(data, toff + 8 * i + 4, 10000);
        });
      } else if (typeName === 'DOUBLE') {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, function (i) {
          bin.writeDouble(data, toff + 8 * i, val[i]);
        });
      }

      if (dlen > 4) {
        dlen += dlen & 1;
        eoff += dlen;
      }

      offset += 4;
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return [offset, eoff];
};

var encodeIfds = function encodeIfds(ifds) {
  var data = new Uint8Array(numBytesInIfd);
  var offset = 4;
  var bin = _binBE; // set big-endian byte-order
  // https://en.wikipedia.org/wiki/TIFF#Byte_order

  data[0] = 77;
  data[1] = 77; // set format-version number
  // https://en.wikipedia.org/wiki/TIFF#Byte_order

  data[3] = 42;
  var ifdo = 8;
  bin.writeUint(data, offset, ifdo);
  offset += 4;
  ifds.forEach(function (ifd, i) {
    var noffs = _writeIFD(bin, data, ifdo, ifd);

    ifdo = noffs[1];

    if (i < ifds.length - 1) {
      bin.writeUint(data, noffs[0], ifdo);
    }
  });

  if (data.slice) {
    return data.slice(0, ifdo).buffer;
  } // node hasn't implemented slice on Uint8Array yet


  var result = new Uint8Array(ifdo);

  for (var i = 0; i < ifdo; i++) {
    result[i] = data[i];
  }

  return result.buffer;
};

var encodeImage = function encodeImage(values, width, height, metadata) {
  if (height === undefined || height === null) {
    throw new Error("you passed into encodeImage a width of type ".concat(height));
  }

  if (width === undefined || width === null) {
    throw new Error("you passed into encodeImage a width of type ".concat(width));
  }

  var ifd = {
    256: [width],
    // ImageWidth
    257: [height],
    // ImageLength
    273: [numBytesInIfd],
    // strips offset
    278: [height],
    // RowsPerStrip
    305: 'geotiff.js' // no array for ASCII(Z)

  };

  if (metadata) {
    for (var i in metadata) {
      if (metadata.hasOwnProperty(i)) {
        ifd[i] = metadata[i];
      }
    }
  }

  var prfx = new Uint8Array(encodeIfds([ifd]));
  var img = new Uint8Array(values);
  var samplesPerPixel = ifd[277];
  var data = new Uint8Array(numBytesInIfd + width * height * samplesPerPixel);
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(prfx.length, function (i) {
    data[i] = prfx[i];
  });
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.forEach)(img, function (value, i) {
    data[numBytesInIfd + i] = value;
  });
  return data.buffer;
};

var convertToTids = function convertToTids(input) {
  var result = {};

  for (var key in input) {
    if (key !== 'StripOffsets') {
      if (!name2code[key]) {
        console.error(key, 'not in name2code:', Object.keys(name2code));
      }

      result[name2code[key]] = input[key];
    }
  }

  return result;
};

var toArray = function toArray(input) {
  if (Array.isArray(input)) {
    return input;
  }

  return [input];
};

var metadataDefaults = [['Compression', 1], // no compression
['PlanarConfiguration', 1], ['ExtraSamples', 0]];
function writeGeotiff(data, metadata) {
  var isFlattened = typeof data[0] === 'number';
  var height;
  var numBands;
  var width;
  var flattenedValues;

  if (isFlattened) {
    height = metadata.height || metadata.ImageLength;
    width = metadata.width || metadata.ImageWidth;
    numBands = data.length / (height * width);
    flattenedValues = data;
  } else {
    numBands = data.length;
    height = data[0].length;
    width = data[0][0].length;
    flattenedValues = [];
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(height, function (rowIndex) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(width, function (columnIndex) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, function (bandIndex) {
          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);
        });
      });
    });
  }

  metadata.ImageLength = height;
  delete metadata.height;
  metadata.ImageWidth = width;
  delete metadata.width; // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml

  if (!metadata.BitsPerSample) {
    metadata.BitsPerSample = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, function () {
      return 8;
    });
  }

  metadataDefaults.forEach(function (tag) {
    var key = tag[0];

    if (!metadata[key]) {
      var value = tag[1];
      metadata[key] = value;
    }
  }); // The color space of the image data.
  // 1=black is zero and 2=RGB.

  if (!metadata.PhotometricInterpretation) {
    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;
  } // The number of components per pixel.


  if (!metadata.SamplesPerPixel) {
    metadata.SamplesPerPixel = [numBands];
  }

  if (!metadata.StripByteCounts) {
    // we are only writing one strip
    metadata.StripByteCounts = [numBands * height * width];
  }

  if (!metadata.ModelPixelScale) {
    // assumes raster takes up exactly the whole globe
    metadata.ModelPixelScale = [360 / width, 180 / height, 0];
  }

  if (!metadata.SampleFormat) {
    metadata.SampleFormat = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, function () {
      return 1;
    });
  } // if didn't pass in projection information, assume the popular 4326 "geographic projection"


  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {
    metadata.GeographicTypeGeoKey = 4326;
    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe

    metadata.GeogCitationGeoKey = 'WGS 84';
    metadata.GTModelTypeGeoKey = 2;
  }

  var geoKeys = Object.keys(metadata).filter(function (key) {
    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.endsWith)(key, 'GeoKey');
  }).sort(function (a, b) {
    return name2code[a] - name2code[b];
  });

  if (!metadata.GeoAsciiParams) {
    var geoAsciiParams = '';
    geoKeys.forEach(function (name) {
      var code = Number(name2code[name]);
      var tagType = _globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[code];

      if (tagType === 'ASCII') {
        geoAsciiParams += "".concat(metadata[name].toString(), "\0");
      }
    });

    if (geoAsciiParams.length > 0) {
      metadata.GeoAsciiParams = geoAsciiParams;
    }
  }

  if (!metadata.GeoKeyDirectory) {
    var NumberOfKeys = geoKeys.length;
    var GeoKeyDirectory = [1, 1, 0, NumberOfKeys];
    geoKeys.forEach(function (geoKey) {
      var KeyID = Number(name2code[geoKey]);
      GeoKeyDirectory.push(KeyID);
      var Count;
      var TIFFTagLocation;
      var valueOffset;

      if (_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[KeyID] === 'SHORT') {
        Count = 1;
        TIFFTagLocation = 0;
        valueOffset = metadata[geoKey];
      } else if (geoKey === 'GeogCitationGeoKey') {
        Count = metadata.GeoAsciiParams.length;
        TIFFTagLocation = Number(name2code.GeoAsciiParams);
        valueOffset = 0;
      } else {
        console.log("[geotiff.js] couldn't get TIFFTagLocation for ".concat(geoKey));
      }

      GeoKeyDirectory.push(TIFFTagLocation);
      GeoKeyDirectory.push(Count);
      GeoKeyDirectory.push(valueOffset);
    });
    metadata.GeoKeyDirectory = GeoKeyDirectory;
  } // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag


  for (var geoKey in geoKeys) {
    if (geoKeys.hasOwnProperty(geoKey)) {
      delete metadata[geoKey];
    }
  }

  ['Compression', 'ExtraSamples', 'GeographicTypeGeoKey', 'GTModelTypeGeoKey', 'GTRasterTypeGeoKey', 'ImageLength', // synonym of ImageHeight
  'ImageWidth', 'Orientation', 'PhotometricInterpretation', 'ProjectedCSTypeGeoKey', 'PlanarConfiguration', 'ResolutionUnit', 'SamplesPerPixel', 'XPosition', 'YPosition'].forEach(function (name) {
    if (metadata[name]) {
      metadata[name] = toArray(metadata[name]);
    }
  });
  var encodedMetadata = convertToTids(metadata);
  var outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);
  return outputImage;
}

/***/ }),

/***/ "./node_modules/geotiff/dist-module/globals.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/globals.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fieldTagNames": function() { return /* binding */ fieldTagNames; },
/* harmony export */   "fieldTags": function() { return /* binding */ fieldTags; },
/* harmony export */   "fieldTagTypes": function() { return /* binding */ fieldTagTypes; },
/* harmony export */   "arrayFields": function() { return /* binding */ arrayFields; },
/* harmony export */   "fieldTypeNames": function() { return /* binding */ fieldTypeNames; },
/* harmony export */   "fieldTypes": function() { return /* binding */ fieldTypes; },
/* harmony export */   "photometricInterpretations": function() { return /* binding */ photometricInterpretations; },
/* harmony export */   "ExtraSamplesValues": function() { return /* binding */ ExtraSamplesValues; },
/* harmony export */   "LercParameters": function() { return /* binding */ LercParameters; },
/* harmony export */   "LercAddCompression": function() { return /* binding */ LercAddCompression; },
/* harmony export */   "geoKeyNames": function() { return /* binding */ geoKeyNames; },
/* harmony export */   "geoKeys": function() { return /* binding */ geoKeys; }
/* harmony export */ });
var fieldTagNames = {
  // TIFF Baseline
  0x013B: 'Artist',
  0x0102: 'BitsPerSample',
  0x0109: 'CellLength',
  0x0108: 'CellWidth',
  0x0140: 'ColorMap',
  0x0103: 'Compression',
  0x8298: 'Copyright',
  0x0132: 'DateTime',
  0x0152: 'ExtraSamples',
  0x010A: 'FillOrder',
  0x0121: 'FreeByteCounts',
  0x0120: 'FreeOffsets',
  0x0123: 'GrayResponseCurve',
  0x0122: 'GrayResponseUnit',
  0x013C: 'HostComputer',
  0x010E: 'ImageDescription',
  0x0101: 'ImageLength',
  0x0100: 'ImageWidth',
  0x010F: 'Make',
  0x0119: 'MaxSampleValue',
  0x0118: 'MinSampleValue',
  0x0110: 'Model',
  0x00FE: 'NewSubfileType',
  0x0112: 'Orientation',
  0x0106: 'PhotometricInterpretation',
  0x011C: 'PlanarConfiguration',
  0x0128: 'ResolutionUnit',
  0x0116: 'RowsPerStrip',
  0x0115: 'SamplesPerPixel',
  0x0131: 'Software',
  0x0117: 'StripByteCounts',
  0x0111: 'StripOffsets',
  0x00FF: 'SubfileType',
  0x0107: 'Threshholding',
  0x011A: 'XResolution',
  0x011B: 'YResolution',
  // TIFF Extended
  0x0146: 'BadFaxLines',
  0x0147: 'CleanFaxData',
  0x0157: 'ClipPath',
  0x0148: 'ConsecutiveBadFaxLines',
  0x01B1: 'Decode',
  0x01B2: 'DefaultImageColor',
  0x010D: 'DocumentName',
  0x0150: 'DotRange',
  0x0141: 'HalftoneHints',
  0x015A: 'Indexed',
  0x015B: 'JPEGTables',
  0x011D: 'PageName',
  0x0129: 'PageNumber',
  0x013D: 'Predictor',
  0x013F: 'PrimaryChromaticities',
  0x0214: 'ReferenceBlackWhite',
  0x0153: 'SampleFormat',
  0x0154: 'SMinSampleValue',
  0x0155: 'SMaxSampleValue',
  0x022F: 'StripRowCounts',
  0x014A: 'SubIFDs',
  0x0124: 'T4Options',
  0x0125: 'T6Options',
  0x0145: 'TileByteCounts',
  0x0143: 'TileLength',
  0x0144: 'TileOffsets',
  0x0142: 'TileWidth',
  0x012D: 'TransferFunction',
  0x013E: 'WhitePoint',
  0x0158: 'XClipPathUnits',
  0x011E: 'XPosition',
  0x0211: 'YCbCrCoefficients',
  0x0213: 'YCbCrPositioning',
  0x0212: 'YCbCrSubSampling',
  0x0159: 'YClipPathUnits',
  0x011F: 'YPosition',
  // EXIF
  0x9202: 'ApertureValue',
  0xA001: 'ColorSpace',
  0x9004: 'DateTimeDigitized',
  0x9003: 'DateTimeOriginal',
  0x8769: 'Exif IFD',
  0x9000: 'ExifVersion',
  0x829A: 'ExposureTime',
  0xA300: 'FileSource',
  0x9209: 'Flash',
  0xA000: 'FlashpixVersion',
  0x829D: 'FNumber',
  0xA420: 'ImageUniqueID',
  0x9208: 'LightSource',
  0x927C: 'MakerNote',
  0x9201: 'ShutterSpeedValue',
  0x9286: 'UserComment',
  // IPTC
  0x83BB: 'IPTC',
  // ICC
  0x8773: 'ICC Profile',
  // XMP
  0x02BC: 'XMP',
  // GDAL
  0xA480: 'GDAL_METADATA',
  0xA481: 'GDAL_NODATA',
  // Photoshop
  0x8649: 'Photoshop',
  // GeoTiff
  0x830E: 'ModelPixelScale',
  0x8482: 'ModelTiepoint',
  0x85D8: 'ModelTransformation',
  0x87AF: 'GeoKeyDirectory',
  0x87B0: 'GeoDoubleParams',
  0x87B1: 'GeoAsciiParams',
  // LERC
  0xC5F2: 'LercParameters'
};
var fieldTags = {};

for (var key in fieldTagNames) {
  if (fieldTagNames.hasOwnProperty(key)) {
    fieldTags[fieldTagNames[key]] = parseInt(key, 10);
  }
}

var fieldTagTypes = {
  256: 'SHORT',
  257: 'SHORT',
  258: 'SHORT',
  259: 'SHORT',
  262: 'SHORT',
  273: 'LONG',
  274: 'SHORT',
  277: 'SHORT',
  278: 'LONG',
  279: 'LONG',
  282: 'RATIONAL',
  283: 'RATIONAL',
  284: 'SHORT',
  286: 'SHORT',
  287: 'RATIONAL',
  296: 'SHORT',
  297: 'SHORT',
  305: 'ASCII',
  306: 'ASCII',
  338: 'SHORT',
  339: 'SHORT',
  513: 'LONG',
  514: 'LONG',
  1024: 'SHORT',
  1025: 'SHORT',
  2048: 'SHORT',
  2049: 'ASCII',
  3072: 'SHORT',
  3073: 'ASCII',
  33550: 'DOUBLE',
  33922: 'DOUBLE',
  34665: 'LONG',
  34735: 'SHORT',
  34737: 'ASCII',
  42113: 'ASCII'
};
var arrayFields = [fieldTags.BitsPerSample, fieldTags.ExtraSamples, fieldTags.SampleFormat, fieldTags.StripByteCounts, fieldTags.StripOffsets, fieldTags.StripRowCounts, fieldTags.TileByteCounts, fieldTags.TileOffsets, fieldTags.SubIFDs];
var fieldTypeNames = {
  0x0001: 'BYTE',
  0x0002: 'ASCII',
  0x0003: 'SHORT',
  0x0004: 'LONG',
  0x0005: 'RATIONAL',
  0x0006: 'SBYTE',
  0x0007: 'UNDEFINED',
  0x0008: 'SSHORT',
  0x0009: 'SLONG',
  0x000A: 'SRATIONAL',
  0x000B: 'FLOAT',
  0x000C: 'DOUBLE',
  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html
  0x000D: 'IFD',
  // introduced by BigTIFF
  0x0010: 'LONG8',
  0x0011: 'SLONG8',
  0x0012: 'IFD8'
};
var fieldTypes = {};

for (var _key in fieldTypeNames) {
  if (fieldTypeNames.hasOwnProperty(_key)) {
    fieldTypes[fieldTypeNames[_key]] = parseInt(_key, 10);
  }
}

var photometricInterpretations = {
  WhiteIsZero: 0,
  BlackIsZero: 1,
  RGB: 2,
  Palette: 3,
  TransparencyMask: 4,
  CMYK: 5,
  YCbCr: 6,
  CIELab: 8,
  ICCLab: 9
};
var ExtraSamplesValues = {
  Unspecified: 0,
  Assocalpha: 1,
  Unassalpha: 2
};
var LercParameters = {
  Version: 0,
  AddCompression: 1
};
var LercAddCompression = {
  None: 0,
  Deflate: 1
};
var geoKeyNames = {
  1024: 'GTModelTypeGeoKey',
  1025: 'GTRasterTypeGeoKey',
  1026: 'GTCitationGeoKey',
  2048: 'GeographicTypeGeoKey',
  2049: 'GeogCitationGeoKey',
  2050: 'GeogGeodeticDatumGeoKey',
  2051: 'GeogPrimeMeridianGeoKey',
  2052: 'GeogLinearUnitsGeoKey',
  2053: 'GeogLinearUnitSizeGeoKey',
  2054: 'GeogAngularUnitsGeoKey',
  2055: 'GeogAngularUnitSizeGeoKey',
  2056: 'GeogEllipsoidGeoKey',
  2057: 'GeogSemiMajorAxisGeoKey',
  2058: 'GeogSemiMinorAxisGeoKey',
  2059: 'GeogInvFlatteningGeoKey',
  2060: 'GeogAzimuthUnitsGeoKey',
  2061: 'GeogPrimeMeridianLongGeoKey',
  2062: 'GeogTOWGS84GeoKey',
  3072: 'ProjectedCSTypeGeoKey',
  3073: 'PCSCitationGeoKey',
  3074: 'ProjectionGeoKey',
  3075: 'ProjCoordTransGeoKey',
  3076: 'ProjLinearUnitsGeoKey',
  3077: 'ProjLinearUnitSizeGeoKey',
  3078: 'ProjStdParallel1GeoKey',
  3079: 'ProjStdParallel2GeoKey',
  3080: 'ProjNatOriginLongGeoKey',
  3081: 'ProjNatOriginLatGeoKey',
  3082: 'ProjFalseEastingGeoKey',
  3083: 'ProjFalseNorthingGeoKey',
  3084: 'ProjFalseOriginLongGeoKey',
  3085: 'ProjFalseOriginLatGeoKey',
  3086: 'ProjFalseOriginEastingGeoKey',
  3087: 'ProjFalseOriginNorthingGeoKey',
  3088: 'ProjCenterLongGeoKey',
  3089: 'ProjCenterLatGeoKey',
  3090: 'ProjCenterEastingGeoKey',
  3091: 'ProjCenterNorthingGeoKey',
  3092: 'ProjScaleAtNatOriginGeoKey',
  3093: 'ProjScaleAtCenterGeoKey',
  3094: 'ProjAzimuthAngleGeoKey',
  3095: 'ProjStraightVertPoleLongGeoKey',
  3096: 'ProjRectifiedGridAngleGeoKey',
  4096: 'VerticalCSTypeGeoKey',
  4097: 'VerticalCitationGeoKey',
  4098: 'VerticalDatumGeoKey',
  4099: 'VerticalUnitsGeoKey'
};
var geoKeys = {};

for (var _key2 in geoKeyNames) {
  if (geoKeyNames.hasOwnProperty(_key2)) {
    geoKeys[geoKeyNames[_key2]] = parseInt(_key2, 10);
  }
}

/***/ }),

/***/ "./node_modules/geotiff/dist-module/logging.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/logging.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setLogger": function() { return /* binding */ setLogger; },
/* harmony export */   "debug": function() { return /* binding */ debug; },
/* harmony export */   "log": function() { return /* binding */ log; },
/* harmony export */   "info": function() { return /* binding */ info; },
/* harmony export */   "warn": function() { return /* binding */ warn; },
/* harmony export */   "error": function() { return /* binding */ error; },
/* harmony export */   "time": function() { return /* binding */ time; },
/* harmony export */   "timeEnd": function() { return /* binding */ timeEnd; }
/* harmony export */ });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * A no-op logger
 */
var DummyLogger = /*#__PURE__*/function () {
  function DummyLogger() {
    _classCallCheck(this, DummyLogger);
  }

  _createClass(DummyLogger, [{
    key: "log",
    value: function log() {}
  }, {
    key: "debug",
    value: function debug() {}
  }, {
    key: "info",
    value: function info() {}
  }, {
    key: "warn",
    value: function warn() {}
  }, {
    key: "error",
    value: function error() {}
  }, {
    key: "time",
    value: function time() {}
  }, {
    key: "timeEnd",
    value: function timeEnd() {}
  }]);

  return DummyLogger;
}();

var LOGGER = new DummyLogger();
/**
 *
 * @param {object} logger the new logger. e.g `console`
 */

function setLogger() {
  var logger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new DummyLogger();
  LOGGER = logger;
}
function debug() {
  var _LOGGER;

  return (_LOGGER = LOGGER).debug.apply(_LOGGER, arguments);
}
function log() {
  var _LOGGER2;

  return (_LOGGER2 = LOGGER).log.apply(_LOGGER2, arguments);
}
function info() {
  var _LOGGER3;

  return (_LOGGER3 = LOGGER).info.apply(_LOGGER3, arguments);
}
function warn() {
  var _LOGGER4;

  return (_LOGGER4 = LOGGER).warn.apply(_LOGGER4, arguments);
}
function error() {
  var _LOGGER5;

  return (_LOGGER5 = LOGGER).error.apply(_LOGGER5, arguments);
}
function time() {
  var _LOGGER6;

  return (_LOGGER6 = LOGGER).time.apply(_LOGGER6, arguments);
}
function timeEnd() {
  var _LOGGER7;

  return (_LOGGER7 = LOGGER).timeEnd.apply(_LOGGER7, arguments);
}

/***/ }),

/***/ "./node_modules/geotiff/dist-module/pool.js":
/*!**************************************************!*\
  !*** ./node_modules/geotiff/dist-module/pool.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compression/index.js */ "./node_modules/geotiff/dist-module/compression/index.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }


var defaultPoolSize = typeof navigator !== 'undefined' ? navigator.hardwareConcurrency || 2 : 2;
/**
 * @module pool
 */

/**
 * Pool for workers to decode chunks of the images.
 */

var Pool = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs
   *                      available. When this parameter is `null` or 0, then the
   *                      decoding will be done in the main thread.
   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.
   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`
   * function is expected to return a `Worker` compatible with Web Workers. For code that
   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.
   *
   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:
   * ```js
   * import { addDecoder, getDecoder } from 'geotiff';
   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));
   * self.addEventListener('message', async (e) => {
   *   const { id, fileDirectory, buffer } = e.data;
   *   const decoder = await getDecoder(fileDirectory);
   *   const decoded = await decoder.decode(fileDirectory, buffer);
   *   self.postMessage({ decoded, id }, [decoded]);
   * });
   * ```
   * The way the above code is built into a worker by the `createWorker()` function
   * depends on the used bundler. For most bundlers, something like this will work:
   * ```js
   * function createWorker() {
   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));
   * }
   * ```
   */
  function Pool() {
    var _this = this;

    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultPoolSize;
    var createWorker = arguments.length > 1 ? arguments[1] : undefined;

    _classCallCheck(this, Pool);

    this.workers = null;
    this._awaitingDecoder = null;
    this.size = size;
    this.messageId = 0;

    if (size) {
      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise(function (resolve) {
        __webpack_require__.e(/*! import() */ "vendors-node_modules_geotiff_dist-module_worker_decoder_js").then(__webpack_require__.bind(__webpack_require__, /*! ./worker/decoder.js */ "./node_modules/geotiff/dist-module/worker/decoder.js")).then(function (module) {
          resolve(module.create);
        });
      });

      this._awaitingDecoder.then(function (create) {
        _this._awaitingDecoder = null;
        _this.workers = [];

        for (var i = 0; i < size; i++) {
          _this.workers.push({
            worker: create(),
            idle: true
          });
        }
      });
    }
  }
  /**
   * Decode the given block of bytes with the set compression method.
   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.
   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`
   */


  _createClass(Pool, [{
    key: "decode",
    value: function () {
      var _decode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(fileDirectory, buffer) {
        var _this2 = this;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._awaitingDecoder) {
                  _context.next = 3;
                  break;
                }

                _context.next = 3;
                return this._awaitingDecoder;

              case 3:
                return _context.abrupt("return", this.size === 0 ? (0,_compression_index_js__WEBPACK_IMPORTED_MODULE_0__.getDecoder)(fileDirectory).then(function (decoder) {
                  return decoder.decode(fileDirectory, buffer);
                }) : new Promise(function (resolve) {
                  var worker = _this2.workers.find(function (candidate) {
                    return candidate.idle;
                  }) || _this2.workers[Math.floor(Math.random() * _this2.size)];

                  worker.idle = false;
                  var id = _this2.messageId++;

                  var onMessage = function onMessage(e) {
                    if (e.data.id === id) {
                      worker.idle = true;
                      resolve(e.data.decoded);
                      worker.worker.removeEventListener('message', onMessage);
                    }
                  };

                  worker.worker.addEventListener('message', onMessage);
                  worker.worker.postMessage({
                    fileDirectory: fileDirectory,
                    buffer: buffer,
                    id: id
                  }, [buffer]);
                }));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function decode(_x, _x2) {
        return _decode.apply(this, arguments);
      }

      return decode;
    }()
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.workers) {
        this.workers.forEach(function (worker) {
          worker.worker.terminate();
        });
        this.workers = null;
      }
    }
  }]);

  return Pool;
}();

/* harmony default export */ __webpack_exports__["default"] = (Pool);

/***/ }),

/***/ "./node_modules/geotiff/dist-module/resample.js":
/*!******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/resample.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resampleNearest": function() { return /* binding */ resampleNearest; },
/* harmony export */   "resampleBilinear": function() { return /* binding */ resampleBilinear; },
/* harmony export */   "resample": function() { return /* binding */ resample; },
/* harmony export */   "resampleNearestInterleaved": function() { return /* binding */ resampleNearestInterleaved; },
/* harmony export */   "resampleBilinearInterleaved": function() { return /* binding */ resampleBilinearInterleaved; },
/* harmony export */   "resampleInterleaved": function() { return /* binding */ resampleInterleaved; }
/* harmony export */ });
/**
 * @module resample
 */
function copyNewSize(array, width, height) {
  var samplesPerPixel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);
}
/**
 * Resample the input arrays using nearest neighbor value selection.
 * @param {TypedArray[]} valueArrays The input arrays to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @returns {TypedArray[]} The resampled rasters
 */


function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {
  var relX = inWidth / outWidth;
  var relY = inHeight / outHeight;
  return valueArrays.map(function (array) {
    var newArray = copyNewSize(array, outWidth, outHeight);

    for (var y = 0; y < outHeight; ++y) {
      var cy = Math.min(Math.round(relY * y), inHeight - 1);

      for (var x = 0; x < outWidth; ++x) {
        var cx = Math.min(Math.round(relX * x), inWidth - 1);
        var value = array[cy * inWidth + cx];
        newArray[y * outWidth + x] = value;
      }
    }

    return newArray;
  });
} // simple linear interpolation, code from:
// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support

function lerp(v0, v1, t) {
  return (1 - t) * v0 + t * v1;
}
/**
 * Resample the input arrays using bilinear interpolation.
 * @param {TypedArray[]} valueArrays The input arrays to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @returns {TypedArray[]} The resampled rasters
 */


function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {
  var relX = inWidth / outWidth;
  var relY = inHeight / outHeight;
  return valueArrays.map(function (array) {
    var newArray = copyNewSize(array, outWidth, outHeight);

    for (var y = 0; y < outHeight; ++y) {
      var rawY = relY * y;
      var yl = Math.floor(rawY);
      var yh = Math.min(Math.ceil(rawY), inHeight - 1);

      for (var x = 0; x < outWidth; ++x) {
        var rawX = relX * x;
        var tx = rawX % 1;
        var xl = Math.floor(rawX);
        var xh = Math.min(Math.ceil(rawX), inWidth - 1);
        var ll = array[yl * inWidth + xl];
        var hl = array[yl * inWidth + xh];
        var lh = array[yh * inWidth + xl];
        var hh = array[yh * inWidth + xh];
        var value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);
        newArray[y * outWidth + x] = value;
      }
    }

    return newArray;
  });
}
/**
 * Resample the input arrays using the selected resampling method.
 * @param {TypedArray[]} valueArrays The input arrays to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @param {string} [method = 'nearest'] The desired resampling method
 * @returns {TypedArray[]} The resampled rasters
 */

function resample(valueArrays, inWidth, inHeight, outWidth, outHeight) {
  var method = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'nearest';

  switch (method.toLowerCase()) {
    case 'nearest':
      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);

    case 'bilinear':
    case 'linear':
      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);

    default:
      throw new Error("Unsupported resampling method: '".concat(method, "'"));
  }
}
/**
 * Resample the pixel interleaved input array using nearest neighbor value selection.
 * @param {TypedArray} valueArrays The input arrays to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @param {number} samples The number of samples per pixel for pixel
 *                         interleaved data
 * @returns {TypedArray} The resampled raster
 */

function resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {
  var relX = inWidth / outWidth;
  var relY = inHeight / outHeight;
  var newArray = copyNewSize(valueArray, outWidth, outHeight, samples);

  for (var y = 0; y < outHeight; ++y) {
    var cy = Math.min(Math.round(relY * y), inHeight - 1);

    for (var x = 0; x < outWidth; ++x) {
      var cx = Math.min(Math.round(relX * x), inWidth - 1);

      for (var i = 0; i < samples; ++i) {
        var value = valueArray[cy * inWidth * samples + cx * samples + i];
        newArray[y * outWidth * samples + x * samples + i] = value;
      }
    }
  }

  return newArray;
}
/**
 * Resample the pixel interleaved input array using bilinear interpolation.
 * @param {TypedArray} valueArrays The input arrays to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @param {number} samples The number of samples per pixel for pixel
 *                         interleaved data
 * @returns {TypedArray} The resampled raster
 */

function resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {
  var relX = inWidth / outWidth;
  var relY = inHeight / outHeight;
  var newArray = copyNewSize(valueArray, outWidth, outHeight, samples);

  for (var y = 0; y < outHeight; ++y) {
    var rawY = relY * y;
    var yl = Math.floor(rawY);
    var yh = Math.min(Math.ceil(rawY), inHeight - 1);

    for (var x = 0; x < outWidth; ++x) {
      var rawX = relX * x;
      var tx = rawX % 1;
      var xl = Math.floor(rawX);
      var xh = Math.min(Math.ceil(rawX), inWidth - 1);

      for (var i = 0; i < samples; ++i) {
        var ll = valueArray[yl * inWidth * samples + xl * samples + i];
        var hl = valueArray[yl * inWidth * samples + xh * samples + i];
        var lh = valueArray[yh * inWidth * samples + xl * samples + i];
        var hh = valueArray[yh * inWidth * samples + xh * samples + i];
        var value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);
        newArray[y * outWidth * samples + x * samples + i] = value;
      }
    }
  }

  return newArray;
}
/**
 * Resample the pixel interleaved input array using the selected resampling method.
 * @param {TypedArray} valueArray The input array to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @param {number} samples The number of samples per pixel for pixel
 *                                 interleaved data
 * @param {string} [method = 'nearest'] The desired resampling method
 * @returns {TypedArray} The resampled rasters
 */

function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {
  var method = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'nearest';

  switch (method.toLowerCase()) {
    case 'nearest':
      return resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);

    case 'bilinear':
    case 'linear':
      return resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);

    default:
      throw new Error("Unsupported resampling method: '".concat(method, "'"));
  }
}

/***/ }),

/***/ "./node_modules/geotiff/dist-module/rgb.js":
/*!*************************************************!*\
  !*** ./node_modules/geotiff/dist-module/rgb.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fromWhiteIsZero": function() { return /* binding */ fromWhiteIsZero; },
/* harmony export */   "fromBlackIsZero": function() { return /* binding */ fromBlackIsZero; },
/* harmony export */   "fromPalette": function() { return /* binding */ fromPalette; },
/* harmony export */   "fromCMYK": function() { return /* binding */ fromCMYK; },
/* harmony export */   "fromYCbCr": function() { return /* binding */ fromYCbCr; },
/* harmony export */   "fromCIELab": function() { return /* binding */ fromCIELab; }
/* harmony export */ });
function fromWhiteIsZero(raster, max) {
  var width = raster.width,
      height = raster.height;
  var rgbRaster = new Uint8Array(width * height * 3);
  var value;

  for (var i = 0, j = 0; i < raster.length; ++i, j += 3) {
    value = 256 - raster[i] / max * 256;
    rgbRaster[j] = value;
    rgbRaster[j + 1] = value;
    rgbRaster[j + 2] = value;
  }

  return rgbRaster;
}
function fromBlackIsZero(raster, max) {
  var width = raster.width,
      height = raster.height;
  var rgbRaster = new Uint8Array(width * height * 3);
  var value;

  for (var i = 0, j = 0; i < raster.length; ++i, j += 3) {
    value = raster[i] / max * 256;
    rgbRaster[j] = value;
    rgbRaster[j + 1] = value;
    rgbRaster[j + 2] = value;
  }

  return rgbRaster;
}
function fromPalette(raster, colorMap) {
  var width = raster.width,
      height = raster.height;
  var rgbRaster = new Uint8Array(width * height * 3);
  var greenOffset = colorMap.length / 3;
  var blueOffset = colorMap.length / 3 * 2;

  for (var i = 0, j = 0; i < raster.length; ++i, j += 3) {
    var mapIndex = raster[i];
    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;
    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;
    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;
  }

  return rgbRaster;
}
function fromCMYK(cmykRaster) {
  var width = cmykRaster.width,
      height = cmykRaster.height;
  var rgbRaster = new Uint8Array(width * height * 3);

  for (var i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {
    var c = cmykRaster[i];
    var m = cmykRaster[i + 1];
    var y = cmykRaster[i + 2];
    var k = cmykRaster[i + 3];
    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);
    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);
    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);
  }

  return rgbRaster;
}
function fromYCbCr(yCbCrRaster) {
  var width = yCbCrRaster.width,
      height = yCbCrRaster.height;
  var rgbRaster = new Uint8ClampedArray(width * height * 3);

  for (var i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {
    var y = yCbCrRaster[i];
    var cb = yCbCrRaster[i + 1];
    var cr = yCbCrRaster[i + 2];
    rgbRaster[j] = y + 1.40200 * (cr - 0x80);
    rgbRaster[j + 1] = y - 0.34414 * (cb - 0x80) - 0.71414 * (cr - 0x80);
    rgbRaster[j + 2] = y + 1.77200 * (cb - 0x80);
  }

  return rgbRaster;
}
var Xn = 0.95047;
var Yn = 1.00000;
var Zn = 1.08883; // from https://github.com/antimatter15/rgb-lab/blob/master/color.js

function fromCIELab(cieLabRaster) {
  var width = cieLabRaster.width,
      height = cieLabRaster.height;
  var rgbRaster = new Uint8Array(width * height * 3);

  for (var i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {
    var L = cieLabRaster[i + 0];
    var a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8

    var b_ = cieLabRaster[i + 2] << 24 >> 24; // same

    var y = (L + 16) / 116;
    var x = a_ / 500 + y;
    var z = y - b_ / 200;
    var r = void 0;
    var g = void 0;
    var b = void 0;
    x = Xn * (x * x * x > 0.008856 ? x * x * x : (x - 16 / 116) / 7.787);
    y = Yn * (y * y * y > 0.008856 ? y * y * y : (y - 16 / 116) / 7.787);
    z = Zn * (z * z * z > 0.008856 ? z * z * z : (z - 16 / 116) / 7.787);
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.2040 + z * 1.0570;
    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : 12.92 * r;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : 12.92 * g;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : 12.92 * b;
    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;
    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;
    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;
  }

  return rgbRaster;
}

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/arraybuffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/arraybuffer.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeBufferSource": function() { return /* binding */ makeBufferSource; }
/* harmony export */ });
/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ "./node_modules/geotiff/dist-module/source/basesource.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/geotiff/dist-module/utils.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var ArrayBufferSource = /*#__PURE__*/function (_BaseSource) {
  _inherits(ArrayBufferSource, _BaseSource);

  var _super = _createSuper(ArrayBufferSource);

  function ArrayBufferSource(arrayBuffer) {
    var _this;

    _classCallCheck(this, ArrayBufferSource);

    _this = _super.call(this);
    _this.arrayBuffer = arrayBuffer;
    return _this;
  }

  _createClass(ArrayBufferSource, [{
    key: "fetchSlice",
    value: function fetchSlice(slice, signal) {
      if (signal && signal.aborted) {
        throw new _utils_js__WEBPACK_IMPORTED_MODULE_0__.AbortError('Request aborted');
      }

      return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);
    }
  }]);

  return ArrayBufferSource;
}(_basesource_js__WEBPACK_IMPORTED_MODULE_1__.BaseSource);

function makeBufferSource(arrayBuffer) {
  return new ArrayBufferSource(arrayBuffer);
}

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/basesource.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/basesource.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseSource": function() { return /* binding */ BaseSource; }
/* harmony export */ });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * @typedef Slice
 * @property {number} offset
 * @property {number} length
 */
var BaseSource = /*#__PURE__*/function () {
  function BaseSource() {
    _classCallCheck(this, BaseSource);
  }

  _createClass(BaseSource, [{
    key: "fetch",
    value:
    /**
     *
     * @param {Slice[]} slices
     * @returns {ArrayBuffer[]}
     */
    function () {
      var _fetch = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(slices) {
        var _this = this;

        var signal,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                signal = _args.length > 1 && _args[1] !== undefined ? _args[1] : undefined;
                return _context.abrupt("return", Promise.all(slices.map(function (slice) {
                  return _this.fetchSlice(slice, signal);
                })));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function fetch(_x) {
        return _fetch.apply(this, arguments);
      }

      return fetch;
    }()
    /**
     *
     * @param {Slice} slice
     * @returns {ArrayBuffer}
     */

  }, {
    key: "fetchSlice",
    value: function () {
      var _fetchSlice = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(slice) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                throw new Error("fetching of slice ".concat(slice, " not possible, not implemented"));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function fetchSlice(_x2) {
        return _fetchSlice.apply(this, arguments);
      }

      return fetchSlice;
    }()
    /**
     * Returns the filesize if already determined and null otherwise
     */

  }, {
    key: "fileSize",
    get: function get() {
      return null;
    }
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }]);

  return BaseSource;
}();

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/blockedsource.js":
/*!******************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/blockedsource.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlockedSource": function() { return /* binding */ BlockedSource; }
/* harmony export */ });
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basesource.js */ "./node_modules/geotiff/dist-module/source/basesource.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/geotiff/dist-module/utils.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }





var Block = /*#__PURE__*/function () {
  /**
   *
   * @param {number} offset
   * @param {number} length
   * @param {ArrayBuffer} [data]
   */
  function Block(offset, length) {
    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, Block);

    this.offset = offset;
    this.length = length;
    this.data = data;
  }
  /**
   * @returns {number} the top byte border
   */


  _createClass(Block, [{
    key: "top",
    get: function get() {
      return this.offset + this.length;
    }
  }]);

  return Block;
}();

var BlockGroup = /*#__PURE__*/_createClass(
/**
 *
 * @param {number} offset
 * @param {number} length
 * @param {number[]} blockIds
 */
function BlockGroup(offset, length, blockIds) {
  _classCallCheck(this, BlockGroup);

  this.offset = offset;
  this.length = length;
  this.blockIds = blockIds;
});

var BlockedSource = /*#__PURE__*/function (_BaseSource) {
  _inherits(BlockedSource, _BaseSource);

  var _super = _createSuper(BlockedSource);

  /**
   *
   * @param {Source} source The underlying source that shall be blocked and cached
   * @param {object} options
   */
  function BlockedSource(source) {
    var _this;

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$blockSize = _ref.blockSize,
        blockSize = _ref$blockSize === void 0 ? 65536 : _ref$blockSize,
        _ref$cacheSize = _ref.cacheSize,
        cacheSize = _ref$cacheSize === void 0 ? 100 : _ref$cacheSize;

    _classCallCheck(this, BlockedSource);

    _this = _super.call(this);
    _this.source = source;
    _this.blockSize = blockSize;
    _this.blockCache = new lru_cache__WEBPACK_IMPORTED_MODULE_0__({
      max: cacheSize
    }); // mapping blockId -> Block instance

    _this.blockRequests = new Map(); // set of blockIds missing for the current requests

    _this.blockIdsToFetch = new Set();
    return _this;
  }

  _createClass(BlockedSource, [{
    key: "fileSize",
    get: function get() {
      return this.source.fileSize;
    }
    /**
     *
     * @param {basesource/Slice[]} slices
     */

  }, {
    key: "fetch",
    value: function () {
      var _fetch = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(slices, signal) {
        var cachedBlocks, blockRequests, missingBlockIds, _iterator, _step, _step$value, offset, length, top, fileSize, firstBlockOffset, current, _blockId2, _iterator2, _step2, _blockId3, _block, cachedBlock, results, retriedBlockRequests, _iterator3, _step3, _step3$value, _blockId, result, rejected, reason, _iterator4, _step4, blockId, block, values, requiredBlocks, _iterator5, _step5, _step5$value, _blockId4, _block2;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cachedBlocks = new Map();
                blockRequests = new Map();
                missingBlockIds = new Set();
                _iterator = _createForOfIteratorHelper(slices);

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    _step$value = _step.value, offset = _step$value.offset, length = _step$value.length;
                    top = offset + length;
                    fileSize = this.fileSize;

                    if (fileSize !== null) {
                      top = Math.min(top, fileSize);
                    }

                    firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize; // chunk the current slice into blocks

                    for (current = firstBlockOffset; current < top; current += this.blockSize) {
                      // check if the block is cached, being requested or still missing
                      _blockId2 = Math.floor(current / this.blockSize);

                      if (this.blockCache.has(_blockId2)) {
                        cachedBlocks.set(_blockId2, this.blockCache.get(_blockId2));
                      } else if (this.blockRequests.has(_blockId2)) {
                        blockRequests.set(_blockId2, this.blockRequests.get(_blockId2));
                      } else if (this.blockIdsToFetch.has(_blockId2)) {
                        missingBlockIds.add(_blockId2);
                      } else {
                        this.blockIdsToFetch.add(_blockId2);
                        missingBlockIds.add(_blockId2);
                      }
                    }
                  } // allow additional block requests to accumulate

                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                _context.next = 7;
                return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wait)();

              case 7:
                this.fetchBlocks(signal);
                _iterator2 = _createForOfIteratorHelper(missingBlockIds);
                _context.prev = 9;

                _iterator2.s();

              case 11:
                if ((_step2 = _iterator2.n()).done) {
                  _context.next = 26;
                  break;
                }

                _blockId3 = _step2.value;
                _block = this.blockRequests.get(_blockId3);
                cachedBlock = this.blockCache.get(_blockId3);

                if (!_block) {
                  _context.next = 19;
                  break;
                }

                blockRequests.set(_blockId3, _block);
                _context.next = 24;
                break;

              case 19:
                if (!cachedBlock) {
                  _context.next = 23;
                  break;
                }

                cachedBlocks.set(_blockId3, cachedBlock);
                _context.next = 24;
                break;

              case 23:
                throw new Error("Block ".concat(_blockId3, " is not in the block requests"));

              case 24:
                _context.next = 11;
                break;

              case 26:
                _context.next = 31;
                break;

              case 28:
                _context.prev = 28;
                _context.t0 = _context["catch"](9);

                _iterator2.e(_context.t0);

              case 31:
                _context.prev = 31;

                _iterator2.f();

                return _context.finish(31);

              case 34:
                _context.next = 36;
                return Promise.allSettled(Array.from(blockRequests.values()));

              case 36:
                results = _context.sent;

                if (!results.some(function (result) {
                  return result.status === 'rejected';
                })) {
                  _context.next = 65;
                  break;
                }

                retriedBlockRequests = new Set();
                _iterator3 = _createForOfIteratorHelper((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zip)(blockRequests.keys(), results));

                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    _step3$value = _slicedToArray(_step3.value, 2), _blockId = _step3$value[0], result = _step3$value[1];
                    rejected = result.rejected, reason = result.reason;

                    if (rejected) {
                      // push some blocks back to the to-fetch list if they were
                      // aborted, but only when a different signal was used
                      if (reason.name === 'AbortError' && reason.signal !== signal) {
                        this.blockIdsToFetch.add(_blockId);
                        retriedBlockRequests.add(_blockId);
                      }
                    }
                  } // start the retry of some blocks if required

                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }

                if (!(this.blockIdsToFetch.length > 0)) {
                  _context.next = 65;
                  break;
                }

                this.fetchBlocks(signal);
                _iterator4 = _createForOfIteratorHelper(retriedBlockRequests);
                _context.prev = 44;

                _iterator4.s();

              case 46:
                if ((_step4 = _iterator4.n()).done) {
                  _context.next = 54;
                  break;
                }

                blockId = _step4.value;
                block = this.blockRequests.get(blockId);

                if (block) {
                  _context.next = 51;
                  break;
                }

                throw new Error("Block ".concat(blockId, " is not in the block requests"));

              case 51:
                blockRequests.set(blockId, block);

              case 52:
                _context.next = 46;
                break;

              case 54:
                _context.next = 59;
                break;

              case 56:
                _context.prev = 56;
                _context.t1 = _context["catch"](44);

                _iterator4.e(_context.t1);

              case 59:
                _context.prev = 59;

                _iterator4.f();

                return _context.finish(59);

              case 62:
                _context.next = 64;
                return Promise.allSettled(Array.from(blockRequests.values()));

              case 64:
                results = _context.sent;

              case 65:
                if (!results.some(function (result) {
                  return result.status === 'rejected';
                })) {
                  _context.next = 69;
                  break;
                }

                if (!(signal && signal.aborted)) {
                  _context.next = 68;
                  break;
                }

                throw new _utils_js__WEBPACK_IMPORTED_MODULE_1__.AbortError('Request was aborted');

              case 68:
                throw new _utils_js__WEBPACK_IMPORTED_MODULE_1__.AggregateError(results.filter(function (result) {
                  return result.status === 'rejected';
                }).map(function (result) {
                  return result.reason;
                }), 'Request failed');

              case 69:
                // extract the actual block responses
                values = results.map(function (result) {
                  return result.value;
                }); // create a final Map, with all required blocks for this request to satisfy

                requiredBlocks = new Map((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zip)(Array.from(blockRequests.keys()), values));
                _iterator5 = _createForOfIteratorHelper(cachedBlocks);

                try {
                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                    _step5$value = _slicedToArray(_step5.value, 2), _blockId4 = _step5$value[0], _block2 = _step5$value[1];
                    requiredBlocks.set(_blockId4, _block2);
                  } // TODO: satisfy each slice

                } catch (err) {
                  _iterator5.e(err);
                } finally {
                  _iterator5.f();
                }

                return _context.abrupt("return", this.readSliceData(slices, requiredBlocks));

              case 74:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[9, 28, 31, 34], [44, 56, 59, 62]]);
      }));

      function fetch(_x, _x2) {
        return _fetch.apply(this, arguments);
      }

      return fetch;
    }()
    /**
     *
     * @param {AbortSignal} signal
     */

  }, {
    key: "fetchBlocks",
    value: function fetchBlocks(signal) {
      var _this2 = this;

      // check if we still need to
      if (this.blockIdsToFetch.size > 0) {
        (function () {
          var groups = _this2.groupBlocks(_this2.blockIdsToFetch); // start requesting slices of data


          var groupRequests = _this2.source.fetch(groups, signal);

          var _loop = function _loop(groupIndex) {
            var group = groups[groupIndex];

            var _iterator6 = _createForOfIteratorHelper(group.blockIds),
                _step6;

            try {
              var _loop2 = function _loop2() {
                var blockId = _step6.value;

                // make an async IIFE for each block
                var blockRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                  var response, blockOffset, o, t, data, block;
                  return regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.prev = 0;
                          _context2.next = 3;
                          return groupRequests;

                        case 3:
                          _context2.t0 = groupIndex;
                          response = _context2.sent[_context2.t0];
                          blockOffset = blockId * _this2.blockSize;
                          o = blockOffset - response.offset;
                          t = Math.min(o + _this2.blockSize, response.data.byteLength);
                          data = response.data.slice(o, t);
                          block = new Block(blockOffset, data.byteLength, data);

                          _this2.blockCache.set(blockId, block);

                          return _context2.abrupt("return", block);

                        case 14:
                          _context2.prev = 14;
                          _context2.t1 = _context2["catch"](0);

                          if (_context2.t1.name === 'AbortError') {
                            // store the signal here, we need it to determine later if an
                            // error was caused by this signal
                            _context2.t1.signal = signal;
                          }

                          throw _context2.t1;

                        case 18:
                          _context2.prev = 18;

                          _this2.blockRequests.delete(blockId);

                          return _context2.finish(18);

                        case 21:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2, null, [[0, 14, 18, 21]]);
                }))();

                _this2.blockRequests.set(blockId, blockRequest);
              };

              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                _loop2();
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
          };

          for (var groupIndex = 0; groupIndex < groups.length; ++groupIndex) {
            _loop(groupIndex);
          }

          _this2.blockIdsToFetch.clear();
        })();
      }
    }
    /**
     *
     * @param {Set} blockIds
     * @returns {BlockGroup[]}
     */

  }, {
    key: "groupBlocks",
    value: function groupBlocks(blockIds) {
      var sortedBlockIds = Array.from(blockIds).sort(function (a, b) {
        return a - b;
      });

      if (sortedBlockIds.length === 0) {
        return [];
      }

      var current = [];
      var lastBlockId = null;
      var groups = [];

      var _iterator7 = _createForOfIteratorHelper(sortedBlockIds),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var blockId = _step7.value;

          if (lastBlockId === null || lastBlockId + 1 === blockId) {
            current.push(blockId);
            lastBlockId = blockId;
          } else {
            groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));
            current = [blockId];
            lastBlockId = blockId;
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));
      return groups;
    }
    /**
     *
     * @param {Slice[]} slices
     * @param {Map} blocks
     */

  }, {
    key: "readSliceData",
    value: function readSliceData(slices, blocks) {
      var _this3 = this;

      return slices.map(function (slice) {
        var top = slice.offset + slice.length;
        var blockIdLow = Math.floor(slice.offset / _this3.blockSize);
        var blockIdHigh = Math.floor((slice.offset + slice.length) / _this3.blockSize);
        var sliceData = new ArrayBuffer(slice.length);
        var sliceView = new Uint8Array(sliceData);

        for (var blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {
          var block = blocks.get(blockId);
          var delta = block.offset - slice.offset;
          var topDelta = block.top - top;
          var blockInnerOffset = 0;
          var rangeInnerOffset = 0;
          var usedBlockLength = void 0;

          if (delta < 0) {
            blockInnerOffset = -delta;
          } else if (delta > 0) {
            rangeInnerOffset = delta;
          }

          if (topDelta < 0) {
            usedBlockLength = block.length - blockInnerOffset;
          } else {
            usedBlockLength = top - block.offset - blockInnerOffset;
          }

          var blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);
          sliceView.set(blockView, rangeInnerOffset);
        }

        return sliceData;
      });
    }
  }]);

  return BlockedSource;
}(_basesource_js__WEBPACK_IMPORTED_MODULE_2__.BaseSource);

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/base.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/base.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseResponse": function() { return /* binding */ BaseResponse; },
/* harmony export */   "BaseClient": function() { return /* binding */ BaseClient; }
/* harmony export */ });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var BaseResponse = /*#__PURE__*/function () {
  function BaseResponse() {
    _classCallCheck(this, BaseResponse);
  }

  _createClass(BaseResponse, [{
    key: "ok",
    get:
    /**
     * Returns whether the response has an ok'ish status code
     */
    function get() {
      return this.status >= 200 && this.status <= 299;
    }
    /**
     * Returns the status code of the response
     */

  }, {
    key: "status",
    get: function get() {
      throw new Error('not implemented');
    }
    /**
     * Returns the value of the specified header
     * @param {string} headerName the header name
     * @returns {string} the header value
     */

  }, {
    key: "getHeader",
    value: function getHeader(headerName) {
      // eslint-disable-line no-unused-vars
      throw new Error('not implemented');
    }
    /**
     * @returns {ArrayBuffer} the response data of the request
     */

  }, {
    key: "getData",
    value: function () {
      var _getData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                throw new Error('not implemented');

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function getData() {
        return _getData.apply(this, arguments);
      }

      return getData;
    }()
  }]);

  return BaseResponse;
}();
var BaseClient = /*#__PURE__*/function () {
  function BaseClient(url) {
    _classCallCheck(this, BaseClient);

    this.url = url;
  }
  /**
   * Send a request with the options
   * @param {object} [options]
   */


  _createClass(BaseClient, [{
    key: "request",
    value: function () {
      var _request = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _ref,
            headers,
            credentials,
            signal,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, headers = _ref.headers, credentials = _ref.credentials, signal = _ref.signal;
                throw new Error('request is not implemented');

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function request() {
        return _request.apply(this, arguments);
      }

      return request;
    }()
  }]);

  return BaseClient;
}();

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/fetch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/fetch.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FetchClient": function() { return /* binding */ FetchClient; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/geotiff/dist-module/source/client/base.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var FetchResponse = /*#__PURE__*/function (_BaseResponse) {
  _inherits(FetchResponse, _BaseResponse);

  var _super = _createSuper(FetchResponse);

  /**
   * BaseResponse facade for fetch API Response
   * @param {Response} response
   */
  function FetchResponse(response) {
    var _this;

    _classCallCheck(this, FetchResponse);

    _this = _super.call(this);
    _this.response = response;
    return _this;
  }

  _createClass(FetchResponse, [{
    key: "status",
    get: function get() {
      return this.response.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(name) {
      return this.response.headers.get(name);
    }
  }, {
    key: "getData",
    value: function () {
      var _getData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var data;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.response.arrayBuffer) {
                  _context.next = 6;
                  break;
                }

                _context.next = 3;
                return this.response.arrayBuffer();

              case 3:
                _context.t0 = _context.sent;
                _context.next = 9;
                break;

              case 6:
                _context.next = 8;
                return this.response.buffer();

              case 8:
                _context.t0 = _context.sent.buffer;

              case 9:
                data = _context.t0;
                return _context.abrupt("return", data);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getData() {
        return _getData.apply(this, arguments);
      }

      return getData;
    }()
  }]);

  return FetchResponse;
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseResponse);

var FetchClient = /*#__PURE__*/function (_BaseClient) {
  _inherits(FetchClient, _BaseClient);

  var _super2 = _createSuper(FetchClient);

  function FetchClient(url, credentials) {
    var _this2;

    _classCallCheck(this, FetchClient);

    _this2 = _super2.call(this, url);
    _this2.credentials = credentials;
    return _this2;
  }

  _createClass(FetchClient, [{
    key: "request",
    value: function () {
      var _request = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _ref,
            headers,
            credentials,
            signal,
            response,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, headers = _ref.headers, credentials = _ref.credentials, signal = _ref.signal;
                _context2.next = 3;
                return fetch(this.url, {
                  headers: headers,
                  credentials: credentials,
                  signal: signal
                });

              case 3:
                response = _context2.sent;
                return _context2.abrupt("return", new FetchResponse(response));

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function request() {
        return _request.apply(this, arguments);
      }

      return request;
    }()
  }]);

  return FetchClient;
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseClient);

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/http.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/http.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HttpClient": function() { return /* binding */ HttpClient; }
/* harmony export */ });
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ "?cdec");
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ "?753a");
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ "?4e4d");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.js */ "./node_modules/geotiff/dist-module/source/client/base.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils.js */ "./node_modules/geotiff/dist-module/utils.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }







var HttpResponse = /*#__PURE__*/function (_BaseResponse) {
  _inherits(HttpResponse, _BaseResponse);

  var _super = _createSuper(HttpResponse);

  /**
   * BaseResponse facade for node HTTP/HTTPS API Response
   * @param {http.ServerResponse} response
   */
  function HttpResponse(response, dataPromise) {
    var _this;

    _classCallCheck(this, HttpResponse);

    _this = _super.call(this);
    _this.response = response;
    _this.dataPromise = dataPromise;
    return _this;
  }

  _createClass(HttpResponse, [{
    key: "status",
    get: function get() {
      return this.response.statusCode;
    }
  }, {
    key: "getHeader",
    value: function getHeader(name) {
      return this.response.headers[name];
    }
  }, {
    key: "getData",
    value: function () {
      var _getData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var data;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.dataPromise;

              case 2:
                data = _context.sent;
                return _context.abrupt("return", data);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getData() {
        return _getData.apply(this, arguments);
      }

      return getData;
    }()
  }]);

  return HttpResponse;
}(_base_js__WEBPACK_IMPORTED_MODULE_3__.BaseResponse);

var HttpClient = /*#__PURE__*/function (_BaseClient) {
  _inherits(HttpClient, _BaseClient);

  var _super2 = _createSuper(HttpClient);

  function HttpClient(url) {
    var _this2;

    _classCallCheck(this, HttpClient);

    _this2 = _super2.call(this, url);
    _this2.parsedUrl = url__WEBPACK_IMPORTED_MODULE_2__.parse(_this2.url);
    _this2.httpApi = _this2.parsedUrl.protocol === 'http:' ? http__WEBPACK_IMPORTED_MODULE_0__ : https__WEBPACK_IMPORTED_MODULE_1__;
    return _this2;
  }

  _createClass(HttpClient, [{
    key: "constructRequest",
    value: function constructRequest(headers, signal) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var request = _this3.httpApi.get(_objectSpread(_objectSpread({}, _this3.parsedUrl), {}, {
          headers: headers
        }), function (response) {
          var dataPromise = new Promise(function (resolveData) {
            var chunks = []; // collect chunks

            response.on('data', function (chunk) {
              chunks.push(chunk);
            }); // concatenate all chunks and resolve the promise with the resulting buffer

            response.on('end', function () {
              var data = Buffer.concat(chunks).buffer;
              resolveData(data);
            });
            response.on('error', reject);
          });
          resolve(new HttpResponse(response, dataPromise));
        });

        request.on('error', reject);

        if (signal) {
          if (signal.aborted) {
            request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__.AbortError('Request aborted'));
          }

          signal.addEventListener('abort', function () {
            return request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__.AbortError('Request aborted'));
          });
        }
      });
    }
  }, {
    key: "request",
    value: function () {
      var _request = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _ref,
            headers,
            signal,
            response,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, headers = _ref.headers, signal = _ref.signal;
                _context2.next = 3;
                return this.constructRequest(headers, signal);

              case 3:
                response = _context2.sent;
                return _context2.abrupt("return", response);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function request() {
        return _request.apply(this, arguments);
      }

      return request;
    }()
  }]);

  return HttpClient;
}(_base_js__WEBPACK_IMPORTED_MODULE_3__.BaseClient);

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/xhr.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/xhr.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "XHRClient": function() { return /* binding */ XHRClient; }
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/geotiff/dist-module/source/client/base.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils.js */ "./node_modules/geotiff/dist-module/utils.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var XHRResponse = /*#__PURE__*/function (_BaseResponse) {
  _inherits(XHRResponse, _BaseResponse);

  var _super = _createSuper(XHRResponse);

  /**
   * BaseResponse facade for XMLHttpRequest
   * @param {XMLHttpRequest} xhr
   * @param {ArrayBuffer} data
   */
  function XHRResponse(xhr, data) {
    var _this;

    _classCallCheck(this, XHRResponse);

    _this = _super.call(this);
    _this.xhr = xhr;
    _this.data = data;
    return _this;
  }

  _createClass(XHRResponse, [{
    key: "status",
    get: function get() {
      return this.xhr.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(name) {
      return this.xhr.getResponseHeader(name);
    }
  }, {
    key: "getData",
    value: function () {
      var _getData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.data);

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getData() {
        return _getData.apply(this, arguments);
      }

      return getData;
    }()
  }]);

  return XHRResponse;
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseResponse);

var XHRClient = /*#__PURE__*/function (_BaseClient) {
  _inherits(XHRClient, _BaseClient);

  var _super2 = _createSuper(XHRClient);

  function XHRClient() {
    _classCallCheck(this, XHRClient);

    return _super2.apply(this, arguments);
  }

  _createClass(XHRClient, [{
    key: "constructRequest",
    value: function constructRequest(headers, signal) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', _this2.url);
        xhr.responseType = 'arraybuffer';

        for (var _i = 0, _Object$entries = Object.entries(headers); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              key = _Object$entries$_i[0],
              value = _Object$entries$_i[1];

          xhr.setRequestHeader(key, value);
        } // hook signals


        xhr.onload = function () {
          var data = xhr.response;
          resolve(new XHRResponse(xhr, data));
        };

        xhr.onerror = reject;

        xhr.onabort = function () {
          return reject(new _utils_js__WEBPACK_IMPORTED_MODULE_1__.AbortError('Request aborted'));
        };

        xhr.send();

        if (signal) {
          if (signal.aborted) {
            xhr.abort();
          }

          signal.addEventListener('abort', function () {
            return xhr.abort();
          });
        }
      });
    }
  }, {
    key: "request",
    value: function () {
      var _request = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _ref,
            headers,
            signal,
            response,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, headers = _ref.headers, signal = _ref.signal;
                _context2.next = 3;
                return this.constructRequest(headers, signal);

              case 3:
                response = _context2.sent;
                return _context2.abrupt("return", response);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function request() {
        return _request.apply(this, arguments);
      }

      return request;
    }()
  }]);

  return XHRClient;
}(_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseClient);

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/file.js":
/*!*********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/file.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeFileSource": function() { return /* binding */ makeFileSource; }
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "?662e");
/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ "./node_modules/geotiff/dist-module/source/basesource.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




function closeAsync(fd) {
  return new Promise(function (resolve, reject) {
    fs__WEBPACK_IMPORTED_MODULE_0__.close(fd, function (err) {
      if (err) {
        reject(err);
      } else {
        resolve();
      }
    });
  });
}

function openAsync(path, flags) {
  var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  return new Promise(function (resolve, reject) {
    fs__WEBPACK_IMPORTED_MODULE_0__.open(path, flags, mode, function (err, fd) {
      if (err) {
        reject(err);
      } else {
        resolve(fd);
      }
    });
  });
}

function readAsync() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return new Promise(function (resolve, reject) {
    fs__WEBPACK_IMPORTED_MODULE_0__.read.apply(fs__WEBPACK_IMPORTED_MODULE_0__, args.concat([function (err, bytesRead, buffer) {
      if (err) {
        reject(err);
      } else {
        resolve({
          bytesRead: bytesRead,
          buffer: buffer
        });
      }
    }]));
  });
}

var FileSource = /*#__PURE__*/function (_BaseSource) {
  _inherits(FileSource, _BaseSource);

  var _super = _createSuper(FileSource);

  function FileSource(path) {
    var _this;

    _classCallCheck(this, FileSource);

    _this = _super.call(this);
    _this.path = path;
    _this.openRequest = openAsync(path, 'r');
    return _this;
  }

  _createClass(FileSource, [{
    key: "fetchSlice",
    value: function () {
      var _fetchSlice = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(slice) {
        var fd, _yield$readAsync, buffer;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.openRequest;

              case 2:
                fd = _context.sent;
                _context.next = 5;
                return readAsync(fd, Buffer.alloc(slice.length), 0, slice.length, slice.offset);

              case 5:
                _yield$readAsync = _context.sent;
                buffer = _yield$readAsync.buffer;
                return _context.abrupt("return", buffer.buffer);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function fetchSlice(_x) {
        return _fetchSlice.apply(this, arguments);
      }

      return fetchSlice;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var fd;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.openRequest;

              case 2:
                fd = _context2.sent;
                _context2.next = 5;
                return closeAsync(fd);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }]);

  return FileSource;
}(_basesource_js__WEBPACK_IMPORTED_MODULE_1__.BaseSource);

function makeFileSource(path) {
  return new FileSource(path);
}

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/filereader.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/filereader.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeFileReaderSource": function() { return /* binding */ makeFileReaderSource; }
/* harmony export */ });
/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ "./node_modules/geotiff/dist-module/source/basesource.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var FileReaderSource = /*#__PURE__*/function (_BaseSource) {
  _inherits(FileReaderSource, _BaseSource);

  var _super = _createSuper(FileReaderSource);

  function FileReaderSource(file) {
    var _this;

    _classCallCheck(this, FileReaderSource);

    _this = _super.call(this);
    _this.file = file;
    return _this;
  }

  _createClass(FileReaderSource, [{
    key: "fetchSlice",
    value: function () {
      var _fetchSlice = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(slice, signal) {
        var _this2 = this;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  var blob = _this2.file.slice(slice.offset, slice.offset + slice.length);

                  var reader = new FileReader();

                  reader.onload = function (event) {
                    return resolve(event.target.result);
                  };

                  reader.onerror = reject;
                  reader.onabort = reject;
                  reader.readAsArrayBuffer(blob);

                  if (signal) {
                    signal.addEventListener('abort', function () {
                      return reader.abort();
                    });
                  }
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function fetchSlice(_x, _x2) {
        return _fetchSlice.apply(this, arguments);
      }

      return fetchSlice;
    }()
  }]);

  return FileReaderSource;
}(_basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource);
/**
 * Create a new source from a given file/blob.
 * @param {Blob} file The file or blob to read from.
 * @returns The constructed source
 */


function makeFileReaderSource(file) {
  return new FileReaderSource(file);
}

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/httputils.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/httputils.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseContentType": function() { return /* binding */ parseContentType; },
/* harmony export */   "parseContentRange": function() { return /* binding */ parseContentRange; },
/* harmony export */   "parseByteRanges": function() { return /* binding */ parseByteRanges; }
/* harmony export */ });
function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var CRLFCRLF = '\r\n\r\n';
/*
 * Shim for 'Object.fromEntries'
 */

function itemsToObject(items) {
  if (typeof Object.fromEntries !== 'undefined') {
    return Object.fromEntries(items);
  }

  var obj = {};

  var _iterator = _createForOfIteratorHelper(items),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
          key = _step$value[0],
          value = _step$value[1];

      obj[key.toLowerCase()] = value;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return obj;
}
/**
 * Parse HTTP headers from a given string.
 * @param {String} text the text to parse the headers from
 * @returns {Object} the parsed headers with lowercase keys
 */


function parseHeaders(text) {
  var items = text.split('\r\n').map(function (line) {
    var kv = line.split(':').map(function (str) {
      return str.trim();
    });
    kv[0] = kv[0].toLowerCase();
    return kv;
  });
  return itemsToObject(items);
}
/**
 * Parse a 'Content-Type' header value to the content-type and parameters
 * @param {String} rawContentType the raw string to parse from
 * @returns {Object} the parsed content type with the fields: type and params
 */


function parseContentType(rawContentType) {
  var _rawContentType$split = rawContentType.split(';').map(function (s) {
    return s.trim();
  }),
      _rawContentType$split2 = _toArray(_rawContentType$split),
      type = _rawContentType$split2[0],
      rawParams = _rawContentType$split2.slice(1);

  var paramsItems = rawParams.map(function (param) {
    return param.split('=');
  });
  return {
    type: type,
    params: itemsToObject(paramsItems)
  };
}
/**
 * Parse a 'Content-Range' header value to its start, end, and total parts
 * @param {String} rawContentRange the raw string to parse from
 * @returns {Object} the parsed parts
 */

function parseContentRange(rawContentRange) {
  var start;
  var end;
  var total;

  if (rawContentRange) {
    var _rawContentRange$matc = rawContentRange.match(/bytes (\d+)-(\d+)\/(\d+)/);

    var _rawContentRange$matc2 = _slicedToArray(_rawContentRange$matc, 4);

    start = _rawContentRange$matc2[1];
    end = _rawContentRange$matc2[2];
    total = _rawContentRange$matc2[3];
    start = parseInt(start, 10);
    end = parseInt(end, 10);
    total = parseInt(total, 10);
  }

  return {
    start: start,
    end: end,
    total: total
  };
}
/**
 * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.
 * Each item in the list has the following properties:
 * - headers: the HTTP headers
 * - data: the sliced ArrayBuffer for that specific part
 * - offset: the offset of the byterange within its originating file
 * - length: the length of the byterange
 * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split
 * @param {String} boundary the boundary string used to split the sections
 * @returns {Object[]} the parsed byteranges
 */

function parseByteRanges(responseArrayBuffer, boundary) {
  var offset = null;
  var decoder = new TextDecoder('ascii');
  var out = [];
  var startBoundary = "--".concat(boundary);
  var endBoundary = "".concat(startBoundary, "--"); // search for the initial boundary, may be offset by some bytes
  // TODO: more efficient to check for `--` in bytes directly

  for (var i = 0; i < 10; ++i) {
    var text = decoder.decode(new Uint8Array(responseArrayBuffer, i, startBoundary.length));

    if (text === startBoundary) {
      offset = i;
    }
  }

  if (offset === null) {
    throw new Error('Could not find initial boundary');
  }

  while (offset < responseArrayBuffer.byteLength) {
    var _text = decoder.decode(new Uint8Array(responseArrayBuffer, offset, Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset))); // break if we arrived at the end


    if (_text.length === 0 || _text.startsWith(endBoundary)) {
      break;
    } // assert that we are actually dealing with a byterange and are at the correct offset


    if (!_text.startsWith(startBoundary)) {
      throw new Error('Part does not start with boundary');
    } // get a substring from where we read the headers


    var innerText = _text.substr(startBoundary.length + 2);

    if (innerText.length === 0) {
      break;
    } // find the double linebreak that denotes the end of the headers


    var endOfHeaders = innerText.indexOf(CRLFCRLF); // parse the headers to get the content range size

    var headers = parseHeaders(innerText.substr(0, endOfHeaders));

    var _parseContentRange = parseContentRange(headers['content-range']),
        start = _parseContentRange.start,
        end = _parseContentRange.end,
        total = _parseContentRange.total; // calculate the length of the slice and the next offset


    var startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;
    var length = parseInt(end, 10) + 1 - parseInt(start, 10);
    out.push({
      headers: headers,
      data: responseArrayBuffer.slice(startOfData, startOfData + length),
      offset: start,
      length: length,
      fileSize: total
    });
    offset = startOfData + length + 4;
  }

  return out;
}

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/remote.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/remote.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeFetchSource": function() { return /* binding */ makeFetchSource; },
/* harmony export */   "makeXHRSource": function() { return /* binding */ makeXHRSource; },
/* harmony export */   "makeHttpSource": function() { return /* binding */ makeHttpSource; },
/* harmony export */   "makeRemoteSource": function() { return /* binding */ makeRemoteSource; }
/* harmony export */ });
/* harmony import */ var _httputils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./httputils.js */ "./node_modules/geotiff/dist-module/source/httputils.js");
/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ "./node_modules/geotiff/dist-module/source/basesource.js");
/* harmony import */ var _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blockedsource.js */ "./node_modules/geotiff/dist-module/source/blockedsource.js");
/* harmony import */ var _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./client/fetch.js */ "./node_modules/geotiff/dist-module/source/client/fetch.js");
/* harmony import */ var _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./client/xhr.js */ "./node_modules/geotiff/dist-module/source/client/xhr.js");
/* harmony import */ var _client_http_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./client/http.js */ "./node_modules/geotiff/dist-module/source/client/http.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var _excluded = ["headers", "credentials", "maxRanges", "allowFullFile"],
    _excluded2 = ["headers", "maxRanges", "allowFullFile"],
    _excluded3 = ["headers", "maxRanges", "allowFullFile"],
    _excluded4 = ["forceXHR"];

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }








var RemoteSource = /*#__PURE__*/function (_BaseSource) {
  _inherits(RemoteSource, _BaseSource);

  var _super = _createSuper(RemoteSource);

  /**
   *
   * @param {BaseClient} client
   * @param {object} headers
   * @param {numbers} maxRanges
   * @param {boolean} allowFullFile
   */
  function RemoteSource(client, headers, maxRanges, allowFullFile) {
    var _this;

    _classCallCheck(this, RemoteSource);

    _this = _super.call(this);
    _this.client = client;
    _this.headers = headers;
    _this.maxRanges = maxRanges;
    _this.allowFullFile = allowFullFile;
    _this._fileSize = null;
    return _this;
  }
  /**
   *
   * @param {Slice[]} slices
   */


  _createClass(RemoteSource, [{
    key: "fetch",
    value: function () {
      var _fetch = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(slices, signal) {
        var _this2 = this;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this.maxRanges >= slices.length)) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", this.fetchSlices(slices, signal));

              case 4:
                if (this.maxRanges > 0 && slices.length > 1) {// TODO: split into multiple multi-range requests
                  // const subSlicesRequests = [];
                  // for (let i = 0; i < slices.length; i += this.maxRanges) {
                  //   subSlicesRequests.push(
                  //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),
                  //   );
                  // }
                  // return (await Promise.all(subSlicesRequests)).flat();
                }

              case 5:
                return _context.abrupt("return", Promise.all(slices.map(function (slice) {
                  return _this2.fetchSlice(slice, signal);
                })));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function fetch(_x, _x2) {
        return _fetch.apply(this, arguments);
      }

      return fetch;
    }()
  }, {
    key: "fetchSlices",
    value: function () {
      var _fetchSlices = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(slices, signal) {
        var _this3 = this;

        var response, _parseContentType, type, params, byteRanges, data, _parseContentRange, start, end, total, first, others, _data;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.client.request({
                  headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                    Range: "bytes=".concat(slices.map(function (_ref) {
                      var offset = _ref.offset,
                          length = _ref.length;
                      return "".concat(offset, "-").concat(offset + length);
                    }).join(','))
                  }),
                  signal: signal
                });

              case 2:
                response = _context2.sent;

                if (response.ok) {
                  _context2.next = 7;
                  break;
                }

                throw new Error('Error fetching data.');

              case 7:
                if (!(response.status === 206)) {
                  _context2.next = 32;
                  break;
                }

                _parseContentType = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_0__.parseContentType)(response.getHeader('content-type')), type = _parseContentType.type, params = _parseContentType.params;

                if (!(type === 'multipart/byteranges')) {
                  _context2.next = 18;
                  break;
                }

                _context2.t0 = _httputils_js__WEBPACK_IMPORTED_MODULE_0__.parseByteRanges;
                _context2.next = 13;
                return response.getData();

              case 13:
                _context2.t1 = _context2.sent;
                _context2.t2 = params.boundary;
                byteRanges = (0, _context2.t0)(_context2.t1, _context2.t2);
                this._fileSize = byteRanges[0].fileSize || null;
                return _context2.abrupt("return", byteRanges);

              case 18:
                _context2.next = 20;
                return response.getData();

              case 20:
                data = _context2.sent;
                _parseContentRange = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_0__.parseContentRange)(response.getHeader('content-range')), start = _parseContentRange.start, end = _parseContentRange.end, total = _parseContentRange.total;
                this._fileSize = total || null;
                first = [{
                  data: data,
                  offset: start,
                  length: end - start
                }];

                if (!(slices.length > 1)) {
                  _context2.next = 29;
                  break;
                }

                _context2.next = 27;
                return Promise.all(slices.slice(1).map(function (slice) {
                  return _this3.fetchSlice(slice, signal);
                }));

              case 27:
                others = _context2.sent;
                return _context2.abrupt("return", first.concat(others));

              case 29:
                return _context2.abrupt("return", first);

              case 32:
                if (this.allowFullFile) {
                  _context2.next = 34;
                  break;
                }

                throw new Error('Server responded with full file');

              case 34:
                _context2.next = 36;
                return response.getData();

              case 36:
                _data = _context2.sent;
                this._fileSize = _data.byteLength;
                return _context2.abrupt("return", [{
                  data: _data,
                  offset: 0,
                  length: _data.byteLength
                }]);

              case 39:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function fetchSlices(_x3, _x4) {
        return _fetchSlices.apply(this, arguments);
      }

      return fetchSlices;
    }()
  }, {
    key: "fetchSlice",
    value: function () {
      var _fetchSlice = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(slice, signal) {
        var offset, length, response, data, _parseContentRange2, total, _data2;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                offset = slice.offset, length = slice.length;
                _context3.next = 3;
                return this.client.request({
                  headers: _objectSpread(_objectSpread({}, this.headers), {}, {
                    Range: "bytes=".concat(offset, "-").concat(offset + length)
                  }),
                  signal: signal
                });

              case 3:
                response = _context3.sent;

                if (response.ok) {
                  _context3.next = 8;
                  break;
                }

                throw new Error('Error fetching data.');

              case 8:
                if (!(response.status === 206)) {
                  _context3.next = 17;
                  break;
                }

                _context3.next = 11;
                return response.getData();

              case 11:
                data = _context3.sent;
                _parseContentRange2 = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_0__.parseContentRange)(response.getHeader('content-range')), total = _parseContentRange2.total;
                this._fileSize = total || null;
                return _context3.abrupt("return", {
                  data: data,
                  offset: offset,
                  length: length
                });

              case 17:
                if (this.allowFullFile) {
                  _context3.next = 19;
                  break;
                }

                throw new Error('Server responded with full file');

              case 19:
                _context3.next = 21;
                return response.getData();

              case 21:
                _data2 = _context3.sent;
                this._fileSize = _data2.byteLength;
                return _context3.abrupt("return", {
                  data: _data2,
                  offset: 0,
                  length: _data2.byteLength
                });

              case 24:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function fetchSlice(_x5, _x6) {
        return _fetchSlice.apply(this, arguments);
      }

      return fetchSlice;
    }()
  }, {
    key: "fileSize",
    get: function get() {
      return this._fileSize;
    }
  }]);

  return RemoteSource;
}(_basesource_js__WEBPACK_IMPORTED_MODULE_1__.BaseSource);

function maybeWrapInBlockedSource(source, _ref2) {
  var blockSize = _ref2.blockSize,
      cacheSize = _ref2.cacheSize;

  if (blockSize === null) {
    return source;
  }

  return new _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__.BlockedSource(source, blockSize, cacheSize);
}

function makeFetchSource(url) {
  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref3$headers = _ref3.headers,
      headers = _ref3$headers === void 0 ? {} : _ref3$headers,
      credentials = _ref3.credentials,
      _ref3$maxRanges = _ref3.maxRanges,
      maxRanges = _ref3$maxRanges === void 0 ? 0 : _ref3$maxRanges,
      _ref3$allowFullFile = _ref3.allowFullFile,
      allowFullFile = _ref3$allowFullFile === void 0 ? false : _ref3$allowFullFile,
      blockOptions = _objectWithoutProperties(_ref3, _excluded);

  var client = new _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__.FetchClient(url, credentials);
  var source = new RemoteSource(client, headers, maxRanges, allowFullFile);
  return maybeWrapInBlockedSource(source, blockOptions);
}
function makeXHRSource(url) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref4$headers = _ref4.headers,
      headers = _ref4$headers === void 0 ? {} : _ref4$headers,
      _ref4$maxRanges = _ref4.maxRanges,
      maxRanges = _ref4$maxRanges === void 0 ? 0 : _ref4$maxRanges,
      _ref4$allowFullFile = _ref4.allowFullFile,
      allowFullFile = _ref4$allowFullFile === void 0 ? false : _ref4$allowFullFile,
      blockOptions = _objectWithoutProperties(_ref4, _excluded2);

  var client = new _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__.XHRClient(url);
  var source = new RemoteSource(client, headers, maxRanges, allowFullFile);
  return maybeWrapInBlockedSource(source, blockOptions);
}
function makeHttpSource(url) {
  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref5$headers = _ref5.headers,
      headers = _ref5$headers === void 0 ? {} : _ref5$headers,
      _ref5$maxRanges = _ref5.maxRanges,
      maxRanges = _ref5$maxRanges === void 0 ? 0 : _ref5$maxRanges,
      _ref5$allowFullFile = _ref5.allowFullFile,
      allowFullFile = _ref5$allowFullFile === void 0 ? false : _ref5$allowFullFile,
      blockOptions = _objectWithoutProperties(_ref5, _excluded3);

  var client = new _client_http_js__WEBPACK_IMPORTED_MODULE_5__.HttpClient(url);
  var source = new RemoteSource(client, headers, maxRanges, allowFullFile);
  return maybeWrapInBlockedSource(source, blockOptions);
}
/**
 *
 * @param {string} url
 * @param {object} options
 */

function makeRemoteSource(url) {
  var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref6$forceXHR = _ref6.forceXHR,
      forceXHR = _ref6$forceXHR === void 0 ? false : _ref6$forceXHR,
      clientOptions = _objectWithoutProperties(_ref6, _excluded4);

  if (typeof fetch === 'function' && !forceXHR) {
    return makeFetchSource(url, clientOptions);
  }

  if (typeof XMLHttpRequest !== 'undefined') {
    return makeXHRSource(url, clientOptions);
  }

  return makeHttpSource(url, clientOptions);
}

/***/ }),

/***/ "./node_modules/geotiff/dist-module/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/geotiff/dist-module/utils.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assign": function() { return /* binding */ assign; },
/* harmony export */   "chunk": function() { return /* binding */ chunk; },
/* harmony export */   "endsWith": function() { return /* binding */ endsWith; },
/* harmony export */   "forEach": function() { return /* binding */ forEach; },
/* harmony export */   "invert": function() { return /* binding */ invert; },
/* harmony export */   "range": function() { return /* binding */ range; },
/* harmony export */   "times": function() { return /* binding */ times; },
/* harmony export */   "toArray": function() { return /* binding */ toArray; },
/* harmony export */   "toArrayRecursively": function() { return /* binding */ toArrayRecursively; },
/* harmony export */   "parseContentRange": function() { return /* binding */ parseContentRange; },
/* harmony export */   "wait": function() { return /* binding */ wait; },
/* harmony export */   "zip": function() { return /* binding */ zip; },
/* harmony export */   "AbortError": function() { return /* binding */ AbortError; },
/* harmony export */   "CustomAggregateError": function() { return /* binding */ CustomAggregateError; },
/* harmony export */   "AggregateError": function() { return /* binding */ AggregateError; }
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function assign(target, source) {
  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }
}
function chunk(iterable, length) {
  var results = [];
  var lengthOfIterable = iterable.length;

  for (var i = 0; i < lengthOfIterable; i += length) {
    var chunked = [];

    for (var ci = i; ci < i + length; ci++) {
      chunked.push(iterable[ci]);
    }

    results.push(chunked);
  }

  return results;
}
function endsWith(string, expectedEnding) {
  if (string.length < expectedEnding.length) {
    return false;
  }

  var actualEnding = string.substr(string.length - expectedEnding.length);
  return actualEnding === expectedEnding;
}
function forEach(iterable, func) {
  var length = iterable.length;

  for (var i = 0; i < length; i++) {
    func(iterable[i], i);
  }
}
function invert(oldObj) {
  var newObj = {};

  for (var key in oldObj) {
    if (oldObj.hasOwnProperty(key)) {
      var value = oldObj[key];
      newObj[value] = key;
    }
  }

  return newObj;
}
function range(n) {
  var results = [];

  for (var i = 0; i < n; i++) {
    results.push(i);
  }

  return results;
}
function times(numTimes, func) {
  var results = [];

  for (var i = 0; i < numTimes; i++) {
    results.push(func(i));
  }

  return results;
}
function toArray(iterable) {
  var results = [];
  var length = iterable.length;

  for (var i = 0; i < length; i++) {
    results.push(iterable[i]);
  }

  return results;
}
function toArrayRecursively(input) {
  if (input.length) {
    return toArray(input).map(toArrayRecursively);
  }

  return input;
} // copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js

function parseContentRange(headerValue) {
  if (!headerValue) {
    return null;
  }

  if (typeof headerValue !== 'string') {
    throw new Error('invalid argument');
  }

  var parseInt = function parseInt(number) {
    return Number.parseInt(number, 10);
  }; // Check for presence of unit


  var matches = headerValue.match(/^(\w*) /);
  var unit = matches && matches[1]; // check for start-end/size header format

  matches = headerValue.match(/(\d+)-(\d+)\/(\d+|\*)/);

  if (matches) {
    return {
      unit: unit,
      first: parseInt(matches[1]),
      last: parseInt(matches[2]),
      length: matches[3] === '*' ? null : parseInt(matches[3])
    };
  } // check for size header format


  matches = headerValue.match(/(\d+|\*)/);

  if (matches) {
    return {
      unit: unit,
      first: null,
      last: null,
      length: matches[1] === '*' ? null : parseInt(matches[1])
    };
  }

  return null;
}
/*
 * Promisified wrapper around 'setTimeout' to allow 'await'
 */

function wait(_x) {
  return _wait.apply(this, arguments);
}

function _wait() {
  _wait = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(milliseconds) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", new Promise(function (resolve) {
              return setTimeout(resolve, milliseconds);
            }));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _wait.apply(this, arguments);
}

function zip(a, b) {
  var A = Array.isArray(a) ? a : Array.from(a);
  var B = Array.isArray(b) ? b : Array.from(b);
  return A.map(function (k, i) {
    return [k, B[i]];
  });
} // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error

var AbortError = /*#__PURE__*/function (_Error) {
  _inherits(AbortError, _Error);

  var _super = _createSuper(AbortError);

  function AbortError(params) {
    var _this;

    _classCallCheck(this, AbortError);

    // Pass remaining arguments (including vendor specific ones) to parent constructor
    _this = _super.call(this, params); // Maintains proper stack trace for where our error was thrown (only available on V8)

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_this), AbortError);
    }

    _this.name = 'AbortError';
    return _this;
  }

  return _createClass(AbortError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var CustomAggregateError = /*#__PURE__*/function (_Error2) {
  _inherits(CustomAggregateError, _Error2);

  var _super2 = _createSuper(CustomAggregateError);

  function CustomAggregateError(errors, message) {
    var _this2;

    _classCallCheck(this, CustomAggregateError);

    _this2 = _super2.call(this, message);
    _this2.errors = errors;
    _this2.message = message;
    _this2.name = 'AggregateError';
    return _this2;
  }

  return _createClass(CustomAggregateError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var AggregateError = CustomAggregateError;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	!function() {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = function(chunkId) {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	}();
/******/
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".wg.js";
/******/ 		};
/******/ 	}();
/******/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/
/******/ 	/* webpack/runtime/load script */
/******/ 	!function() {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "wg:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = function(url, done, key, chunkId) {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = function(prev, event) {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach(function(fn) { return fn(event); });
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			;
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	}();
/******/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "";
/******/ 	}();
/******/
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		// no baseURI
/******/
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/
/******/ 		__webpack_require__.f.j = function(chunkId, promises) {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; });
/******/ 							promises.push(installedChunkData[2] = promise);
/******/
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = function(event) {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/
/******/ 		// no prefetching
/******/
/******/ 		// no preloaded
/******/
/******/ 		// no HMR
/******/
/******/ 		// no HMR manifest
/******/
/******/ 		// no on chunks loaded
/******/
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/
/******/ 		}
/******/
/******/ 		var chunkLoadingGlobal = self["webpackChunkwg"] = self["webpackChunkwg"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	}();
/******/
/************************************************************************/
/******/
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./node_modules/regenerator-runtime/runtime.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./build/index.js");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/
/******/ 	return __webpack_exports__;
/******/ })()
;
});
// export default wg